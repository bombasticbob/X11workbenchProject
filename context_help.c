///////////////////////////////////////////////////////////////////////////////////
//                                                                               //
//                      _               _         _            _                 //
//    ___  ___   _ __  | |_  ___ __  __| |_      | |__    ___ | | _ __     ___   //
//   / __|/ _ \ | '_ \ | __|/ _ \\ \/ /| __|     | '_ \  / _ \| || '_ \   / __|  //
//  | (__| (_) || | | || |_|  __/ >  < | |_      | | | ||  __/| || |_) |_| (__   //
//   \___|\___/ |_| |_| \__|\___|/_/\_\ \__|_____|_| |_| \___||_|| .__/(_)\___|  //
//                                         |_____|               |_|             //
//                                                                               //
///////////////////////////////////////////////////////////////////////////////////


/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2018 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                           all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is linked with, equivalent to, or derived from any portion of this
  software, along with this paragraph that explains the terms of the license if
  the source is also being made available.  "Linked with" includes the use of a
  portion of any of the source and/or header files, or their compiled binary
  output, as a part of your application or library.   A "derived work"
  describes a work that uses a significant portion of the source files or the
  algorithms that are included with this software.

  EXCLUSIONS

  Specifically excluded from this requirement are files that were generated by
  the software, or anything that is included with the software that is part of
  another package (such as files that were created or added during the
  'configure' process).

  DISTRIBUTION

  The license also covers the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application, in source or
  binary form.  If you do not ship the source, the above copyright statement
  and DISCLAIMER is still required to be placed in a reasonably prominent
  place, such as documentation, splash screens, and/or 'about the application'
  dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README.md files for more information.

  Additionally, this software, in source or binary form, and in whole or in
  part, may be used by explicit permission from the author, without the need
  of a license.

  Additional information at http://sourceforge.net/projects/X11workbench
  and http://bombasticbob.github.io/X11workbench/

******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <signal.h>
#include <time.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>

// project includes
#include "X11workbench.h"
#include "platform_helper.h"
#include "debug_helper.h"
#include "file_help.h"
#include "conf_help.h"

#include "context_help.h"


static char * InternalMan2Html(const char *szTerm, const char *szText);


////////////////////////////////////////////////////////////////
//    ____            _            _     _   _      _         //
//   / ___|___  _ __ | |_ _____  _| |_  | | | | ___| |_ __    //
//  | |   / _ \| '_ \| __/ _ \ \/ / __| | |_| |/ _ \ | '_ \   //
//  | |__| (_) | | | | ||  __/>  <| |_  |  _  |  __/ | |_) |  //
//   \____\___/|_| |_|\__\___/_/\_\\__| |_| |_|\___|_| .__/   //
//                                                   |_|      //
////////////////////////////////////////////////////////////////

// CONTEXT SENSITIVE HELP NOTES using DOXYGEN GENERATED DOCS

// doxygen generates doc/html/group__*.html files that will contain the desired documentation
//
// Each documented item has a tag similar to the following:
//
//   <!-- doxytag: member="window_helper.h::WBSetInputFocus" ref="ga28d82cd699b08cf93278ae26c5ad4788" args="(Window wID)" -->
//
// jumping to the correct HTML link with the anchor set to the 'ref' value will open it up in doxygen, as
//
// file:///usr/local/share/X11workbench/doc/html/group__wcore.html#ga28d82cd699b08cf93278ae26c5ad4788
//


void DoContextSensitiveHelp(const char *szTerm)
{
char szDocFilePath[PATH_MAX * 2], szName[PATH_MAX];
char *p1, *p2, *p3;//, *p5;
const char *p4;
void *pSettings, *pDirList;
int i1;
unsigned long dwAttr;
FILE *pTemp;
WB_FILE_HANDLE hProcess;
static char szLineBuf[4096], szDoxyTag[PATH_MAX * 2 + 512], szHelpBrowser[PATH_MAX];


  // step 1:  get 'docs' directory from settings, and if there isn't a setting for it,
  //          use the current directory + "docs/html"

  bzero(szDocFilePath, sizeof(szDocFilePath));


  pSettings = CHOpenConfFile(APP_NAME, CH_FLAGS_DEFAULT);

  if(pSettings)
  {
    if(0 >= CHGetConfFileString(pSettings, "paths", "browser", szHelpBrowser, sizeof(szHelpBrowser)))
    {
      WB_ERROR_PRINT("ERROR did not find 'paths' 'browser', using default\n");
      goto find_url_opener;
    }
//    else
//    {
//      WB_ERROR_PRINT("TEMPORARY: %s - browser \"%s\"\n", __FUNCTION__, szHelpBrowser);
//    }

    i1 = CHGetConfFileString(pSettings, "paths","documentation",szDocFilePath, sizeof(szDocFilePath) - 2);

    CHCloseConfFile(pSettings);
    pSettings = NULL;
  }
  else
  {
find_url_opener:

    i1 = 0;

    p1 = CHGetMimeDefaultApp("text/html");
    p2 = p3 = NULL;

    if(!p1 || *p1 <= ' ')
    {
      if(p1)
      {
        WBFree(p1);
      }

      p1 = CHGetMimeDefaultApp("x-scheme-handler/http"); // Mate uses this one
    }

    if(p1 && *p1 > ' ')
    {
      if(strlen(p1) > 8 /* strlen(".desktop") */ &&
         !memcmp(p1 + strlen(p1) - 8, ".desktop", 8)) // it's a '.desktop' file
      {
        p2 = p1;
        p1 = CHGetDesktopFileInfo(p2, "Exec");
        // NOTE:  the 'Exec' string will have a '%f' or '%u' or similar in it.  trim that.

        if(!p1)
        {
          p1 = p2; // restore original, hope it still works
        }
        else
        {
          WBFree(p2);
          p2 = p1 + strlen(p1);

          while(p2 > p1 && *(p2 - 1) <= ' ')
          {
            *(--p2) = 0; // right-trim
          }

          if(p2 >= p1 + 2 && *(p2 - 2) == '%' &&
             (*(p2 - 1) == 'u' || *(p2 - 1) == 'U' || *(p2 - 1) == 'f' || *(p2 - 1) == 'F'))
          {
            p2 -= 2;
            *p2 = 0; // trim off argument

            while(p2 > p1 && *(p2 - 1) <= ' ')
            {
              *(--p2) = 0; // right-trim
            }
          }

          // NOTE:  for _NOW_ assume that there are no extra parameters [later I'll fix that...]
        }
      }

      strcpy(szHelpBrowser, p1);
      WBFree(p1);

      p1 = NULL;
      p2 = NULL;
    }
    else
    {
      if(p1)
      {
        WB_ERROR_PRINT("%s - \"%s\" - No default browser available!\n", __FUNCTION__, p1);

        WBFree(p1);
      }
      else
      {
        WB_ERROR_PRINT("%s - No default browser available!\n", __FUNCTION__);
      }

      DLGMessageBox(MessageBox_OK | MessageBox_Error, None,
                    "Context Help", "No default browser available for displaying help");
      return;
    }
  }

  if(i1 <= 0)
  {
    p1 = WBGetCanonicalPath("doc/html/");
    if(p1)
    {
      strncpy(szDocFilePath, p1, sizeof(szDocFilePath) - 2);
      WBFree(p1);
    }
    else
    {
      strcpy(szDocFilePath, "doc/html/");
    }
  }

  if(szDocFilePath[strlen(szDocFilePath) - 1] != '/')
  {
    strcat(szDocFilePath, "/");
  }

//  WB_ERROR_PRINT("TEMPORARY: %s - szDocFilePath = \"%s\"\n", __FUNCTION__, szDocFilePath);
//  WB_ERROR_PRINT("           %s - szTerm = \"%s\"\n", __FUNCTION__, szTerm);

  p1 = szDocFilePath + strlen(szDocFilePath);

  // now that THAT mess is over with, determine which file has the appropriate term in it,
  // and invoke the default web browser to open that link.  I'll do this using 'xdg-open'.

  strcpy(p1, "group__*.html");

  pDirList = WBAllocDirectoryList(szDocFilePath);

  *p1 = 0; // 'szDocFilePath' is once again, ONLY a path
  szDoxyTag[0] = 0; // it will be a flag

  if(!pDirList)
  {
    WB_ERROR_PRINT("ERROR:  %s no dir list \"%s\"\n", __FUNCTION__, szDocFilePath);
    return;
  }
  else
  {
    while(!WBNextDirectoryEntry(pDirList, szName, sizeof(szName), &dwAttr))
    {
      if(S_ISREG(dwAttr))
      {
        strcpy(p1, szName);

//        WB_ERROR_PRINT("TEMPORARY:  opening \"%s\"\n", szDocFilePath);

        pTemp = fopen(szDocFilePath, "r");
        if(!pTemp)
        {
          WB_ERROR_PRINT("ERROR:  %s - unable to open \"%s\"\n", __FUNCTION__, szDocFilePath);
        }
        else
        {
          *p1 = 0; // file name not needed now, but path name IS needed

          while(!feof(pTemp))
          {
            if(!fgets(szLineBuf, sizeof(szLineBuf), pTemp))
            {
              break;
            }

            // THIS METHOD APPLIES TO Doxygen version 1.8.3.1 and later
            // (it has also been tested with Doxygen 1.8.13.2)
            // If you have an earlier version of doxygen, consider UPGRADING PLEASE!
            // If you cannot upgrade Doxygen, and this API does not work with your
            // generated documentation, consider downloading the pre-built documentation.

            if(NULL != (p2 = strstr(szLineBuf, "class=\"el\"")))
            {
              while(p2 > szLineBuf && *p2 != '<') // search for start of tag
              {
                p2--;
              }

              if(p2 >= szLineBuf && *p2 == '<')
              {
                // parse the tag, find 'href'

                p4 = CHFindEndOfXMLTag(p2, -1); // XML parse helper

                if(*p4 == '>')
                {
                  // the search term will be the 'anchor' term.

                  if(!memcmp(p4 + 1, szTerm, strlen(szTerm)) &&
                     !memcmp(p4 + 1 + strlen(szTerm), "</a>", 4)) // ending tag
                  {
                    p3 = CHParseXMLTagContents(p2, p4 - p2);
                    if(p3)
                    {
                      // now that I have the tag, grab the 'href' member
                      for(p2=p3; *p2; p2 += strlen(p2) + 1)
                      {
                        if(!strncmp(p2, "href=", 5))
                        {
                          strcpy(szDoxyTag, "file://");
                          strcat(szDoxyTag, szDocFilePath); // the path only at this point
                          strcat(szDoxyTag, p2 + 5); // the 'href' text
                          break;
                        }
                      }

                      WBFree(p3);
                      if(szDoxyTag[0])
                      {
                        break;
                      }
                    }
                  }
                }
              }
            }

#if 0 /* this is the OLD way - new method uses '<a class="el" href="">' tags */
            if(strstr(szLineBuf, "doxytag"))
            {
              p2 = strstr(szLineBuf, szTerm);

              if(p2 && p2 > szLineBuf + 10 && *(p2 - 1) == ':' && *(p2 - 2) == ':' &&
                 (p2[strlen(szTerm)] == '"' || p2[strlen(szTerm)] == '\'')) // must be followed by a quote mark
              {
                // grab the entire XML tag
                while(p2 > szLineBuf && (*p2 != '<' || p2[1] != '!' || p2[2] != '-' || p2[3] != '-'))
                {
                  p2--;
                }

                if(*p2 == '<' && p2[1] == '!' && p2[2] == '-' && p2[3] == '-') // doxytag comment block
                {
                  p4 = CHFindEndOfXMLTag(p2 + 4, -1); // point past the '<!--' first, then find the end

                  if(*p4 == '>')
                  {
                    p3 = CHParseXMLTagContents(p2 + 4, p4 - (p2 + 4));
                    if(p3)
                    {
                      // now that I have the tag, grab the 'ref' member
                      for(p2=p3; *p2; p2 += strlen(p2) + 1)
                      {
                        if(!strncmp(p2, "ref=", 4))
                        {
                          strcpy(szDoxyTag, "file://");
                          strcat(szDoxyTag, szDocFilePath);
                          strcat(szDoxyTag, "#");
                          strcat(szDoxyTag, p2 + 4);
                          break;
                        }
                      }

                      WBFree(p3);
                      if(szDoxyTag[0])
                      {
                        break;
                      }
// TODO:  with this much nesting, consider writing utility functions
//        to do some of it and make the code more readable
                    }
                  }
                }
              }
            }
#endif // 0
          }

          fclose(pTemp);
          pTemp = NULL; // by convention
        }
      }
    }
  }

  if(szDoxyTag[0]) // found the right file
  {
//    WB_ERROR_PRINT("TEMPORARY:  %s  spawn %s\n   with \"%s\"\n\n",
//                   __FUNCTION__, szHelpBrowser, szDoxyTag);
    hProcess = WBRunAsync(szHelpBrowser, szDoxyTag, NULL);

    // TODO:  does '--new-instance' work properly?

    if(hProcess != WB_INVALID_FILE_HANDLE)
    {
      // TODO:  display 'wait' cursor and wait for app window to appear ?

      return;
    }

    goto fail_to_run_help;
  }

  // TODO:  other documentation

  // search for related language runtime library MAN pages
  // command line:  man -S 2:3 keyword - pipe output via man2html then open temp html and delete it

  // TODO:  write 'man to HTML' mini-web-server?
  // TODO:  use embedded web client if webkit is available?

  p2 = WBRunResult("man", "-S", "2:3", szTerm, NULL);
  if(!p2 || !*p2)
  {
    if(p2)
    {
      WBFree(p2);
      p2 = NULL;
    }

fail_to_run_man2html:
//      WB_ERROR_PRINT("TEMPORARY:  fail to run man2html \"%s\"\n", p1);

    goto fail_to_run_help;
  }

//    WB_ERROR_PRINT("TEMPORARY:  man output \"%s\"\n", p2);

    // instead of calling an external program to convert, I wrote something
    // that does the conversion as reliably as possible.  external scripts
    // sometimes 'pooch up' the HTML version of the man page, inject garbage,
    // lose large chunks of text, or have issues with hyphenated words.
    // it's possible MY code may exhibit similar problems, but I think I've
    // nailed the issues without too much trouble.  And, if I ever set up a
    // web server for the help system, I'll fix linkage as well.  That would be
    // EVEN MORE interesting, actually... (and it's less troublesome than trying
    // to get groff to work with man consistently across multiple platforms)

  p3 = InternalMan2Html(szTerm, p2);

  WBFree(p2);
  p2 = NULL;

  if(!p3)
  {
    WB_ERROR_PRINT("Failed to run InternalMan2Html in %s\n", __FUNCTION__);
    goto fail_to_run_man2html;
  }

  p2 = WBTempFile(".html"); // temporary HTML file

    // write 'p3' to a temp html file now
  if(!p2) // new temp file name
  {
    WBFree(p3);
    p3 = NULL;

//      WB_ERROR_PRINT("TEMPORARY:  here I am (2)\n");
    goto fail_to_run_man2html;
  }

  if(FBWriteFileFromBuffer(p2, p3, strlen(p3)) < 0)
  {
//      WB_ERROR_PRINT("TEMPORARY:  here I am (3) p2=\"%s\"\n", p2);

    WBFree(p2);
    WBFree(p3);
    p2 = p3 = NULL;

    goto fail_to_run_man2html;
  }

  // p2 contains the ".html" temp file name

  hProcess = WBRunAsync(szHelpBrowser, p2, NULL);

  // TODO:  does '--new-instance' work properly?


  WBFree(p2);
  WBFree(p3);
  p1 = p2 = p3 = NULL;

  if(hProcess != WB_INVALID_FILE_HANDLE)
  {
    // TODO:  display 'wait' cursor and wait for app window to appear ?

    return;
  }



fail_to_run_help:

  p1 = WBCopyString("No help available for \"");
  WBCatString(&p1, szTerm);
  WBCatString(&p1, "\"");

  if(p1)
  {
    Window wIDOwner = pMainFrame ? pMainFrame->wID : -1;

    DLGMessageBox(MessageBox_OK | MessageBox_MiddleFinger, wIDOwner,
                  "Context Help", p1);

    WBFree(p1);
  }
}

static char * CreateNBSPString(const char *szRef, int nLen)
{
static const char szNBSP[]="&nbsp";
int i1, i2;
char *pRval;

#define NBSP_TAB_WIDTH 8

  if(nLen < 0)
  {
    return NULL;
  }

  pRval = WBAlloc(nLen * 8 * (sizeof(szNBSP) - 1) + 2);

  if(pRval)
  {
    char *p2 = pRval;
    const char *p1 = szRef;

    for(i1=0, i2=0; i1 < nLen; p1++, i1++, i2 = (i2 + 1) % NBSP_TAB_WIDTH)
    {
      if(*p1 == '\t')
      {
        for(; i2 < NBSP_TAB_WIDTH; i2++)
        {
          memcpy(p2, szNBSP, sizeof(szNBSP) - 1);
          p2 += sizeof(szNBSP) - 1;
        }
        i2 = NBSP_TAB_WIDTH - 1; // tab position
      }
      else
      {
        memcpy(p2, szNBSP, sizeof(szNBSP) - 1);
        p2 += sizeof(szNBSP) - 1;
      }
    }

    *p2 = 0;
  }

  return pRval;
}



////////////////////////////////////////////////////////////////////
//   __  __    _    _   _   _          _   _ _____ __  __ _       //
//  |  \/  |  / \  | \ | | | |_ ___   | | | |_   _|  \/  | |      //
//  | |\/| | / _ \ |  \| | | __/ _ \  | |_| | | | | |\/| | |      //
//  | |  | |/ ___ \| |\  | | || (_) | |  _  | | | | |  | | |___   //
//  |_|  |_/_/   \_\_| \_|  \__\___/  |_| |_| |_| |_|  |_|_____|  //
//                                                                //
////////////////////////////////////////////////////////////////////

static char * InternalMan2Html(const char *szTerm, const char *szText)
{
char *pRval, *p1, *p2, *pTemp, *pHyphenBuf = NULL;
const char *p3, *p4, *p5;
int i1, i2, cbLineLen, nTabTwist, bNoHyphen = 0;
static const char szNBSP[]="&nbsp;";


  pRval = WBCopyString("<HTML><HEAD><TITLE>X11workbench Help - man ");
  if(pRval)
  {
    WBCatString(&pRval, szTerm);

    if(pRval)
    {
      WBCatString(&pRval, "</TITLE></HEAD><BODY><TT>\r\n");
    }
  }

  if(!pRval)
  {
    return NULL;
  }

  p3 = szText;

  while(*p3 && pRval)
  {
    // skip white space
    p4 = p3;
    nTabTwist = 0;

    while(*p3 && *p3 <= ' ')
    {
      if(*p3 == '\r' || *p3 == '\n' || *p3 == '\f')
      {
        // TODO:  handle tabs?
        pTemp = CreateNBSPString(p4, p3 - p4);
        if(pTemp)
        {
          WBCatString(&pRval, pTemp);
          WBFree(pTemp);
          pTemp = NULL;
        }

        if(pHyphenBuf)
        {
          // rare possibility of hyphenated text on a blank line
          // but I want to indent it past the end of the white space
          if(pRval)
          {
            WBCatString(&pRval, pHyphenBuf);
          }

          WBFree(pHyphenBuf);
          pHyphenBuf = NULL;
        }

        p4 = p3; // to indicate I shouldn't copy anything
        break; // it will fall through to the next part
      }

      if(*p3 == '\t')
      {
        nTabTwist = 0; // reset after a tab
      }
      else
      {
        nTabTwist++;
      }

      p3++;
    }

    nTabTwist = nTabTwist % NBSP_TAB_WIDTH; // 'tab twist' for converting tabs

    if(pRval && p3 > p4)
    {
      pTemp = CreateNBSPString(p4, p3 - p4);
      if(pTemp)
      {
        WBCatString(&pRval, pTemp);
        WBFree(pTemp);
        pTemp = NULL;
      }

      p4 = p3;
    }

    if(!pRval)
    {
      break;
    }

    // at this point 'p3' and 'p4' point to the first non-white-space character
    // and all of the white space (any any 'hyphen buf' stuff) is copied

    while(*p3 && *p3 != '\r' && *p3 != '\n' && *p3 != '\f')
    {
      p3++; // go to the end of the line
    }

    cbLineLen = p3 - p4; // not including CR, LF, or FF

    if(*p3 == '\r' && p3[1] == '\n') // for now just check for <CRLF>
    {
      p3++;
    }

    p3++;

    if(!cbLineLen || pHyphenBuf) // blank line
    {
      // if I have de-hyphenated text, I need to INSERT it into the buffer.  There will be no tabs
      // in it and for NOW I'll assume there's no bolding nor underlining [later I might have to
      // check for this independently and I don't want to complicate this any more]

      if(pHyphenBuf)
      {
        nTabTwist = (nTabTwist + strlen(pHyphenBuf)) % NBSP_TAB_WIDTH;

        WBCatString(&pRval, pHyphenBuf);

        WBFree(pHyphenBuf);
        pHyphenBuf = NULL;
      }

      if(!cbLineLen)
      {
        if(pRval)
        {
          WBCatString(&pRval, "<br>\r\n");
        }

        continue;
      }
    }

    // I need to look for backspaces and handle them as bold-text or underscores (depending)

#define STRSEGCMP(X,Y) strncmp(X,Y,strlen(Y))

    if(!bNoHyphen &&
       (!STRSEGCMP(p4, "SEE ALSO") ||
        !STRSEGCMP(p4, "S\x08""SE\x08""EE\x08""E A\x08""AL\x08""LS\x08""SO\x08""O") ||
        !STRSEGCMP(p4, "S\x08""SE\x08""EE\x08""E \x08 A\x08""AL\x08""LS\x08""SO\x08""O")))
    {
      bNoHyphen = 1;
    }

    p5 = p4; // p4 is the beginning of my line, of 'cbLineLen' characters

    while(p5 < p3 && *p5 != '\x08' && *p5 != '<' && *p5 != '>') // backspace in the line? 'GT'? 'LT'?
    {
      p5++;
    }

    if(p5 >= p3 || !cbLineLen) // no backspaces or zero-length line
    {
      if(cbLineLen)
      {
        // if there are tabs in the line I have to deal with this differently
        p5 = p4;
        i1 = 0;

        while(p5 < p3) // tabs?
        {
          if(*p5 == '\t')
          {
            i1++; // count them
          }

          p5++;
        }
        if(!i1) // no tabs
        {
          WBCatStringN(&pRval, p4, cbLineLen);
        }
        else
        {
          // each tab converts to a variable number of spaces up to NBSP_TAB_WIDTH
          // this is a little silly but it's probably the easiest way to make it work

          pTemp = WBAlloc(i1 * NBSP_TAB_WIDTH * (sizeof(szNBSP) - 1) + cbLineLen + 4);
          if(!pTemp)
          {
            WBFree(pRval);
            pRval = NULL;

            break; // buh-bye (error)
          }

          for(p1=pTemp, p5 = p4, i1 = 0, i2=nTabTwist; i1 < cbLineLen;
              i1++, p5++, i2 = (i2 + 1) % NBSP_TAB_WIDTH)
          {
            if(*p5 == '\t')
            {
              for(; i2 < NBSP_TAB_WIDTH; i2++)
              {
                memcpy(p1, szNBSP, sizeof(szNBSP) - 1);
                p1 += sizeof(szNBSP) - 1;
              }

              i2 = NBSP_TAB_WIDTH - 1; // so when it increments it will be zero
            }
            else
            {
              *(p1++) = *p5;
            }
          }

          *p1 = 0;

          WBCatString(&pRval, pTemp);

          WBFree(pTemp);
          pTemp = NULL;
        }

        // check for hyphenated text

        if(pRval)
        {
          p2 = pRval + strlen(pRval);

          if(bNoHyphen)
          {
            if(*(p2 - 1) == '-')
            {
              p2--;
              *p2 = 0; // trim the dash

              while(p2 > pRval && *(p2 - 1) > ' ' && *(p2 - 1) != '.'
                    && *(p2 - 1) != ',' && *(p2 - 1) != ')' && *(p2 - 1) != ']' && *(p2 - 1) != '}')
              {
                p2--; // decrement until at the beginning of a word
              }

              pHyphenBuf = WBCopyString(p2);
              *p2 = 0; // trim hyphenated partial word off of the string

//              WB_ERROR_PRINT("TEMPORARY:  (d) pHyphenBuf=\"%s\"\n", pHyphenBuf);
            }
            else if(p2 > pRval + 3 && *(p2 - 3) == '\xe2' && *(p2 - 2) == '\x80' && *(p2 - 1) == '\x90')
            {
              // the sequence <E2><80><90> is found on debian's man program, and since they
              // define the gnu standard, it's likely to be elsewhere also

              p2 -= 3; // 3 character sequence (remove it)
              *p2 = 0; // trim the 3 character sequence

              while(p2 > pRval && *(p2 - 1) > ' ' && *(p2 - 1) != '.'
                    && *(p2 - 1) != ',' && *(p2 - 1) != ')' && *(p2 - 1) != ']' && *(p2 - 1) != '}')
              {
                p2--; // decrement until at the beginning of a word
              }

              pHyphenBuf = WBCopyString(p2);
              *p2 = 0; // trim hyphenated partial word off of the string

//              WB_ERROR_PRINT("TEMPORARY:  (e) pHyphenBuf=\"%s\"\n", pHyphenBuf);
            }
          }
          else if(p2 > pRval + 3 && *(p2 - 3) == '\xe2' && *(p2 - 2) == '\x80' && *(p2 - 1) == '\x90')
          {
            // the sequence <E2><80><90> is found on debian's man program, and since they
            // define the gnu standard, it's likely to be elsewhere also

            p2 -= 2; // 3 character sequence (remove it, replace with '-')
            *(p2 - 1) = '-';
            *p2 = 0; // trim the 3 character sequence

//            WB_ERROR_PRINT("TEMPORARY:  (f) pHyphenBuf=\"%s\"\n", pHyphenBuf);
          }
        }
      }

      if(pRval)
      {
        WBCatString(&pRval, "<br>\r\n");
      }
    }
    else
    {
      p5 = p4;
      i1 = 0;

      while(p5 < p3) // tabs?
      {
        if(*p5 == '\t')
        {
          i1++; // count them
        }

        p5++;
      }

      pTemp = WBAlloc(i1 * NBSP_TAB_WIDTH * (sizeof(szNBSP) - 1) + cbLineLen * 12 + 4); // way more than enough space (12 times the length)

      if(!pTemp)
      {
        WBFree(pRval);
        pRval = NULL;
        break;
      }

      memcpy(pTemp, p4, cbLineLen);
      pTemp[cbLineLen] = 0;

      p2 = pTemp;
      i2 = nTabTwist;

      while(*p2)
      {
        if(*p2 == '\x8') // backspace at start of line?
        {
          strcpy(p2, p2 + 1); // just skip it
          continue;
        }

        if(p2[1] == '\x8') // next char is a backspace (this precludes line starting with a backspace
        {
          // there are 2 options possible - one is A<BS>A and the other is _<BS>A or A<BS>_ [either fine]

          if(*p2 == p2[2]) // BOLD
          {
            // Insert a <B> here and overwrite the first 2 characters

            memmove(p2 + 1, p2, strlen(p2) + 1); // 2 chars overwritten, move over 1
            memcpy(p2, "<B>", 3);

            p2 += 3; // point to the original character

            // if the first character in the sequence is a '<' or '>' I have to deal with it FIRST
            if(*p2 == '<' || *p2 == '>')
            {
              char cTemp = *p2;

              memmove(p2 + 3, p2, strlen(p2) + 1); // need room for '&gt;' or '&lt;' overwriting the original

              if(cTemp == '<')
              {
                memcpy(p2, "&lt;", 4);
              }
              else  // if(cTemp == '>')
              {
                memcpy(p2, "&gt;", 4);
              }

              p2 += 4; // increment past the tag
            }
            else
            {
              p2++; // increment past the character
            }

            while(*p2 && p2[1] == '\x8' && *p2 == p2[2])
            {
              if(*p2 == '<' || *p2 == '>')
              {
                char cTemp = *p2;

                memmove(p2 + 1, p2, strlen(p2) + 1); // need room for '&gt;' or '&lt;' and minus 3 chars

                if(cTemp == '<')
                {
                  memcpy(p2, "&lt;", 4);
                }
                else  // if(cTemp == '>')
                {
                  memcpy(p2, "&gt;", 4);
                }

                p2 += 4; // increment past the tag
              }
              else
              {
                memcpy(p2, p2 + 2, strlen(p2 + 2) + 1); // skip the A<BS> and just have A
                p2++;
              }
            }

            // now that I'm at the end of the sequence, insert </B>

            memmove(p2 + 4, p2, strlen(p2) + 1);
            memcpy(p2, "</B>", 4);

            p2 += 4;
            continue;
          }
          else if(*p2 == '_' || p2[2] == '_') // UNDERSCORE
          {
            // Insert a <U> here

            memmove(p2 + 1, p2, strlen(p2) + 1); // 2 chars overwritten, move over 1
            if(*p2 != '_')
            {
              p2[2] = *p2; // move the character to underline "up there"
            }
            memcpy(p2, "<U>", 3);

            p2 += 3; // point to the original 'underscored' character

            // if the first character in the sequence is a '<' or '>' I have to deal with it FIRST
            if(*p2 == '<' || *p2 == '>')
            {
              char cTemp = *p2;

              memmove(p2 + 3, p2, strlen(p2) + 1); // need room for '&gt;' or '&lt;' overwriting the original

              if(cTemp == '<')
              {
                memcpy(p2, "&lt;", 4);
              }
              else  // if(cTemp == '>')
              {
                memcpy(p2, "&gt;", 4);
              }

              p2 += 4; // increment past the tag
            }
            else
            {
              p2++; // increment past the character
            }


            while(*p2 && p2[1] == '\x8' && (*p2 == '_' || p2[2] == '_'))
            {
              if(*p2 == '_')
              {
                *p2 = p2[2]; // move it "back down"
              }

              if(*p2 == '<' || *p2 == '>')
              {
                char cTemp = *p2;

                memmove(p2 + 1, p2, strlen(p2) + 1); // need room for '&gt;' or '&lt;' and minus 3 chars

                if(cTemp == '<')
                {
                  memcpy(p2, "&lt;", 4);
                }
                else  // if(cTemp == '>')
                {
                  memcpy(p2, "&gt;", 4);
                }

                p2 += 4; // increment past the tag
              }
              else
              {
                memcpy(p2, p2 + 2, strlen(p2 + 2) + 1); // skip the A<BS> and just have A
                p2++;
              }
            }

            // now that I'm at the end of the sequence, insert </U>

            memmove(p2 + 4, p2, strlen(p2) + 1);
            memcpy(p2, "</U>", 4);

            p2 += 4;
            continue;
          }
        }
        else if(*p2 == '<' || *p2 == '>')
        {
          memmove(p2 + 3, p2, strlen(p2) + 1); // need room for '&gt;' or '&lt;'

          if(*p2 == '<')
          {
            memcpy(p2, "&lt;", 4);
          }
          else  // if(*p2 == '>')
          {
            memcpy(p2, "&gt;", 4);
          }

          p2 += 3;  // point at the ';' and loop
        }

        // once THAT has been done, check for a tab character and insert '&nbsp;'s
        if(*p2 == '\t')
        {
          p1 = p2; // current position - has a tab in it
          p2 += (sizeof(szNBSP) - 1) * (NBSP_TAB_WIDTH - i2); // next character to process, skips nbsp's

          if(p1[1])
          {
            memmove(p2, p1 + 1, strlen(p1 + 1) + 1); // don't copy the tab, but DO copy everything else (p1 + 1)
          }
          else
          {
            *p2 = 0; // end the string (I'm at the end)
          }

          for(; i2 < NBSP_TAB_WIDTH; i2++)
          {
            memcpy(p1, szNBSP, sizeof(szNBSP) - 1);
            p1 += sizeof(szNBSP) - 1;
          }

          i2 = 0; // no tab twist at the moment
        }
        else
        {
          p2++; // next character
          i2 = (i2 + 1) % NBSP_TAB_WIDTH; // "tab twist"
        }
      }

      // pTemp now contains the entire 'cooked' line.  If I must trim off a trailing hyphen
      // put the text into 'pHyphenBuf'.  Then create a line from the rest

      p2 = pTemp + strlen(pTemp);

      if(bNoHyphen)
      {
        if(*pTemp && *(p2 - 1) == '-') // hyphenated
        {
          p2--;
          *p2 = 0; // trim the dash

          while(p2 > pTemp && *(p2 - 1) > ' ' && *(p2 - 1) != '.'
                && *(p2 - 1) != ',' && *(p2 - 1) != ')' && *(p2 - 1) != ']' && *(p2 - 1) != '}')
          {
            p2--; // decrement until at the beginning of a word
          }

          pHyphenBuf = WBCopyString(p2);
          *p2 = 0; // trim hyphenated partial word off of the string

//          WB_ERROR_PRINT("TEMPORARY:  (b) pHyphenBuf=\"%s\"\n", pHyphenBuf);
        }
        else if(p2 > pTemp + 3 && *(p2 - 3) == '\xe2' && *(p2 - 2) == '\x80' && *(p2 - 1) == '\x90')
        {
          // the sequence <E2><80><90> is found on debian's man program, and since they
          // define the gnu standard, it's likely to be elsewhere also

          p2 -= 3; // 3 character sequence (remove it)
          *p2 = 0; // trim the 3 character sequence

          while(p2 > pTemp && *(p2 - 1) > ' ' && *(p2 - 1) != '.'
                && *(p2 - 1) != ',' && *(p2 - 1) != ')' && *(p2 - 1) != ']' && *(p2 - 1) != '}')
          {
            p2--; // decrement until at the beginning of a word
          }

          pHyphenBuf = WBCopyString(p2);
          *p2 = 0; // trim hyphenated partial word off of the string

//          WB_ERROR_PRINT("TEMPORARY:  (c) pHyphenBuf=\"%s\"\n", pHyphenBuf);
        }
      }
      else  if(p2 > pTemp + 3 && *(p2 - 3) == '\xe2' && *(p2 - 2) == '\x80' && *(p2 - 1) == '\x90')
      {
        // the sequence <E2><80><90> is found on debian's man program, and since they
        // define the gnu standard, it's likely to be elsewhere also

        p2 -= 2; // 3 character sequence (remove it, replace with '-')
        *(p2 - 1) = '-';
        *p2 = 0; // trim the 3 character sequence

//      WB_ERROR_PRINT("TEMPORARY:  (f) pHyphenBuf=\"%s\"\n", pHyphenBuf);
      }

      strcat(pTemp, "<br>\r\n");

      if(pRval)
      {
        WBCatString(&pRval, pTemp);
      }

      WBFree(pTemp);
      pTemp = NULL; // by convention
    }
  }

  if(pRval)
  {
    WBCatString(&pRval, "<br>\r\n<hr size=2>\r\n<p align=\"center\">Generated internally by X11workbench</p>\r\n"
                "</TT></BODY></HTML>\r\n");
  }

  return pRval;
}


