/////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                             //
//      _  _         _                                       _                _         _      //
//   __| |(_)  __ _ | |  ___    __ _       ___  ___   _ __  | |_  _ __  ___  | | ___   | |__   //
//  / _` || | / _` || | / _ \  / _` |     / __|/ _ \ | '_ \ | __|| '__|/ _ \ | |/ __|  | '_ \  //
// | (_| || || (_| || || (_) || (_| |    | (__| (_) || | | || |_ | |  | (_) || |\__ \ _| | | | //
//  \__,_||_| \__,_||_| \___/  \__, |_____\___|\___/ |_| |_| \__||_|   \___/ |_||___/(_)_| |_| //
//                             |___/|_____|                                                    //
//                                                                                             //
//                                  dialog control support                                     //
//                                                                                             //
/////////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2016 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no waranties, either implied or explicit.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/


#ifndef DIALOG_CONTROLS_H_INCLUDED
#define DIALOG_CONTROLS_H_INCLUDED

#include "window_helper.h"
#include "dialog_window.h"

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


/** \file dialog_controls.h definitions for dialog control structures and APIs */

/** \defgroup dlgctrl_atom 'Control Name' Atoms for standard dialog controls
  * \ingroup dlgctrl
  *
  * 'Control Name' atoms for pre-defined (standard) dialog controls
**/

/** \defgroup dlgctrl_notify CONTROL NOTIFY Atoms for dialog controls
  * \ingroup dlgctrl
  *
  * Control Notification (ClientMessage) Atoms for standard dialog controls
  * using the \ref aCONTROL_NOTIFY atom as the message type.
**/


#define DIALOG_CONTROL_TAG (*((const unsigned int *)"DLGC"))

/** \ingroup dlgctrl
  * \typedef WB_DIALOG_PROP
  * \brief Dialog property storage structure
  *
  * Internally dialog properties are stored using this structure.  An
  * array of these are stored as a \ref WBDialogPropList for each
  * dialog control that has properties.  Certain properties, however,
  * are mapped to structure members within the \ref WBDialogControl
  * structure.\n
\code
typedef struct __WB_DIALOG_PROP__
{
  Atom aProp;          // Atom identifying the property
  unsigned long lVal;  // 'long' data value, assigned as needed
  void *pVal;          // pointer to data, as needed (may be allocated, some property types auto-free the data)
} WB_DIALOG_PROP;
\endcode
  *  /sa  __WB_DIALOG_PROP__ and WBDialogPropList
*/
/** \ingroup dlgctrl
  * \struct __WB_DIALOG_PROP__
  * \brief Dialog property storage structure (one structure per property)
  *
  * Dialog property storage structure.  Additional details can be found in the
  * documentation for \ref WB_DIALOG_PROP and \ref WBDialogPropList.\n
*/
typedef struct __WB_DIALOG_PROP__
{
  Atom aProp;          ///< Atom identifying the property
  unsigned long lVal;  ///< 'long' data value, assigned as needed
  void *pVal;          ///< pointer to data, as needed (may be allocated, some property types auto-free the data)
} WB_DIALOG_PROP;

/** \ingroup dlgctrl
  * \typedef WBDialogPropList
  * \brief Dialog Property List, container for \ref WB_DIALOG_PROP
  *
  * Container structure for WB_DIALOG_PROP structures, pre-allocated
  * to hold 'nMaxProps'.  Can be re-allocated as necessary to increase
  * the total number of properties so long as the pointer to this
  * structure isn't being cached outside of the \ref WBDialogConrol\n
  *
\code
typedef struct __WB_DIALOG_PROPLIST__
{
  int nProps, nMaxProps;      // total number of active properties and maximum size of aDlgProp
  WB_DIALOG_PROP aDlgProp[1]; // Array of property definitions (contiguous, pre-allocated)
} WBDialogPropList;
\endcode
  *
  * /sa  \ref __WB_DIALOG_PROPLIST__, \ref __WB_DIALOG_PROP__
  *
  * Properties are maintained using the following X11 Work Bench Toolkit API functions:\n
  * low-level functions:  WBDialogControlSetDialogProp(), WBDialogControlDelDialogProp(), WBDialogControlGetDialogProp()\n
  * mid-level functions:  WBDialogControlSetProperty(), WBDialogControlSetProperty2(), WBDialogControlGetProperty(), WBDialogControlGetProperty2()\n
  * high-level functions:  WBDialogControlSetCaption(), WBDialogControlGetCaption(), WBDialogControlSetPixmap(), WBDialogControlGetPixmap()
  * WBDialogControlSetIconPixmap(), WBDialogControlGetIconPixmap(), WBDialogControlSetText(), WBDialogControlGetText()\n
  * simplified string property functions:  DLGSetControlProperty(), DLGGetControlProperty()\n
  * combined with dialog window:  DLGSetControlCaption(), DLGGetControlCaption()\n
*/
/** \ingroup dlgctrl
  * \struct __WB_DIALOG_PROPLIST__
  * \brief Container structure for the dialog property storage structures
  *
  * Pre-allocated container structure for dialog property storage.  Maintenance of this
  * structure should NOT be performed outside of the X11 Work Bench Toolkit API functions.
  * Additional details, and a list of API functions, can be found in the
  * documentation for \ref WBDialogPropList.\n
*/
typedef struct __WB_DIALOG_PROPLIST__
{
/** \brief current number of (contiguous) properties in 'aDlgProp' */
  int nProps,
/** \brief maximum number of available \ref WB_DIALOG_PROP structures in aDlgProp */
      nMaxProps;
/** \brief Pre-allocated array of (contiguous) structures for property storage
  *
  * This structure integrates the pre-allocated array of WB_DIALOG_PROP structures
  * and provides access to them via the aDlgProp array.  Whenever adding a new
  * property causes the total number to exceed nMaxProps, the entire structure must
  * be re-allocated to accomodate the new entries, with all existing members of the
  * array copied to the re-allocated structure.  This is handled properly by use of
  * the X11 Work Bench Toolkit API functions for dialog control property management. */
  WB_DIALOG_PROP aDlgProp[1];
} WBDialogPropList;


/** \ingroup dlgctrl
  * \typedef WBDialogControl
  * \brief Structure identifying the properties of a dialog box control
  *
  * All dialog box controls have certain properties in common, and most of them
  * also have a number of other common properties.  Those properties most commonly
  * used by dialog box controls are stored as members of a WBDialogControl structure
  * and additional properties in an allocated WBDialogPropList (as needed)\n
  * For performance reasons, some control types may allocate a 'superclass' of this
  * structure with additional data members.\n
\code
typedef struct __WB_DIALOG_CONTROL__
{
  unsigned int ulTag;               // The value DIALOG_CONTROL_TAG
  Window wID;                       // Window ID of the dialog control window
  Atom aClass;                      // basic control class atom
  WBDialogWindow *pOwner;           // pointer to owner dialog box
  WBDialogEntry *pDlgControlEntry;  // pointer to dialog box's WBDialogEntry
  WBWinEvent pDLGControlCallback;   // control's callback function
  unsigned long ulFlags;            // generic flag bits
  XColor clrFG, clrBG, clrBD;       // FG, BG, and border colors
  XColor clrBD2, clrBD3;            // additional 3D border colors
  XColor clrHFG, clrHBG;            // highlight BG and FG colors
  XColor clrAFG, clrABG;            // active BG and FG colors
  char *pCaption;                   // in lieu of using WM_NAME property
  WBDialogPropList *pPropList;      // property list
  int cbStructSize;                 // assigned at allocation time, the total size of this structure

  // unique per-control data members follow (see cbStructSize for validation)

} WBDialogControl;
\endcode
  * For each dialog control, a pointer to this structure is assigned to window property index 0, and can be
  * easily obtained using DLGGetDialogControlStruct() (preferred method)
  *
  * /sa  __WB_DIALOG_CONTROL__ and WBDialogPropList
*/
/** \ingroup dlgctrl
  * \struct __WB_DIALOG_CONTROL__
  * \brief Structure identifying the properties of a dialog box control
  *
  * This data structure identifies a dialog control's properties.  For more information,
  * see \ref WBDialogControl
*/
typedef struct __WB_DIALOG_CONTROL__
{
  unsigned int ulTag;               ///< The value DIALOG_CONTROL_TAG
  Window wID;                       ///< Window ID of the dialog control window
  Atom aClass;                      ///< basic control class atom
  WBDialogWindow *pOwner;           ///< pointer to owner dialog box
  WBDialogEntry *pDlgControlEntry;  ///< pointer to dialog box's WBDialogEntry
  WBWinEvent pDLGControlCallback;   ///< control's callback function
  unsigned long ulFlags;            ///< generic flag bits
  XColor clrFG,                     ///< foreground color
         clrBG,                     ///< background color
         clrBD;                     ///< border color
  XColor clrBD2,                    ///< 3D border color 2 (light)
         clrBD3;                    ///< 3D border color 3 (dark)
  XColor clrHFG,                    ///< highlighted state-based foreground color
         clrHBG;                    ///< highlighted state-based background color
  XColor clrAFG,                    ///< active state-based foreground color
         clrABG;                    ///< active state-based background color
  char *pCaption;                   ///< allocated pointer to caption, in lieu of using a WM_NAME property (may be NULL)
  WBDialogPropList *pPropList;      ///< pointer to the property list (may be NULL)
  int cbStructSize;                 ///< assigned at allocation time, the total size of this structure

  // unique per-control data members follow (see cbStructSize for validation)

} WBDialogControl;


/** \ingroup dlgctrl
  * \brief Initialization function for dialog controls
  *
  * This function must be called once before using any of the Dialog Control functions.
  * Normally an explicit call to this won't be necessary since Dialog (frame) Window
  * support code in dialog_window.c does this automatically.
*/
void WBDialogControlsInit(void);  // call once before using (dialog_window.c does this for you)

/** \ingroup dlgctrl
  * \brief Create a dialog control window
  *
  * \return Pointer to a WBDialogControl structure associated with the dialog control window
  * \param aClass The class name atom for the window being created (may be None)
  * \param pOwner The owner window (usually a dialog frame window)
  * \param pDialogEntry A pointer to the WBDialogEntry structure associated with the control (the one I will be using)
  * \param iX The horizontal position of the upper left corner of the control window (relative to the owner window)
  * \param iY The vertical position of the upper left corner of the control window (relative to the owner window)
  * \param iWidth The width of the control window
  * \param iHeight The height of the control window
  * \param szTitle A null-byte terminated string containing the 'title' text for the control (may be NULL)
  * \param szPropertyList A set of newline terminated strings, ending with a null-byte, containing property/value pairs for initial property assignment
  * \returns A pointer to a WBDialogControl structure identifying the control
  *
  * Use this function to create a dialog conrol window, returning a pointer to the WBDialogControl
  * class containing its properties.
*/
WBDialogControl * WBDialogControlCreate(Atom aClass, WBDialogWindow *pOwner,
                                        WBDialogEntry *pDialogEntry, // pointer to the dialog entry I'll be using
                                        int iX, int iY, int iWidth, int iHeight,
                                        const char *szTitle, const char *szPropertyList);

/** \ingroup dlgctrl
  * \brief Register the dialog control's callback function and class name
  *
  * \param pDialogControl A pointer to the WBDialogControl structure that is associated with the dialog control window
  * \param szClassName An optional 'class name' string to be used for debug and tracing (may be NULL)
  * \param pCallback The callback function to assign to the control window
  *
  * Registers the callback function for the dialog control.  Also assigns the class name string pointer (for debug
  * and trace purposes), which may be different from the default in the case of a subclassed control.  This will
  * normally be called immediately after creating the control using WBDialogControlCreate()
*/
void DLGRegisterControlCallback(WBDialogControl *pDialogControl, const char *szClassName, WBWinEvent pCallback);


// generic property list helpers (low level)
/** \ingroup dlgctrl
  * \brief Low-level dialog control property assignment
*/
int WBDialogControlSetDialogProp(WBDialogControl *pCtrl, WB_DIALOG_PROP *pPropVal); // returns 0 on success
/** \ingroup dlgctrl
  * \brief Low-level dialog control property removal
*/
void WBDialogControlDelDialogProp(WBDialogControl *pCtrl, Atom aProp);
/** \ingroup dlgctrl
  * \brief Low-level dialog control property retrieval
*/
const WB_DIALOG_PROP *WBDialogControlGetDialogProp(WBDialogControl *pCtrl, Atom aProp);
/** \ingroup dlgctrl
  * \brief Low-level dialog control property list retrieval
*/
static __inline__ const WBDialogPropList *WBDialogControlGetPropList(WBDialogControl *pCtrl)
{
  if(pCtrl)
  {
    return pCtrl->pPropList;
  }
  return NULL;
}

// generic property list helpers (mid-level)

/** \ingroup dlgctrl
  * \brief Mid-level dialog control property list assignment
*/
int WBDialogControlSetPropList(WBDialogControl *pCtrl, const char *szPropList); // prop:value prop:"value" etc. separated by white space
/** \ingroup dlgctrl
  * \brief Mid-level dialog control property assignment (character string)
  *
  * Strings are stored internally within the property list as a memory block allocated via 'malloc()'.
  * If an existing pointer is already present when a new string is assigned, it is destroyed via 'free()'.
  * The assigned value is then copied into a memory block allocated via 'malloc()' and stored in the property list.
*/
int WBDialogControlSetProperty(WBDialogControl *pCtrl, Atom aPropName, const char *szPropVal);
/** \ingroup dlgctrl
  * \brief Mid-level dialog control property list assignment (generic pointer)
  *
  * Pointers assigned as a property must have been allocated using 'malloc()' (or NULL).  Any existing
  * pointer already assigned to this property will be automatically destroyed using 'free()'.
  * The property itself is considered to be 'owned' by the property list, and will be cleaned up
  * when the control window is destroyed.
*/
void WBDialogControlSetProperty2(WBDialogControl *pCtrl, Atom aPropName, void *szPropVal); // szPropVal must be malloc'd pointer or NULL

/** \ingroup dlgctrl
  * \brief Mid-level dialog control property retrieval (character string)
  *
  * This function returns the actual string pointer stored within the property list, and may be NULL.
  * To modify an existing sring value, you should first make a copy of the string (as needed), then modify
  * the copy and re-assign teh value via WBDialogControlSetProperty().
*/
const char *WBDialogControlGetProperty(WBDialogControl *pCtrl, Atom aPropName);
/** \ingroup dlgctrl
  * \brief Mid-level dialog control property list retrieval (generic pointer)
  *
  * Pointers assigned as a property must have been allocated using 'malloc()'.  Any existing
  * pointer already assigned to this property will be automatically destroyed using 'free()'.
  * The property itself is considered to be 'owned' by the property list, and will be cleaned up
  * when the control window is destroyed.
*/
void *WBDialogControlGetProperty2(WBDialogControl *pCtrl, Atom aPropName); // returns actual malloc'd pointer or NULL

// NOTE:  use WBDialogControlSetProperty2 to directly assign malloc'd pointer, and modify actual data returned by above
//        Assigning different pointer in WBDialogControlGetProperty2 'free's existing pointer
//        Destroying property list does the same thing.


/** \ingroup dlgctrl
  * \brief Returns a pointer to the WBDialogControl structure for a dialog control with validation.  May return NULL
  *
  * \param wID Window ID of the dialog control
  * \return Pointer to WBDialogControl structure associated with the dialog control, or NULL if error or nonexistent
  *
  * This is the preferred function for obtaining a pointer to the WBDialogControl structure for a dialog control window
*/
static __inline__ WBDialogControl *DLGGetDialogControlStruct(Window wID)  // for frame windows, returns the frame window struct
{
  WBDialogControl *pRval = (WBDialogControl *)WBGetWindowData(wID, 0);  // offset 0 for window-specific structs

  if(pRval && pRval->ulTag == DIALOG_CONTROL_TAG)
    return(pRval);

  return(NULL);
}



// dialog control property management (high level)

/** \ingroup dlgctrl
  * \brief Assign text to the 'CAPTION' property of a dialog control
  *
  * The CAPTION property is a standard property for a dialog control.  Since it has
  * its own data member in the \ref WBDialogControl structure, you should maintain
  * it using this function.  It is equivalent to the 'Title'.
*/
void WBDialogControlSetCaption(WBDialogControl *pCtrl, const char *szCaption); // caption (all, equiv to 'title')
/** \ingroup dlgctrl
  * \brief Obtain a pointer to the assigned text for the 'CAPTION' property of a dialog control
  *
  * The CAPTION property is a standard property for a dialog control.  Since it has
  * its own data member in the \ref WBDialogControl structure, you should only query
  * it using this function.  It is equivalent to the 'Title'.
*/
const char *WBDialogControlGetCaption(WBDialogControl *pCtrl);

/** \ingroup dlgctrl
  * \brief Assign the PIXMAP (image) property for a control
  *
  * The PIXMAP property is a standard property for a dialog control.  Since it has
  * its own data member in the \ref WBDialogControl structure, you should only
  * maintain it using this function.  It is equivalent to the IMAGE or ICON property.
*/
void WBDialogControlSetPixmap(WBDialogControl *pCtrl, Pixmap pixmap);  // pixmaps (image, icon, button?)
/** \ingroup dlgctrl
  * \brief Obtain the assigned PIXMAP (image) property for a control
  *
  * The PIXMAP property is a standard property for a dialog control.  Since it has
  * its own data member in the \ref WBDialogControl structure, you should only
  * query it using this function.  It is equivalent to the IMAGE or ICON property.
*/
Pixmap WBDialogControlGetPixmap(WBDialogControl *pCtrl);

/** \ingroup dlgctrl
  * \brief Assign the ICON (image) property for a control, which consists of 2 pixmaps
  *
  * \param pCtrl A ponter to the WBDialogControl structure for the control
  * \param pixmap The foreground pixmap for the ICON image
  * \param pixmap2 The transparency (mask) pixmap for the ICON image
  *
  * The ICON property is a standard property for a dialog control.  Since it has
  * its own data member in the \ref WBDialogControl structure, you should only
  * maintain it using this function.  It is equivalent to the IMAGE or PIXMAP property.
*/
void WBDialogControlSetIconPixmap(WBDialogControl *pCtrl, Pixmap pixmap, Pixmap pixmap2);  // icons only
/** \ingroup dlgctrl
  * \brief Obtain the assigned ICON (image) property for a control, which consists of 2 pixmaps
  *
  * \param pCtrl A ponter to the WBDialogControl structure for the control
  * \param pPixmap2 A pointer to the storage for the returned transparency (mask) pixmap for the ICON image.  May be NULL
  * \return The foreground pixmap for the ICON image.  May be None if no pixmap has been assigned.
  *
  * The ICON property is a standard property for a dialog control.  Since it has
  * its own data member in the \ref WBDialogControl structure, you should only
  * maintain it using this function.  It is equivalent to the IMAGE or PIXMAP property.
*/
Pixmap WBDialogControlGetIconPixmap(WBDialogControl *pCtrl, Pixmap *pPixmap2);

/** \ingroup dlgctrl
  * \brief Assign the TEXT property for a control, which is different from the CAPTION or Title
  *
  * The TEXT property is a standard property for a dialog control.  To preserve consistency
  * use this function to assign it, rather than assigning the TEXT property directly.
*/
static __inline__ void WBDialogControlSetText(WBDialogControl *pCtrl, const char *szText)
{
#ifdef DIALOG_SUPPORT_C
extern Atom aDLGC_TEXT;
#else // DIALOG_SUPPORT_C
extern const Atom aDLGC_TEXT;
#endif // DIALOG_SUPPORT_C

  // multi-line edit, listboxes, and combo boxes use this

  WBDialogControlSetProperty(pCtrl, aDLGC_TEXT, szText);
}

/** \ingroup dlgctrl
  * \brief Obtain the assigned TEXT property for a control, which is different from the CAPTION or Title
  *
  * The TEXT property is a standard property for a dialog control.  To preserve consistency
  * use this function to query it, rather than querying the TEXT property directly.
*/
static __inline__ const char *WBDialogControlGetText(WBDialogControl *pCtrl)
{
#ifdef DIALOG_SUPPORT_C
extern Atom aDLGC_TEXT;
#else // DIALOG_SUPPORT_C
extern const Atom aDLGC_TEXT;
#endif // DIALOG_SUPPORT_C

  return WBDialogControlGetProperty(pCtrl, aDLGC_TEXT);
}



// combined functionality with dialog window

/** \ingroup dlgctrl
  * \brief Returns a pointer to the WBDialogControl structure for a dialog control with validation.  May return NULL
  *
  * \param pDialog Pointer to the WBDialogWindow structure of the parent
  * \param iControlID Dialog control ID for the desired control
  * \return Pointer to WBDialogControl structure associated with the dialog control, or NULL if error or nonexistent
  *
  * This is the preferred function for obtaining a pointer to the WBDialogControl structure for a dialog control window
  * using the control ID and owning dialog window
*/
static __inline__ WBDialogControl *DLGGetDialogControlStructFromID(WBDialogWindow *pDialog, int iControlID)
{
  if(pDialog)
  {
    Window idCtrl = DLGGetDialogControl(pDialog, iControlID);
    if(idCtrl > 0)
    {
      WBDialogControl *pRval = (WBDialogControl *)WBGetWindowData(idCtrl, 0);  // offset 0 for window-specific structs

      if(pRval && pRval->ulTag == DIALOG_CONTROL_TAG)
        return(pRval);
    }
  }
  return NULL;
}

/** \ingroup dlgctrl
  * \brief Convenience function to assign a dialog control's caption based on its control ID
  *
  * \param pDialog Pointer to the WBDialogWindow structure of the parent
  * \param iControlID Dialog control ID for the desired control
  * \param szCaption pointer to ASCII string containing the new caption
  *
  * Often it is desirable to assign control properties using the WBDialogWindow structure for the
  * dialog (frame) window and the control's ID, rather than writing several lines of code to query
  * for the correct information, test for validity, etc. and THEN make the assignment.  When the
  * control ID is known, but the Window or WBDialogControl structure pointer is not, use THIS
  * function to assign the caption.
*/
static __inline__ void DLGSetControlCaption(WBDialogWindow *pDialog, int iControlID, const char *szCaption)
{
  if(pDialog)
  {
    Window idCtrl = DLGGetDialogControl(pDialog, iControlID);
    if(idCtrl > 0)
    {
      WBDialogControl *pCtrl = (WBDialogControl *)WBGetWindowData(idCtrl, 0);  // offset 0 for window-specific structs

      if(pCtrl && pCtrl->ulTag == DIALOG_CONTROL_TAG)
      {
        WBDialogControlSetCaption(pCtrl, szCaption);
      }
    }
  }
}

/** \ingroup dlgctrl
  * \brief Convenience function to query a dialog control's caption based on its control ID
  *
  * \param pDialog Pointer to the WBDialogWindow structure of the parent
  * \param iControlID Dialog control ID for the desired control
  *
  * Often it is desirable to query control properties using the WBDialogWindow structure for the
  * dialog (frame) window and the control's ID, rather than writing several lines of code to query
  * for the correct information, test for validity, etc. and THEN make the final query.  When the
  * control ID is known, but the Window or WBDialogControl structure pointer is not, use THIS
  * function to query for the caption.
*/
static __inline__ const char * DLGGetControlCaption(WBDialogWindow *pDialog, int iControlID)
{
  if(pDialog)
  {
    Window idCtrl = DLGGetDialogControl(pDialog, iControlID);
    if(idCtrl > 0)
    {
      WBDialogControl *pCtrl = (WBDialogControl *)WBGetWindowData(idCtrl, 0);  // offset 0 for window-specific structs

      if(pCtrl && pCtrl->ulTag == DIALOG_CONTROL_TAG)
      {
        return WBDialogControlGetCaption(pCtrl);
      }
    }
  }

  return NULL;
}

/** \ingroup dlgctrl
  * \brief Convenience function to assign a dialog control's TEXT based on its control ID
  *
  * \param pDialog Pointer to the WBDialogWindow structure of the parent
  * \param iControlID Dialog control ID for the desired control
  * \param szText pointer to ASCII string containing the new text
  *
  * Often it is desirable to assign control properties using the WBDialogWindow structure for the
  * dialog (frame) window and the control's ID, rather than writing several lines of code to query
  * for the correct information, test for validity, etc. and THEN make the assignment.  When the
  * control ID is known, but the Window or WBDialogControl structure pointer is not, use THIS
  * function to assign the caption.
*/
static __inline__ void DLGSetControlText(WBDialogWindow *pDialog, int iControlID, const char *szText)
{
  if(pDialog)
  {
    Window idCtrl = DLGGetDialogControl(pDialog, iControlID);
    if(idCtrl > 0)
    {
      WBDialogControl *pCtrl = (WBDialogControl *)WBGetWindowData(idCtrl, 0);  // offset 0 for window-specific structs

      if(pCtrl && pCtrl->ulTag == DIALOG_CONTROL_TAG)
      {
        WBDialogControlSetText(pCtrl, szText);
      }
    }
  }
}

/** \ingroup dlgctrl
  * \brief Convenience function to query a dialog control's TEXT based on its control ID
  *
  * \param pDialog Pointer to the WBDialogWindow structure of the parent
  * \param iControlID Dialog control ID for the desired control
  *
  * Often it is desirable to query control properties using the WBDialogWindow structure for the
  * dialog (frame) window and the control's ID, rather than writing several lines of code to query
  * for the correct information, test for validity, etc. and THEN make the final query.  When the
  * control ID is known, but the Window or WBDialogControl structure pointer is not, use THIS
  * function to query for the caption.
*/
static __inline__ const char * DLGGetControlText(WBDialogWindow *pDialog, int iControlID)
{
  if(pDialog)
  {
    Window idCtrl = DLGGetDialogControl(pDialog, iControlID);
    if(idCtrl > 0)
    {
      WBDialogControl *pCtrl = (WBDialogControl *)WBGetWindowData(idCtrl, 0);  // offset 0 for window-specific structs

      if(pCtrl && pCtrl->ulTag == DIALOG_CONTROL_TAG)
      {
        return WBDialogControlGetText(pCtrl);
      }
    }
  }

  return NULL;
}

// simplified string property handlers

/** \ingroup dlgctrl
  * \brief Convenience function to assign a text property for a dialog control based on its control ID
  *
  * \param pDialog Pointer to the WBDialogWindow structure of the parent
  * \param iControlID Dialog control ID for the desired control
  * \param aPropName Atom for the property to be assigned
  * \param szPropVal a pointer to the (text) data to assign to the property
  *
  * Often it is desirable to assign control properties using the WBDialogWindow structure for the
  * dialog (frame) window and the control's ID, rather than writing several lines of code to query
  * for the correct information, test for validity, etc. and THEN make the assignment.  When the
  * control ID is known, but the Window or WBDialogControl structure pointer is not, use THIS
  * function to assign the property's text value.
  *
  * \sa \ref WBDialogControlSetProperty()
*/
static __inline__ int DLGSetControlProperty(WBDialogWindow *pDialog, int iControlID, Atom aPropName, const char *szPropVal)
{
  if(pDialog)
  {
    Window idCtrl = DLGGetDialogControl(pDialog, iControlID);
    if(idCtrl > 0)
    {
      WBDialogControl *pCtrl = (WBDialogControl *)WBGetWindowData(idCtrl, 0);  // offset 0 for window-specific structs

      if(pCtrl && pCtrl->ulTag == DIALOG_CONTROL_TAG)
      {
        return WBDialogControlSetProperty(pCtrl, aPropName, szPropVal);
      }
    }
  }

  return -1; // error
}

/** \ingroup dlgctrl
  * \brief Convenience function to query a text property for a dialog control based on its control ID
  *
  * \param pDialog Pointer to the WBDialogWindow structure of the parent
  * \param iControlID Dialog control ID for the desired control
  * \param aPropName Atom for the property to be assigned
  * \return A (const) pointer to the (text) data associated with the property, or NULL
  *
  * Often it is desirable to query control properties using the WBDialogWindow structure for the
  * dialog (frame) window and the control's ID, rather than writing several lines of code to query
  * for the correct information, test for validity, etc. and THEN make the final query.  When the
  * control ID is known, but the Window or WBDialogControl structure pointer is not, use THIS
  * function to query for the text property.
  *
  * \sa \ref WBDialogControlGetProperty()
*/
static __inline__ const char * DLGGetControlProperty(WBDialogWindow *pDialog, int iControlID, Atom aPropName)
{
  if(pDialog)
  {
    Window idCtrl = DLGGetDialogControl(pDialog, iControlID);
    if(idCtrl > 0)
    {
      WBDialogControl *pCtrl = (WBDialogControl *)WBGetWindowData(idCtrl, 0);  // offset 0 for window-specific structs

      if(pCtrl && pCtrl->ulTag == DIALOG_CONTROL_TAG)
      {
        return WBDialogControlGetProperty(pCtrl, aPropName);
      }
    }
  }

  return NULL;
}


// standard control IDs
#define IDOK     0x7ffffff0
#define IDNO     0x7ffffff1
#define IDYES    0x7ffffff2
#define IDABORT  0x7ffffff3
#define IDRETRY  0x7ffffff4
#define IDIGNORE 0x7ffffff5
#define IDCANCEL 0x7fffffff
#define IDSTATIC -1 /* may be repeated for static items */
#define IDNONE   0 /* this may be repeated as needed for things that need no ID */


// standard atoms for control types

/** \ingroup dlgctrl_atom **/
#define FRAME_CONTROL_STR            "Frame"             /**< Static Frame Control - \ref aFRAME_CONTROL */
/** \ingroup dlgctrl_atom **/
#define TEXT_CONTROL_STR             "Text"              /**< Static Text Control - \ref aTEXT_CONTROL */
/** \ingroup dlgctrl_atom **/
#define ICON_CONTROL_STR             "Icon"              /**< Static Icon Control - \ref aICON_CONTROL */
/** \ingroup dlgctrl_atom **/
#define IMAGE_CONTROL_STR            "Image"             /**< Static Image Control - \ref aIMAGE_CONTROL */
/** \ingroup dlgctrl_atom **/
#define EDIT_CONTROL_STR             "Edit"              /**< Edit (Text) Control - \ref aEDIT_CONTROL */
/** \ingroup dlgctrl_atom **/
#define PUSHBUTTON_CONTROL_STR       "PushButton"        /**< Push Button Control - \ref aPUSHBUTTON_CONTROL */
/** \ingroup dlgctrl_atom **/
#define DEFPUSHBUTTON_CONTROL_STR    "DefPushButton"     /**< Default Push Button Control - \ref aDEFPUSHBUTTON_CONTROL */
/** \ingroup dlgctrl_atom **/
#define CANCELBUTTON_CONTROL_STR     "CancelButton"      /**< Cancel Push Button Control - \ref aCANCELBUTTON_CONTROL */
/** \ingroup dlgctrl_atom **/
#define RADIOBUTTON_CONTROL_STR      "RadioButton"       /**< Radio Button Control - \ref aRADIOBUTTON_CONTROL */
/** \ingroup dlgctrl_atom **/
#define FIRSTRADIOBUTTON_CONTROL_STR "FirstRadioButton"  /**< First Radio Button Control - \ref aFIRSTRADIOBUTTON_CONTROL */
/** \ingroup dlgctrl_atom **/
#define CHECKBUTTON_CONTROL_STR      "CheckButton"       /**< Checkbox Button Control - \ref aCHECKBUTTON_CONTROL */
/** \ingroup dlgctrl_atom **/
#define TRISTATEBUTTON_CONTROL_STR   "TriStateButton"    /**< Tri-State Button Control - \ref aTRISTATEBUTTON_CONTROL */
/** \ingroup dlgctrl_atom **/
#define HSCROLL_CONTROL_STR          "HScroll"           /**< Horizontal Scroll Bar Control - \ref aHSCROLL_CONTROL */
/** \ingroup dlgctrl_atom **/
#define VSCROLL_CONTROL_STR          "VScroll"           /**< Vertical Scroll Bar Control - \ref aVSCROLL_CONTROL */
/** \ingroup dlgctrl_atom **/
#define SLIDER_CONTROL_STR           "Slider"            /**< Sliding Bar Control - \ref aSLIDER_CONTROL */
/** \ingroup dlgctrl_atom **/
#define KNOB_CONTROL_STR             "Knob"              /**< 'Volume' Knob Control - \ref aKNOB_CONTROL */
/** \ingroup dlgctrl_atom **/
#define LIST_CONTROL_STR             "List"              /**< List Box Control - \ref aLIST_CONTROL */
/** \ingroup dlgctrl_atom **/
#define COMBO_CONTROL_STR            "Combo"             /**< Combo Box Control - \ref aCOMBO_CONTROL */
/** \ingroup dlgctrl_atom **/
#define TREE_CONTROL_STR             "Tree"              /**< Tree Control - \ref aTREE_CONTROL */
/** \ingroup dlgctrl_atom **/
#define COMBOTREE_CONTROL_STR        "ComboTree"         /**< Combo Tree Control - \ref aCOMBOTREE_CONTROL */
/** \ingroup dlgctrl_atom **/
#define FILE_LIST_CONTROL_STR        "FileList"          /**< File List Control - \ref aFILE_LIST_CONTROL */
/** \ingroup dlgctrl_atom **/
#define FILE_COMBO_CONTROL_STR       "FileCombo"         /**< File Combo Control - \ref aFILE_COMBO_CONTROL */
/** \ingroup dlgctrl_atom **/
#define PATH_TREE_CONTROL_STR        "PathTree"          /**< Path Tree Control - \ref aPATH_TREE_CONTROL */
/** \ingroup dlgctrl_atom **/
#define TAB_CONTROL_STR              "Tab"               /**< Tab Control - \ref aTAB_CONTROL */


// atoms and strings for standard control types (doxygen - these are documented in dialog_controls.c)
#ifndef DIALOG_SUPPORT_C

// static controls

extern const Atom aFRAME_CONTROL;             // transparent frame with optional text - \ref FRAME_CONTROL_STR
extern const Atom aTEXT_CONTROL;              // static text (single or multi-line) - \ref TEXT_CONTROL_STR
extern const Atom aICON_CONTROL;              // icon container (has a nice 3D border) - \ref ICON_CONTROL_STR
extern const Atom aIMAGE_CONTROL;             // generic image/pixmap holder - \ref IMAGE_CONTROL_STR


// text entry

extern const Atom aEDIT_CONTROL;              // editable text (single or multi-line, scrollable, clipboard) - \ref EDIT_CONTROL_STR


// buttons, knobs, and sliders

extern const Atom aPUSHBUTTON_CONTROL;        // Pushbutton control - \ref PUSHBUTTON_CONTROL_STR
extern const Atom aDEFPUSHBUTTON_CONTROL;     // default Pushbutton control (has dark border, accepts &lt;ENTER&gt; as hotkey) - \ref DEFPUSHBUTTON_CONTROL_STR
extern const Atom aCANCELBUTTON_CONTROL;      // cancel pushbutton control (accepts &lt;ESC&gt; as hotkey) - \ref CANCELBUTTON_CONTROL_STR
extern const Atom aRADIOBUTTON_CONTROL;       // radio button - \ref RADIOBUTTON_CONTROL_STR
extern const Atom aFIRSTRADIOBUTTON_CONTROL;  // 'first' radio button - defines start of radio button 'group' - \ref FIRSTRADIOBUTTON_CONTROL_STR
extern const Atom aCHECKBUTTON_CONTROL;       // check[box] button - push-on/push-off with 'check mark' (or whatever) - \ref CHECKBUTTON_CONTROL_STR
extern const Atom aTRISTATEBUTTON_CONTROL;    // tristate - like check, but with a third state - \ref TRISTATEBUTTON_CONTROL_STR
extern const Atom aHSCROLL_CONTROL;           // horizontal scroll - \ref HSCROLL_CONTROL_STR
extern const Atom aVSCROLL_CONTROL;           // vertical scroll - \ref VSCROLL_CONTROL_STR
extern const Atom aSLIDER_CONTROL;            // volume control (slider bar) (h or v depending on geometry) - \ref SLIDER_CONTROL_STR
extern const Atom aKNOB_CONTROL;              // "volume knob" (270 degrees of rotation, left to right) - \ref KNOB_CONTROL_STR


// lists

extern const Atom aLIST_CONTROL;              // list - single, multi, extended select (h, v, multicol) - \ref LIST_CONTROL_STR
extern const Atom aCOMBO_CONTROL;             // classic 'combo box' control - \ref COMBO_CONTROL_STR
extern const Atom aTREE_CONTROL;              // class 'tree' control - \ref TREE_CONTROL_STR
extern const Atom aCOMBOTREE_CONTROL;         // 'combo tree' (tree with interlocked edit/text box like combo box) - \ref COMBOTREE_CONTROL_STR


// file lists

extern const Atom aFILE_LIST_CONTROL;         // File List - \ref FILE_LIST_CONTROL_STR
extern const Atom aFILE_COMBO_CONTROL;        // file combo control - \ref FILE_COMBO_CONTROL_STR
extern const Atom aPATH_TREE_CONTROL;         // path tree - directory hierarchy - \ref PATH_TREE_CONTROL_STR


// containers

extern const Atom aTAB_CONTROL;               // 'tab' container (auto enable/disable contents) - \ref TAB_CONTROL_STR



// messages

// generic control notification - use aCONTROL_NOTIFY (doxygen docs in dialog_controls.c)

//extern const Atom aCONTROL_NOTIFY;
//    'notify' message - l[0] is notify code, l[1] is control ID, l[2] is pointer to control object
// others are message-specific

// CONTROL_NOTIFY "NOTIFICATION" CODES (code will be in data.l[0])
// button-specific notifications
extern const Atom aBUTTON_PRESS;
// l[1] is control ID, l[2] is (truncated) pointer to pDlgControlEntry

// list-specific
extern const Atom aLIST_NOTIFY; // also applies to tab controls, combos, etc.
// data.l[1] is control ID, data.l[2] is notification, data.l[3] is selection index
// on receipt default dialog proc will end dialog with 'IDOK'

// edit-specific, combo-specific
extern const Atom aTEXT_CHANGED;
extern const Atom aTEXTSELECT_CHANGE;


// other notification messages

// scroll notifications
extern const Atom aSCROLL_NOTIFY; // specific notification for scrollbars (see enumeration, below)
// data.l[0] is scrollbar enum, data.l[1] is notification enum, data.l[2] is optional position modifier


// common to all
extern const Atom aGOTFOCUS;  // sent as its own message type - data.l[0] = wID, data.l[1] = pDlgControlEntry
extern const Atom aLOSTFOCUS; // sent as its own message type - data.l[0] = wID, data.l[1] = pDlgControlEntry


// low level common (not all return these)
extern const Atom aMOUSE_DOWN;
extern const Atom aMOUSE_UP;
extern const Atom aMOUSE_DRAG;
extern const Atom aKEY_DOWN;
extern const Atom aKEY_UP;
extern const Atom aKEYSTROKE;  // valid key down/up sequence, including repeat


// other dialog-related message atoms
extern const Atom aDIALOG_INIT;

//extern const Atom aDIALOG_SETFOCUS; // l[0] is <,0,> for prev, 'set to', next.  For 'set to' l[1] is item ID
extern Atom aDLGC_PROP_NOTIFY; // l[0] is the property Atom

// control-specific 'globally known' atoms

extern Atom aDLGC_PATH; // PATH information for file-related controls

#endif // DIALOG_SUPPORT_C


// NOTIFICATION PARAMETERS

// data.l[2] parameter definitions for aCONTROL_NOTIFY + aLIST_NOTIFY ClientMessage

/** \ingroup dlgctrl_notify **/
#define WB_LIST_NONE      0 /**< 'default' notification value (no action needed) */
/** \ingroup dlgctrl_notify **/
#define WB_LIST_SELCHANGE 1 /**< simple notification that the selection has changed */
/** \ingroup dlgctrl_notify **/
#define WB_LIST_DBLCLICK  2 /**< double click by default drives an 'End Dialog' with IDOK */



// parameter enumerations for aSCROLL_NOTIFY ClientMessage

// consider moving this to another group
/** \ingroup dlgctrl
  * \hideinitializer
  * \brief Enumeration for \ref aSCROLL_NOTIFY CLientMessage
  *
  * Enumeration of values used in scroll notification messages.\n
  * \sa  \ref DLGScrollBarHandler()
*/
enum
{
  WB_SCROLL_DEFAULT = 0,    ///< 1st parameter (bar) - 'Default Bar', currently not implemented, probably won't be used
  WB_SCROLL_HORIZONTAL = 1, ///< 1st parameter (bar) - The horizontal scroll bar for the control or window
  WB_SCROLL_VERTICAL = 2,   ///< 1st parameter (bar) - The vertical scroll bar for the control or window.

  WB_SCROLL_KNOB = 0,       ///< 2nd parameter (direction) - 'knob track' - pos in data.l[2]
  WB_SCROLL_FORWARD = 1,    ///< 2nd parameter (direction) - down, right
  WB_SCROLL_BACKWARD = -1,  ///< 2nd parameter (direction) - up, left
  WB_SCROLL_PAGEFWD = 2,    ///< 2nd parameter (direction) - pgdn, pgright
  WB_SCROLL_PAGEBACK = -2,  ///< 2nd parameter (direction) - pgup, pgleft
  WB_SCROLL_FIRST = -3,     ///< 2nd parameter (direction) - home, top
  WB_SCROLL_LAST = 3,       ///< 2nd parameter (direction) - bottom, end

  WB_SCROLL_DBLCLICK = 4,   ///< 2nd parameter (direction) - double-clicked item (no selection change info) (sent to list control's owner)

  WB_SCROLL_ABSOLUTE = 99,  ///< 2nd parameter (direction) - absolute scroll - pos in data.l[2]
  WB_SCROLL_RELATIVE = -99, ///< 2nd parameter (direction) - relative scroll - rel pos in data.l[2]

  WB_SCROLL_NA = 0x80000000 ///< generic 'NA' or 'UNDEFINED' value
};


////////////////////////////////
// control-specific definitions
////////////////////////////////

// LISTBOX-related (applies to anything with a LIST property)

/** \ingroup dlglist
  * \hideinitializer
  * \brief LIST-related constants for the index of an item within a list
  *
  * \sa \ref DLGGetControlListText(), \ref DLGGetControlListData(), \ref DLGAddControlListEntry(), \ref DLGDelControlListEntry()
*/
enum ControlListIndex
{
  ControlListIndex_FIRST = 0,                ///< first list index
  ControlListIndex_LAST = 0x7fffffff,        ///< last list index
  ControlListIndex_INSERT_FIRST = -1,        ///< always insert at beginning
  ControlListIndex_INSERT_LAST = 0x7fffffff, ///< always insert at end
  ControlListIndex_DELETE_ALL = -1,          ///< delete all
  ControlListIndex_NONE = -1                 ///< "no selection"
};

/** \ingroup dlglist
  * \hideinitializer
  * \brief Create flags specified in the call to DLGInitControlListInfo()
*/
enum ListInfoFlags
{
  ListInfoFlags_SORTED = 1,         ///< list is sorted
  ListInfoFlags_RESERVED1 = 2,      ///< reserved 1
  ListInfoFlags_RESERVED2 = 4,      ///< reserved 2
  ListInfoFlags_RESERVED3 = 8,      ///< reserved 3
  ListInfoFlags_RESERVED4 = 0x10,   ///< reserved 4
  ListInfoFlags_RESERVED5 = 0x20,   ///< reserved 5
  ListInfoFlags_RESERVED6 = 0x40,   ///< reserved 6
  ListInfoFlags_RESERVED7 = 0x80    ///< reserved 7

  // others are reserved
};



// 'ulFlags' bits 0000ffff is "common", 00ff0000 is control-specific, ff000000 is 'reserved for custom'
/** \ingroup dlgctrl
  * \hideinitializer
  * \brief Various bit flags used for controls, defined here for convenience
  *
  * Intended for the 'ulFlags' member of the WBDialogControl structure.  Bits 0000ffff are 'common' flags
  * for all controls.  Bits 00ff0000 are control-specific flags.  Bits ff000000 are 'reserved' for
  * custom usage.
*/
enum CONTROL_FLAGS
{
  // COMMON bits (APPLIES TO ALL)
  CONTROL_Reserved00      = 0x00000001,  ///< CONTROL bits, reserved 00
  CONTROL_Reserved01      = 0x00000002,  ///< CONTROL bits, reserved 01
  CONTROL_Reserved02      = 0x00000004,  ///< CONTROL bits, reserved 02
  CONTROL_Reserved03      = 0x00000008,  ///< CONTROL bits, reserved 03
  CONTROL_Reserved04      = 0x00000010,  ///< CONTROL bits, reserved 04
  CONTROL_Reserved05      = 0x00000020,  ///< CONTROL bits, reserved 05
  CONTROL_Reserved06      = 0x00000040,  ///< CONTROL bits, reserved 06
  CONTROL_Reserved07      = 0x00000080,  ///< CONTROL bits, reserved 07
  CONTROL_Reserved08      = 0x00000100,  ///< CONTROL bits, reserved 08
  CONTROL_Reserved09      = 0x00000200,  ///< CONTROL bits, reserved 09
  CONTROL_Reserved10      = 0x00000400,  ///< CONTROL bits, reserved 10
  CONTROL_Reserved11      = 0x00000800,  ///< CONTROL bits, reserved 11
  CONTROL_Reserved12      = 0x00001000,  ///< CONTROL bits, reserved 12
  CONTROL_Reserved13      = 0x00002000,  ///< CONTROL bits, reserved 13
  CONTROL_Reserved14      = 0x00004000,  ///< CONTROL bits, reserved 14

  CONTROL_SupportListInfo = 0x00008000,  ///< this control supports a LISTINFO property.\n
                                         // NOTE: A \ref WBListCurSel struct must immediately follow the \ref WBDialogControl members

  // CONTROL TYPE-SPECIFIC bits

  // STATIC bits

  STATIC_Frame        = 0x00010000,     ///< STATIC - frame control window
  STATIC_Text         = 0x00020000,     ///< STATIC - Text control window
  STATIC_Icon         = 0x00030000,     ///< STATIC - Icon control window
  STATIC_Image        = 0x00040000,     ///< STATIC - Image control window

  STATIC_TYPEMASK     = 0x000f0000,     ///< STATIC - 'type mask' for static controls

  STATIC_3DBorder     = 0x00100000,     ///< STATIC - display with a 3D-looking border


  // BUTTON bits

  BUTTON_PushButton       = 0x00010000, ///< BUTTON - Push button (generic)
  BUTTON_DefPushButton    = 0x00020000, ///< BUTTON - Default Push Button (activate by &lt;ENTER&gt;)
  BUTTON_CancelButton     = 0x00030000, ///< BUTTON - Cancel Push Button (activate by &lt;ESC&gt;)
  BUTTON_RadioButton      = 0x00040000, ///< BUTTON - Radio button (generic)
  BUTTON_FirstRadioButton = 0x00050000, ///< BUTTON - 'First' radio button in a group
  BUTTON_CheckButton      = 0x00060000, ///< BUTTON - Checkbox button
  BUTTON_TriStateButton   = 0x00070000, ///< BUTTON - Tri-state button

  BUTTON_TYPEMASK         = 0x000f0000, ///< BUTTON - 'type mask' for buttons


  // others here

  // auto-alignment flags (for resizable dialog boxes)

  CONTROL_VAlignFixed     = WBDialogEntry_VAlignFixed,  ///< default position re-alignment with respect to center (as a percentage, no stretching)
  CONTROL_VAlignTop       = WBDialogEntry_VAlignTop,    ///< resize maintains position/size with respect to top
  CONTROL_VAlignBottom    = WBDialogEntry_VAlignBottom, ///< resize maintains position/size with respect to bottom
  CONTROL_VAlignCenter    = WBDialogEntry_VAlignCenter, ///< re-alignment with respect to center (as a percentage, stretching allowed)
  CONTROL_VAlignMask      = WBDialogEntry_VAlignMask,   ///< vertical alignment mask

  CONTROL_HAlignFixed     = WBDialogEntry_HAlignFixed,  ///< default position re-alignment with respect to center (as a percentage, no stretching)
  CONTROL_HAlignLeft      = WBDialogEntry_HAlignLeft,   ///< resize maintains position/size with respect to left
  CONTROL_HAlignRight     = WBDialogEntry_HAlignRight,  ///< resize maintains position/size with respect to right
  CONTROL_HAlignCenter    = WBDialogEntry_HAlignCenter, ///< re-alignment with respect to center (as a percentage, stretching allowed)
  CONTROL_HAlignMask      = WBDialogEntry_HAlignMask,   ///< vertical alignment mask

  CONTROL_AlignMask       = WBDialogEntry_AlignMask,    ///< alignment mask (both horizontal and vertical)

  // reserved for custom controls

  CUSTOM_Reserved24       = 0x01000000, ///< CUSTOM - reserved bit 24
  CUSTOM_Reserved25       = 0x02000000, ///< CUSTOM - reserved bit 25
  CUSTOM_Reserved26       = 0x04000000, ///< CUSTOM - reserved bit 26
  CUSTOM_Reserved27       = 0x08000000, ///< CUSTOM - reserved bit 27
  CUSTOM_Reserved28       = 0x10000000, ///< CUSTOM - reserved bit 28
  CUSTOM_Reserved29       = 0x20000000, ///< CUSTOM - reserved bit 29
  CUSTOM_Reserved30       = 0x40000000, ///< CUSTOM - reserved bit 30
  CUSTOM_Reserved31       = 0x80000000  ///< CUSTOM - reserved bit 31
};


//////////////////////////////////////
// control-specific utility functions
//////////////////////////////////////

/** \ingroup dlglist
  * \brief The default 'List Info' data allocator for a control's list info */
void * DLGCDefaultListInfoAllocator(const void *pData, int cbData);

/** \ingroup dlglist
  * \brief Retrieve the text poiner for a single list entry (listbox, combo, and tree controls only)
*/
const char * DLGGetControlListText(WBDialogControl *pCtrl, int iIndex);  // retrieve data pointer for single list entry
/** \ingroup dlglist
  * \brief Retrieve the data pointer for a single list entry (listbox, combo, and tree controls only)
*/
const void * DLGGetControlListData(WBDialogControl *pCtrl, int iIndex);  // retrieve data pointer for single list entry

/** \ingroup dlglist
  * \brief Initialize the 'List Entry' for a control, specifying various callbacks and flags
  *
  * \param pCtrl Pointer to the WBDialogControl structure
  * \param nFlags Flags that identify the data type in the list
  * \param pfnAllocator The allocator that must be used when adding new data
  * \param pfnDestructor The de-allocator that must be used when removing data (including cleanup)
  * \param pfnDisplay The function that is called to display the data
  * \param pfnSort The compare function that is called to sort the data
  * \return non-zero on error, zero on success
  *
  * This is a generic method by which a control's list entry can be initialized.  If the control's
  * list consists entirely of text data, you can simplify the process by using \ref DLGInitControlListInfoDefault()
*/
int DLGInitControlListInfo(WBDialogControl *pCtrl, int nFlags,
                           void *(*pfnAllocator)(const void *,int), void (*pfnDestructor)(void *),
                           void (*pfnDisplay)(WBDialogControl *, void *, int, GC, WB_GEOM *),
                           int (*pfnSort)(const void *, const void *));

/** \ingroup dlglist
  * \brief wrapper macro for DLGInitControlListInfo() for standard malloc'd text data
  *
  * This macro creates a standard malloc'd text data list entry using DLGCDefaultListInfoAllocator()
  * and free, for sorted text data with standard display and sort comparison functions
  *  NOTE:  using DLGInitControlListInfoDefault implies string data that's malloc'd.  For some other scheme of maintaining
  *         and copying data pointers for a listbox, substitute your own function pointers as needed.
**/
#define DLGInitControlListInfoDefault(X) \
  DLGInitControlListInfo(X, ListInfoFlags_SORTED, DLGCDefaultListInfoAllocator, free, NULL, NULL)



/** \ingroup dlglist
  * \brief Modify the 'List Entry' for a control, specifying various callbacks and flags
  *
  * \param pCtrl Pointer to the WBDialogControl structure
  * \param bFlags Indicates whether to modify the Flags - 1 to modify, 0 to use the existing value
  * \param nFlags Flags that identify the data type in the list
  * \param bAllocator Indicates whether to modify the Allocator - 1 to modify, 0 to use the existing value
  * \param pfnAllocator The allocator that must be used when adding new data
  * \param bDestructor Indicates whether to modify the Destructor - 1 to modify, 0 to use the existing value
  * \param pfnDestructor The de-allocator that must be used when removing data (including cleanup)
  * \param bDisplay Indicates whether to modify the Display function - 1 to modify, 0 to use the existing value
  * \param pfnDisplay The function that is called to display the data
  * \param bSort Indicates whether to modify the Sort function - 1 to modify, 0 to use the existing value
  * \param pfnSort The compare function that is called to sort the data
  * \return non-zero on error, zero on success
  *
  * This is a generic method by which the parameters of a control's list entry can be modified.  If the
  * entry does not already exist, a new entry will be initialized with 'default' parameters assigned
  * using the same values you would get with \ref DLGInitControlListInfoDefault()
*/
int DLGModifyControlListInfo(WBDialogControl *pCtrl, int bFlags, int nFlags,
                             int bAllocator, void *(*pfnAllocator)(const void *,int),
                             int bDestructor, void (*pfnDestructor)(void *),
                             int bDisplay, void (*pfnDisplay)(WBDialogControl *, void *, int, GC, WB_GEOM *),
                             int bSort, int (*pfnSort)(const void *, const void *));

/** \ingroup dlglist
  * \brief Add a list entry to a control's list info
  *
  * \param pCtrl Identifies the WBDialogControl structure
  * \param pData Pointer to the data for the added item (may be NULL with cbData == 0 for "null data")
  * \param cbData Data size in bytes.  May also indicate copy method (default allocator uses cbData < 0 to copy as string, > 0 as binary data).
  *        cbData is zero to assign 'pData' "as-is" (i.e. without copying) [allocator/deallocator should be NULL for this to work]\n
  * \param iIndex Insert point. Can be an actual index (inserts after that point) or one of the ControlListIndex_INSERT_xxx' enumerations.
  * \return Non-zero on error, zero on success
  *
  * Although there are some specific nuances associated with the use of this function (such as 'string copy') the 'pData' and
  * 'cbData' parameters are passed along without modification to the allocator function.  Whenever DefaultListInfoAllocator()
  * is used, a cbData value less than zero indicates that pData points to a null-byte terminated string, and whenever cbData
  * is equal to zero, the pointer value of 'pData' is assigned to the internal list entry 'as-is'.
*/
int DLGAddControlListEntry(WBDialogControl *pCtrl, const char *pData, long cbData, int iIndex);

/** \ingroup dlglist
  * \brief Delete a list entry from a control's list info at a specified index (or deletes ALL entries)
  *
  * \param pCtrl Identifies the WBDialogControl structure
  * \param iIndex Identifies the index of the entry to delete, or is < 0 (i.e. ControlListIndex_DELETE_ALL) to delete ALL entries
  *
  * Use this function to remove one or all entries from the control's list info
*/
void DLGDelControlListEntry(WBDialogControl *pCtrl, int iIndex); // delete item at index 'iIndex' (iIndex < 0 to delete all)

/** \ingroup dlglist
  * \brief Obtain the current selection index for a single-selection list
  *
  * \param pCtrl Identifies the WBDialogControl structure
  * \return The index of the selected item, or ControlListIndex_NONE
  *
  * In a single-selection list, or in a list where multiple selection operations are being performed,
  * there is one item that has a 'selected' state.  This function returns the index for that item.
*/
int DLGGetControlListSelection(WBDialogControl *pCtrl); // get selection for single-selection list

/** \ingroup dlglist
  * \brief Assign the current selection index for a single-selection list
  *
  * \param pCtrl Identifies the WBDialogControl structure
  * \param iIndex Identifies the new selection index.  May be ControlListIndex_NONE for NO selection.
  *
  * In a single-selection list, or in a list where multiple selection operations are being performed,
  * there is one item that has a 'selected' state.  This function assigns the index for that item.
*/
void DLGSetControlListSelection(WBDialogControl *pCtrl, int iIndex); // set single selection for list

/** \ingroup dlglist
  * \brief Assign the selection state for a specific index within a control's list info
  *
  * \param pCtrl Identifies the WBDialogControl structure
  * \param iIndex Identifies the index for the new selection state.
  * \param iSelState The new selection state for that index (reserved)
  *
  * In a multi-selection list, each item has a specified 'selection state' that identifies whether
  * or not the item is selected.  This function assigns that value for a single item.
*/
void DLGSetControlListSelectionValue(WBDialogControl *pCtrl, int iIndex, int iSelState);  // set sel state for specific index

/** \ingroup dlglist
  * \brief Query the selection state for multiple items within a control's list info
  *
  * \param pCtrl Identifies the WBDialogControl structure
  * \param piBits (reserved) A pointer to a block of memory that is 'nSize' integers in length, where the index is a LSB bit within the integer.  A '1' bit indicates 'selected', a '0' bit indicates 'not selected'
  * \param nSize The size of the 'piBits' array as a number of int elements.
  * \return 0 for no sel, > 0 for the number of selections, < 0 on error.  If 'piBits is NULL, it returns the necessary size for the array (in integers)
  *
  * The 'piBits' and 'nSize' parameters must indicate a memory block of sufficient size, or an error will be returned.
  * Use a NULL value of 'piBits' to obtain the necessary size of the array, if it is not known.
  * To determine if a specific bit is set, use a formula similar to the following\n
\code
    piBits[(iIndex >> 32)] & (1 << (iIndex & 31)) ? TRUE : FALSE
\endcode
  * where 'iIndex' represents the index of the bit you wish to query.
*/
int DLGGetControlListSelectionBits(WBDialogControl *pCtrl, unsigned int *piBits, int nSize);
  // piBits and nSize must be large enough to accomodate bits.  'nSize' is number of integers (not bytes)
  // return value is 0 for no sel, >0 for number of selections, < 0 on error.  assume 32 bits per entry ( LSbit is entry '0' )
  // a '1' in a bit position indicates the entry has been selected.

/** \ingroup dlglist
  * \brief Query the selection text as multiple strings in an allocated buffer
  *
  * The return value is a single allocated buffer (using 'malloc') containing a set of string entries,
  * each separated by a newline character, corresponding to the selected list entries (TEXT elements only).\n
  * The return value is NULL if there are no selections or on error.\n
  * For non-NULL return values, the caller must use 'free()' to destroy the allocated buffer.
*/
char * DLGGetControlListSelectionText(WBDialogControl *pCtrl); // caller must 'free()' non-NULL returned pointer
  // this returns TEXT elements (separated by line feeds) for corresponding selected LB entries
  // use this for multi-selection listboxes with unique text entries for which the list text is desired


// SCROLL NOTIFICATION GENERATOR - generic pre-filter / handler for embedded scroll bars

/** \ingroup dlgctrl
  * \brief Scroll bar event filter for dialog control callback function.  Generates scroll events
  *
  * \param wID The Window ID of the dialog control
  * \param pCtrl A pointer to the WBDialogControl structure for the dialog control
  * \param pEvent The event to query and possibly filter
  * \return A zero if the event is to pass on to the rest of the callback; otherwise, the return value for the dialog control's callback function (the callback function must return this value unmodified)
  *
  * When a dialog control needs to process events for scroll bars, it should FIRST call this function to ensure that
  * they are handled properly in a standardized manner.  If the return value is non-zero, that value must be returned
  * unmodified (the dialog control callback handler uses this value).  Otherwise, processing can continue.\n
  *
  * Scroll events are send via a ClientMessage using \ref aSCROLL_NOTIFY .
*/
int DLGScrollBarHandler(Window wID, WBDialogControl *pCtrl, XEvent *pEvent);
  // NOTE:  if this function returns a non-zero value, that same value should be returned
  //        unmodified from the control's message callback in order for this to work properly.


// notification methods (inline functions) - messages "sent" (not placed in queue)

/** \ingroup dlgctrl
  * \brief Notify Owner by calling the owner window's callback function directly with an event
  *
  * Use this function when immediate notification is needed, and there is no possibility
  * of a blocking call, recursion, or invalid state as a result of the event processing
  *
  * \sa  DLGNotifyOwnerAsync()
*/

static __inline__ void DLGNotifyOwner(WBDialogControl *pDialogControl, Atom aNotify,
                                      long lData0, long lData1, long lData2, long lData3, long lData4)
{
Display *pDisplay = WBGetWindowDisplay(pDialogControl->wID);

  if(pDialogControl->pOwner)
  {
// C99 constructs are cool, but maybe not portable...
//    XClientMessageEvent evt = {
//                                .type=ClientMessage,
//                                .serial=0,
//                                .send_event=0,
//                                .display=pDisplay,
//                                .window=pDialogControl->pOwner->wID,
//                                .message_type=aNotify, // typically aCONTROL_NOTIFY
//                                .format=32
//                              };
    XClientMessageEvent evt;

    evt.type=ClientMessage;
    evt.serial=0;
    evt.send_event=0;
    evt.display=pDisplay;
    evt.window=pDialogControl->pOwner->wID;
    evt.message_type=aNotify; // typically aCONTROL_NOTIFY
    evt.format=32;

    evt.data.l[0] = lData0; // nearly always an Atom
    evt.data.l[1] = lData1; // typically the window ID
    evt.data.l[2] = lData2;
    evt.data.l[3] = lData3;
    evt.data.l[4] = lData4;

    WBWindowDispatch(pDialogControl->pOwner->wID, (XEvent *)&evt);
  }
}

/** \ingroup dlgctrl
  * \brief Notify 'self' by calling the window's own callback function directly with an event
  *
  * Use this function when immediate notification is needed, and there is no possibility
  * of a blocking call, recursion, or invalid state as a result of the event processing.
  *
  * Often it's useful to consilidate processing for a single type of event, such as clicking
  * on a scrollbar or pressing an arrow key.  Both send completely different event sequences
  * to the control, but have similar processing after a certain point.  If each of these
  * generates a 'scroll' type event, and the event is sent to the control's callback, the
  * 'scroll' functionality can be consolidated for both types of event handlers and you avoid
  * duplication and the potential for additional 'bugginess'.
  *
  * \sa  DLGNotifySelfAsync()
*/

static __inline__ void DLGNotifySelf(WBDialogControl *pDialogControl, Atom aNotify,
                                     long lData0, long lData1, long lData2, long lData3, long lData4)
{
Display *pDisplay = WBGetWindowDisplay(pDialogControl->wID);

  XClientMessageEvent evt = {
                              .type=ClientMessage,
                              .serial=0,
                              .send_event=0,
                              .display=pDisplay,
                              .window=pDialogControl->wID,
                              .message_type=aNotify,
                              .format=32
                            };
  evt.data.l[0] = lData0;
  evt.data.l[1] = lData1;
  evt.data.l[2] = lData2;
  evt.data.l[3] = lData3;
  evt.data.l[4] = lData4;

  WBWindowDispatch(pDialogControl->wID, (XEvent *)&evt);
}

// asynchronous versions (posts priority event on message queue)

/** \ingroup dlgctrl
  * \brief Notify Owner by posting an event that will ASYNCHRONOUSLY be sent to the owner window's callback function
  *
  * Use this function whenever immediate notification is NOT needed, or if there is a possibility
  * of a blocking call, recursion, or invalid state as a result of a direct call to the owner window's
  * callback function.
  *
  * \sa  DLGNotifyOwner()
*/

static __inline__ void DLGNotifyOwnerAsync(WBDialogControl *pDialogControl, Atom aNotify,
                                           long lData0, long lData1, long lData2, long lData3, long lData4)
{
Display *pDisplay = WBGetWindowDisplay(pDialogControl->wID);

  if(pDialogControl->pOwner)
  {
    XClientMessageEvent evt = {
                                .type=ClientMessage,
                                .serial=0,
                                .send_event=0,
                                .display=pDisplay,
                                .window=pDialogControl->pOwner->wID,
                                .message_type=aNotify,
                                .format=32
                              };
    evt.data.l[0] = lData0;
    evt.data.l[1] = lData1;
    evt.data.l[2] = lData2;
    evt.data.l[3] = lData3;
    evt.data.l[4] = lData4;

    WBPostPriorityEvent(pDialogControl->pOwner->wID, (XEvent *)&evt);
  }
}

/** \ingroup dlgctrl
  * \brief Notify 'self' by posting an event that will ASYNCHRONOUSLY be sent to the window's callback function
  *
  * Use this function whenever immediate notification is NOT needed, or if there is a possibility
  * of a blocking call, recursion, or invalid state as a result of a direct call to the window's
  * callback function.
  *
  * Often it's useful to consilidate processing for a single type of event, such as clicking
  * on a scrollbar or pressing an arrow key.  Both send completely different event sequences
  * to the control, but have similar processing after a certain point.  If each of these
  * generates a 'scroll' type event, and the event is sent to the control's callback, the
  * 'scroll' functionality can be consolidated for both types of event handlers and you avoid
  * duplication and the potential for additional 'bugginess'.
  *
  * \sa  DLGNotifySelf()
*/

static __inline__ void DLGNotifySelfAsync(WBDialogControl *pDialogControl, Atom aNotify,
                                          long lData0, long lData1, long lData2, long lData3, long lData4)
{
Display *pDisplay = WBGetWindowDisplay(pDialogControl->wID);

  XClientMessageEvent evt = {
                              .type=ClientMessage,
                              .serial=0,
                              .send_event=0,
                              .display=pDisplay,
                              .window=pDialogControl->wID,
                              .message_type=aNotify,
                              .format=32
                            };
  evt.data.l[0] = lData0;
  evt.data.l[1] = lData1;
  evt.data.l[2] = lData2;
  evt.data.l[3] = lData3;
  evt.data.l[4] = lData4;

  WBPostPriorityEvent(pDialogControl->wID, (XEvent *)&evt);
}

#ifdef __cplusplus
};
#endif // __cplusplus


#endif // DIALOG_CONTROLS_H_INCLUDED


