//////////////////////////////////////////////////////////////////////////////////////////////
//    __                                            _             _                  _      //
//   / _| _ __  __ _  _ __ ___    ___    __      __(_) _ __    __| |  ___ __      __| |__   //
//  | |_ | '__|/ _` || '_ ` _ \  / _ \   \ \ /\ / /| || '_ \  / _` | / _ \\ \ /\ / /| '_ \  //
//  |  _|| |  | (_| || | | | | ||  __/    \ V  V / | || | | || (_| || (_) |\ V  V /_| | | | //
//  |_|  |_|   \__,_||_| |_| |_| \___|_____\_/\_/  |_||_| |_| \__,_| \___/  \_/\_/(_)_| |_| //
//                                   |_____|                                                //
//                                                                                          //
//    a top-level window that can have menus, toolbars, a status bar, and a client area     //
//               (multiple-document versions have tabs and child frames)                    //
//                                                                                          //
//////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2019 by Bob Frazier (aka 'Big Bad Bombastic Bob')


  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.
               Any claims to alleged functionality or features should be
               considered 'preliminary', and might not function as advertised.

  MIT-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  MIT-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/


#ifndef FRAME_WINDOW_H_INCLUDED
#define FRAME_WINDOW_H_INCLUDED

#include <inttypes.h> // needed for intptr_t, uintptr_t among other things

//#include "window_helper.h"
#include "window_dressing.h"
#include "menu_bar.h"

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus



/** \file frame_window.h
  * \brief Frame Window API functions and definitions
  *
  * Frame Windows are top-level windows that have a border, title bar, and (optionally)
  * a menu or other means of user interaction (like toolbars).  This file contains the
  * API functions generally needed to create, modify, and destroy Frame Windows.
**/

/** \ingroup frame
  * \defgroup frame_window Frame Window APIs and Structures
  *
  * To create a frame window, you will need to call the \ref FWCreateFrameWindow() API function,
  * which returns a WBFrameWindow structure pointer.  Until the window has been destroyed this
  * pointer will remain valid, though you should not manipulate its contents directly.\n
  * Typical code for creating a frame window follows:
  *
  * \code

  XSizeHints  xsh;            // Size hints for window manager
  WBFrameWindow *pFrame;      // pointer to WBFrameWindow for my new frame window

  ...

    // use 'size hints' along with display characteristics to pre-size window

    WBInitSizeHints(&xsh,                  // pointer to XSizeHints
                    WBGetDefaultDisplay(), // current (default) display
                    300,                   // minimum height (300 pixels in this case)
                    600);                  // minimum width (600 pixels in this case)

    // create frame window object

    pFrame = FWCreateFrameWindow("Window Title",           // title
                                 ID_APPLICATION,           // 'well known' icon identifier
                                                           // see PXM_GetIconPixmap()
                                 szAppMenu,                // default app menu (as text)
                                 xsh.x, xsh.y,             // position
                                 xsh.width, xsh.height,    // size
                                 MyWindowCallback,         // callback
                                 WBFrameWindow_APP_WINDOW  // flags and attributes
                                 | WBFrameWindow_VISIBLE);

  * \endcode
  *
  * Once the window has been created, you can manage its contents using FWAddContainedWindow()
  * and related functions.\n
  *
  * Contained windows need no special interface handling unless you want to control the
  * context of the menu, or overload the frame window's default menu event handling.  A
  * set of messages are used by the frame window for its 'contents' windows in order to
  * request that a new menu be assigned to the containing frame window.  Menu commands are
  * passed directly to the contained window's callback functions as they are received,
  * before being handled by the frame window itself.  In this way the frame window can
  * handle anything NOT already handled by the contained window.\n
  * Menu and UI events for which there is no handler should always return '-1'.\n
  *
  * In order to 'fit' a contained window within the frame window's client area, it will always
  * be re-sized when added, and whenever it gains the focus.  A re-size will also be performed
  * for the 'focus' window whenever the frame window is re-sized.  The focus window will
  * need to respond to re-size events and re-draw itself as needed.
  *
**/

/** \ingroup frame
  * \defgroup frame_menu Frame Window Menu Handling
  * \brief Macros and functions needed to set up a frame window's menu
  *
  * Setting up a menu event handler for a frame window using the WBFWMenuHandler structures involves
  * the use of set of macros to create the structure, and a call to \ref FWSetMenuHandlers() to
  * assign them to the Frame window.
  *
  * Typical sample code follows:
  *
  * \code

  static int FileExitHandler(XClientMessageEvent *);
  static int FileOpenHandler(XClientMessageEvent *);
  static int FileSaveHandler(XClientMessageEvent *);

  static char szMyMenu[]="1\n"
                         "_File\tpopup\t2\n"
                         "2\n"
                         "_Open File\tIDM_FILE_OPEN\tOpen File\tCtrl+O\n"
                         "_Save File\tIDM_FILE_SAVE\tSave File\tCtrl+S\n"
                         "\tseparator\n"
                         "\tdynamic\tIDM_RECENT_FILESn"
                         "\tseparator\n"
                         "E_xit\tIDM_FILE_EXIT\tClose Application\tAlt+F4\n"
                         "\n";

  ...

  FW_MENU_HANDLER_BEGIN(main_menu_handler)
    FW_MENU_HANDLER_ENTRY("IDM_FILE_EXIT",FileExitHandler,NULL)
    FW_MENU_HANDLER_ENTRY("IDM_FILE_OPEN",FileOpenHandler,NULL)
    FW_MENU_HANDLER_ENTRY("IDM_FILE_SAVE",FileSaveHandler,NULL)
    FW_MENU_HANDLER_ENTRY("IDM_RECENT_FILES",NULL,RecentFilesUIHandler)
  FW_MENU_HANDLER_END

  ---

    // after creating the frame window 'pFrameWindow' with menu 'szMyMenu'

    FWSetMenuHandlers(pFrameWindow, main_menu_handler);

  * \endcode
  *
  * \sa \ref frame_window "Frame Window APIs and Structures"
  *
**/



/** \ingroup frame_window
  * \brief TAG for the WBFrameWindow structure
**/
#define FRAME_WINDOW_TAG (*((const unsigned int *)"FWFW"))


/** \struct tagWB_FW_MENU_HANDLER
  * \ingroup frame_menu
  * \copydoc WBFWMenuHandler
**/
/** \typedef WBFWMenuHandler
  * \ingroup frame_menu
  * \brief structure for managing menu callbacks
  *
  * The WBFWMenuHandler structure is designed to be initialized via macros, so
  * that a set of callback functions can then be easily used to handle menu events.
  * If no menu handler is present for a menu item, or if the menu UI handler is
  * NOT NULL and returns a non-zero value, the menu item will be disabled and
  * displayed accordingly.  It will not be possible to use its hotkey nor select it.
  * Otherwise, the menu will be displayed normally and be selectable, and its hotkey
  * will be able to activate it.
  *
  * \code

  typedef struct tagWB_FW_MENU_HANDLER
  {
    uintptr_t lMenuID;                           // menu ID (< 0x10000L) or const pointer to string

    int (* callback)(XClientMessageEvent *);     // menu callback (gets pointer to the 'XClientMessageEvent')
    int (* UIcallback)(WBMenu *, WBMenuItem *);  // menu 'UI' callback to handle displaying menu states
                                                 // A return value of '0' displays normally, -1 disables
                                                 // Other return values are reserved
  } WBFWMenuHandler;

  * \endcode
  *
  * \sa \ref FW_MENU_HANDLER_ENTRY "FW_MENU_HANDLER_ENTRY", \ref FW_MENU_HANDLER_BEGIN "FW_MENU_HANDLER_BEGIN"
**/
typedef struct tagWB_FW_MENU_HANDLER
{
  uintptr_t lMenuID;                       ///< menu ID (< 0x10000L) or const pointer to string

  int (* callback)(XClientMessageEvent *);     ///< menu callback (gets pointer to the 'XClientMessageEvent').

  /** \brief menu 'UI' callback to handle displaying menu states.
    *
    * This callback function handles the menu states.  A return value of '0' displays normaly, -1 disables.\n
    * Other return values are reserved.
  **/
  int (* UIcallback)(WBMenu *, WBMenuItem *);
} WBFWMenuHandler;



/** \struct tagWB_FRAME_WINDOW
  * \ingroup frame_window
  * \copydoc WBFrameWindow
**/
/** \typedef WBFrameWindow
  * \ingroup frame_window
  * \brief main controlling structure for frame windows
  *
  * By default a frame window can handle multiple documents.  Documents are selected via tabs.  At least
  * one tab will always be visible unless there are no 'contents'.  The contained windows will be re-sized
  * automatically as needed.  Contained windows may also register their own menus and/or menu handlers.
  *
  * The WBFrameWindow structure maintains the basic window state information, and contains additional
  * data members that are not declared in WBFrameWindow.  You should not create any derived 'superclass'
  * versions that contain this structure as an embedded member.  Instead, you should use a pointer to
  * a WBFrameWindow structure within your implementation, and not rely on any data members within the
  * structure that are not accessible through the use of an API function.
  *
  * This structure is created using FWCreateFrameWindow(), and destroyed using either
  * FWDestroyFrameWindow() (using the Window ID) or FWDestroyFrameWindow2() (using the structure pointer).
  *
  * \code

  typedef struct tagWB_FRAME_WINDOW
  {
    unsigned int ulTag;                  // tag indicating I'm a frame window
    Window wID;                          // Window id for the frame window
    int iFlags;                          // bitmask of attribute flags (see \ref WBFrameWindow_FLAGS enumeration)

    int iClientX;                        // The current X position of the frame window's client area
    int iClientY;                        // The current Y position of the frame window's client area
    int iClientWidth;                    // The current width of the frame window's client area
    int iClientHeight;                   // The current height of the frame window's client area

  } WBFrameWindow;

  * \endcode
  *
  * \sa \ref frame_window "Frame Window APIs and Structures"
  *
**/
typedef struct tagWB_FRAME_WINDOW
{
  unsigned int ulTag;                  ///< tag indicating I'm a frame window
  Window wID;                          ///< Window id for the frame window
  int iFlags;                          ///< bitmask of attribute flags (see \ref WBFrameWindow_FLAGS enumeration)

  int iClientX;                        ///< The current X position of the frame window's client area (relative to the window)
  int iClientY;                        ///< The current Y position of the frame window's client area (relative to the window)
  int iClientWidth;                    ///< The current width of the frame window's client area
  int iClientHeight;                   ///< The current height of the frame window's client area

} WBFrameWindow;



/** \ingroup frame_window
  * \enum WBFrameWindow_FLAGS
  * \brief Frame Window type and status flags
  *
  * Assign zero or more of these flags to the 'iFlags' parameter in the call to FWCreateFrameWindow()
**/
enum WBFrameWindow_FLAGS
{

  WBFrameWindow_APP_WINDOW = 1,   ///< set this flag for application top-level window and whenever it is destroyed the application will exit
  WBFrameWindow_VISIBLE    = 2,   ///< set this to make window immediately visible
  WBFrameWindow_NO_TABS    = 4,   ///< set this to disable tabs (single child frame only)
  WBFrameWindow_STATUS_BAR = 8,   ///< set this to enable a 'status bar' at the bottom

  WBFrameWindow_MAX = 0x80000000L ///< maximum flag value (for reference only)
};

/** \enum WBStatusTabInfo_FLAGS
  * \ingroup frame_window
  * \brief enumeration for bit flags that are 'or'd with the tab stop index
  *
**/
enum WBStatusTabInfo_FLAGS
{
  WBStatusTabInfo_MASK          = 0x0fffffff, ///< mask for the actual tab value
  WBStatusTabInfo_BREAK         = 0x10000000, ///< represents a 'break' (marks end of a column)
  WBStatusTabInfo_JUSTIFY_MASK  = 0x6fffffff, ///< mask for the 'justification' value
  WBStatusTabInfo_JUSTIFY_LEFT  = 0x00000000, ///< left-justify text within the column (default)
  WBStatusTabInfo_JUSTIFY_CENTER= 0x20000000, ///< center text within the column
  WBStatusTabInfo_JUSTIFY_RIGHT = 0x40000000, ///< right justify text within the column
  WBStatusTabInfo_JUSTIFY_res6  = 0x60000000, ///< reserved: unspecified new justification method
  WBStatusTabInfo_RTL_COLUMN    = 0x80000000, ///< bit flag to 'right justify' the column location
};


// NOTE:  WBChildFrame and WBChildFrameUI are defined HERE to avoid circular header file dependencies
// (also defining supporting structs for same reason)

struct tagWBChildFrameUI; // forward declaration

/** \struct tagWBChildFrame
  * \ingroup child_frame
  * \copydoc WBChildFrame
**/
/** \typedef WBChildFrame
  * \ingroup child_frame
  * \brief Structure that defines a Child Frame within a Frame Window
  *
  * This structure represents a generic 'child frame' within a Frame Window.  You should
  * not use the default implementation, but rather derive something from it, aka a 'superclass'.
  * The callback function array 'vtable' (WBChildFrameUI *) will be assigned to the 'pUI'
  * member so that the correct functions will be called for the many possible UI events.
  *
  * In this way, you can derive many types of 'child frames', from text to graphic display
  * and/or edit windows.  For a sample implementation, see WBEditWindow
  *
  * Additionally, you should not modify the member variables of this structure without using
  * one of the API functions.  In some cases, you might have to make additional function calls
  * that result from modifying their values.  The API functions will do that correctly.
  *
  * The WBChildFrame structure is as follows:
  *
  * \code

  typedef struct tagWBChildFrame
  {
    unsigned int ulTag;
      // tag indicating I'm a 'Child Frame' window
    Window wID;
      // window identifier for the 'Child Frame' window.  may contain 'None' while being destroyed
    WBFrameWindow *pOwner;
      // a pointer to the WBFrameWindow owner
    WB_FONT pFont;
      // default font for the window

    WB_GEOM geom;
      // client-area geometry (excludes scroll bars)

    WB_GEOM geomEntire;
      // entire client-area geometry (for painting scroll bars)

    WB_POINT origin;
      // 'origin' in 'client units' (such as chars and lines) - determines scroll behavior

    WB_EXTENT extent;
      // 'extent' in 'client units' (such as chars and lines) - determines scroll behavior

    int iRowHeight;
      // cached 'row height' (height of line including interline spacing)
    int iColWidth;
      // cached 'column width' (width of 1 character)

    WB_SCROLLINFO scroll;
      // 'scroll info' (horizontal and vertical min/max/pos and other details)

    int iSplit;
      // reserved - position for 'split' (-1 for 'no split')

    WB_SCROLLINFO scrollSplit;
      // reserved - 'scroll info' for 'split' area (implementation-defined)

    int fFlags;
      // various bitflags defining features.

    char *szDisplayName;
      // display name shown in tab and title bar.  You should not alter this member directly.
    Atom aImageAtom;
      // 'image' atom for display in tabs.  default is 'None'.  You should not alter this member directly.

    char *szStatusText;
      // Status text ('WBAlloc'd) to display when this child frame window has the input focus.
      // Updated by 'superclass'.  Can be NULL.

    char *pszMenuResource;
      // WBAlloc'd resource string for this child frame's menu (NULL = 'use default')
    WBFWMenuHandler *pMenuHandler;
      // WBAlloc'd menu handler for this child frame's menu (NULL = 'use default')
    int iContextMenuID;
      // menu ID (from pszMenuResource or owning frame's menu) for context popup, -1 if none

    WBWinEvent pUserCallback;
      // message callback function pointer (can be NULL)
    void (*destructor)(struct tagWBChildFrame *);
      // pointer to a destructor.  if not NULL, will be called by FWDestroyChildFrame()

    WBChildFrameUI *pUI;
      // pointer to 'WBChildFrameUI' function pointer table (assigned by 'superclass')

    struct tagWBChildFrame *pNext;
      // 'Next Object' pointer in an internally stored linked list (do not alter or use this)
  } WBChildFrame;

  * \endcode
  *
  * \sa \ref frame "Frame Windows"
  *
**/
typedef struct tagWBChildFrame
{
  unsigned int ulTag;               ///< tag indicating I'm a 'Child Frame' window
  Window wID;                       ///< window identifier for the 'Child Frame' window.  may contain 'None' while being destroyed
  WBFrameWindow *pOwner;            ///< a pointer to the WBFrameWindow owner
  WB_FONT pFont;                    ///< default font for the window

  WB_GEOM geom;                     ///< total client-area geometry (excludes scroll bars) in 'pixels'
  WB_GEOM geomEntire;               ///< client-area geometry (excludes scroll bars)
  WB_POINT origin;                  ///< viewport 'origin' in 'client units' (such as chars and lines) - determines scroll behavior
  WB_EXTENT extent;                 ///< viewport 'extent' in 'client units' (such as chars and lines) - determines scroll behavior

  int iRowHeight;                   ///< cached 'row height' (height of line including interline spacing)
  int iColWidth;                    ///< cached 'column width' (width of 1 character)

  WB_SCROLLINFO scroll;             ///< 'scroll info' (horizontal and vertical min/max/pos and other details)

  int iSplit;                       ///< reserved - position for 'split' (-1 for 'no split')

  WB_SCROLLINFO scrollSplit;        ///< reserved - 'scroll info' for 'split' area (implementation-defined)

  int fFlags;                       ///< various bitflags defining features.  See WBChildFrame_FLAGS enum.

  char *szDisplayName;              ///< display name shown in tab and title bar.  You should not alter this member directly.
  Atom aImageAtom;                  ///< 'image' atom for display in tabs.  default is 'None'.  You should not alter this member directly.

  char *szStatusText;               ///< Status text ('WBAlloc'd) to display when this child frame window has the input focus.  Updated by 'superclass'.  can be NULL.

  char *pszMenuResource;            ///< resource string for this child frame's menu (NULL = 'use default')
  WBFWMenuHandler *pMenuHandler;    ///< menu handler for this child frame's menu (NULL = 'use default')
  int iContextMenuID;               ///< menu ID (from pszMenuResource or owning frame's menu) for context popup, -1 if none

  WBWinEvent pUserCallback;         ///< message callback function pointer (can be NULL)
  void (*destructor)(struct tagWBChildFrame *);  ///< pointer to a 'superclass' destructor.  If not NULL, will be called by FWDestroyChildFrame()
  struct tagWBChildFrameUI *pUI;   ///< pointer to 'WBChildFrameUI' function pointer table (assigned by 'superclass')

  struct tagWBChildFrame *pNext;   ///< 'Next Object' pointer in an internally stored linked list (do not alter or use this)
} WBChildFrame;


/** \struct tagWBChildFrameUI
  * \ingroup child_frame
  * \copydoc WBChildFrameUI
**/
/** \typedef WBChildFrameUI
  * \ingroup child_frame
  * \brief Structure that defines a Child Frame's UI, mainly for a 'superclass'
  *
  * The base user interface for a child frame does very little except interact with tabs and the
  * Frame Window.  To make it really do something, you need some kind of interface. This function table
  * defines the UI interface for a Child Frame that will allow it to perform basic editing and navigation
  * functions.  If you need additional capabilities, you can hook the messages with the assigned callback
  * function.  Otherwise, most of the work will already be done for your custom child frame.\n
  *
  * \code

  typedef struct tagWBChildFrameUI
  {
    unsigned int ulTag;
      // tag indicating I'm a 'Child Frame UI' structure

    void (*do_char)(WBChildFrame *, XClientMessageEvent *);
      // handler for regular WB_CHAR Client Messages (typed-in characters).
      // NOT called for 'special' characters.

    void (*scancode)(WBChildFrame *, XClientMessageEvent *);
      // handler for 'other scan code' WB_CHAR Client Messages (typed-in characters)

    void (*bkspace)(WBChildFrame *, int iACS);
      // 'backspace' delete character (backspace equivalent).
      // 'iACS' is the Alt/Ctrl/Shift flags. See Also:  aWB_CHAR

    void (*del)(WBChildFrame *, int iACS);
      // 'delete' char under cursor (delete equivalent).
      // 'iACS' is the Alt/Ctrl/Shift flags. See Also:  aWB_CHAR

    void (*tab)(WBChildFrame *, int iACS);
      // 'tab' char, or tab navigation.
      // 'iACS' is the Alt/Ctrl/Shift flags. See Also:  aWB_CHAR

    void (*enter)(WBChildFrame *, int iACS);
      // 'enter' char, or 'enter' for navigation.
      // 'iACS' is the Alt/Ctrl/Shift flags. See Also:  aWB_CHAR

    void (*properties)(WBChildFrame *);
      // display the property sheet for the displayed document

    void (*uparrow)(WBChildFrame *, int iACS);
      // 'up' arrow navigation.
      // 'iACS' is the Alt/Ctrl/Shift flags. See Also:  aWB_CHAR

    void (*downarrow)(WBChildFrame *, int iACS);
      // 'down' arrow navigation.
      // 'iACS' is the Alt/Ctrl/Shift flags. See Also:  aWB_CHAR

    void (*leftarrow)(WBChildFrame *, int iACS);
      // 'left' arrow navigation.
      // 'iACS' is the Alt/Ctrl/Shift flags. See Also:  aWB_CHAR

    void (*rightarrow)(WBChildFrame *, int iACS);
      // 'right' arrow navigation.
      // 'iACS' is the Alt/Ctrl/Shift flags. See Also:  aWB_CHAR

    void (*home)(WBChildFrame *, int iACS);
      // 'home' arrow navigation.
      // 'iACS' is the Alt/Ctrl/Shift flags. See Also:  aWB_CHAR

    void (*end)(WBChildFrame *, int iACS);
      // 'end' arrow navigation.
      // 'iACS' is the Alt/Ctrl/Shift flags. See Also:  aWB_CHAR

    void (*pgup)(WBChildFrame *, int iACS);
      // 'page up' navigation.
      // 'iACS' is the Alt/Ctrl/Shift flags. See Also:  aWB_CHAR

    void (*pgdown)(WBChildFrame *, int iACS);
      // 'page down' navigation.
      // 'iACS' is the Alt/Ctrl/Shift flags. See Also:  aWB_CHAR

    void (*pgleft)(WBChildFrame *, int iACS);
      // 'page left' navigation.
      // 'iACS' is the Alt/Ctrl/Shift flags. See Also:  aWB_CHAR

    void (*pgright)(WBChildFrame *, int iACS);
      // 'page right' navigation.
      // 'iACS' is the Alt/Ctrl/Shift flags. See Also:  aWB_CHAR

    void (*help)(WBChildFrame *, int iACS);
      // 'help' context (F1).
      // 'iACS' is the Alt/Ctrl/Shift flags. See Also:  aWB_CHAR

    void (*hover_notify)(WBChildFrame *, int x, int y);
      // 'mouse hover' notification (x and y are pixel coords with respect to upper left corner)

    void (*hover_cancel)(WBChildFrame *);
      // 'mouse hover' cancel notification (cancel any 'hover' action)

    int (*is_ins_mode)(WBChildFrame *);
      // returns non-zero if in 'insert' mode, 0 for 'overwrite'

    void (*toggle_ins_mode)(WBChildFrame *);
      // toggles insert mode on/off (press 'INS' key)

    void (*copy_to_cb)(WBChildFrame *);
      // copy selection to clipboard

    void (*paste_from_cb)(WBChildFrame *);
      // paste from clipboard

    void (*cut_to_cb)(WBChildFrame *);
      // delete selection, copying to clipboard first

    void (*delete_sel)(WBChildFrame *);
      // delete selection only

    void (*select_all)(WBChildFrame *);
      // select all

    void (*select_none)(WBChildFrame *);
      // select none

    void (*save)(WBChildFrame *, const char *szFileName);
      // save to specified file name (NULL to keep same file name)

    WB_PCSTR (* get_file_name)(WBChildFrame *);
      // get (const) pointer to file name string

    void (*mouse_click)(WBChildFrame *, int iX, int iY,
                        int iButtonMask, int iACS);
      // 'mouse click' notification.  See Also: aWB_POINTER

    void (*mouse_dblclick)(WBChildFrame *, int iX, int iY,
                           int iButtonMask, int iACS);
      // 'mouse double click' notification.  See Also: aWB_POINTER

    void (*mouse_drag)(WBChildFrame *, int iX, int iY,
                       int iButtonMask, int iACS);
      // 'mouse drag' (begin) notification.  See Also: aWB_POINTER

    void (*mouse_drop)(WBChildFrame *, int iX, int iY,
                       int iButtonMask, int iACS);
      // 'mouse drop' (drag end) notification.  See Also: aWB_POINTER

    void (*mouse_move)(WBChildFrame *, int iX, int iY);
      // 'mouse motion' notification.  See Also: aWB_POINTER

    void (*scroll_vert)(WBChildFrame *, int iMode, int iValue);
      // 'scroll vertical' notification.  See Also: aSCROLL_NOTIFY

    void (*scroll_horiz)(WBChildFrame *, int iMode, int iValue);
      // 'scroll horizontal' notification.  See Also: aSCROLL_NOTIFY

    void (*mouse_cancel)(WBChildFrame *);
      // 'mouse cancel' notification (cancel 'drag', etc.).
      // See Also:  aWB_POINTER , WBMouseCancel()

    void (*get_row_col)(WBChildFrame *, int *piR, int *piC);
      // Obtain the current row/column cursor location for UI notification.
      // 'piR' points to an integer to get the row, and
      // 'piC' points to an integer to get the column.
      // Both are 1-based values (<= 0 is 'error' or 'NA')

    int (*has_selection)(WBChildFrame *);
      // returns non-zero value if there is a selection

    void (*undo)(WBChildFrame *);
      // perform an undo

    void (*redo)(WBChildFrame *);
      // perform a re-do

    int (*can_undo)(WBChildFrame *);
      // returns non-zero value if 'can undo'

    int (*can_redo)(WBChildFrame *);
      // returns non-zero value if 'can redo'

    int (*is_empty)(WBChildFrame *);
      // returns non-zero value if contents are 'empty' (cannot select anything)

  } WBChildFrameUI;

  * \endcode
  *
  * A window interface derived from 'WBChildFrame' needs a way for the 'abstract class' to invoke the
  * UI functionality.  To make this work, the 'superclass' (i.e. derived) window interface can populate
  * a WBChildFrameUI structure with function pointers, as needed, to implement the necessary elements.
  *
  * For those elements that are NOT implemented, you can use NULL for the function pointer.  That way if
  * the derived window interface does not need 'hover' support, you can leave the 'hover_notify' and
  * 'hover_cancel' function pointers as NULL, but populate everything else.
  *
  * For the 'iACS' parameters, use the 'iACS' information from the aWB_CHAR.  This is the 'Alt/Ctrl/Shift'
  * flag that indicates which of those buttons were being held down at the time of the character translation.
  * For more information on THAT, see \ref aWB_CHAR "WB_CHAR".
  *
  * The basic difference between 'do_char' and 'scancode' is that the 'character' events will be passed along
  * to the 'do_char' callback, but 'scan code' events (NOT processed by one of the other callbacks) will be
  * passed along via the 'scancode' callback.  This will allow your custom UI handler to interpret additional
  * 'special' keys as needed.  The ones normally processed are:  insert, delete, home, end, pgup, pgdown, and
  * the 'F1' key.
  *
  * NOTE:  if a menu defines hotkey combinations, no 'WB_CHAR' event will be generated for any of those.  Instead,
  * the menu handler needs to interpret them correctly if the UI callback will need to be invoked.  One example
  * in the X11workbench.c handler (for the main edit window UI) is the handling of the 'Edit' sub-menu, which
  * includes hotkey combinations such as 'CTRL+V' for 'paste'.  When the 'paste' menu is invoked, the handler will
  * need to grab the WBChildFrameUI structure for the currently active Child Window, and invoke its 'paste_from_cb'
  * callback function directly.  Similarly, if 'F1' is invoked, it will need to call the 'help' function directly,
  * passing the correct 'iACS' parameter value.
  *
**/
typedef struct tagWBChildFrameUI
{
  unsigned int ulTag;                                       ///< tag indicating I'm a 'Child Frame UI' structure
  void (*do_char)(WBChildFrame *, XClientMessageEvent *);   ///< handler for regular WB_CHAR Client Messages (typed-in characters). \details The XClientMessageEvent will be interpreted and characters added to the associated document or object.  This function should NOT be called for 'special' characters, like cursors, backspace, and so on.
  void (*scancode)(WBChildFrame *, XClientMessageEvent *);  ///< handler for 'other scan code' WB_CHAR Client Messages.  \details For those characters NOT already processed as actual characters or 'special' characters, call this function.  The XClientMessageEvent will be interpreted, and characters may be added to the associated document or object.  In some cases, there may be additional actions performed.  This function should rarely be needed.
  void (*bkspace)(WBChildFrame *, int iACS);                ///< 'backspace' delete character (backspace equivalent), or perform related 'backspace' operation via ctrl/alt/shift.  \details 'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
  void (*del)(WBChildFrame *, int iACS);                    ///< 'delete' char under cursor (delete equivalent), or perform related 'delete' operation via ctrl/alt/shift.  \details 'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
  void (*tab)(WBChildFrame *, int iACS);                    ///< 'tab' char, or tab navigation.  \details 'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
  void (*enter)(WBChildFrame *, int iACS);                  ///< 'enter' char, or 'enter' for navigation.  \details 'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
  void (*properties)(WBChildFrame *);                       ///< display the property sheet for the displayed document (optional)
  void (*uparrow)(WBChildFrame *, int iACS);                ///< 'up' arrow navigation.  \details 'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
  void (*downarrow)(WBChildFrame *, int iACS);              ///< 'down' arrow navigation.  \details 'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
  void (*leftarrow)(WBChildFrame *, int iACS);              ///< 'left' arrow navigation.  \details 'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
  void (*rightarrow)(WBChildFrame *, int iACS);             ///< 'right' arrow navigation.  \details 'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
  void (*home)(WBChildFrame *, int iACS);                   ///< 'home' arrow navigation.  \details 'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
  void (*end)(WBChildFrame *, int iACS);                    ///< 'end' arrow navigation.  \details 'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
  void (*pgup)(WBChildFrame *, int iACS);                   ///< 'page up' navigation.  \details 'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
  void (*pgdown)(WBChildFrame *, int iACS);                 ///< 'page down' navigation.  \details 'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
  void (*pgleft)(WBChildFrame *, int iACS);                 ///< 'page left' navigation.  \details 'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
  void (*pgright)(WBChildFrame *, int iACS);                ///< 'page right' navigation.  \details 'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
  void (*help)(WBChildFrame *, int iACS);                   ///< 'help' context (F1).  \details 'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
  void (*hover_notify)(WBChildFrame *, int x, int y);       ///< 'mouse hover' notification \details x and y are pixel coords with respect to upper left corner
  void (*hover_cancel)(WBChildFrame *);                     ///< 'mouse hover' cancel notification \details This will cancel any 'hover' action
  int (*is_ins_mode)(WBChildFrame *);                       ///< Use this to determine whether you are in 'insert' or 'overwrite' mode. \details returns non-zero if in 'insert' mode, 0 for 'overwrite'
  void (*toggle_ins_mode)(WBChildFrame *);                  ///< toggles insert mode on or off \details You can determine the current insert/overwrite state by calling is_ins_mode()
  void (*copy_to_cb)(WBChildFrame *);                       ///< copy selection to clipboard \details implements 'copy' functionality.  The current selection will be copied to the clipboard
  void (*paste_from_cb)(WBChildFrame *);                    ///< paste from clipboard \details implements 'paste' functionality.  The current clipboard contents will be pasted, either at the cursor location, or replacing the current selection
  void (*cut_to_cb)(WBChildFrame *);                        ///< delete selection, copying to clipboard first \details implements 'cut' functionality
  void (*delete_sel)(WBChildFrame *);                       ///< delete selection only \details deletes the current selection, but has no effect if there is no selection.  To delete a character, see 'del()'
  void (*select_all)(WBChildFrame *);                       ///< select all \details implements the 'select all' functionality
  void (*select_none)(WBChildFrame *);                      ///< select none \details implements the 'select none' functionality
  void (*save)(WBChildFrame *, const char *szFileName);     ///< save to specified file name \details A value of 'NULL' will keep same file name.  If the file name is also NULL (or blank), nothing will be saved.

  WB_PCSTR (* get_file_name)(WBChildFrame *);               ///< get a (const) pointer to the file name string \details Use this function to find out what the currently assigned file name is.  The returned pointer is NOT persistent across function calls.  If you need a copy, use SBCopyString() or similar

  void (*mouse_click)(WBChildFrame *, int iX, int iY,
                      int iButtonMask, int iACS);           ///< 'mouse click' notification.  \details part of the mouse UI handling.  'iX', 'iY', 'iButtonMask', and 'iACS'  are copied from the aWB_POINTER Client Message event.
  void (*mouse_dblclick)(WBChildFrame *, int iX, int iY,
                         int iButtonMask, int iACS);        ///< 'mouse double click' notification.  \details part of the mouse UI handling.  'iX', 'iY', 'iButtonMask', and 'iACS'  are copied from the aWB_POINTER Client Message event.
  void (*mouse_drag)(WBChildFrame *, int iX, int iY,
                     int iButtonMask, int iACS);            ///< 'mouse drag' (begin) notification.  \details part of the mouse UI handling.  'iX', 'iY', 'iButtonMask', and 'iACS'  are copied from the aWB_POINTER Client Message event.
  void (*mouse_drop)(WBChildFrame *, int iX, int iY,
                     int iButtonMask, int iACS);            ///< 'mouse drop' (drag end) notification.  \details part of the mouse UI handling.  'iX', 'iY', 'iButtonMask', and 'iACS'  are copied from the aWB_POINTER Client Message event.
  void (*mouse_move)(WBChildFrame *, int iX, int iY);       ///< 'mouse motion' notification.  \details part of the mouse UI handling.  'iX' and 'iY' are copied from the aWB_POINTER Client Message event.

  void (*scroll_vert)(WBChildFrame *, int iMode, int iValue); ///< 'scroll vertical' notification.  \details A higher-level scrolling notification.  'iMode' is 0 for absolute, 1 for relative.  'iValue' is the absolute (or relative) new vertical scroll position to assign  \sa aSCROLL_NOTIFY
  void (*scroll_horiz)(WBChildFrame *, int iMode, int iValue);///< 'scroll vertical' notification.  \details A higher-level scrolling notification.  'iMode' is 0 for absolute, 1 for relative.  'iValue' is the absolute (or relative) new horizontal scroll position to assign  \sa aSCROLL_NOTIFY

  void (*mouse_cancel)(WBChildFrame *);                     ///< 'mouse cancel' notification (cancel 'drag', etc.).  \details This is a notification only (any mouse capture must already have been handled).  \sa aWB_POINTER , WBMouseCancel()
  void (*get_row_col)(WBChildFrame *, int *piR, int *piC);  ///< Obtain the current row/column cursor locationfor UI notification. \details 'piR' points to an integer to get the row, and 'piC' points to an integer to get the column.  Both are 1-based values, so a value \<\= 0 is considered 'error' or 'NA'
  int (*has_selection)(WBChildFrame *);                     ///< returns non-zero value if there is a selection \details Since this affects specific UI behavior, you should use this to control enabling of the 'copy' and 'cut' menus, as an example
  void (*undo)(WBChildFrame *);                             ///< perform an undo operation \details Use 'can_undo()' to determine whether an undo is possible
  void (*redo)(WBChildFrame *);                             ///< perform a re-do \details Use 'can_redo()' to determine whether a re-do is possible
  int (*can_undo)(WBChildFrame *);                          ///< returns non-zero value if 'can undo' \details Interfaces/Objects that support 'undo' AND have a non-empty undo buffer will return non-zero.
  int (*can_redo)(WBChildFrame *);                          ///< returns non-zero value if 'can redo' \details Interfaces/Objects that support 're-do' AND have a non-empty re-do buffer will return non-zero.
  int (*is_empty)(WBChildFrame *);                          ///< returns non-zero value if contents are 'empty' \details If the contents are such that a selection cannot be made, this function will return a non-zero value

} WBChildFrameUI;




/** \enum WBChildFrame_FLAGS
  * \ingroup child_frame
  * \brief enumeration for 'fFlags' member of WBChildFrame
  *
**/
enum WBChildFrame_FLAGS
{
  WBChildFrame_NO_TAB = 1,        ///< does not use MDI tabs [intended for SDI interface]
  WBChildFrame_PIXELS = 2,        ///< use PIXELS instead of characters and lines to define the viewport
  WBChildFrame_VSPLIT = 4,        ///< RESERVED - 'splitter' window with vertical sizeable 'split'
  WBChildFrame_HSPLIT = 8,        ///< RESERVED - 'splitter' window with horizontal sizeable 'split'
  WBChildFrame_SPLIT_MASK = 12,   ///< RESERVED - bit mask for 'splitter' flags
  WBChildFrame_SPLIT_NOSIZE = 16, ///< RESERVED - bit set if split cannot be sized with the mouse
};


// FRAME WINDOW ATOMS

#if !defined(_FRAME_WINDOW_C_) && !defined(_CLIPBOARD_HELPER_C)
     /* this declares the atoms 'const' outside of frame_window.c, and does NOT declare them in clipboard_helper.c */
     /* These atoms are GLOBAL variables, assigned by the DEFAULT Display, and may not work for other threads.     */

extern const Atom aTAB_MESSAGE;  // command sent by Client Message related to tabs

#endif // !defined(_FRAME_WINDOW_C_) && !defined(_CLIPBOARD_HELPER_C)





/** \ingroup frame_window
  * \brief Create a frame window
  *
  * \param szTitle A zero-byte terminated ASCII string that defines the window title
  * \param idIcon An integer identifier coresponding to a registered icon resource
  * \param szMenuResource A zero-byte terminated ASCII definition of the menu for this window.  Pass 'NULL' for this parameter if you do not want a menu.
  * \param iX An integer identifying the x-coordinate for the window, or -1 for default
  * \param iY An integer identifying the y-coordinate for the window, or -1 for default
  * \param iWidth An integer identifying the width of the window, or -1 for default
  * \param iHeight An integer identifying the height of the window, or -1 for default
  * \param pUserCallback A WBWinEvent callback function that receives event notifications for the window
  * \param iFlags An integer with one or more bit flags that alters the parameters for the frame window.  See \ref WBFrameWindow_FLAGS
  * \return A pointer to a WBFrameWindow object.  The caller should not destroy this object, nor directly
  *         reference it after the window has been destroyed.
  *
  * Use this function to create a basic frame window.  A frame window has a title, icon, menu, and
  * can contain one or more 'Child Frames'.  The menu is optional, and support for multiple 'tab'
  * child frames is also optional, depending on the bit flags set in 'iFlags'.
  *
  * NOTE:  scroll up to the 'Detailed Description' section for an example of how to use this function
  *
  * Header File:  frame_window.h
  *
  * \sa \ref frame_menu "Frame Window Menu Handling"
**/
WBFrameWindow *FWCreateFrameWindow(const char *szTitle, int idIcon, const char *szMenuResource,
                                   int iX, int iY, int iWidth, int iHeight,
                                   WBWinEvent pUserCallback, int iFlags);

/** \ingroup frame_window
  * \brief Force a frame window to recalculate its layout, which may involve resizing multiple contained windows
  *
  * \param wID The Window ID of the WBFrameWindow (typically will be called within a message handler, such as a window re-size)
  *
  * Forces the frame window to recalculate its layout (i.e. size of menus, tabs, and 'child frame' windows) and propogate
  * that information to all 'owned' windows and objects it contains.
  *
  * Header File:  frame_window.h
**/
void FWRecalcLayout(Window wID);  // recalculate layout information (propagates to contained windows)


/** \ingroup frame_window
  * \brief assign a new WBWinEvent callback function for a frame window
  *
  * \param pFW A pointer to the WBFrameWindow structure
  * \param pCallBack A function pointer of type \ref WBWinEvent for the user-defined event handler callback.  Can be NULL.
  *
  * Use this function to assign the event handler callback for the frame window. Not all events pass through
  * the callback.  Some events are sent directly to the callback, and may have required implementation.
  *
  * Header File:  frame_window.h
**/
void FWSetUserCallback(WBFrameWindow *pFW, WBWinEvent pCallBack);


/** \ingroup frame_window
  * \brief Obtain the associated WBFrameWindow structure pointer for a frame window's Window ID
  *
  * \param wID A valid Window ID
  * \returns A pointer to the associated WBFrameWindow structure (if it is a WBFrameWindow), or NULL on error
  *
  * Use this function to safely obtain the correct WBFrameWindow structure for a given Window ID.
  *
  * Header File:  frame_window.h
**/
static __inline__ WBFrameWindow *FWGetFrameWindowStruct(Window wID)  // for frame windows, returns the frame window struct
{
  WBFrameWindow *pRval = (WBFrameWindow *)WBGetWindowData(wID, 0);  // offset 0 for window-specific structs

  if(pRval && pRval->ulTag == FRAME_WINDOW_TAG)
  {
    return(pRval);
  }

  return(NULL);
}

/** \ingroup frame_window
  * \brief Function to destroy a frame window based on the Window id
  *
  * \param wID The Window ID associated with the WBFrameWindow to destroy
  *
  * Use this function to destroy a WBFrameWindow based on it's ID.  After calling this function
  * the WBFrameWindow struct is no longer valid
  *
  * Header File:  frame_window.h
**/
void FWDestroyFrameWindow(Window wID);  // destroys frame window using the Window ID (frees the struct also)

/** \ingroup frame_window
  * \brief Function to destroy a frame window based on the WBFrameWindow structure
  *
  * \param pFrameWindow The pointer to the WBFrameWindow structure for the desired frame window
  *
  * Use this function to destroy a WBFrameWindow based on the WBFrameWindow struct pointer value.
  * After calling this function the WBFrameWindow struct is no longer valid
  *
  * Header File:  frame_window.h
**/
void FWDestroyFrameWindow2(WBFrameWindow *pFrameWindow); // destroys it using the struct pointer

/** \ingroup frame_window
  * \brief Function to assign the default menu handler to a frame window
  *
  * \param pFrameWindow The pointer to the WBFrameWindow structure for the desired frame window
  * \param pHandlerArray A pointer to an array of WBFWMenuHandler structures - see \ref FW_MENU_HANDLER_ENTRY
  *
  * Assigns the menu handlers for the frame window.  The array will be copied, and the copy will be
  * used internally.  These handlers are checked for matching entries after checking the 'contained' window's
  * handlers for the WBChildFrame that has the current focus.
  *
  * \sa \ref frame_menu "Frame Menus"
  *
  * Header File:  frame_window.h
**/
void FWSetMenuHandlers(WBFrameWindow *pFrameWindow, const WBFWMenuHandler *pHandlerArray);

/** \ingroup frame_menu
  * \def FW_MENU_HANDLER_BEGIN
  * \brief Use this macro to begin definition of a WBFWMenuHandler array
  *
  * \param X the name of the menu handler array variable
**/
#define FW_MENU_HANDLER_BEGIN(X) static const WBFWMenuHandler X[] = {
/** \ingroup frame_menu
  * \def FW_MENU_HANDLER_ENTRY
  * \brief Use this macro to define an entry for a WBFWMenuHandler array
  *
  * \param X A menu identifier expressed as an ASCII string or ID
  * \param Y A callback function pointer, or NULL - see WBFWMenuHandler::callback
  * \param Z A UI callback functino pointer, or NULL - see WBFWMenuHandler::UIcallback
**/
#define FW_MENU_HANDLER_ENTRY(X,Y,Z) { (unsigned long)X, Y, Z },
/** \ingroup frame_menu
  * \def FW_MENU_HANDLER_END
  * \brief Use this macro to complete the definition of a WBFWMenuHandler array
**/
#define FW_MENU_HANDLER_END {0, 0, 0} };


// frame window 'contents' functions

/** \ingroup frame_window
  * \brief Returns the total number of 'contained' windows
  *
  * \param pFrameWindow A const pointer to a WBFrameWindow structure for the frame window
  * \returns The total number of 'contained' windows, or -1 on error
  *
  * Header File:  frame_window.h
**/
int FWGetNumContWindows(const WBFrameWindow *pFrameWindow);

/** \ingroup frame_window
  * \brief Returns the Window ID for the specified 'contained' window.  The index follows the tab order.
  *
  * \param pFrameWindow A const pointer to a WBFrameWindow structure for the frame window
  * \param iIndex The 'tab order' index of the 'contained' window.  The first window is '0'.  A negative value implies the 'current focus' window
  * \returns A pointer to the WBChildFrame for the 'contained' window corresponding to the index, or 'NULL' on error
  *
  * Use this function to get the Window ID of a 'contained' (child frame) window.  To get more information
  * about contained 'Child Frame' window, see \ref child_frame "Child Frames"
  *
  * Header File:  frame_window.h
**/
WBChildFrame * FWGetContainedWindowByIndex(const WBFrameWindow *pFrameWindow, int iIndex);

/** \ingroup frame_menu
  * \def FWGetFocusWindow
  * \brief A macro to aid code readability, returning the Window ID of the contained window that has the focus
  *
  * \param pFW The WBFrameWindow structure pointer
**/
#define FWGetFocusWindow(pFW) (FWGetNumContWindows(pFW) > 0 ? FWGetContainedWindowByIndex(pFW, -1) : NULL)

/** \ingroup frame_window
  * \brief Adds a 'contained' window and returns the tab order index
  *
  * \param pFrameWindow A pointer to a WBFrameWindow structure for the frame window
  * \param pNew A pointer to the WBChildFrame for the window that is to become part of the 'contents' for the frame window
  * \returns The tab order index of the window, or -1 on error
  *
  * Header File:  frame_window.h
**/
int FWAddContainedWindow(WBFrameWindow *pFrameWindow, WBChildFrame *pNew);

/** \ingroup frame_window
  * \brief Removes a 'contained' window from a frame window.  Does not destroy the 'contained' window.
  *
  * \param pFrameWindow A pointer to a WBFrameWindow structure for the frame window
  * \param pCont A pointer to the WBChildFrame for the window that is to be removed from the 'contents' for the frame window
  * \returns void
  *
  * Header File:  frame_window.h
**/
void FWRemoveContainedWindow(WBFrameWindow *pFrameWindow, WBChildFrame *pCont);

/** \ingroup frame_window
  * \brief Replace a 'contained' window from a frame window
  *
  * \param pFrameWindow A pointer to a WBFrameWindow structure for the frame window
  * \param pCont A pointer to the WBChildFrame for the window that is to be removed from the 'contents' for the frame window
  * \param pContNew A pointer to the WBChildFrame for the window that is to replace the previous contained window
  * \returns void
  *
  * sometimes the document type will change when you are editing or creating a new document.  As an example,
  * you are creating a plain text file, but then name it with a '.c' extension, or with the name 'Makefile'.
  * Your document editing window might decide to change the view based on that information, and you would then
  * re-open the file with the new document editing window, and replace the current one with that one, then
  * destroy the old one (after saving the new document, of course).  This provides a seamless way of making
  * all of this happen without the user noticing anything EXCEPT the new view.
  *
  * An alternate purpose might be to view something in 'text mode' or 'graphic edit mode'.  A dialog resource
  * or image resource editor might be a typical use for this.  In 'text mode' you view the resource as a text
  * file (it might be a pixmap, for example). Switching to 'graphic edit mode' could display a graphical editor
  * for the pixmap, which would allow you to draw, erase, add elements, change colors, etc. like any other
  * graphical editor might do.
  *
  * Typically you'll have a default view for 'any document type'.  The application would need to swap it out
  * for the correct view when the document type changes, by creating the new document view/edit window, and then
  * calling this function.
  *
  * Header File:  frame_window.h
**/
void FWReplaceContainedWindow(WBFrameWindow *pFrameWindow, WBChildFrame *pCont, WBChildFrame *pContNew);

/** \ingroup frame_window
  * \brief Sets the focus to a specific contained window using the Window ID
  *
  * \param pFrameWindow A pointer to a WBFrameWindow structure for the frame window
  * \param pCont A pointer to the WBChildFrame for the window that is to be assigned the focus.
  * \returns void
  *
  * Header File:  frame_window.h
**/
void FWSetFocusWindow(WBFrameWindow *pFrameWindow, WBChildFrame *pCont);

/** \ingroup frame_window
  * \brief Sets the focus to a specific contained window using its tab order index
  *
  * \param pFrameWindow A pointer to a WBFrameWindow structure for the frame window
  * \param iIndex The 'tab order' index of the 'contained' window that is to receive the focus
  * \returns void
  *
  * Header File:  frame_window.h
**/
void FWSetFocusWindowIndex(WBFrameWindow *pFrameWindow, int iIndex);

/** \ingroup frame_window
  * \brief Sets the focus to a specific contained window using its tab order index
  *
  * \param pFrameWindow A pointer to a WBFrameWindow structure for the frame window
  * \param pCont A pointer to a WBChildFrame structure for the contained window.  Use NULL for the current focus window
  * \returns The tab order index of 'pCont', or a negative value on error.
  *
  * Header File:  frame_window.h
**/
int FWGetChildFrameIndex(WBFrameWindow *pFrameWindow, WBChildFrame *pCont);

/** \ingroup frame_window
  * \brief Sets the specific contained window to a particular index in the tab order
  *
  * \param pFrameWindow A pointer to a WBFrameWindow structure for the frame window
  * \param pCont A pointer to a WBChildFrame structure for the contained window.  Use NULL for the current focus window
  * \param iIndex The new 'tab order' index to assign to the 'contained' window, or a constant indicating how to adjust the index\n A value of 0 to n assigns the specified tab index.  Positive values greater than the total number of tabs moves it to the end of the tab order.\n A value of MOVE_CHILD_FRAME_TAB_INDEX_LEFT moves the tab 1 to the left\n A value of MOVE_CHILD_FRAME_TAB_INDEX_RIGHT moves the tab 1 to the right\n\n Use a value of MOVE_CHILD_FRAME_TAB_INDEX_BEGINNING (0) to move the tab to the beginning.
  * \returns void
  *
  * Header File:  frame_window.h
**/
void FWMoveChildFrameTabIndex(WBFrameWindow *pFrameWindow, WBChildFrame *pCont, int iIndex);

/** \ingroup frame_window
  * \def MOVE_CHILD_FRAME_TAB_INDEX_BEGINNING
  * \brief pass as 'iIndex' for FWMoveChildFrameTabIndex() to move the tab index to the beginning
**/
#define MOVE_CHILD_FRAME_TAB_INDEX_BEGINNING 0
/** \ingroup frame_window
  * \def MOVE_CHILD_FRAME_TAB_INDEX_RIGHT
  * \brief pass as 'iIndex' for FWMoveChildFrameTabIndex() to move the tab index right
**/
#define MOVE_CHILD_FRAME_TAB_INDEX_RIGHT -2
/** \ingroup frame_window
  * \def MOVE_CHILD_FRAME_TAB_INDEX_LEFT
  * \brief pass as 'iIndex' for FWMoveChildFrameTabIndex() to move the tab index left
**/
#define MOVE_CHILD_FRAME_TAB_INDEX_LEFT -1

/** \ingroup frame_window
  * \brief Sets the 'status' text for a Frame Window with a status bar, forcing a re-paint
  *
  * \param pFrameWindow A pointer to a WBFrameWindow structure for the frame window
  * \param szText A tab-delimited character string containing UTF8 or ASCII status text. A copy of this will be stored internally.
  * \returns void
  *
  * Use this function to update the status text.  Status text can contain multiple 'columns' that
  * are displayed using the tab stop information assigned by FWSetStatusTabInfo().  Each column's
  * text data will be 'appropriately justified' and displayed in the status bar according to the tab info.\n
  * This function forces a re-paint of the status bar.  If you also want to change the tabs, call
  * FWSetStatusTabInfo() first, followed by this function.
  *
  * Header File:  frame_window.h
**/
void FWSetStatusText(WBFrameWindow *pFrameWindow, const char *szText);

/** \ingroup frame_window
  * \brief Sets the 'status' tab info for a Frame Window with a status bar
  *
  * \param pFrameWindow A pointer to a WBFrameWindow structure for the frame window
  * \param nTabs The total number of tabs in 'pTabs'.  If 'pTabs' is NULL, it is the default (even) tab spacing.
  * \param pTabs A pointer to an array of integers containing tab values.  See below on how they are interpreted.
  * \returns void
  *
  * Use this function to assign the tab spacing and/or columns for the status bar.  Tabs are bit-wise
  * 'or'd with flags from the \ref WBStatusTabInfo_FLAGS enumeration.\n
  * The physical tab value starts at the left side unless WBStatusTabInfo_RTL_COLUMN has been 'or'd with
  * its value.  Columns width is determined by both the next tab value and the current one.  Use the
  * 'WBStatusTabInfo_BREAK' flag to create a 'blank' area that defines the width of the previous column
  * but does not have anything displayed within it.\n
  * To left, right, or center text within a column, use one of the WBStatusTabInfo_JUSTIFY_ constants.  The
  * default (zero) is left-justification (even for RTL columns).\n
  * This function does NOT force a re-paint of the status bar.  It does invalidate the status bar rectangle,
  * however. To force a re-paint after updating the tabs, call WBUpdateWindow() for the frame window.
  *
  * Header File:  frame_window.h
**/
void FWSetStatusTabInfo(WBFrameWindow *pFrameWindow, int nTabs, const int *pTabs);

// DEFAULT COLORS AND FONTS

/** \ingroup frame_window
  * \brief Get the default foreground color
  *
  * \returns XColor representing default foreground color
  *
  * Header File:  frame_window.h
**/
XColor FWGetDefaultFG(void);

/** \ingroup frame_window
  * \brief Get the default background color
  *
  * \returns XColor representing default background color
  *
  * Header File:  frame_window.h
**/
XColor FWGetDefaultBG(void);

/** \ingroup frame_window
  * \brief Get the default border color
  *
  * \returns XColor representing default border color
  *
  * Header File:  frame_window.h
**/
XColor FWGetDefaultBD(void);

/** \ingroup frame_window
  * \brief Get the frame window WB_FONTC
  *
  * \returns WB_FONTC assigned to frame window for font
  *
  * Header File:  frame_window.h
**/
WB_FONTC FWGetFont(WBFrameWindow *pFW);

/** \ingroup frame_window
  * \brief Get the frame window bold WB_FONTC
  *
  * \returns WB_FONTC assigned to frame window for bold font
  *
  * Header File:  frame_window.h
**/
WB_FONTC FWGetBoldFont(WBFrameWindow *pFW);


#if 0
/** \ingroup frame_window
  * \brief Handles 'selection' events for frame windows
  *
  * \param pFrameWindow A pointer to a WBFrameWindow structure for the frame window
  * \param wID The ID of the frame window
  * \param wIDMenu The Window ID of the frame window's currently active menu
  * \param pEvent The 'selection' event
  * \returns Non-zero if 'handled', zero if further (or default) processing is needed
  *
  * This function performs basic 'selection event' processing.  It is normally called
  * internally for default handling of selection events whenever the specified callback
  * function returns 0 for such events.
  *
  * Header File:  frame_window.h
**/
int FWDoSelectionEvents(WBFrameWindow *pFrameWindow, Window wID, Window wIDMenu, XEvent *pEvent);
#endif // 0


#ifdef __cplusplus
};
#endif // __cplusplus


#endif // FRAME_WINDOW_H_INCLUDED

