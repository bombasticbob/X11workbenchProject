//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//              _             _                        _                       _                   _        //
//   __      __(_) _ __    __| |  ___ __      __    __| | _ __  ___  ___  ___ (_) _ __    __ _    | |__     //
//   \ \ /\ / /| || '_ \  / _` | / _ \\ \ /\ / /   / _` || '__|/ _ \/ __|/ __|| || '_ \  / _` |   | '_ \    //
//    \ V  V / | || | | || (_| || (_) |\ V  V /   | (_| || |  |  __/\__ \\__ \| || | | || (_| | _ | | | |   //
//     \_/\_/  |_||_| |_| \__,_| \___/  \_/\_/_____\__,_||_|   \___||___/|___/|_||_| |_| \__, |(_)|_| |_|   //
//                                           |_____|                                     |___/              //
//                                                                                                          //
//                     Utilities for painting and handling standard components of windows                   //
//                                                                                                          //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2016 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no waranties, either implied or explicit.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/


#ifndef _WINDOW_DRESSING_H_INCLUDED_
#define _WINDOW_DRESSING_H_INCLUDED_

#include "window_helper.h" // make sure
#include "font_helper.h" // make sure

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


/** \file window_dressing.h Utilities for painting and handling standard components of windows
**/

// SCROLL BARS

/** \struct __WB_SCROLLINFO__
  * \ingroup window_dressing
  * \copydoc WB_SCROLLINFO
**/
/** \typedef WB_SCROLLINFO
  * \ingroup window_dressing
  * \brief Structure that defines scroll bar info for both horizontal and vertical scroll bars
  *
  * This structure defines the scroll bar information for both vertical and horizontal scroll
  * bars.  You can have both a horizontal AND a vertical scroll bar at the same time.  This
  * structure is maintained by various API functions, particularly WBUpdateScrollBarGeometry().
  *
  * \code

  typedef struct __WB_SCROLLINFO__
  {
    int iScrollState;         // scroll state flags - see enumeration \ref WBScrollState_ENUM

    // fixed dimension sizes - 0 if not known, else based on owner client width/height
    int iVScrollWidth;        // calculated width of vertical scroll bar (in pixels); 0 if not known
    int iHScrollHeight;       // calculated height of horizontal scroll bar (in pixels); 0 if not known
    int iVBarHeight;          // calculated height of vertical scroll bar (re-calculate on window size change)
    int iHBarWidth;           // calculated width of horizontal scroll bar (re-calculate on window size change)

    int iHKnob;               // calculated relative X pixel position of horizontal scroll 'knob'
    int iVKnob;               // calculated relative Y pixel position of vertical scroll 'knob'
    int iHKnobSize;           // calculated pixel width of horizontal scroll 'knob'
    int iVKnobSize;           // calculated pixel height of vertical scroll 'knob'

    int iHMin;                // minimum horizontal range (0 if no bar)
    int iHMax;                // maximum horizontal range (0 if no bar)
    int iVMin;                // minimum vertical range (0 if no bar)
    int iVMax;                // maximum vertical range (0 if no bar)

    int iHPos;                // current horozontal scroll position (N/A if outside of min/max range)
    int iVPos;                // current vertical scroll position (N/A if outside of min/max range)

    WB_GEOM geomHBar;         // geometry for the horizontal scroll bar excluding border (empty if not visible)
    WB_GEOM geomHLeft;        // geometry for the horizontal scroll bar 'left' button (empty if not visible)
    WB_GEOM geomHRight;       // geometry for the horizontal scroll bar 'right' button (empty if not visible)
    WB_GEOM geomHKnob;        // geometry for the horizontal scroll bar 'knob' (empty if not visible)
    WB_GEOM geomVBar;         // geometry for the vertical scroll bar excluding border (empty if not visible)
    WB_GEOM geomVUp;          // geometry for the vertical scroll bar 'up' button (empty if not visible)
    WB_GEOM geomVDown;        // geometry for the vertical scroll bar 'down' button (empty if not visible)
    WB_GEOM geomVKnob;        // geometry for the vertical scroll bar 'knob' (empty if not visible)
  } WB_SCROLLINFO;

  * \endcode
  *
  * \sa WBInitScrollInfo(), WBUpdateScrollBarGeometry()
**/
typedef struct __WB_SCROLLINFO__
{
  int iScrollState;         ///< scroll state flags - see enumeration \ref WBScrollState_ENUM

  // fixed dimension sizes - 0 if not known, else based on owner client width/height
  int iVScrollWidth;        ///< calculated width of vertical scroll bar (in pixels); 0 if not known
  int iHScrollHeight;       ///< calculated height of horizontal scroll bar (in pixels); 0 if not known
  int iVBarHeight;          ///< calculated height of vertical scroll bar (re-calculate on window size change)
  int iHBarWidth;           ///< calculated width of horizontal scroll bar (re-calculate on window size change)

  int iHKnob;               ///< calculated relative X pixel position of horizontal scroll 'knob'
  int iVKnob;               ///< calculated relative Y pixel position of vertical scroll 'knob'
  int iHKnobSize;           ///< calculated pixel width of horizontal scroll 'knob'
  int iVKnobSize;           ///< calculated pixel height of vertical scroll 'knob'

  int iHMin;                ///< minimum horizontal range (0 if no bar)
  int iHMax;                ///< maximum horizontal range (0 if no bar)
  int iVMin;                ///< minimum vertical range (0 if no bar)
  int iVMax;                ///< maximum vertical range (0 if no bar)

  int iHPos;                ///< current horozontal scroll position (N/A if outside of min/max range)
  int iVPos;                ///< current vertical scroll position (N/A if outside of min/max range)

  WB_GEOM geomHBar;         ///< geometry for the horizontal scroll bar excluding border (empty if not visible)
  WB_GEOM geomHLeft;        ///< geometry for the horizontal scroll bar 'left' button (empty if not visible)
  WB_GEOM geomHRight;       ///< geometry for the horizontal scroll bar 'right' button (empty if not visible)
  WB_GEOM geomHKnob;        ///< geometry for the horizontal scroll bar 'knob' (empty if not visible)
  WB_GEOM geomVBar;         ///< geometry for the vertical scroll bar excluding border (empty if not visible)
  WB_GEOM geomVUp;          ///< geometry for the vertical scroll bar 'up' button (empty if not visible)
  WB_GEOM geomVDown;        ///< geometry for the vertical scroll bar 'down' button (empty if not visible)
  WB_GEOM geomVKnob;        ///< geometry for the vertical scroll bar 'knob' (empty if not visible)
} WB_SCROLLINFO;


/** \ingroup window_dressing
  * \enum WBScrollState_ENUM
  *
  * Enumeration of scroll state flags.
  *
  * \sa \ref WB_SCROLLINFO
  *
**/  
enum WBScrollState_ENUM
{
  WBScrollState_LDRAG = 1,   ///< left button in 'drag' state on vertical scroll bar (relies on drag cancel)
  WBScrollState_RDRAG = 2,   ///< right button in 'drag' state on vertical scroll bar
  WBScrollState_MDRAG = 4,   ///< middle button in 'drag' state on vertical scroll bar
  WBScrollState_HLDRAG = 8,  ///< left button in 'drag' state on horizontal scroll bar (relies on drag cancel)
  WBScrollState_HRDRAG = 16, ///< right button in 'drag' state on horizontal scroll bar
  WBScrollState_HMDRAG = 32  ///< middle button in 'drag' state on horizontal scroll bar
};


/** \ingroup window_dressing
  * \brief Initialization function for a 'WB_SCROLLINFO' structure.
  *
  * \param pSI A pointer to the WB_SCROLLINFO structure to be initialized
  *
  * Use this function to initialize a WB_SCROLLINFO structure in a standardized way
  *
  * Header File:  window_dressing.h
**/
static __inline__ void WBInitScrollInfo(WB_SCROLLINFO *pSI) { bzero(pSI, sizeof(*pSI)); pSI->iHPos = pSI->iVPos = -1; }

/** \ingroup window_dressing
  * \brief Set the scroll range for a vertical scrollbar in the WB_SCROLLINFO structure
  *
  * \param pSI A pointer to the WB_SCROLLINFO structure
  * \param iMin The minimum scroll value
  * \param iMax The maximum scroll value
  *
  * Use this function to assign the correct 'scroll range' for a vertical scroll bar that
  * is managed by a WB_SCROLLINFO structure
  *
  * Header File:  window_dressing.h
**/
void WBSetVScrollRange(WB_SCROLLINFO *pSI, int iMin, int iMax);

/** \ingroup window_dressing
  * \brief Set the scroll range for a horizontal scrollbar in the WB_SCROLLINFO structure
  *
  * \param pSI A pointer to the WB_SCROLLINFO structure
  * \param iMin The minimum scroll value
  * \param iMax The maximum scroll value
  *
  * Use this function to assign the correct 'scroll range' for a horizontal scroll bar that
  * is managed by a WB_SCROLLINFO structure.
  *
  * Header File:  window_dressing.h
**/
void WBSetHScrollRange(WB_SCROLLINFO *pSI, int iMin, int iMax);

/** \ingroup window_dressing
  * \brief Set the scroll range for a vertical scrollbar in the WB_SCROLLINFO structure
  *
  * \param pSI A pointer to the WB_SCROLLINFO structure
  * \param iPos The new scroll position
  *
  * Use this function to assign the correct 'scroll position' for a vertical scroll bar that
  * is managed by a WB_SCROLLINFO structure
  *
  * Header File:  window_dressing.h
**/
void WBSetVScrollPos(WB_SCROLLINFO *pSI, int iPos);

/** \ingroup window_dressing
  * \brief Set the scroll range for a horizontal scrollbar in the WB_SCROLLINFO structure
  *
  * \param pSI A pointer to the WB_SCROLLINFO structure
  * \param iPos The new scroll position
  *
  * Use this function to assign the correct 'scroll position' for a horizontal scroll bar that
  * is managed by a WB_SCROLLINFO structure
  *
  * Header File:  window_dressing.h
**/
void WBSetHScrollPos(WB_SCROLLINFO *pSI, int iPos);

/** \ingroup window_dressing
  * \brief Update the scroll bar geometry within the WB_SCROLLINFO structure
  *
  * \param pSI A pointer to the WB_SCROLLINFO structure
  * \param pfontReference The reference font for scroll bar size.  Pass NULL to use the 'Default' font.
  * \param pgeomClient The geometry of the client area where the scroll bars will be displayed.
  * \param pgeomUsable Returns the resulting 'usable' client area after scroll bar geometry calculations are done.
  *
  * Use this function to assign the correct 'scroll position' for a vertical scroll bar that
  * is managed by a WB_SCROLLINFO structure
  *
  * Header File:  window_dressing.h
**/
void WBUpdateScrollBarGeometry(WB_SCROLLINFO *pSI, XFontStruct *pfontReference,
                               WB_GEOM *pgeomClient, WB_GEOM *pgeomUsable);

/** \ingroup window_dressing
  * \brief Calculate and assign the correct vertical scroll bar position from mouse coordinates
  *
  * \param pScrollInfo A pointer to the WB_SCROLLINFO structure
  * \param iY The mouse Y coordinate from the most recent Motion event
  *
  * Use this function to calculate and assign the correct 'scroll position' for a vertical scroll
  * bar that is managed by a WB_SCROLLINFO structure
  *
  * Header File:  window_dressing.h
**/
int WBCalcVScrollDragPos(WB_SCROLLINFO *pScrollInfo, int iY); // 'iY' is the 'y' value for the mouse position relative to window orig

/** \ingroup window_dressing
  * \brief Calculate and assign the correct horizontal scroll bar position from mouse coordinates
  *
  * \param pScrollInfo A pointer to the WB_SCROLLINFO structure
  * \param iX The mouse X coordinate from the most recent Motion event
  *
  * Use this function to calculate and assign the correct 'scroll position' for a horizontal scroll
  * bar that is managed by a WB_SCROLLINFO structure
  *
  * Header File:  window_dressing.h
**/
int WBCalcHScrollDragPos(WB_SCROLLINFO *pScrollInfo, int iX); // 'iX' is the 'x' value for the mouse position relative to window orig

// internal SCROLLINFO utilities for list-based dialog controls
/** \ingroup window_dressing
  * \brief Calculate the parameters for a vertical scroll bar
  *
  * \param pScrollInfo A pointer to the WB_SCROLLINFO structure to be initialized
  * \param pgeomClient A pointer to the WB_GEOM for the client area
  * \param iVScrollWidth The width of the vertical scroll bar in pixels
  * \param iHScrollHeight The height of the horizontal scroll bar in pixels
  * \param nListItems The number of items in a list of scrollable items
  * \param nPos The current position within the list of scrollable items
  *
  * Use this function to re-calculate the parameters associated with a vertical scroll bar
  *
  * Header File:  window_dressing.h
**/
void WBCalcVScrollBar(WB_SCROLLINFO *pScrollInfo, WB_GEOM *pgeomClient, int iVScrollWidth,
                      int iHScrollHeight, int nListItems, int nPos);  // calculates V scroll geometry for paint

/** \ingroup window_dressing
  * \brief Calculate the parameters for a horizontal scroll bar
  *
  * \param pScrollInfo A pointer to the WB_SCROLLINFO structure to be initialized
  * \param pgeomClient A pointer to the WB_GEOM for the client area
  * \param iVScrollWidth The width of the vertical scroll bar in pixels
  * \param iHScrollHeight The height of the horizontal scroll bar in pixels
  * \param nListItems The number of items in a list of scrollable items
  * \param nPos The current position within the list of scrollable items
  *
  * Use this function to re-calculate the parameters associated with a horizontal scroll bar
  *
  * Header File:  window_dressing.h
**/
void WBCalcHScrollBar(WB_SCROLLINFO *pScrollInfo, WB_GEOM *pgeomClient, int iVScrollWidth,
                      int iHScrollHeight, int nListItems, int nPos);  // calculates H scroll geometry for paint

/** \ingroup window_dressing
  * \brief Paint the vertical scroll bar within a window based on WB_SCROLLINFO
  *
  * \param pScrollInfo A pointer to the WB_SCROLLINFO structure to be initialized
  * \param pDisplay A pointer to the current display (or NULL to use the default Display)
  * \param wID the Drawable, typically the Window ID for the target window
  * \param gc The GC (graphics context) to use
  * \param pgeomClient A pointer to the WB_GEOM for the client area
  *
  * Use this function to paint the vertical scroll bar within the specified window, based on WB_SCROLLINFO
  *
  * Header File:  window_dressing.h
**/
void WBPaintVScrollBar(WB_SCROLLINFO *pScrollInfo, Display *pDisplay, Drawable wID,
                       GC gc, WB_GEOM *pgeomClient);

/** \ingroup window_dressing
  * \brief Paint the horizontal scroll bar within a window based on WB_SCROLLINFO
  *
  * \param pScrollInfo A pointer to the WB_SCROLLINFO structure to be initialized
  * \param pDisplay A pointer to the current display (or NULL to use the default Display)
  * \param wID the Drawable, typically the Window ID for the target window
  * \param gc The GC (graphics context) to use
  * \param pgeomClient A pointer to the WB_GEOM for the client area
  *
  * Use this function to paint the horizontal scroll bar within the specified window, based on WB_SCROLLINFO
  *
  * Header File:  window_dressing.h
**/
void WBPaintHScrollBar(WB_SCROLLINFO *pScrollInfo, Display *pDisplay, Drawable wID,
                       GC gc, WB_GEOM *pgeomClient);

// borders and '3D' rectangle art

/** \ingroup window_dressing
  * \brief Draw a 'border' rectangle
  *
  * \param pDisplay A pointer to the current display (or NULL to use the default Display)
  * \param wID the Drawable, typically the Window ID for the target window
  * \param gc The GC (graphics context) to use
  * \param pgeomBorder A WB_GEOM that identifies the border rectangle to draw
  * \param lBorderColor A 'Pixel' color value to use when painting the border
  *
  * Use this function to draw a border rectangle in the specified window, using the specified geometry.
  *
  * Header File:  window_dressing.h
**/
void WBDrawBorderRect(Display *pDisplay, Drawable wID, GC gc,
                      WB_GEOM *pgeomBorder, unsigned long lBorderColor);

/** \ingroup window_dressing
  * \brief Draw a 3D 'border' rectangle
  *
  * \param pDisplay A pointer to the current display (or NULL to use the default Display)
  * \param wID the Drawable, typically the Window ID for the target window
  * \param gc The GC (graphics context) to use
  * \param pgeomBorder A WB_GEOM that identifies the border rectangle to draw
  * \param lBorderColor1 A 'Pixel' color value to use when painting the border (upper, left)
  * \param lBorderColor2 A 'Pixel' color value to use when painting the border (lower, right)
  *
  * Use this function to draw a 3D border rectangle in the specified window, using the specified geometry.
  *
  * Header File:  window_dressing.h
**/
void WBDraw3DBorderRect(Display *pDisplay, Drawable wID, GC gc, WB_GEOM *pgeomBorder,
                        unsigned long lBorderColor1, unsigned long lBorderColor2);

/** \ingroup window_dressing
  * \brief Draw a 'dashed' rectangle
  *
  * \param pDisplay A pointer to the current display (or NULL to use the default Display)
  * \param wID the Drawable, typically the Window ID for the target window
  * \param gc The GC (graphics context) to use
  * \param pgeomRect A WB_GEOM that identifies the rectangle to draw
  * \param lColor A 'Pixel' color value to use when painting the dashed rectangle
  *
  * Use this function to draw a border rectangle in the specified window, using the specified geometry.
  *
  * Header File:  window_dressing.h
**/
void WBDrawDashedRect(Display *pDisplay, Drawable wID, GC gc, WB_GEOM *pgeomRect, unsigned long lColor);


/** \ingroup window_dressing
  * \brief Draw a left arrow in a window within a specified geometry
  *
  * \param pDisplay A pointer to the current display (or NULL to use the default Display)
  * \param wID the Drawable, typically the Window ID for the target window
  * \param gc The GC (graphics context) to use
  * \param pgeomRect A WB_GEOM that identifies the rectangle within which to draw the arrow
  * \param lColor A 'Pixel' color value to use when painting the arrow as a polygon
  *
  * Use this function to draw a left arrow in the specified window, using the specified geometry.
  *
  * Header File:  window_dressing.h
**/
void WBDrawLeftArrow(Display *pDisplay, Drawable wID, GC gc, WB_GEOM *pgeomRect, unsigned long lColor);

/** \ingroup window_dressing
  * \brief Draw a right arrow in a window within a specified geometry
  *
  * \param pDisplay A pointer to the current display (or NULL to use the default Display)
  * \param wID the Drawable, typically the Window ID for the target window
  * \param gc The GC (graphics context) to use
  * \param pgeomRect A WB_GEOM that identifies the rectangle within which to draw the arrow
  * \param lColor A 'Pixel' color value to use when painting the arrow as a polygon
  *
  * Use this function to draw a right arrow in the specified window, using the specified geometry.
  *
  * Header File:  window_dressing.h
**/
void WBDrawRightArrow(Display *pDisplay, Drawable wID, GC gc, WB_GEOM *pgeomRect, unsigned long lColor);

/** \ingroup window_dressing
  * \brief Draw an up arrow in a window within a specified geometry
  *
  * \param pDisplay A pointer to the current display (or NULL to use the default Display)
  * \param wID the Drawable, typically the Window ID for the target window
  * \param gc The GC (graphics context) to use
  * \param pgeomRect A WB_GEOM that identifies the rectangle within which to draw the arrow
  * \param lColor A 'Pixel' color value to use when painting the arrow as a polygon
  *
  * Use this function to draw an up arrow in the specified window, using the specified geometry.
  *
  * Header File:  window_dressing.h
**/
void WBDrawUpArrow(Display *pDisplay, Drawable wID, GC gc, WB_GEOM *pgeomRect, unsigned long lColor);

/** \ingroup window_dressing
  * \brief Draw a down arrow in a window within a specified geometry
  *
  * \param pDisplay A pointer to the current display (or NULL to use the default Display)
  * \param wID the Drawable, typically the Window ID for the target window
  * \param gc The GC (graphics context) to use
  * \param pgeomRect A WB_GEOM that identifies the rectangle within which to draw the arrow
  * \param lColor A 'Pixel' color value to use when painting the arrow as a polygon
  *
  * Use this function to draw a down arrow in the specified window, using the specified geometry.
  *
  * Header File:  window_dressing.h
**/
void WBDrawDownArrow(Display *pDisplay, Drawable wID, GC gc, WB_GEOM *pgeomRect, unsigned long lColor);


/** \ingroup window_dressing
  * \brief Draw a 'tab' within a specified 'outline' rectangle
  *
  * \param pDisplay A pointer to the current display (or NULL to use the default Display)
  * \param wID the Drawable, typically the Window ID for the target window
  * \param gc The GC (graphics context) to use
  * \param pgeomOutline A WB_GEOM that identifies the rectangular border of the tab to draw
  * \param fFocus A flag value that indicates whether or not this tab has the 'focus', and whether or not the 'x' is being 'pressed'.\n\n A value of 0 indicates 'no focus'.  A positive value is 'focus'.\n\n A negative value generally indicates 'pressing the "x" button'.  Specifically, a -1 indicates 'focus', and any other negative value indicates 'no focus' while pressing the 'x'.  This is necessary to properly implement UI feedback for the tab.  Clicking 'x' does not imply getting the focus.\n
  * \param lFGColor The current 'foreground' 'Pixel' color for text and borders
  * \param lBGColor The current 'background' 'Pixel' color for areas outside of the tab
  * \param lBorderColor1 The upper, left 'Pixel' color to use when drawing the tab
  * \param lBorderColor2 The lower, right 'Pixel' color to use when drawing the tab
  * \param lHighlightColor The 'highlight' 'Pixel' color to use for a tab that has the focus
  * \param pFont The 'normal' font to render text in
  * \param pBoldFont The 'bold' font to render text in (this includes the 'x' close button on the tab)
  * \param aGraphic An atom for the current (registered) pixmap graphic, or 'None' for no graphic
  * \param szText A const pointer to a character string containing the descriptive text for the tab
  *
  * Use this function to draw a tab within the specified 'Outline' geometry, in the specified
  * Window, with the specified colors, graphic, and text.\n
  * Tabs are drawn differently when they have focus, so 'bFocus' determines whether or not the tab
  * currently has focus.  Non-focus tabs are greyish in appearance, whereas focus tabs have the
  * 'Highlight Color' applied to them.  A Highlight Color of 'WHITE' should be used whenever you
  * do not want special colorization based on focus.  Additional 'focus' tab characteristics include
  * painting the background color across the bottom line, so that any 3D rectangle that was previously
  * drawn will be overwritten underneath the tab.
  *
  * For proper appearance, the 'focus' tab should be drawn last, and tabs should be drawn from right to left.
  *
  * Header File:  window_dressing.h
**/
void WBDraw3DBorderTab(Display *pDisplay, Drawable wID, GC gc, WB_GEOM *pgeomOutline,
                       int fFocus, unsigned long lFGColor, unsigned long lBGColor,
                       unsigned long lBorderColor1, unsigned long lBorderColor2,
                       unsigned long lHighlightColor,
                       XFontStruct *pFont, XFontStruct *pBoldFont,
                       Atom aGraphic, const char *szText);



#ifdef __cplusplus
};
#endif // __cplusplus


#endif // _WINDOW_DRESSING_H_INCLUDED_



