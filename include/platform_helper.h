//////////////////////////////////////////////////////////////////////////////////////////////////////////
//          _         _     __                               _            _                     _       //
//   _ __  | |  __ _ | |_  / _|  ___   _ __  _ __ ___       | |__    ___ | | _ __    ___  _ __ | |__    //
//  | '_ \ | | / _` || __|| |_  / _ \ | '__|| '_ ` _ \      | '_ \  / _ \| || '_ \  / _ \| '__|| '_ \   //
//  | |_) || || (_| || |_ |  _|| (_) || |   | | | | | |     | | | ||  __/| || |_) ||  __/| | _ | | | |  //
//  | .__/ |_| \__,_| \__||_|   \___/ |_|   |_| |_| |_|_____|_| |_| \___||_|| .__/  \___||_|(_)|_| |_|  //
//  |_|                                               |_____|               |_|                         //
//                                                                                                      //
//                     platform-specific definitions to rectify various issues                          //
//                                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2013 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no waranties, either implied or explicit.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

/** \file platform_helper.h
  * \brief Definition file for platform-specific utility functions
  *
  * This file contains definitions, stubs, workarounds, and any kind of
  * platform-specific wrapper function or locally implemented library
  * definition that is needed to make this system work on a given platform.
*/



#ifndef _PLATFORM_HELPER_H_INCLUDED_
#define _PLATFORM_HELPER_H_INCLUDED_

#include <stdarg.h> /* stdarg to make sure I have va_list and other important stuff */

// X11 header files (TODO:  use 'ifdef' blocks around this as needed for non-X platforms)

#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xmd.h>  // for 'CARD32' and other things
#include <X11/Xatom.h> // for 'XA_CARDINAL' and other things


#if defined(__GNUC__) || defined(__DOXYGEN__)

// this section included for doxygen documentation using the X11 definitions

#include <pthread.h> /* make sure this is included for POSIX */

/** \ingroup platform
  * \brief INVALID HANDLE VALUE equivalent
  *
  * This definition generically refers to an INVALID HANDLE
  */
#define INVALID_HANDLE_VALUE ((int)-1)

// jump optimization macros - gcc only
#define WB_UNLIKELY(x) (__builtin_expect (!!(x), 0))
#define WB_LIKELY(x) (__builtin_expect (!!(x), 1))

//#ifdef _LONGLONG /* TODO test for _LONGLONG in configure script */

/** \ingroup platform
  * \brief Platform abstract 64-bit integer
  *
  * This definition identifies the data type for a 64-bit integer
  */
#define WB_INT64 long long

/** \ingroup platform
  * \brief Platform abstract unsigned 64-bit integer
  *
  * This definition identifies the data type for an unsigned 64-bit integer
  */
#define WB_UINT64 unsigned long long

//#else // !defined _LONGLONG, unlikely
//typedef struct __WB_INT64__ { unsigned long l1, l2; } WB_INT64;
//typedef struct __WB_UINT64__ { unsigned long l1, l2; } WB_UINT64;
//#endif // _LONGLONG

/** \ingroup platform
  * \brief Platform abstract 32-bit integer
  *
  * This definition identifies the data type for a 32-bit integer
  */
#define WB_INT32 int

/** \ingroup platform
  * \brief Platform abstract unsigned 32-bit integer
  *
  * This definition identifies the data type for an unsigned 32-bit integer
  */
#define WB_UINT32 unsigned int


#define WB_C99_INITIALIZERS /* allow C99-style initializers */

/** \ingroup platform
  * \brief MODULE HANDLE equivalent
  *
  * This 'typedef' refers to a MODULE
  */
typedef void * WB_MODULE;

/** \ingroup platform
  * \brief THREAD HANDLE equivalent
  *
  * This 'typedef' refers to a THREAD
  */
typedef pthread_t WB_THREAD;

/** \ingroup platform
  * \brief PROC ADDRESS equivalent
  *
  * This 'typedef' refers to a PROC ADDRESS as exported from a shared library
  */
typedef void (* WB_PROCADDRESS)(void);

/** \ingroup platform
  * \brief THREAD LOCAL STORAGE 'key' equivalent
  *
  * This 'typedef' refers to a THREAD LOCAL STORAGE key, identifying a storage slot
  */
typedef pthread_key_t   WB_THREAD_KEY;

/** \ingroup platform
  * \brief CONDITION HANDLE equivalent (similar to an 'event')
  *
  * This 'typedef' refers to a CONDITION, a triggerable synchronization resource
  */
typedef unsigned int WB_COND; // defined as 'unsigned int' because of pthread_cond problems under Linux
//typedef pthread_cond_t  WB_COND;

/** \ingroup platform
  * \brief MUTEX HANDLE equivalent
  *
  * This 'typedef' refers to a MUTEX, a lockable synchronization object
  */
typedef pthread_mutex_t WB_MUTEX;


// TODO:  sizeof(int) sizeof(long) - long is 64-bit for GNUC - MS compilers make it 32-bit

// dont' forget to globally include the output of the configure script for GNUC compiles
#include "X11WorkbenchToolkit_config.h"


#ifdef __DOXYGEN__

/** \ingroup platform
  * \brief PACKED definition
  *
  * This assignes the 'packed' attribute; i.e. byte-level alignment
  */
#define __PACKED__ /* platform dependent; actual def must be a blank or doxygen barphs on it */

#else // !__DOXYGEN__

#define __PACKED__ __attribute__((__packed__))

#endif // __DOXYGEN__

#elif defined(_MSC_VER) /* Microsoft C/C++ compiler */

// TODO:  add proper support for MS compiler
#if _MSC_VER > 1300

// TODO:  specify correct version in which C99 initializers are supported
//        as of MSC for ".Net" 2010 it's _NOT_ supported (still!)
//#define WB_C99_INITIALIZERS

#endif // _MSC_VER > xxxx

#define WB_UNLIKELY(x) (x)
#define WB_LIKELY(x) (x)

#ifndef __inline__
#define __inline__ inline /* this assumes 'inline' is supported (MSC should support this) */
#endif // __inline__

#define WB_INT64 __int64
#define WB_UINT64 unsigned __int64
#define WB_INT32 int
#define WB_UINT32 unsigned int

// assume MS Windows Win32 API
typedef HMODULE WB_MODULE ;     /* module handle */
typedef HANDLE WB_THREAD;       /* thread handle - thread IDs are still 'int' types */
typedef FARPROC WB_PROCADDRESS; // generic proc address returned from GetProcAddress()

typedef DWORD WBTHREAD_KEY;     // return from 'TlsAlloc()'
typedef HANDLE WB_COND;         // equivalent to an event handle
typedef HANDLE WB_MUTEX;        // equivalent to a mutex handle


// TODO:  sizeof(int) sizeof(long) - long is 32-bit for MSC

// TODO:  compatibility definition file for winders

#define __PACKED__ /* TODO: a definition for packing in MS-land */

#else // !defined(_MSVC_VER) && !defined(__GNUC__)

#error unknown and/or unsupported compiler

#define __PACKED__

#endif // __GNUC__



// XPM library (libXpm) and X11/xpm.h

#if defined(HAVE_XPM) && !defined(__DOXYGEN__)

// Doxygen doesn't need THIS part, it needs the other one.

#include <X11/xpm.h>

#define XPM_ATTRIBUTES XpmAttributes
#define XPM_CREATE_PIXMAP_FROM_DATA(A,B,C,D,E,F) XpmCreatePixmapFromData(A,B,C,D,E,F)

#else // HAVE_XPM

/** \ingroup platform
  * \brief Internal XPM helper structure
  *
  * This structure is used internally when libXpm is not available
  */
typedef struct _XPM_ATTRIBUTES_
{
  // I only need certain information from MyLoadPixmapFromData(), so that's all I'm doing with this structure

  int width;    ///< The width of the returned pixmaps
  int height;   ///< height of the returned pixmaps
  int depth;    ///< depth of the returned 'image' pixmap.  The mask pixmap always has a depth of '1'.

} XPM_ATTRIBUTES;

/** \ingroup platform
  * \brief Internal XPM helper function to load a pixmap
  *
  * This function is used whenever libXpm is not available, via the macro XPM_CREATE_PIXMAP_FROM_DATA
  */
int MyLoadPixmapFromData(Display *pDisplay, Window wID, char *aData[],
                         Pixmap *pPixmap, Pixmap *pMask, XPM_ATTRIBUTES *pAttr);

/** \ingroup platform
  * \def XPM_CREATE_PIXMAP_FROM_DATA
  * \brief Platform helper macro to create a pixmap from data
  *
  * \param A A pointer to the Display
  * \param B The Window ID
  * \param C A pointer to an array of 'char *' that represents the pixmap data
  * \param D A pointer to a Pixmap into which the data will be saved, or NULL
  * \param E A pointer to the Pixmap into which the mask data will be saved (icons only), or NULL
  * \param F A pointer to an XPM_ATTRIBUTES structure.  If libXpm is present, this will be defined in X11/xpm.h
  * \returns An integer indicating success or failure.  See XpmCreatePixmapFromData in libXpm documentation
  *
  * This macro abstracts calls to XpmCreatePixmapFromData() by allowing an internal function to be called
  * whenever libXpm is not available for this purpose.
  */
#define XPM_CREATE_PIXMAP_FROM_DATA(A,B,C,D,E,F) MyLoadPixmapFromData(A,B,C,D,E,F)


#endif

// documentation for XPM_CREATE_PIXMAP_FROM_DATA

/** \ingroup platform
  * \def XPM_CREATE_PIXMAP_FROM_DATA
  * \brief Wrapper for XpmCreatePixmapFromData
  *
  * This macro wraps the functionality of XpmCreatePixmapFromData so that when libXpm
  * is not present, an alternate function \ref MyLoadPixmapFromData() can be used
  * in its place.  Use of the libXpm function is preferred, and the configure script
  * is set up to detect it and use it whenever it is present.
  *
**/

/** \ingroup pixmap
  * \fn int MyLoadPixmapFromData(Display *pDisplay, Window wID, char *aData[], Pixmap *pPixmap, Pixmap *pMask, XPM_ATTRIBUTES *pAttr)
  * \brief Alternate for XpmCreatePixmapFromData() when libXpm is not present
  *
  * \param pDisplay A pointer to the display to use when creating the pixmaps
  * \param wID A window used as a 'drawable' reference when creating the pixmaps
  * \param aData An 'xpm' pixmap array, using the standard format generated by utilities like 'gimp'
  * \param pPixmap Pointer to the variable to receive the Pixmap.  If the function fails, this will be 'None'
  * \param pMask Pointer to the variable to receive the transparency mask Pixmap.  This may be 'None' if there is no transparency mask
  * \param pAttr Pointer to the 'XPM_ATTRIBUTES' structure, which is a subset of the XpmAttributes structure used by XpmCreatePixmapFromData()
  * \return A value of zero on success (same as XpmSuccess, returned by XpmCreatePixmapFromData() on success).
  *
  * This function is an alternate for XpmCreatePixmapFromData() when libXpm is not present.  It provides similar functionality,
  * although there are some significant differences, particularly with the use of XPM_ATTRIBUTES as an actual structure and
  * not just a '#define'.  When libXpm is compiled in, XPM_ATTRIBUTES becomes a macro that is defined as XpmAttributes, the structure
  * used by XpmCreatePixmapFromData().  There are a large number of members in this structure that are not useful for the purpose of
  * this function, and so a scaled-down version is used when MyLoadPixmapFromData is being invoked.\n
  * You should use libXpm when it is present on your system, as this function has not been fully tested on all platforms.
**/

/** \ingroup pixmap
  * \struct _XPM_ATTRIBUTES_
  * \brief Compatibility structure for use with MyLoadPixmapFromData() whenever libXpm is not in use.
  *
  * For more information, see \ref XPM_ATTRIBUTES and \ref MyLoadPixmapFromData()
**/

/** \ingroup pixmap
  * \typedef typedef struct _XPM_ATTRIBUTES_ XPM_ATTRIBUTES
  * \brief Compatibility structure for use with MyLoadPixmapFromData() whenever libXpm is not in use.
  *
  * When libXpm is in use, XPM_ATTRIBUTES becomes a #define for XpmAttributes, the structure used by XpmCreatePixmapFromData().
  * Because so many elements are not needed, MyLoadPixmapFromData() uses this scaled-down version when libXpm is not available.
  *
  * When libXpm is NOT in use, the follow structure is defined:\n
  *
\code

  typedef struct _XPM_ATTRIBUTES_
  {
    // I only need certain information from MyLoadPixmapFromData(), so that's all I'm doing with this structure

    int width,    // width of the returned pixmaps
        height,   // height of the returned pixmaps
        depth;    // depth of the returned 'image' pixmap.  The mask pixmap always has a depth of '1'.

  } XPM_ATTRIBUTES;

\endcode
  *
  * When libXpm IS in use, the follownig macro is defined:\n
  *
\code

  #define XPM_ATTRIBUTES XpmAttributes

\endcode
  *
**/


// some helpful macros that need to be universal without being in a different header

/** \ingroup text
  * \brief Obtain the 'next word' within a string pointed to by pX, bounded by pY and pZ
  *
  * \param pX A pointer to a 0-byte terminated string; returned as the 'current' pointer within that string for further parsing
  * \param pY A pointer to the word that was found within the string
  * \param pZ A pointer to the character just following the found word.  If pY == pZ, no word was found (and *pX should be 0)
  *
  * use this function in a loop to parse out the "next word" within the string until *pX == 0 or pY == pZ
**/
#define NEXT_WORD(pX, pY, pZ) {while(*(pX) && *(pX) <= ' '){(pX)++;} (pY)=(pZ)=(pX); while(*(pX)>' '){(pX)++;} (pZ)=(pX);}





#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// common macros

#ifndef FALSE
#define FALSE 0
#endif // FALSE
#ifndef TRUE
#define TRUE !0
#endif // TRUE



// HANDLING qsort_r CALLING CONVENTION DIFFERENCES
//
#if defined(QSORT_R_BSD) && !defined(__DOXYGEN__)

// DECLARE_SORT_FUNCTION based on - int (*compar)(void *, const void *, const void *)
//    generates    int fn_name(void *p0, const void *p1, const void *p2)
#define DECLARE_SORT_FUNCTION(fn_name,p0,p1,p2) int fn_name(void *p0, const void *p1, const void *p2)
// void qsort_r(void *base, size_t nmemb, size_t size, void *thunk, int (*compar)(void *, const void *, const void *))
#define QSORT_R(A,B,C,D,E) qsort_r((A),(B),(C),(D),(E))

#elif defined(QSORT_R_GNUC) && !defined(__DOXYGEN__)

// DECLARE_SORT_FUNCTION based on typedef int (*__compar_d_fn_t) (__const void *, __const void *, void *)
//    generates    int fn_name(const void *p1, const void *p2, void *p0)
#define DECLARE_SORT_FUNCTION(fn_name,p0,p1,p2) int fn_name(const void *p1, const void *p2, void *p0)
// extern void qsort_r (void *__base, size_t __nmemb, size_t __size, __compar_d_fn_t __compar, void *__arg)
#define QSORT_R(A,B,C,D,E) qsort_r((A),(B),(C),(E),(D))

#else

// here is where I implement 'vectored' quicksort for OTHER PLATFORMS

/** \ingroup platform
  * \brief Local implementation of qsort_r() for operating systems that do not have it
  *
  * \param base Pointer to 'base' of items to sort
  * \param nmemb Number of members to sort
  * \param size Size of a single member (including any padding)
  * \param thunk The value to pass along as the first parameter to 'compar'
  * \param compar The comparison function, declared using DECLARE_SORT_FUNCTION
  *
  * This function implements the QSORT_R macro when there is no libc function for qsort_r()
**/
void my_qsort_r(void *base, int nmemb, int size, void *thunk,
                int (*compar)(void *, const void *, const void *));

// the rest is exactly like the BSD version

/** \ingroup platform
  * \brief Wrapper to declare a sort function for \ref QSORT_R
  *
  * \param fn_name  The function name
  * \param p0 The 'thunk' parameter passed in by QSORT_R
  * \param p1 The first compare parameter
  * \param p2 The second compare parameter
  *
  * Use this wrapper macro to properly declare a compare function for \ref QSORT_R,
  * similar to the following example:
  *
\code
  DECLARE_SORT_FUNCTION(MySort,pThunk,pParam1,pParam2)
  {
    const char **pStringArray = (const char **)pThunk; // the real data
    const int *pP1 = (const int *)pParam1;
    const int *pP2 = (const int *)pParam2;

    // I am sorting integer indices into an array of character strings so
    // that I can sort the integers and not the actual strings.  But I needed
    // a pointer to my string array, so I pass that in as 'pThunk'.

    return strcmp(pStringArray[*pP1],pStringArray[*pP2]);
  }
\endcode
  *
**/
#define DECLARE_SORT_FUNCTION(fn_name,p0,p1,p2) int fn_name(void *p0, const void *p1, const void *p2)


/** \ingroup platform
  * \brief Local implementation of qsort_r() for operating systems that do not have it
  *
  * \param base Pointer to 'base' of items to sort
  * \param nmemb Number of members to sort
  * \param size Size of a single member (including any padding)
  * \param thunk The value to pass along as the first parameter to 'compar'
  * \param compar The comparison function, declared using DECLARE_SORT_FUNCTION
  *
  * Use this UNIVERSALLY whenever you need to use qsort_r(), as it is platform independent and
  * deals with the incompatibilities associated with the BSD version and the Linux version.
**/
#define QSORT_R(base,nmemb,size,thunk,compar) my_qsort_r((base),(nmemb),(size),(thunk),(compar))

#endif


// *******************************************
// FILE/APPLICATION SEARCH PATH AND TEMP FILES
// *******************************************


/** \ingroup startup
  * \brief Resource initialization on startup
  *
  * Call this function right before using any 'platform_helper' functions to initialize any global resources
  * from 'platform_helper.h'.  WBInit() does this automatically.  It should only be called once.\n
**/
void WBPlatformOnInit(void);

/** \ingroup startup
  * \brief Resource 'free-up' on exit (must call)
  *
  * Call this function right before exiting the application if you have made use of any system-specific resources
  * from 'platform_helper.h'.  WBExit() does this automatically.  Among other things, it will delete any temporary
  * files that were created via WBTempFile().\n
  * It should also be safe to call this function from within a 'signal' handler.
**/
void WBPlatformOnExit(void);

/** \ingroup platform
  * \brief Run an application asynchronously
  *
  * \param szFileName A const pointer to a character string containing a file or path name
  * \returns A 'malloc'd pointer to a character string containing the ACTUAL path to the file
  *
  * This function locates a file using the PATH environment variable and the value of 'szFileName'
  * by testing the file (or directory name) using 'stat'.  When the file (or directory) is located,
  * this function returns the path name as a 'malloc'd string.  If the file (or directory) cannot
  * be located, the function returns NULL.\n
  * The caller must 'free()' any non-NULL pointer returned by this function.
**/
char * WBSearchPath(const char *szFileName);

/** \ingroup platform
  * \brief Get the name for a new, unique temporary file, creating the file in the process, and save its name for later deletion
  *
  * \param szExt A const pointer to a string containing the file's extension (without the '.'), or NULL if no extension is desired.
  * \returns A 'malloc'd pointer to a character string containing fully qualified path to the file
  *
  * This function obtains a unique temporary file name and then creates the file with a zero length,
  * returning the name of the file in a malloc'd character string.  On error, it returns NULL.\n
  * The actual location of the temporary file depends upon platform-specific parameters, such as
  * environment variables and system settings.\n
  * The caller must 'free()' any non-NULL pointer returned by this function.\n
  * This function preserves the name of the file in a list of temporary files that need to be deleted once the
  * application has terminated.  This way an external application can keep the file open indefinitely, or even
  * re-read the file, without negative effects.  The 'WBPlatformOnExit()' function will delete all temporary files
  * that have been previously created by 'WBTempFile'.
**/
char * WBTempFile(const char *szExt);


/** \ingroup platform
  * \brief Get the name for a new, unique temporary file, creating the file in the process
  *
  * \param szExt A const pointer to a string containing the file's extension (without the '.'), or NULL if no extension is desired.
  * \returns A 'malloc'd pointer to a character string containing fully qualified path to the file
  *
  * This function obtains a unique temporary file name and then creates the file with a zero length,
  * returning the name of the file in a malloc'd character string.  On error, it returns NULL.\n
  * The actual location of the temporary file depends upon platform-specific parameters, such as
  * environment variables and system settings.\n
  * The caller must 'free()' any non-NULL pointer returned by this function.
**/
char * WBTempFile0(const char *szExt);



//////////////////////////////////////////////////////////////////////////////////////////////
//   ____  ____   ___   ____ _____ ____ ____     ____ ___  _   _ _____ ____   ___  _        //
//  |  _ \|  _ \ / _ \ / ___| ____/ ___/ ___|   / ___/ _ \| \ | |_   _|  _ \ / _ \| |       //
//  | |_) | |_) | | | | |   |  _| \___ \___ \  | |  | | | |  \| | | | | |_) | | | | |       //
//  |  __/|  _ <| |_| | |___| |___ ___) |__) | | |__| |_| | |\  | | | |  _ <| |_| | |___    //
//  |_|   |_| \_\\___/ \____|_____|____/____/   \____\___/|_| \_| |_| |_| \_\\___/|_____|   //
//                                                                                          //
//////////////////////////////////////////////////////////////////////////////////////////////

// *********************
// SPAWNING APPLICATIONS
// *********************

#ifdef WIN32
#define WB_FILE_HANDLE HANDLE
#define WB_PROCESS_ID HANDLE
#define WB_INVALID_FILE_HANDLE INVALID_HANDLE_VALUE
#else // !WIN32
#define WB_FILE_HANDLE int
#define WB_PROCESS_ID unsigned int
#define WB_INVALID_FILE_HANDLE -1
#endif // WIN32
/** \ingroup process
  * \brief Run an application asynchronously
  *
  * \param szAppName A const pointer to a character string containing the path to the application
  * \returns A valid process ID or process handle, depending upon the operating system
  *
  * Use this function to spawn an asynchronous process.  The function returns an invalid process ID
  * or process handle on error.  If the process ID is an allocated resource, the caller must free it.
  * Each additional parameter passed to this function is a parameter that is to be passed to the program.
  * The final parameter in the list must be NULL, so any call to this function will need to have at
  * least 2 parameters.
**/
WB_PROCESS_ID WBRunAsync(const char *szAppName, ...);

/** \ingroup process
  * \brief Run an application synchronously, returning 'stdout' output in a character buffer.
  *
  * \param szAppName A const pointer to a character string containing the path to the application
  * \returns A malloc'd pointer to a buffer containing the 'stdout' output from the application.
  *
  * Use this function to run an external process and capture its output.  This function will ignore the
  * error return code from the program, so if this information is necessary, you should write a different
  * function (based on this one) using 'WBRunAsync' and a wait loop, etc. that checks the application's
  * return value on exit.
  * Each additional parameter passed to this function is a parameter that is to be passed to the program.
  * The final parameter in the list must be NULL, so any call to this function will need to have at
  * least 2 parameters.
  * On error this function returns a NULL value.  Any non-NULL value must be 'free'd by the caller.
**/
char * WBRunResult(const char *szAppName, ...);

/** \ingroup process
  * \brief Run an application synchronously, returning 'stdout' output in a character buffer.
  *
  * \param szInBuf A const pointer to 0-byte terminated string/buffer containing the input for piped data.
  * \param szAppName A const pointer to a character string containing the path to the application
  * \returns A malloc'd pointer to a buffer containing the 'stdout' output from the application.
  *
  * Use this function to run an external process, providing a buffer that contains data to be sent to the
  * applications 'stdin', and in the process, capture its output.  This function will ignore the
  * error return code from the program, so if this information is necessary, you should write a different
  * function (based on this one) using 'WBRunAsync' and a wait loop, etc. that checks the application's
  * return value on exit.
  * Each additional parameter passed to this function is a parameter that is to be passed to the program.
  * The final parameter in the list must be NULL, so any call to this function will need to have at
  * least 2 parameters.
  * On error this function returns a NULL value.  Any non-NULL value must be 'free'd by the caller.\n
  *
  * To create piped output, pass the result of the previous 'WBRunResult' or 'WBRunResultPipe' as the
  * 'szStdInBuf' parameter to a subsequent 'WBRunResultPipe' call.
**/
char * WBRunResultPipe(const char *szStdInBuf, const char *szAppName, ...);


/** \ingroup process
  * \brief Run an application asynchronously, specifying file handles for STDIN, STDOUT, and STDERR
  *
  * \param hStdIn A WB_FILE_HANDLE for STDIN, or WB_INVALID_FILE_HANDLE
  * \param hStdOut A WB_FILE_HANDLE for STDOUT, or WB_INVALID_FILE_HANDLE
  * \param hStdErr A WB_FILE_HANDLE for STDERR, or WB_INVALID_FILE_HANDLE.  This can be the same handle as hStdErr, though interleaved output may not occur as expected.
  * \param szAppName A const pointer to a character string containing the path to the application
  * \returns A valid process ID or process handle, depending upon the operating system
  *
  * Use this function to spawn an asynchronous process in which you want to track STDIN, STDOUT,
  * and/or STDERR.  The function returns an invalid process ID or process handle
  * on error.  If the process ID is an allocated resource, the caller must free it.
  * Each additional parameter passed to this function will become a parameter that is to be passed to the program.
  * The final parameter in the list must be NULL to mark the end of the list, so any call to this function will
  * need to have at least 5 parameters.\n
  * If you do not want to re-direct a file handle, pass 'WB_INVALID_FILE_HANDLE' for its value.  It is
  * also possible to pass the SAME file handle for hStdIn, hStdOut, and hStdErr provided that it has
  * the correct read/write access available.  File handled passed to this function will be duplicated,
  * but not closed.  It is also safe to close the original file handles immediately after calling this
  * function.\n
  * You can monitor 'WB_PROCESS_ID' to find out if the process is running.  Additionally, you can use
  * the output of hStdOut and hStdErr by re-directing them to anonymous pipes and monitoring their activity.
**/
WB_PROCESS_ID WBRunAsyncPipe(WB_FILE_HANDLE hStdIn, WB_FILE_HANDLE hStdOut, WB_FILE_HANDLE hStdErr,
                             const char *szAppName, ...);


/** \ingroup process
  * \brief Run an application asynchronously, specifying file handles for STDIN, STDOUT, and STDERR, using a va_list for the program's parameters
  *
  * \param hStdIn A WB_FILE_HANDLE for STDIN, or WB_INVALID_FILE_HANDLE
  * \param hStdOut A WB_FILE_HANDLE for STDOUT, or WB_INVALID_FILE_HANDLE
  * \param hStdErr A WB_FILE_HANDLE for STDERR, or WB_INVALID_FILE_HANDLE.  This can be the same handle as hStdErr, though interleaved output may not occur as expected.
  * \param szAppName A const pointer to a character string containing the path to the application
  * \param va A va_list of the arguments (the final one must be NULL)
  * \returns A valid process ID or process handle, depending upon the operating system
  *
  * This function is identical to WBRunAsyncPipe() except that the variable argument list is passed as a va_list.\n
  * Use this function to spawn an asynchronous process in which you want to track STDIN, STDOUT,
  * and/or STDERR.  The function returns an invalid process ID or process handle
  * on error.  If the process ID is an allocated resource, the caller must free it.
  * Parameters passed to this function as part of the va_list are parameters that are to be passed to the program.
  * The final parameter in the va_list must be NULL to mark the end of the list.\n
  * If you do not want to re-direct a file handle, pass 'WB_INVALID_FILE_HANDLE' for its value.  It is
  * also possible to pass the SAME file handle for hStdIn, hStdOut, and hStdErr provided that it has
  * the correct read/write access available.  File handles passed to this function will be duplicated,
  * but not closed.  It is also safe to close the original file handles immediately after calling this
  * function.\n
  * You can monitor 'WB_PROCESS_ID' to find out if the process is running.  Additionally, you can use
  * the output of hStdOut and hStdErr by re-directing them to anonymous pipes and monitoring their activity.
  *
  * This function is used internally by the other process control functions, and is defined here in case
  * you need to write a customized version of one of the process control functions.  A typical example might
  * be the use of stderr rather than stdout for WBRunResult().
**/
WB_PROCESS_ID WBRunAsyncPipeV(WB_FILE_HANDLE hStdIn, WB_FILE_HANDLE hStdOut, WB_FILE_HANDLE hStdErr,
                              const char *szAppName, va_list va);




///////////////////////////////////////////////////////////////////////
//   ____  _   _    _    ____  _____ ____    _     ___ ____ ____     //
//  / ___|| | | |  / \  |  _ \| ____|  _ \  | |   |_ _| __ ) ___|    //
//  \___ \| |_| | / _ \ | |_) |  _| | | | | | |    | ||  _ \___ \    //
//   ___) |  _  |/ ___ \|  _ <| |___| |_| | | |___ | || |_) |__) |   //
//  |____/|_| |_/_/   \_\_| \_\_____|____/  |_____|___|____/____/    //
//                                                                   //
///////////////////////////////////////////////////////////////////////

/** \ingroup process
  * \brief Loads a shared library, DLL, module, or whatever you call it on your operating system
  *
  * \param szModuleName A const pointer to a character string containing the path for the library, module, DLL, or whatever
  * \returns A valid WB_MODULE module handle, depending upon the operating system
  *
  * This function is identical to LoadLibrary() under Windows, and calls 'dlopen()' on POSIX systems
**/
WB_MODULE WBLoadLibrary(const char *szModuleName); // load a library module (shared lib, DLL, whatever)

/** \ingroup process
  * \brief Frees a shared library, DLL, module, or whatever, that was loaded via 'WBLoadLibrary()'
  *
  * \param hModule A valid WB_MODULE module handle, as returned by WBLoadLibrary()
  *
  * This function is identical to FreeLibrary() under Windows, and calls 'dlfree()' on POSIX systems
**/
void WBFreeLibrary(WB_MODULE hModule);                 

/** \ingroup process
  * \brief Loads a shared library, DLL, module, or whatever you call it on your operating system
  *
  * \param hModule A valid WB_MODULE module handle, as returned by WBLoadLibrary()
  * \param szProcName A const pointer to a character string containing the proc name
  * \returns A valid WB_MODULE module handle, depending upon the operating system
  *
  * This function is identical to GetProcAddress() under Windows, and calls 'dlproc()' on POSIX systems
**/
WB_PROCADDRESS WBGetProcAddress(WB_MODULE hModule, const char *szProcName);



//////////////////////////////////////////////////////
//   _____ _   _ ____  _____    _    ____  ____     //
//  |_   _| | | |  _ \| ____|  / \  |  _ \/ ___|    //
//    | | | |_| | |_) |  _|   / _ \ | | | \___ \    //
//    | | |  _  |  _ <| |___ / ___ \| |_| |___) |   //
//    |_| |_| |_|_| \_\_____/_/   \_\____/|____/    //
//                                                  //
//////////////////////////////////////////////////////

/** \ingroup threads
  * \brief Allocate 'thread local' storage
  *
  * \returns The 'key' that identifies the thread local storage data slot
  *
  * Allocate thread local storage, returning the identifier to that local storage slot
**/
WB_THREAD_KEY WBThreadAllocLocal(void);

/** \ingroup threads
  * \brief Free 'thread local' storage allocated by WBThreadAllocLocal()
  *
  * \returns The 'key' that identifies the thread local storage data slot
  *
  * Free an allocate thread local storage slot
**/
void WBThreadFreeLocal(WB_THREAD_KEY keyVal);

/** \ingroup threads
  * \brief Get 'thread local' data identified by 'keyVal'
  *
  * \param keyVal the 'WB_THREAD_KEY' identifier of the thread local data - see WBThreadAllocLocal()
  * \returns The stored thread-specific data value, or NULL if not assigned
  *
  * Get the data associated with a thread local storage slot
**/
void * WBThreadGetLocal(WB_THREAD_KEY keyVal);

/** \ingroup threads
  * \brief Get 'thread local' data identified by 'keyVal'
  *
  * \param keyVal the 'WB_THREAD_KEY' identifier of the thread local data - see WBThreadAllocLocal()
  * \param pVal the value to assign for thread local data
  *
  * Assign (set) the data associated with a thread local storage slot
**/
void WBThreadSetLocal(WB_THREAD_KEY keyVal, void *pValue);


// simplified thread support (cross-platform)

/** \ingroup threads
  * \brief Get 'current thread' identifier
  *
  * \returns The WB_THREAD associated with the current thread
  *
  * Returns a 'WB_THREAD' resource representing the current thread.  This returned value should
  * NOT be free'd using WBThreadClose(), nor waited on with WBThreadWait().
**/
WB_THREAD WBThreadGetCurrent(void);

/** \ingroup threads
  * \brief Create a new thread, returning its WB_THREAD identifier
  *
  * \param function A pointer to the callback function that runs the thread
  * \param pParam The parameter to be passed to 'function' when it start
  * \returns A WB_THREAD thread identifier, or INVALID_HANDLE_VALUE on error
  *
  * Call this function to create a new thread using standard attributes.
**/
WB_THREAD WBThreadCreate(void *(*function)(void *), void *pParam);

/** \ingroup threads
  * \brief Wait for a specified threat to exit
  *
  * \param hThread the WB_THREAD identifier
  * \returns The return value from the thread's thread proc or 'WBThreadExit()'
  *
  * Call this function to wait for a thread to complete and/or obtain its exit code.
  * This function will block until the thread has terminated or is canceled (pthreads only).
**/
void *WBThreadWait(WB_THREAD hThread);        // closes hThread, returns exit code, waits for thread to terminate (blocks)

/** \ingroup threads
  * \brief Determine whether a thread is running (can be suspended)
  *
  * \param hThread the WB_THREAD identifier
  * \returns A value > 0 if the thread is running, < 0 on error, == 0 if the thread has ended and has a return code.
  *
  * Use this function to determine whether a thread is still running.  For a thread that has exited, it will return 0
  * indicating that there is an exit code available.  If the thread has terminated (invalidating its WB_THREAD identifier)
  * the function will return a value < 0.  otherwise, The return value is > 0 indicating the thread is still active.\n
  * NOTE:  an active thread that has been suspended will return a value > 0.
**/
int WBThreadRunning(WB_THREAD hThread);

/** \ingroup threads
  * \brief Exit the current thread immediately, specifying return code
  *
  * \param pRval The return code for the exiting thread
  *
  * Call this function to exit the current thread immediately, specifying a return code\n
  * NOTE:  when the thread proc returns, it implies a call to WBThreadExit() on completion, using the return
  *        value as the exit code.
**/
void WBThreadExit(void *pRval);

/** \ingroup threads
  * \brief Close the specified WB_THREAD identifier
  *
  * \param hThread the WB_THREAD identifier
  *
  * Call this function to close the WB_THREAD thread identifier specified by 'hThread'.  Not closing the
  * thread identifier can result in a 'zombie' thread that consumes resources.  By closing the handle, you
  * can allow a thread to run to its completion, and automatically delete the associated resources on exit.
  * You should not call this function after a call to WBThreadWait()\n
  * NOTE:  internally it calls either pthread_detach or CloseHandle (depending)
**/
void WBThreadClose(WB_THREAD hThread);


/** \ingroup threads
  * \brief Create a signallable condition
  *
  * \param pCond A pointer to the WB_COND that will be created (could be a struct or just a pointer)
  * \returns A zero value if successful; non-zero on error
  *
  * Use this function to create a 'condition' that can be signaled using WBCondSignal()\n
  * This is roughly the equivalent of an 'Event' object on MS Windows
**/
int WBCondCreate(WB_COND *pCond);

/** \ingroup threads
  * \brief Create a lockable mutex
  *
  * \param pMtx A pointer to the WB_MUTEX that will be created (could be a struct or just a pointer)
  * \returns A zero value if successful; non-zero on error
  *
  * Use this function to create a 'mutex' synchronization object that can be locked by only a single thread at a time
**/
int WBMutexCreate(WB_MUTEX *pMtx);

/** \ingroup threads
  * \brief Free a signallable condition
  *
  * \param pCond a pointer to the WB_COND signallable condition
  *
  * Use this function to free a WB_COND that was previously allocated with WBCondCreate()
**/
void WBCondFree(WB_COND *pCond);

/** \ingroup threads
  * \brief Free a lockable mutex
  *
  * \param pMtx a pointer to the WB_MUTEX lockable mutex object
  *
  * Use this function to free a WB_MUTEX that was previously allocated with WBMutexCreate()
**/
void WBMutexFree(WB_MUTEX *pMtx);

/** \ingroup threads
  * \brief Wait for and lock a mutex, blocking until it is available
  *
  * \param pMtx a pointer to the WB_MUTEX lockable mutex object
  * \param nTimeout the timeout period in microseconds, or a negative value to indicate 'INFINITE'
  * \returns A zero if the lock succeeded, a value > 0 if the lock period timed out, or a negative value indicating error
  *
  * This function attempts to lock the WB_MUTEX and returns a zero value if it succeeds, blocking for the period
  * of time specified by 'nTimeout' (in microseconds).  A negative 'nTimeout' causes an infinite waiting period.
  * The function will return a positive value if the timeout period was exceeded, or a negative value on error.
**/
int WBMutexLock(WB_MUTEX *pMtx, int nTimeout);

/** \ingroup threads
  * \brief Unlock a previously locked mutex
  *
  * \param pMtx a pointer to the WB_MUTEX lockable mutex object
  * \returns A zero if the unlock succeeded, non-zero on error
  *
  * This function unlocks a previously locked mutex
**/
int WBMutexUnlock(WB_MUTEX *pMtx);

/** \ingroup threads
  * \brief Signal a condition (event)
  *
  * \param pCond a pointer to the WB_COND condition object
  * \returns A zero if the signal succeeded, or non-zero on error
  *
  * This function signals a condition so that a waiting process will 'wake up'
  * see WBCondWait() and WBCondWaitMutex()
**/
int WBCondSignal(WB_COND *pCond);

/** \ingroup threads
  * \brief Wait for a signal on a condition (event)
  *
  * \param pCond a poiner to the WB_COND condition object
  * \param nTimeout the timeout (in microseconds), or a value < 0 to indicate 'INFINITE'
  * \returns A zero if the condition was triggered, a value > 0 on timeout, or a value < 0 on error
  *
  * This function waits up to a specified time (in microseconds), or indefinitely if the specified
  * wait time is negative, until the condition object 'hCond' has been signaled.  See WBCondSignal()
**/
int WBCondWait(WB_COND *pCond, int nTimeout);

/** \ingroup threads
  * \brief Wait for a signal on a condition (event)
  *
  * \param pCond a pointer to the WB_COND condition object
  * \param pMtx a pointer to a locked WB_MUTEX object
  * \param nTimeout the timeout (in microseconds), or a value < 0 to indicate 'INFINITE'
  * \returns A zero if the condition was triggered, a value > 0 on timeout, or a value < 0 on error
  *
  * This function waits up to a specified time (in microseconds), or indefinitely if the specified
  * wait time is negative, until the condition object 'hCond' has been signaled.  See WBCondSignal()\n
  * Additionally, when the waiting process begins, the WB_MUTEX referenced by 'hMtx' will be unlocked,
  * until the condition referenced by 'hCond' has been signaled, or the timeout period has been exceeded.
  * At that point, the mutex 'hMtx' will be re-locked (waiting indefinitely for the lock to be successful)\n
  * Upon return, 'hMtx' will be locked again by the calling thread.  'hMtx' must be already locked before
  * calling this function.  It will remain unlocked during the wait state.
**/
int WBCondWaitMutex(WB_COND *pCond, WB_MUTEX *pMtx, int nTimeout);


/** \ingroup threads
  * \brief Interlocked 'atomic' decrement of an unsigned integer
  *
  * \param pValue - a pointer to an 'unsigned int' to be decremented atomically.  Must be a valid pointer
  * \returns The new value stored in 'pValue' after decrementing
  *
  * This function performs an interlocked 'atomic' decrement of an unsigned integer,
  * guaranteeing that at the time the value is decremented, no other thread is allowed
  * to read or modify the value until the function returns.
**/
unsigned int WBInterlockedDecrement(unsigned int *pValue);


/** \ingroup threads
  * \brief Interlocked 'atomic' increment of an unsigned integer
  *
  * \param pValue - a pointer to an 'unsigned int' to be incremented atomically.  Must be a valid pointer
  * \returns The new value stored in 'pValue' after incrementing
  *
  * This function performs an interlocked 'atomic' increment of an unsigned integer,
  * guaranteeing that at the time the value is incremented, no other thread is allowed
  * to read or modify the value until the function returns.
**/
unsigned int WBInterlockedIncrement(unsigned int *pValue);


/** \ingroup threads
  * \brief Interlocked 'atomic' exchange of an unsigned integer with a specified value
  *
  * \param pValue - a pointer to an 'unsigned int' to be exchanged with the specified value.  Must be a valid pointer.
  * \param nNewVal - the new value to assign to 'pValue' atomically
  * \returns The old value previously stored in 'pValue' after exchanging
  *
  * This function performs an interlocked 'atomic' assignment of an unsigned integer,
  * guaranteeing that at the time the value is assigned, no other thread is allowed
  * to read or modify the value until the function returns.  The previous value is returned
  * by the function, effectively 'exchanging' the value with one that you specify.
**/
unsigned int WBInterlockedExchange(unsigned int *pValue, unsigned int nNewVal);


/** \ingroup threads
  * \brief Interlocked 'atomic' read of an unsigned integer
  *
  * \param pValue - a pointer to an 'unsigned int' to be read.  Must be a valid pointer.
  * \returns The value stored in 'pValue' after reading.  The value will be read while write operations have been 'locked out'
  *
  * This function performs an interlocked 'atomic' read of an unsigned integer,
  * guaranteeing that at the time the value is read, no other thread is allowed
  * to modify the value.  Once read, the value can still change; however, the value
  * as-read will be 'atomic' i.e. not a partially changed value.
**/
unsigned int WBInterlockedRead(unsigned int *pValue);



//////////////////////////////////////////////////////
//   ____  ____  ___ _   _ _____ ___ _   _  ____    //
//  |  _ \|  _ \|_ _| \ | |_   _|_ _| \ | |/ ___|   //
//  | |_) | |_) || ||  \| | | |  | ||  \| | |  _    //
//  |  __/|  _ < | || |\  | | |  | || |\  | |_| |   //
//  |_|   |_| \_\___|_| \_| |_| |___|_| \_|\____|   //
//                                                  //
//////////////////////////////////////////////////////

// NOTE:  the POSIX world uses postscript, particularly with CUPS.  So does this library.

/** \ingroup printer
  * \brief Send postscript file to a printer (using lpr-cups or lpr on POSIX systems)
  *
  * \param szPrinterName the unique (system) name of the printer
  * \param szFileName the name of the file containing the postscript data
  * \returns Zero on success, non-zero on error.
  *
  * Use this function to send pre-prepared postscript data to a printer.  On POSIX
  * systems, it invokes 'lpr-cups' or 'lpr'.  On non-POSIX systems, its operation is
  * system-dependent.  The version of 'lpr' that is run will be the CUPS version,
  * whenever it is installed.  On some systems this may require installing the 'bsd'
  * compatible CUPS utilities\n
  * NOTE: This function may need to translate the postscript data into the
  * raw printer format on non-POSIX systems, as needed.  The 'ghostscript' package
  * can do this, if present.  Other options may be added as required.  Entries in
  * the 'printcap' file can configure the ghostscript filter for raster printers.\n
  * NOTE 2:  some Linux packages require installing the cups version of lpr separately
  * and possibly EXCLUSIVELY from the system version, example debian 'cups-bsd' vs 'lpr'.\n
  * NOTE 3:  newer Linux versions don't support printcap mods based on CUPS.  Using the
  * IPP protocol to discover printers is probably a better idea.\n
  * NOTE 4:  may need to dynamically link to CUPS libraries, as needed, or invoke
  * ghostscript and/or lpd directly.  Additional support for PDF, etc. may be in order.\n
  * NOTE 5:  'ipptool' may be the best CUPS method of sending files to a printer\n
  * example:  ipptool -4 -t http://localhost:631/printers/printername get-printer-attributes.test
**/
int WBPrintPostScriptFile(const char *szPrinterName, const char *szFileName);

/** \ingroup printer
  * \brief Get a list of printer names
  *
  * \returns a 'malloc'd pointer to a list of zero-byte terminated strings containing the printer names, ending with 2 zero-bytes
  *
  * Use this function to get a list of printer names that can be used with WBPrintPostScriptFile().
  * On POSIX systems, it will be information from '/usr/local/etc/printcap' or '/etc/printcap'.
  * When CUPS is installed, the '/usr/local/etc/printcap' or '/etc/printcap' file is maintained by CUPS.
  * On non-POSIX systems, this function generates a system-dependent list of printers, which might
  * consist of port names, or actual printer names, or a combination thereof.\n
  * NOTE:  for IPP see RFC2911 section 4.4 and other related RFCs to request printer info.  'ipptest' may help
  * resolve how to make these things work.\n
  * NOTE 2:  for CUPS, use 'lpstat -s' and filter the output to get the printer names.  URL should be
  *          http://localhost:631/printers/printername\n
  * NOTE 3:  fallback to /etc/printcap /usr/local/etc/printcap and other sources
**/
char *WBGetPrinterList(void);

// TODO:  complete IPP support for cups and network-capable printers

// TODO:  printer capabilities in a binary structure

// TODO:  support for port 515 'printer' TCP/UDP printer services (i.e. cups-lpd or lpd)

// TODO:  dynamically load CUPS API when available. see 'cups-config' application docs



#ifdef __cplusplus
};
#endif // __cplusplus


#endif // _PLATFORM_HELPER_H_INCLDUED_

