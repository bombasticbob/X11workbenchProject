//////////////////////////////////////////////////////////////////////////////////////////////////////////
//          _         _     __                               _            _                     _       //
//   _ __  | |  __ _ | |_  / _|  ___   _ __  _ __ ___       | |__    ___ | | _ __    ___  _ __ | |__    //
//  | '_ \ | | / _` || __|| |_  / _ \ | '__|| '_ ` _ \      | '_ \  / _ \| || '_ \  / _ \| '__|| '_ \   //
//  | |_) || || (_| || |_ |  _|| (_) || |   | | | | | |     | | | ||  __/| || |_) ||  __/| | _ | | | |  //
//  | .__/ |_| \__,_| \__||_|   \___/ |_|   |_| |_| |_|_____|_| |_| \___||_|| .__/  \___||_|(_)|_| |_|  //
//  |_|                                               |_____|               |_|                         //
//                                                                                                      //
//          Copyright (c) 2010-2017 by 'Big Bad Bombastic Bob' Frazier - all rights reserved.           //
//         You may use this file in any way you see fit provided that any copy or derived work          //
//         includes the above copyright notice.                                                         //
//                                                                                                      //
//          This header contains platform-specific definitions that rectify various issues.             //
//          It also contains a lot of the 'core' functionality for strings, startup, etc.               //
//                                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2018 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.
               Any claims to alleged functionality or features should be
               considered 'preliminary', and might not function as advertised.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

/** \file platform_helper.h
  * \brief Definition file for platform-specific utility functions
  *
  * This file contains definitions, stubs, workarounds, and any kind of
  * platform-specific wrapper function or locally implemented library
  * definition that is needed to make this system work on a given platform.
**/



#ifndef _PLATFORM_HELPER_H_INCLUDED_
#define _PLATFORM_HELPER_H_INCLUDED_

#include <stdarg.h> /* stdarg to make sure I have va_list and other important stuff */
#include <stdint.h> /* for standard integer types like uint32_t */

// X11 header files (TODO:  use 'ifdef' blocks around this as needed for non-X platforms)

#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xmd.h>  // for 'CARD32' and other things
#include <X11/Xatom.h> // for 'XA_CARDINAL' and other things


#if defined(__GNUC__) || defined(__DOXYGEN__)

// this section included for doxygen documentation using the X11 definitions

#include <pthread.h> /* make sure this is included for POSIX */

#ifdef X11WORKBENCH_PROJECT_BUILD

// Globally include the output of the configure script for GNUC compiles for "the project"
#include "X11workbenchToolkit_config.h" // the 'generated' version'

#else // X11WORKBENCH_PROJECT_BUILD

// This is for the installed version, a subset of the things defined by the configure output script.
// NOTE:  this must be installed in the appropriate package directory along with platform_helper.h
#include "X11workbenchToolkit_install_config.h"

#endif // X11WORKBENCH_PROJECT_BUILD

// TESTING THE CONFIGURATION - TODO:  for some, provide alternates?
// NOTE that for 'WIN32' defined, certain features won't be checked

#if !defined( HAVE_ALARM ) || !defined( HAVE_CHOWN ) || \
    !defined( HAVE_CLOCK_GETTIME ) || !defined( HAVE_DUP2 ) || !defined( HAVE_FORK ) || \
    !defined( HAVE_FTRUNCATE ) || !defined( HAVE_GETCWD ) || !defined( HAVE_GETTIMEOFDAY ) || \
    !defined( HAVE_MALLOC ) || !defined( HAVE_MBLEN ) || !defined( HAVE_MEMCHR ) || \
    !defined( HAVE_MEMMOVE ) || !defined( HAVE_MEMSET ) || !defined( HAVE_MKDIR ) || \
    !defined( HAVE_PRINTF ) || !defined( HAVE_REALLOC ) || \
    !defined( HAVE_SELECT ) || !defined( HAVE_SETLOCALE ) || !defined( HAVE_STRCASECMP ) || \
    !defined( HAVE_STRCHR ) || !defined( HAVE_STRNCASECMP ) || !defined( HAVE_STRRCHR ) || \
    !defined( HAVE_STRSTR ) || !defined( HAVE__BOOL ) || \
    ( !defined(WIN32) && ( !defined( LSTAT_FOLLOWS_SLASHED_SYMLINK ) || !defined( HAVE_VFORK ) || \
                          !defined( HAVE_WORKING_FORK ) || !defined( HAVE_WORKING_VFORK ) ))
#error
#error configure script feature check 1 fail
#error critical features missing
#error
#else
#if !( HAVE_ALARM ) || !( HAVE_CHOWN ) || \
    !( HAVE_CLOCK_GETTIME ) || !( HAVE_DUP2 ) || !( HAVE_FORK ) || \
    !( HAVE_FTRUNCATE ) || !( HAVE_GETCWD ) || !( HAVE_GETTIMEOFDAY ) || \
    !( HAVE_MALLOC ) || !( HAVE_MBLEN ) || !( HAVE_MEMCHR ) || \
    !( HAVE_MEMMOVE ) || !( HAVE_MEMSET ) || !( HAVE_MKDIR ) || \
    !( HAVE_PRINTF ) || !( HAVE_REALLOC ) || \
    !( HAVE_SELECT ) || !( HAVE_SETLOCALE ) || !( HAVE_STRCASECMP ) || \
    !( HAVE_STRCHR ) || !( HAVE_STRNCASECMP ) || !( HAVE_STRRCHR ) || \
    !( HAVE_STRSTR ) || !( HAVE__BOOL ) || \
    ( !defined(WIN32) && ( !( LSTAT_FOLLOWS_SLASHED_SYMLINK ) || !( HAVE_VFORK ) || \
                           !( HAVE_WORKING_FORK ) || !( HAVE_WORKING_VFORK ) ))
#error
#error configure script feature check 2 fail
#error critical features missing
#error
#endif // all that stuff
#endif // all that prior stuff

#ifndef HAVE_BZERO
  #define HAVE_BZERO 0
#endif // !HAVE_BZERO

#if !( HAVE_BZERO )
  #define bzero(X,Y) memset((X),0,(Y))
#endif


// DEBUG vs RELEASE code

#ifdef DEBUG /* explicit DEBUG build */
#ifdef NO_DEBUG
#undef NO_DEBUG
#endif // NO_DEBUG
#endif // DEBUG

// NOTE:  The debug code will be included when NO_DEBUG is *NOT* defined


/** \ingroup platform
  * \hideinitializer
  * \brief INVALID HANDLE VALUE equivalent
  *
  * This definition generically refers to an INVALID HANDLE, more specifically a FILE or SOCKET handle on POSIX systems
**/
#define INVALID_HANDLE_VALUE ((int)-1)


/** \ingroup platform
  * @{
**/

//-------------------------------------------------
// branch optimization macros - gcc and clang only
//-------------------------------------------------

#if defined(COMPILER_SUPPORTS_BUILTIN_EXPECT) || defined(__DOXYGEN__)

#define WB_UNLIKELY(x) (__builtin_expect (!!(x), 0)) /**< optimization for code branching when condition is 'unlikely'.  use within conditionals **/
#define WB_LIKELY(x) (__builtin_expect (!!(x), 1))   /**< optimization for code branching when condition is 'likely'.  use within conditionals **/

#else // !COMPILER_SUPPORTS_BUILTIN_EXPECT

#define WB_UNLIKELY(x) (x)
#define WB_LIKELY(x) (x)

#endif // COMPILER_SUPPORTS_BUILTIN_EXPECT

#if defined(COMPILER_SUPPORTS_UNUSED_ATTRIBUTE) || defined(__DOXYGEN__)

#define WB_UNUSED __attribute__((unused))  /**< marks a variable as likely to be 'unused'.  warning abatement.  Place macro directly after the variable name **/

#else // !COMPILER_SUPPORTS_UNUSED_ATTRIBUTE

#define WB_UNUSED

#endif // COMPILER_SUPPORTS_UNUSED_ATTRIBUTE


/** \brief The minimum 'internal' Atom value used by the toolkit
  *
  * This is the minimum 'internal' Atom value that is used by the toolkit.  Atoms that are allocated via XInternAtom()
  * will have a value that is LESS than WB_INTERNAL_ATOM_MIN_VAL, and anything allocated via WBGetAtom() will have
  * a value that is GREATER THAN OR EQUAL to WB_INTERNAL_ATOM_MIN_VAL.
  *
  * Use of this constant to determine 'internal' from 'X11' Atoms is based on the source code for the Xorg X11 server,
  * which uses the function 'MakeAtom()' (in 'dix/atom.c') to allocate new atoms.  These values are assigned SEQUENTIALLY,
  * beginning with 'XA_LAST_PREDEFINED+1' and continuing from there.  A value of this magnitude allows for about 1 billion
  * Atom allocations before 'hitting the limit'.  (having that many atoms would negatively impact the X windows system)
  *
  * In the future, it is possible that an Atom *MAY* have a randomly assigned value, or a value assigned that clashes
  * with this definition.  In such a case, a major re-write might be needed to correct for it.
  *
  * NOTE:  This value must NOT include any of the bits 'Or'd with an Atom within a menu, such as 'WBMENU_POPUP_HIGH_BIT'
  * or 'WBMENU_DYNAMIC_HIGH_BIT'.  Otherwise, THAT architecture would need to be modified as well.
  *
**/
#define WB_INTERNAL_ATOM_MIN_VAL 0x3f000000L         /**< the minimum 'internal' Atom value used by the toolkit **/

/**
  * @}
**/

/** \ingroup platform
  * \brief Platform abstract 32-bit integer
  *
  * This definition identifies the data type for a 32-bit integer
**/
typedef int WB_INT32;

/** \ingroup platform
  * \brief Platform abstract unsigned 32-bit integer
  *
  * This definition identifies the data type for an unsigned 32-bit integer
**/
typedef unsigned int WB_UINT32;


#if defined(HAVE_LONGLONG) || defined(__DOXYGEN__) /* 'configure' tests for 'long long' datatype valid in configure script */

/** \ingroup platform
  * \brief defined whenever the 'WB_UINT64' data type is a 'built in' data type
**/
#define HAS_WB_UINT64_BUILTIN


/** \ingroup platform
  * \brief Platform abstract 64-bit integer
  *
  * This definition identifies the data type for a 64-bit integer
**/
typedef long long WB_INT64;

/** \ingroup platform
  * \brief Platform abstract unsigned 64-bit integer
  *
  * This definition identifies the data type for an unsigned 64-bit integer
**/
typedef unsigned long long WB_UINT64;

#else // !defined HAVE_LONGLONG, unlikely (this part won't show up in doxygen either)

typedef struct __WB_INT64__ { WB_UINT32 dw2; WB_INT32 dw1; } WB_INT64;    // note 'dw1' is a signed value
typedef struct __WB_UINT64__ { WB_UINT32 dw2; WB_UINT32 dw1; } WB_UINT64;

#endif // _LONGLONG

#ifdef __DOXYGEN__
/** \ingroup platform
  * \brief Platform abstract unsigned integer that matches pointer size
  *
  * Definition for an integer equivalent of a pointer for platform-independent type casting without warnings
**/
typedef unsigned long long WB_UINTPTR;
#else /* regular code uses this next part */

#if !defined(__SIZEOF_POINTER__) // TODO find a better way to deal with pointer size if this isn't defined
#define __SIZEOF_POINTER__ 0
#endif

#ifdef __LP64__ /* TODO see what WIN32 vs WIN64 does */
typedef WB_UINT64 WB_UINTPTR;
#elif __SIZEOF_POINTER__ == 4 /* 4-byte pointer */
typedef WB_UINT32 WB_UINTPTR;
#else // assume long pointer
typedef WB_UINT64 WB_UINTPTR;
#endif // __LP64__
#endif // __DOXYGEN__


// pointer to integer conversion without those irritating truncation warnings




#define WB_C99_INITIALIZERS /* allow C99-style initializers */

/** \ingroup platform
  * \brief MODULE HANDLE equivalent
  *
  * This 'typedef' refers to a MODULE
**/
typedef void * WB_MODULE;

/** \ingroup platform
  * \brief THREAD HANDLE equivalent
  *
  * This 'typedef' refers to a THREAD
**/
typedef pthread_t WB_THREAD;

/** \ingroup platform
  * \brief PROC ADDRESS equivalent
  *
  * This 'typedef' refers to a PROC ADDRESS as exported from a shared library
**/
typedef void (* WB_PROCADDRESS)(void);

/** \ingroup platform
  * \brief THREAD LOCAL STORAGE 'key' equivalent
  *
  * This 'typedef' refers to a THREAD LOCAL STORAGE key, identifying a storage slot
**/
typedef pthread_key_t   WB_THREAD_KEY;

/** \ingroup platform
  * \brief CONDITION HANDLE equivalent (similar to an 'event')
  *
  * This 'typedef' refers to a CONDITION, a triggerable synchronization resource
**/
typedef WB_UINT32 WB_COND; // defined as 'WB_UINT32' because of pthread_cond problems under Linux
//typedef pthread_cond_t  WB_COND;

/** \ingroup platform
  * \brief MUTEX HANDLE equivalent
  *
  * This 'typedef' refers to a MUTEX, a lockable synchronization object
**/
typedef pthread_mutex_t WB_MUTEX;


// TODO:  sizeof(int) sizeof(long) - long is 64-bit for GNUC - MS compilers make it 32-bit



#ifdef __DOXYGEN__

/** \ingroup platform
  * \brief PACKED definition
  *
  * This assignes the 'packed' attribute; i.e. byte-level alignment
**/
#define __PACKED__ /* platform dependent; actual def must be a blank or doxygen barphs on it */

#else // !__DOXYGEN__

#define __PACKED__ __attribute__((__packed__))

#endif // __DOXYGEN__

#elif defined(_MSC_VER) /* Microsoft C/C++ compiler */

// TODO:  add proper support for MS compiler
#if _MSC_VER > 1300

// TODO:  specify correct version in which C99 initializers are supported
//        as of MSC for ".Net" 2010 it's _NOT_ supported (still!)
//#define WB_C99_INITIALIZERS

#endif // _MSC_VER > xxxx

#define WB_UNLIKELY(x) (x)
#define WB_LIKELY(x) (x)

#ifndef __inline__
#define __inline__ inline /* this assumes 'inline' is supported (MSC should support this) */
#endif // __inline__

typedef __int64 WB_INT64;
typedef unsigned __int64 WB_UINT64;
typedef int WB_INT32;
typedef unsigned int WB_UINT32;

// assume MS Windows Win32 API
typedef HMODULE WB_MODULE ;     /* module handle */
typedef HANDLE WB_THREAD;       /* thread handle - thread IDs are still 'int' types */
typedef FARPROC WB_PROCADDRESS; // generic proc address returned from GetProcAddress()

typedef DWORD WBTHREAD_KEY;     // return from 'TlsAlloc()'
typedef HANDLE WB_COND;         // equivalent to an event handle
typedef HANDLE WB_MUTEX;        // equivalent to a mutex handle


// TODO:  sizeof(int) sizeof(long) - long is 32-bit for MSC

// TODO:  compatibility definition file for winders

#define __PACKED__ /* TODO: a definition for packing in MS-land */

#else // !defined(_MSVC_VER) && !defined(__GNUC__)

#error unknown and/or unsupported compiler

#define __PACKED__

#endif // __GNUC__


// put standard '#define's and typedefs here, the ones that apply to EVERYBODY

/** \ingroup platform
  * @{
**/
#define WB_SECURE_HASH_TIMEOUT 60000 /**< 'secure hash' maximum lifetime, in milliseconds **/

typedef char * WB_PSTR;         ///< pointer to char string - a convenience typedef
typedef const char * WB_PCSTR;  ///< pointer to const char string - a convenience typedef
/**
  * @}
**/



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                               //
//   ____   _                _                      _                _   ____   _             _       _                          //
//  / ___| | |_  __ _  _ __ | |_  _   _  _ __      / \    _ __    __| | / ___| | |__   _   _ | |_  __| |  ___ __      __ _ __    //
//  \___ \ | __|/ _` || '__|| __|| | | || '_ \    / _ \  | '_ \  / _` | \___ \ | '_ \ | | | || __|/ _` | / _ \\ \ /\ / /| '_ \   //
//   ___) || |_| (_| || |   | |_ | |_| || |_) |  / ___ \ | | | || (_| |  ___) || | | || |_| || |_| (_| || (_) |\ V  V / | | | |  //
//  |____/  \__|\__,_||_|    \__| \__,_|| .__/  /_/   \_\|_| |_| \__,_| |____/ |_| |_| \__,_| \__|\__,_| \___/  \_/\_/  |_| |_|  //
//                                      |_|                                                                                      //
//                                                                                                                               //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** \ingroup startup
  * \hideinitializer
  * \var bQuitFlag
  * \brief 'Quit' Flag - you should check this periodically in your main (message) loop and exit whenever it is TRUE (non-zero)
  *
  * \c Quit \c Flag - assign to TRUE (non-zero) when it's time to exit.  This may be done asynchronously at any point in time.\n
  * Signal procs that terminate the application, as well as the main frame window's 'Destroy' handler,
  * and any 'Exit' functions, should all set this to TRUE (non-zero) to force the application to exit.
  *
  * \code

  extern int bQuitFlag;

  * \endcode
  *
**/
extern int bQuitFlag;

// these functions are internal-only, implemented in window_helper.c, but must be defined here
void __internal_startup_display(const char *szVal);
void __internal_startup_minimize(void);
void __internal_startup_maximize(void);
void __internal_startup_geometry(const char *szVal);



// *******************************************
// STARTUP AND SHUTDOWN (must-call functions)
// *******************************************

/** \ingroup startup
  * \brief Resource initialization on startup
  *
  * Call this function right before using any 'platform_helper' functions to initialize any global resources
  * from 'platform_helper.h'.  WBInit() does this automatically.  It should only be called once.  It's ok
  * to call it before calling WBInit(), however.\n
  *
  * Header File:  platform_helper.h
**/
void WBPlatformOnInit(void);

/** \ingroup startup
  * \brief Resource 'free-up' on exit (must call)
  *
  * Call this function right before exiting the application if you have made use of any system-specific resources
  * from 'platform_helper.h'.  WBExit() does this automatically.  Among other things, it will delete any temporary
  * files that were created via WBTempFile().\n
  * It should also be safe to call this function from within a 'signal' handler, prior to '__exit()'.
  *
  * Header File:  platform_helper.h
**/
void WBPlatformOnExit(void);


/** \ingroup startup
  * \brief parses standard C arguments as passed to 'main()'
  *
  * In order to support a large number of default switches and parameters that are
  * supported by the X11workbench Toolkit API, you should pass pointers to the
  * parameters that were passed to 'main()' by the C startup code to this function.\n
  * Returns 0 on success, non-zero (or error code) otherwise.\n
  * The values for 'argc' (as *pargc) 'argv' (as *pargv) and 'envp' (as *penvp) will
  * likely be modified from their original values as part of the processing.  If you
  * want to retain the original values, pass 'copies' to this function and use the
  * copies for normal argument processing (as with 'getarg').
  *
  * Header File:  platform_helper.h
**/
int WBParseStandardArguments(int *pargc, char ***pargv, char ***penvp);

/** \ingroup startup
  * \brief Displays 'usage' for toolkit options to stderr
  *
  * Header File:  platform_helper.h
**/
void WBToolkitUsage(void);

/** \ingroup startup
  * \brief returns a pointer to a copy of the application name from argv[0]
  *
  * \returns A const pointer to a zero-byte terminated string containing a copy of the application name
  *
  * This function is only valid if you call WBParseStandardArguments() on startup
  *
  * Header File:  platform_helper.h
**/
const char *GetStartupAppName(void);




//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//      ____               _                     _   _  _    _  _           //
//     / ___|  _   _  ___ | |_  ___  _ __ ___   | | | || |_ (_)| | ___      //
//     \___ \ | | | |/ __|| __|/ _ \| '_ ` _ \  | | | || __|| || |/ __|     //
//      ___) || |_| |\__ \| |_|  __/| | | | | | | |_| || |_ | || |\__ \     //
//     |____/  \__, ||___/ \__|\___||_| |_| |_|  \___/  \__||_||_||___/     //
//             |___/                                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


/** \ingroup platform
  * \brief Returns the current 'time index' (in microseconds)
  *
  * \return An unsigned 64-bit time index value, in microseconds
  *
  * The 'time index' is the master timer that determines when a timer event will be generated.
  * By design it uses a 64-bit integer that never 'wraps around' to zero.  It is generally
  * derived from the 'gettimeofday' API call for operating systems such as BSD and Linux that
  * support the POSIX standard.
  *
  * Header File:  platform_helper.h
**/
WB_UINT64 WBGetTimeIndex(void);  // returns current 'time index' (in microseconds) which never wraps around
                                 // NOTE:  it is derived from the 'gettimeofday' call on BSD, Linux, etc.


/** \ingroup platform
  * \brief Delay for a specified period in microseconds
  *
  * \param uiDelay The delay period, in microseconds
  *
  * A generic delay utility that will use 'nanosleep' (when available), or some other
  * means (such as 'usleep') when it is not.  On systems that do not support microsecond
  * resolution on delays, this function will always delay at least one millisecond.
  * On some systems, this delay may be interruptible.
  * For exact timing, a non-interruptible loop that times execution by counting CPU
  * instructions shyould be used instead.  This function is approximate only.
  *
  * Header File:  platform_helper.h
**/
void WBDelay(uint32_t uiDelay);  // approximate delay for specified period (in microseconds).  may be interruptible


/** \ingroup platform
  * \brief Get the number of available CPU cores
  *
  * \return The total number of available CPU cores on the system.  On a VM, only those cores that have been assigned to the VM will be counted.
  *
  * A generic delay utility that returns the total number of available cores on the system.  This
  * may be useful when determining how to divide up a parallel algorithm, for example.
  *
  * If the number of available cores is not known or cannot be determined for some reason, this
  * function returns a value of 0.
  *
  * Header File:  platform_helper.h
**/
int WBCPUCount(void);



//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                          //
//   __  __                                           _     _  _                     _    _                 //
//  |  \/  |  ___  _ __ ___    ___   _ __  _   _     / \   | || |  ___    ___  __ _ | |_ (_)  ___   _ __    //
//  | |\/| | / _ \| '_ ` _ \  / _ \ | '__|| | | |   / _ \  | || | / _ \  / __|/ _` || __|| | / _ \ | '_ \   //
//  | |  | ||  __/| | | | | || (_) || |   | |_| |  / ___ \ | || || (_) || (__| (_| || |_ | || (_) || | | |  //
//  |_|  |_| \___||_| |_| |_| \___/ |_|    \__, | /_/   \_\|_||_| \___/  \___|\__,_| \__||_| \___/ |_| |_|  //
//                                         |___/                                                            //
//                                                                                                          //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////


// memory allocation (with debug support)

/** \ingroup sub_alloc
  * \brief High performance memory sub-allocator 'allocate'
  *
  * \param nSize The length of memory being requested
  * \returns A pointer to the allocated buffer, always aligned on a 'pointer size' boundary.  Do NOT overrun the buffer!
  *
  * Header File:  platform_helper.h
**/
void *WBAlloc(int nSize);

/** \ingroup sub_alloc
  * \brief High performance memory sub-allocator 'free'
  *
  * \param pBuf A pointer to the previously sub-allocated memory
  * \returns void
  *
  * Header File:  platform_helper.h
**/
void WBFree(void *pBuf);

/** \ingroup sub_alloc
  * \brief High performance memory sub-allocator, similar to 'malloc_usable_size'
  *
  * \param pBuf A pointer to the previously sub-allocated memory
  * \returns The usable size of the allocated memory.
  *
  * Use this function to determine how big a memory block REALLY is, particularly if
  * 'malloc_usable_size' is supported.  The sub-allocators use power-of-two allocation
  * sizes in order to minimize the need to re-allocate blocks of memory.  The assumption
  * is that memory re-allocation is likely.  To minimize the need to flip pointers around
  * all of the time, and copy blocks of memory from one place to another via re-allocation,
  * you can use this function to determine how much memory is REALLY available in the
  * memory block.  (this function is used internally within WBReAlloc(), and is generally 'advisory'
  * when used for other purposes).
  *
  * Header File:  platform_helper.h
**/
int WBAllocUsableSize(void *pBuf);

/** \ingroup sub_alloc
  * \brief High performance memory sub-allocator 're-allocate'
  *
  * \param pBuf A pointer to the previously sub-allocated memory
  * \param nNewSize The desired 'new' size of the memory block
  * \return A pointer to the new allocated memory block, or NULL on error.  If the return value is NOT NULL, the previous pointer becomes invalid.
  *
  * Header File:  platform_helper.h
**/
void * WBReAlloc(void *pBuf, int nNewSize);

/** \ingroup sub_alloc
  * \brief High performance memory sub-allocator 'trash masher' - call periodically to minimize wasted memory
  *
  * Sub-allocation sometimes leaves 'holes' in memory.  This function is intended to minimize that, by freeing
  * up blocks of allocated memory that are no longer in use.  It is not the same as 'garbage collection', but
  * it may have the same basic effect.  Call this function within the main message loop in the main thread.
  *
  * Header File:  platform_helper.h
**/
void WBSubAllocTrashMasher(void);


// BASIC STRING UTILITIES

// simple but helpful string utilities

/** \ingroup text
  * \brief A simple utility that returns a WBAlloc() copy of a 0-byte terminated string
  *
  * \param pSrc A pointer to the original ASCII string (0-byte terminated)
  * \return a 'WBAlloc() copy of the string (0-byte terminated)
  *
  * This function creates a 'WBAlloc() copy of szStr, up to the 0-byte.  The returned string
  * ALWAYS ends in a zero byte.  The caller must deallocate the returned pointer using 'WBFree()'.\n
  * The function returns NULL on error.
  *
  * Header File:  platform_helper.h
**/
char *WBCopyString(const char *pSrc);

/** \ingroup text
  * \brief A simple utility that returns a WBAlloc() copy of a string up to a maximum length (can also be 0-byte terminated)
  *
  * \param pSrc A pointer to the original ASCII string (can be 0-byte terminated)
  * \param nMaxChars The maximum number of characters to be copied, or until a 0-byte is found
  * \return a 'WBAlloc() copy of the string (0-byte terminated)
  *
  * This function creates a 'WBAlloc() copy of pStr, up to 'nMaxChars' or until a 0-byte is
  * found, whichever happens first.  The returned string ALWAYS ends in a zero byte.
  * The caller must deallocate the returned pointer using 'WBFree()'.\n
  * The function returns NULL on error.
  *
  * Header File:  platform_helper.h
**/
char *WBCopyStringN(const char *pSrc, unsigned int nMaxChars);

/** \ingroup text
  * \brief A simple utility that concatenates a string onto the end of a 0-byte terminated WBAlloc() string
  *
  * \param ppDest A pointer to a pointer to a WBAlloc() string containing the first portion of the concatenated result (also the return value)
  * \param pSrc A pointer to a character string to concatenate onto the end of the first string
  *
  * This function concatenates two strings together.  The first parameter must point to the character pointer variable
  * that points to the first string to be concatenated.  This must either be a WBAlloc() pointer or NULL, and the string
  * itself must be 0-byte terminated.  The second parameter points to a 0-byte terminated string, which does not
  * have to be a WBAlloc() string.  The function will overwrite the first pointer with WBAlloc() copy of the result
  * of concatenating the two strings.\n
  * On error, the function does NOT modify ppDest and aborts the concatenate operation.
  *
  * Header File:  platform_helper.h
**/
void WBCatString(char **ppDest, const char *pSrc);

/** \ingroup text
  * \brief A simple utility that concatenates a string onto the end of a 0-byte terminated WBAlloc() string up to a maximum length (can also be 0-byte terminated)
  *
  * \param ppDest A pointer to a pointer to a WBAlloc() string containing the first portion of the concatenated result (also the return value)
  * \param pSrc A pointer to a character string to concatenate onto the end of the first string (can be 0-byte terminated)
  * \param nMaxChars The maximum number of characters to be concatenated, or until a 0-byte is found in pSrc
  *
  * This function concatenates two strings together.  The first parameter must point to the character pointer variable
  * that points to the first string to be concatenated.  This must either be a WBAlloc() pointer or NULL, and the string
  * itself must be 0-byte terminated.  The second parameter points to a POSSIBLY 0-byte terminated string, which does not
  * have to be a WBAlloc() string.  The function will overwrite the first pointer with WBAlloc() copy of the result
  * of concatenating the two strings.  The string 'pSrc' will be concatenated up to 'nMaxChars' or until a 0-byte is
  * found, whichever happens first.\n
  * On error, the function does NOT modify pszStr1 and aborts the concatenate operation.
  *
  * Header File:  platform_helper.h
**/
void WBCatStringN(char **ppDest, const char *pSrc, unsigned int nMaxChars);

/** \ingroup text
  * \brief De-Quote a string 'in place', that is modifying the original string by removing quotes
  *
  * \param pszStr A pointer to a (0-byte terminated) ASCII string that may contain quotes.  Quotes are removed 'in place'
  *
  * Often you need to be able to remove quote characters from a string in a standardized manner.  This
  * function handles just about every standard quoting method available, including the use of double-quotes
  * to indicate a quote within a quoted string, the use of single or double quotes, etc.
  *
  * Header File:  platform_helper.h
**/
void WBDeQuoteString(char *pszStr);      // de-quote a string in place

/** \ingroup text
  * \brief De-Quote and 'normalize' an XML string 'in place', that is modifying the original string by removing quotes and translationg things like '&amp;' '&gt;' etc.
  *
  * \param pszStr A pointer to a (0-byte terminated) ASCII string that may contain quotes.  Quotes are removed 'in place'
  *
  * Often you need to be able to remove quote characters and otherwise 'normalize' an XML string in a standardized
  * manner.  This function handles just about every standard quoting method available, including the use of
  * double-quotes, as well as special character indicators like '&amp;' and '&gt;', to indicate a quote or special
  * character within a quoted string, as well as allowing the the use of either single or double quotes, etc.
  *
  * Header File:  platform_helper.h
**/
void WBNormalizeXMLString(char *pString);

/** \ingroup text
  * \brief Determine how many 'lines' are in a block of text by counting 'linefeed' characters
  *
  * \param pSrc A const pointer to an ASCII or UTF8 string (may end in zero byte)
  * \param nMaxChars The maximum number of characters in the buffer
  * \returns The total number of lines (including blank lines)
  *
  * Use this function to determine how many lines are in the block of text.  A line is considered to be
  * a string of 1 or more characters, ending in a zero byte [or end of text as determined by 'nMaxChars'],
  * or one of the following sequences:  \<CRLF\>, \<LF\>, \<CR\>, or \<LFCR\>
  *
  * Header File:  platform_helper.h
**/
int WBStringLineCount(const char *pSrc, unsigned int nMaxChars);

/** \ingroup text
  * \brief Locate the next line in a block of text, returning its pointer (and updating remaining length)
  *
  * \param pSrc A const pointer to an ASCII or UTF8 string (may end in a zero byte)
  * \param pnMaxChars A pointer to an integer containing maximum number of characters in the buffer
  * \returns A pointer to the next line, the character just following a \<CRLF\>, \<LF\>, \<CR\>, or \<LFCR\> sequence.
  *
  * Use this function to find the 'next line' in a block of text.  It will also update the number of characters remaining
  * in the buffer, and store the result in '*pnMaxChars'.  If 'pnMaxChars' is NULL, the string buffer is assumed to
  * terminate with a zero-byte.
  *
  * Header File:  platform_helper.h
**/
const char *WBStringNextLine(const char *pSrc, unsigned int *pnMaxChars);


#if 0

// THIS IS ALL RESERVED FOR FUTURE USE
// MAY NOT BE NEEDED IF I USE _Xmbtowc _Xwctomb and _Xwctomb
// X11 defines them as mblen(), mbtowc(), and wctomb()
// The alternative is to do something similar on WIN32, once that is implemented in the toolkit
// with '#ifdef blocks all around it

/** \ingroup text
  * \brief Check for and report if multi-byte string
  *
  * \param pszStr A pointer to a (0-byte terminated) UTF-8 string that may have multi-byte characters
  * \return A positive value indicating the length of the UTF-16 string if it were converted, zero if
  *         there are no multi-byte characters, or < 0 if the string is malformed or cannot be converted
  *
  * multi-byte character strings may require special handling to conver to/from unicode before they
  * can be handled by X11.  Further, you may need to use a '16' version of an X11 API to manage the
  * double-byte characters.  Even more complex, you might actually have to convert the entire string
  * to/from unicode in an RFC-COMPLIANT AND SECURE MANNER before you can go off and try to render it.
  * This function scans a UTF-8 string and returns the length as a UTF-16 string if it contains ANY
  * multi-byte characters _AND_ can be properly converted.  It returns 0 if it's pure ASCII, and
  * a value of -1 if it cannot be properly converted, and -2 if it is simply 'malformed'.
  *
  * Header File:  platform_helper.h
**/
int WBIsMultiByte(const char *pszStr);


/** \ingroup text
  * \brief Convert UTF-8 string to UTF-16 string
  *
  * \param pszStr A pointer to a (0-byte terminated) UTF-8 string that may have multi-byte characters
  * \return A 'WBAlloc() pointer to an array of XChar2b structures containing the UTF-16
  *
  * Use this function to create a UTF-16 string from a UTF-8 string for use with the '16' X11 API
  * text-related functions
  *
  * Header File:  platform_helper.h
**/
XChar2b * WBConvertMultiByteTo16(const char *pszStr);

/** \ingroup text
  * \brief Convert UTF-16 string to UTF-8 string
  *
  * \param pszStr A pointer to a (0-word terminated) UTF-16 string
  * \return A 'WBAlloc() pointer to a UTF-8 string that may have multi-byte characters
  *
  * Use this function to create a UTF-8 string from a UTF-16 string.
  *
  * Header File:  platform_helper.h
**/
char *WBConvertMultiByteFrom16(const XChar2b *pwzStr);
#endif // 0


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//     __  __ ____   __  __   _      _  _                                   //
//     \ \/ /|  _ \ |  \/  | | |    (_)| |__   _ __  __ _  _ __  _   _      //
//      \  / | |_) || |\/| | | |    | || '_ \ | '__|/ _` || '__|| | | |     //
//      /  \ |  __/ | |  | | | |___ | || |_) || |  | (_| || |   | |_| |     //
//     /_/\_\|_|    |_|  |_| |_____||_||_.__/ |_|   \__,_||_|    \__, |     //
//                                                               |___/      //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


// XPM library (libXpm) and X11/xpm.h

#if defined(X11WORKBENCH_TOOLKIT_HAVE_XPM) && !defined(__DOXYGEN__)

// Doxygen doesn't need THIS part, it needs the other one.

#include <X11/xpm.h>

// no need for doxygen doc comments here, see '!defined(__DOXYGEN__)' above
// these definitions are for when libXpm is being used
#define XPM_ATTRIBUTES XpmAttributes
#define XPM_CREATE_PIXMAP_FROM_DATA(A,B,C,D,E,F) XpmCreatePixmapFromData(A,B,C,D,E,F)
#define XPM_FREE_ATTRIBUTES(pAttr) XpmFreeAttributes(pAttr)

#else // !X11WORKBENCH_TOOLKIT_HAVE_XPM or __DOXYGEN__

/** \ingroup pixmap
  * \struct _XPM_ATTRIBUTES_
  * \copydoc XPM_ATTRIBUTES
**/
/** \ingroup pixmap
  * \typedef XPM_ATTRIBUTES
  * \brief Compatibility structure for use with MyLoadPixmapFromData() whenever libXpm is not in use.
  *
  * When libXpm is in use, XPM_ATTRIBUTES becomes a \#define for XpmAttributes, the structure used
  * by XpmCreatePixmapFromData().  Because so many elements are not needed, MyLoadPixmapFromData()
  * uses this scaled-down version whenever libXpm is not being used by the library.
  *
  * The configure option "--enable-libXpm" forces linkage with libXpm.  Note that this is NOT the
  * default option, since performance is adversely affected when using libXpm.  However, for 100\%
  * compatibility, it may be necessary to use libXpm as MyLoadPixmapFromData() has not been tested
  * on all platforms.
  *
  * When libXpm is NOT in use, the follow structure is defined:
  *
  * \code

  typedef struct _XPM_ATTRIBUTES_
  {
    int width;    // The width of the returned pixmaps
    int height;   // height of the returned pixmaps
    int depth;    // depth of the returned 'image' pixmap.  The mask pixmap always has a depth of '1'.

  } XPM_ATTRIBUTES;

  * \endcode
  *
  * When libXpm IS in use, the following macro is defined:
  *
  * \code

  #define XPM_ATTRIBUTES XpmAttributes

  * \endcode
  *
  * In summary, this structure is a scaled-down version of the standard X11 structure 'XpmAttributes', and
  * is defined ONLY when libXpm is not in use (based on the configure script).  Only those structure
  * members that are needed by this toolkit have been defined in the scaled-down version.
  *
  * For more information, see MyLoadPixmapFromData()
  *
**/
typedef struct _XPM_ATTRIBUTES_
{
  // I only need certain information from MyLoadPixmapFromData(), so that's all I'm doing with this structure

  int width;    ///< The width of the returned pixmaps
  int height;   ///< height of the returned pixmaps
  int depth;    ///< depth of the returned 'image' pixmap.  The mask pixmap always has a depth of '1'.

} XPM_ATTRIBUTES;


/** \ingroup pixmap
  * \brief Alternate for XpmCreatePixmapFromData() whenever libXpm is not being used
  *
  * \param pDisplay A pointer to the display to use when creating the pixmaps
  * \param wID A window used as a 'drawable' reference when creating the pixmaps
  * \param aData An 'xpm' pixmap array, using the standard format generated by utilities like 'gimp'
  * \param pPixmap Pointer to the variable to receive the Pixmap.  If the function fails, this will be 'None'
  * \param pMask Pointer to the variable to receive the transparency mask Pixmap.  This may be 'None' if there is no transparency mask
  * \param pAttr Pointer to the 'XPM_ATTRIBUTES' structure, which is a subset of the XpmAttributes structure used by XpmCreatePixmapFromData()
  * \return A value of zero on success (same as XpmSuccess, returned by XpmCreatePixmapFromData() on success).
  *
  * This function is an alternate for XpmCreatePixmapFromData() whenever libXpm is not being used.  It provides similar
  * functionality, although there are some significant differences, particularly with the use of XPM_ATTRIBUTES as an
  * actual structure and not just a '\#define'.  Additionally, there is a significant performance benefit for using
  * this function in lieu of libXpm.  As such it is the default configuration NOT to use libXpm.
  *
  * If you want to use libXpm, you can use the '--enable-libXpm' option in the 'configure' script for the project.
  *
  * Whenever libXpm is compiled in, XPM_ATTRIBUTES becomes a macro that is defined as XpmAttributes, the structure
  * used by XpmCreatePixmapFromData().  There are a large number of members in this structure that are not useful
  * for the purpose of this function, and so a scaled-down version is used when MyLoadPixmapFromData is being invoked.
  *
  * You should consider whether or not you want to use libXpm whenever it is present on your system, as this function has
  * not been fully tested on all platforms.  However, using libXpm carries with it a significant performance penalty.
  * If the application runs ok with the default configuration (i.e. no libXpm), you might as well leave it as-is.
  *
  * Header File:  platform_helper.h
**/
int MyLoadPixmapFromData(Display *pDisplay, Window wID, char *aData[],
                         Pixmap *pPixmap, Pixmap *pMask, XPM_ATTRIBUTES *pAttr);

/** \ingroup pixmap
  * \brief Platform helper macro to create a pixmap from data
  *
  * \param A A pointer to the Display
  * \param B The Window ID
  * \param C A pointer to an array of 'char *' that represents the pixmap data
  * \param D A pointer to a Pixmap into which the data will be saved, or NULL
  * \param E A pointer to the Pixmap into which the mask data will be saved (icons only), or NULL
  * \param F A pointer to an XPM_ATTRIBUTES structure.  If libXpm is present, this will be defined in X11/xpm.h
  * \returns An integer indicating success or failure.  See XpmCreatePixmapFromData in libXpm documentation
  *
  * This macro abstracts calls to XpmCreatePixmapFromData() by allowing an internal function to be called
  * whenever libXpm is not available for this purpose.
**/
#define XPM_CREATE_PIXMAP_FROM_DATA(A,B,C,D,E,F) MyLoadPixmapFromData(A,B,C,D,E,F)

/** \ingroup pixmap
  * \brief Platform helper macro to free XPM_ATTRIBUTES filled in by XPM_CREATE_PIXMAP_FROM_DATA()
  *
  * \param pAttr A pointer to the XPM_ATTRIBUTES that was filled in by a successful call to XPM_CREATE_PIXMAP_FROM_DATA()
  *
  * This macro abstracts calls to XpmFreeAttributes() by allowing an internal function to be called whenever
  * libXpm is not available for this purpose.  For the current implementation, the non-libXpm version does nothing.\n
  * Use this macro to free up XPM_ATTRIBUTES structure members that consume resources after a successful call
  * to XPM_CREATE_PIXMAP_FROM_DATA().  This will help prevent resource leaks.
  *
**/
#define XPM_FREE_ATTRIBUTES(pAttr) /* does nothing */


#endif


// some helpful macros that need to be universal without being in a different header

/** \ingroup text
  * \brief Obtain the 'next word' within a string pointed to by pX, bounded by pY and pZ
  *
  * \param pX A pointer to a 0-byte terminated string; returned as the 'current' pointer within that string for further parsing
  * \param pY A pointer to the word that was found within the string
  * \param pZ A pointer to the character just following the found word.  If pY == pZ, no word was found (and *pX should be 0)
  *
  * use this function in a loop to parse out the "next word" within the string until *pX == 0 or pY == pZ
**/
#define NEXT_WORD(pX, pY, pZ) {while(*(pX) && *(pX) <= ' '){(pX)++;} (pY)=(pZ)=(pX); while(*(pX)>' '){(pX)++;} (pZ)=(pX);}





#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// common macros

#ifndef FALSE
#define FALSE 0
#endif // FALSE
#ifndef TRUE
#define TRUE !0
#endif // TRUE



// HANDLING qsort_r CALLING CONVENTION DIFFERENCES
//
#if defined(QSORT_R_BSD) && !defined(__DOXYGEN__)

// DECLARE_SORT_FUNCTION based on - int (*compar)(void *, const void *, const void *)
//    generates    int fn_name(void *p0, const void *p1, const void *p2)
#define DECLARE_SORT_FUNCTION(fn_name,p0,p1,p2) int fn_name(void *p0, const void *p1, const void *p2)
// void qsort_r(void *base, size_t nmemb, size_t size, void *thunk, int (*compar)(void *, const void *, const void *))
#define QSORT_R(A,B,C,D,E) qsort_r((A),(B),(C),(D),(E))

#elif defined(QSORT_R_GNUC) && !defined(__DOXYGEN__)

// DECLARE_SORT_FUNCTION based on typedef int (*__compar_d_fn_t) (__const void *, __const void *, void *)
//    generates    int fn_name(const void *p1, const void *p2, void *p0)
#define DECLARE_SORT_FUNCTION(fn_name,p0,p1,p2) int fn_name(const void *p1, const void *p2, void *p0)
// extern void qsort_r (void *__base, size_t __nmemb, size_t __size, __compar_d_fn_t __compar, void *__arg)
#define QSORT_R(A,B,C,D,E) qsort_r((A),(B),(C),(E),(D))

#else

// here is where I implement 'vectored' quicksort for OTHER PLATFORMS

/** \ingroup platform
  * \brief Local implementation of qsort_r() for operating systems that do not have it
  *
  * \param base Pointer to 'base' of items to sort
  * \param nmemb Number of members to sort
  * \param size Size of a single member (including any padding)
  * \param thunk The value to pass along as the first parameter to 'compar'
  * \param compar The comparison function, declared using DECLARE_SORT_FUNCTION
  *
  * This function implements the QSORT_R macro when there is no libc function for qsort_r()
  *
  * Header File:  platform_helper.h
**/
void my_qsort_r(void *base, int nmemb, int size, void *thunk,
                int (*compar)(void *, const void *, const void *));

// the rest is exactly like the BSD version

/** \ingroup platform
  * \brief Wrapper to declare a sort function for \ref QSORT_R
  *
  * \param fn_name  The function name
  * \param p0 The 'thunk' parameter passed in by QSORT_R
  * \param p1 The first compare parameter
  * \param p2 The second compare parameter
  *
  * Use this wrapper macro to properly declare a compare function for \ref QSORT_R,
  * similar to the following example:
  *
  * \code

  DECLARE_SORT_FUNCTION(MySort,pThunk,pParam1,pParam2)
  {
    const char **pStringArray = (const char **)pThunk; // the real data
    const int *pP1 = (const int *)pParam1;
    const int *pP2 = (const int *)pParam2;

    // I am sorting integer indices into an array of character strings so
    // that I can sort the integers and not the actual strings.  But I needed
    // a pointer to my string array, so I pass that in as 'pThunk'.

    return strcmp(pStringArray[*pP1],pStringArray[*pP2]);
  }

  * \endcode
  *
  * this helps resolve the known platform differences in qsort_r() for POSIX systems
  *
  * \sa QSORT_R
**/
#define DECLARE_SORT_FUNCTION(fn_name,p0,p1,p2) int fn_name(void *p0, const void *p1, const void *p2)


/** \ingroup platform
  * \brief Local implementation of qsort_r() for operating systems that do not have it
  *
  * \param base Pointer to 'base' of items to sort
  * \param nmemb Number of members to sort
  * \param size Size of a single member (including any padding)
  * \param thunk The value to pass along as the first parameter to 'compar'
  * \param compar The comparison function, declared using DECLARE_SORT_FUNCTION
  *
  * Use this UNIVERSALLY whenever you need to use qsort_r(), as it is platform independent and
  * deals with the incompatibilities associated with the BSD version and the Linux version, as
  * well as implementing qsort_r() for systems that do not support it directly.
**/
#define QSORT_R(base,nmemb,size,thunk,compar) my_qsort_r((base),(nmemb),(size),(thunk),(compar))

#endif


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                ___         _                             _               //
//               |_ _| _ __  | |_  ___  _ __  _ __    __ _ | |              //
//                | | | '_ \ | __|/ _ \| '__|| '_ \  / _` || |              //
//                | | | | | || |_|  __/| |   | | | || (_| || |              //
//               |___||_| |_| \__|\___||_|   |_| |_| \__,_||_|              //
//                                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


// *********************************
// INTERNAL memory/security helpers
// *********************************

/** \ingroup platform
  * \brief Create/obtain a 32-bit 'secure' hash for a pointer
  *
  * \param pPointer A pointer to memory that remains valid after the call
  * \returns An allocated 'hash' to the pointer.  The hash should be free'd after use.
  *
  * This function will create a 'secure' hash for a pointer.  The hash can be used asynchronously
  * for up to WB_SECURE_HASH_TIMEOUT milliseconds, after which it the reference automatically be free'd.
  * In this way, an asynchronous message can contain references to pointers that are difficult to
  * 'fake' if another application were to attempt to inject Events into the queue.
  *
  * NOTE:  automatically freeing the reference does NOT free the pointer.  Failure to handle these
  *        correctly can result in memory leaks, but THAT is preferable to security vulnerabilities
  *
  * If the same pointer is used more than once in a call to this function, and the hash is still 'valid',
  * the same hash will be returned as before, but with a higher (internal) reference count.  The timeout
  * threshold will be reset using the current request time.  This makes it 'thread safe'.
  *
  * Passing a pointer asynchronously via a hash, particularly across thread boundaries, SHOULD implement
  * its own method of reference counting to avoid re-using a pointer after the memory has been free'd.  If
  * you do not queue the message, this becomes less important.  In any case, care needs to be taken to
  * avoid using a pointer after it has been free'd.
  *
  * Header File:  platform_helper.h
**/
WB_UINT32 WBCreatePointerHash(void *pPointer);

/** \ingroup platform
  * \brief Destroy a 32-bit 'secure' hash for a pointer
  *
  * \param uiHash The 'hash' value created by WBCreatePointerHash()
  *
  * This function will destroy a 'secure' hash for a pointer that was created by WBCreatePointerHash()
  *
  * NOTE:  destroying the hash reference does NOT free the pointer.  Failure to handle these
  *        correctly can result in memory leaks, but that is preferable to security vulnerabilities
  *
  * You should call this function immediately, once you have completed using the 'secure' pointer hash.
  * In some cases, this will be done for you (such as via WBWindowDispatch() with certain ClientMessage
  * events).  In other cases, you will have to explicitly do this yourself.
  *
  * Header File:  platform_helper.h
**/
void WBDestroyPointerHash(WB_UINT32 uiHash);

/** \ingroup platform
  * \brief Destroy a 32-bit 'secure' hash for a pointer regardless of reference count
  *
  * \param pPointer A pointer for which a hash may exist
  *
  * This function will destroy a 'secure' hash for a pointer that was created by WBCreatePointerHash(),
  * regardless of the reference count.  The hash will remain valid for up to WB_SECURE_HASH_TIMEOUT
  * milliseconds, but will have a value of 'NULL'.  This helps to mitigate possible pointer re-use.
  *
  * You should call this function immediately before you free a pointer that might be referenced by a
  * secure pointer hash, to prevent 'use after free' problems.  This will NOT solve problems where the
  * hash is being used across threads, however.  You may need to provide a different method of
  * synchronizing hashes under such a condition, such as thread-safe reference counting.
  *
  * Header File:  platform_helper.h
**/
void WBDestroyPointerHashPtr(void *pPointer);

/** \ingroup platform
  * \brief Obtain a pointer from a 32-bit 'secure' pointer hash value
  *
  * \param uiHash The 'hash' value created by WBCreatePointerHash()
  * \returns An allocated 'hash' to the pointer, or NULL if not valid.  The hash should be destroyed immediately after use.
  *
  * This function will create a 'secure' hash for a pointer.  The hash can be used asynchronously
  * for up to WB_SECURE_HASH_TIMEOUT milliseconds, after which it the referenced pointer will
  * automatically be free'd.
  *
  * In this way, an asynchronous message can contain references to pointers that are difficult to
  * 'fake' if another application were to attempt to inject XEvents into the queue.
  *
  * NOTE:  automatically freeing the reference does NOT free the pointer.  Failure to handle these
  *        correctly can result in memory leaks, but that is preferable to security vulnerabilities
  *
  * Header File:  platform_helper.h
**/
void * WBGetPointerFromHash(WB_UINT32 uiHash);



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                        _    _                                            //
//                       / \  | |_  ___   _ __ ___   ___                    //
//                      / _ \ | __|/ _ \ | '_ ` _ \ / __|                   //
//                     / ___ \| |_| (_) || | | | | |\__ \                   //
//                    /_/   \_\\__|\___/ |_| |_| |_||___/                   //
//                                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//-----------------------------------------
// ATOM HELPERS (internally-defined atoms)
//-----------------------------------------


/** \ingroup platform
  * \brief Lookup and/or allocate an internal Atom for a named string (lookups include X11 atoms)
  *
  * \param pDisplay The display to search for a matching X11 Atom
  * \param szAtomName The text 'Atom name' to search (and optionally create) for an Atom
  * \returns An Atom representing the specified szAtomName.  For values less than WB_INTERNAL_ATOM_MIN_VAL, it will be an X11 Atom.  Otherwise, the value will be 'internal only'
  *
  * This function will lookup and/or allocate an internal Atom based on the specified Atom name.  If the Atom
  * name exists as an X11 Atom, or already exists as an internal atom, the function will return that value.
  * Otherwise, this function will return an allocated Atom with a value >= WB_INTERNAL_ATOM_MIN_VAL.
  *
  * NOTE:  If an X11 Atom with a matching name exists, along with an 'internal' definition, the internal
  * definition will be returned.  This is to prevent problems with a 'race condition' on an atom name.
  *
  * If you need a globally defined atom with the matching name, use 'XInternAtom' instead.  Internally defined
  * atoms must never be used with other applications, window properties, or the window manager.
  *
  * The X11 workbench toolkit makes use of Atoms for menu and dialog box events.  To prevent flooding the X11 server with
  * a lot of unnecessary proprietary Atom names, this function lets X11 workbench continue to use the Atom paradigm
  * while simultaneously keeping its own separate, private list of Atoms.
  *
  * Header File:  platform_helper.h
**/
Atom WBGetAtom(Display *pDisplay, const char *szAtomName);

/** \ingroup platform
  * \brief Lookup (but do not allocate) an internal (or X11) Atom for a named string
  *
  * \param pDisplay The display to search for a matching X11 Atom
  * \param szAtomName The text 'Atom name' to search for an Atom
  * \returns An Atom representing the specified szAtomName.  For values less than WB_INTERNAL_ATOM_MIN_VAL, it will be an X11 Atom.  Otherwise, the value will be 'internal only'
  *
  * If an atom is not found, this function will return 'None'.  It does not allocate a new atom.
  *
  * This function will lookup an internal (or X11) Atom based on the specified Atom name.  If the Atom
  * name exists as an X11 Atom, or already exists as an internal atom, the function will return that value.
  * Otherwise, this function will return 'None'.
  *
  * An internal atom will have a value >= WB_INTERNAL_ATOM_MIN_VAL
  *
  * NOTE:  If an X11 Atom with a matching name exists, along with an 'internal' definition, the internal
  * definition will be returned.  This is to prevent problems with a 'race condition' on an atom name.
  *
  * If you need a globally defined atom with the matching name, use 'XInternAtom' instead.  Internally defined
  * atoms must never be used with other applications, window properties, or the window manager.
  *
  * The X11 workbench toolkit makes use of Atoms for menu and dialog box events.  To prevent flooding the X11 server with
  * a lot of unnecessary proprietary Atom names, this function lets X11 workbench continue to use the Atom paradigm
  * while simultaneously keeping its own separate, private list of Atoms.
  *
  * Header File:  platform_helper.h
**/
Atom WBLookupAtom(Display *pDisplay, const char *szAtomName);

/** \ingroup platform
  * \brief Lookup and/or allocate an internal Atom for a named string
  *
  * \param pDisplay The display to search for a matching X11 Atom
  * \param aAtom The Atom to return the text for
  * \returns An allocated pointer containing the 'Atom name' text string.  This pointer will need to be free'd using WBFree() (it is created via 'WBCopyString()')
  *
  * This function returns the Atom name (as an allocated character string) associate with the specified Atom,
  * whether the Atom is an X11 Atom or an internal 'X11 workbench toolkit' Atom.
  *
  * The X11 workbench toolkit makes use of Atoms for menu and dialog box events.  To prevent flooding the X11 server with
  * a lot of unnecessary proprietary Atom names, this function lets X11 workbench continue to use the Atom paradigm
  * while simultaneously keeping its own separate, private list of Atoms.  This function is intended to be compatible
  * with the X11 function 'XGetAtomName()' to simplify the implementation of the application's code.
  *
  * A non-NULL return value must be free'd using 'WBFree()' rather than 'XFree()' (as it would have been with 'XGetAtomName()').
  * This is primarily for future cross-platform compatibility.
  *
  * Header File:  platform_helper.h
**/
char * WBGetAtomName(Display *pDisplay, Atom aAtom);




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                               //
//   ____         _    _                              _   _____                         _____  _  _              //
//  |  _ \  __ _ | |_ | |__   ___    __ _  _ __    __| | |_   _|___  _ __ ___   _ __   |  ___|(_)| |  ___  ___   //
//  | |_) |/ _` || __|| '_ \ / __|  / _` || '_ \  / _` |   | | / _ \| '_ ` _ \ | '_ \  | |_   | || | / _ \/ __|  //
//  |  __/| (_| || |_ | | | |\__ \ | (_| || | | || (_| |   | ||  __/| | | | | || |_) | |  _|  | || ||  __/\__ \  //
//  |_|    \__,_| \__||_| |_||___/  \__,_||_| |_| \__,_|   |_| \___||_| |_| |_|| .__/  |_|    |_||_| \___||___/  //
//                                                                             |_|                               //
//                                                                                                               //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// *******************************************
// FILE/APPLICATION SEARCH PATH AND TEMP FILES
// *******************************************

/** \ingroup platform
  * \brief Run an application asynchronously
  *
  * \param szFileName A const pointer to a character string containing a file or path name
  * \returns A 'WBAlloc() pointer to a character string containing the ACTUAL path to the file
  *
  * This function locates a file using the PATH environment variable and the value of 'szFileName'
  * by testing the file (or directory name) using 'stat'.  When the file (or directory) is located,
  * this function returns the path name as a 'WBAlloc() string.  If the file (or directory) cannot
  * be located, the function returns NULL.\n
  * The caller must 'WBFree()' any non-NULL pointer returned by this function.
  *
  * Header File:  platform_helper.h
**/
char * WBSearchPath(const char *szFileName);

/** \ingroup platform
  * \brief Get the name for a new, unique temporary file, creating the file in the process, and save its name for later deletion
  *
  * \param szExt A const pointer to a string containing the file's extension (without the '.'), or NULL if no extension is desired.
  * \returns A 'WBAlloc() pointer to a character string containing fully qualified path to the file
  *
  * This function obtains a unique temporary file name and then creates the file with a zero length,
  * returning the name of the file in a WBAlloc() character string.  On error, it returns NULL.\n
  * The actual location of the temporary file depends upon platform-specific parameters, such as
  * environment variables and system settings.\n
  * The caller must 'WBFree()' any non-NULL pointer returned by this function.\n
  * This function preserves the name of the file in a list of temporary files that need to be deleted once the
  * application has terminated.  This way an external application can keep the file open indefinitely, or even
  * re-read the file, without negative effects.  The 'WBPlatformOnExit()' function will delete all temporary files
  * that have been previously created by 'WBTempFile'.
  *
  * Header File:  platform_helper.h
**/
char * WBTempFile(const char *szExt);


/** \ingroup platform
  * \brief Get the name for a new, unique temporary file, creating the file in the process
  *
  * \param szExt A const pointer to a string containing the file's extension (without the '.'), or NULL if no extension is desired.
  * \returns A 'WBAlloc() pointer to a character string containing fully qualified path to the file
  *
  * This function obtains a unique temporary file name and then creates the file with a zero length,
  * returning the name of the file in a WBAlloc() character string.  On error, it returns NULL.\n
  * The actual location of the temporary file depends upon platform-specific parameters, such as
  * environment variables and system settings.\n
  * The caller must 'WBFree()' any non-NULL pointer returned by this function.
  *
  * Header File:  platform_helper.h
**/
char * WBTempFile0(const char *szExt);



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                       //
//   _____        _                             _      _                   _  _              _    _                      //
//  | ____|__  __| |_  ___  _ __  _ __    __ _ | |    / \    _ __   _ __  | |(_)  ___  __ _ | |_ (_)  ___   _ __   ___   //
//  |  _|  \ \/ /| __|/ _ \| '__|| '_ \  / _` || |   / _ \  | '_ \ | '_ \ | || | / __|/ _` || __|| | / _ \ | '_ \ / __|  //
//  | |___  >  < | |_|  __/| |   | | | || (_| || |  / ___ \ | |_) || |_) || || || (__| (_| || |_ | || (_) || | | |\__ \  //
//  |_____|/_/\_\ \__|\___||_|   |_| |_| \__,_||_| /_/   \_\| .__/ | .__/ |_||_| \___|\__,_| \__||_| \___/ |_| |_||___/  //
//                                                          |_|    |_|                                                   //
//                                                                                                                       //
//                          _                _   ____                                                                    //
//                         / \    _ __    __| | |  _ \  _ __  ___    ___  ___  ___  ___   ___  ___                       //
//                        / _ \  | '_ \  / _` | | |_) || '__|/ _ \  / __|/ _ \/ __|/ __| / _ \/ __|                      //
//                       / ___ \ | | | || (_| | |  __/ | |  | (_) || (__|  __/\__ \\__ \|  __/\__ \                      //
//                      /_/   \_\|_| |_| \__,_| |_|    |_|   \___/  \___|\___||___/|___/ \___||___/                      //
//                                                                                                                       //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// *********************
// SPAWNING APPLICATIONS
// *********************

#ifdef WIN32
#define WB_FILE_HANDLE HANDLE
#define WB_PROCESS_ID HANDLE
#define WB_INVALID_FILE_HANDLE INVALID_HANDLE_VALUE
#else // !WIN32
#define WB_FILE_HANDLE int
#define WB_PROCESS_ID unsigned int
#define WB_INVALID_FILE_HANDLE -1
#endif // WIN32
/** \ingroup process
  * \brief Run an application asynchronously
  *
  * \param szAppName A const pointer to a character string containing the path to the application
  * \returns A valid process ID or process handle, depending upon the operating system
  *
  * Use this function to spawn an asynchronous process.  The function returns an invalid process ID
  * or process handle on error.  If the process ID is an allocated resource, the caller must free it.
  * Each additional parameter passed to this function is a parameter that is to be passed to the program.
  * The final parameter in the list must be NULL, so any call to this function will need to have at
  * least 2 parameters.
  *
  * Header File:  platform_helper.h
**/
WB_PROCESS_ID WBRunAsync(const char *szAppName, ...);

/** \ingroup process
  * \brief Run an application synchronously, returning 'stdout' output in a character buffer.
  *
  * \param szAppName A const pointer to a character string containing the path to the application
  * \returns A WBAlloc() pointer to a buffer containing the 'stdout' output from the application.
  *
  * Use this function to run an external process and capture its output.  This function will ignore the
  * error return code from the program, so if this information is necessary, you should write a different
  * function (based on this one) using 'WBRunAsync' and a wait loop, etc. that checks the application's
  * return value on exit.
  * Each additional parameter passed to this function is a parameter that is to be passed to the program.
  * The final parameter in the list must be NULL, so any call to this function will need to have at
  * least 2 parameters.
  * On error this function returns a NULL value.  Any non-NULL value must be 'free'd by the caller using WBFree().
  *
  * Header File:  platform_helper.h
**/
char * WBRunResult(const char *szAppName, ...);

/** \ingroup process
  * \brief Run an application synchronously, returning 'stdout' output in a character buffer.
  *
  * \param szStdInBuf A const pointer to 0-byte terminated string/buffer containing the input for piped data.
  * \param szAppName A const pointer to a character string containing the path to the application
  * \returns A WBAlloc() pointer to a buffer containing the 'stdout' output from the application.
  *
  * Use this function to run an external process, providing a buffer that contains data to be sent to the
  * applications 'stdin', and in the process, capture its output.  This function will ignore the
  * error return code from the program, so if this information is necessary, you should write a different
  * function (based on this one) using 'WBRunAsync' and a wait loop, etc. that checks the application's
  * return value on exit.
  * Each additional parameter passed to this function is a parameter that is to be passed to the program.
  * The final parameter in the list must be NULL, so any call to this function will need to have at
  * least 2 parameters.
  * On error this function returns a NULL value.  Any non-NULL value must be 'free'd by the caller using WBFree().\n
  *
  * To create piped output, pass the result of the previous 'WBRunResult' or 'WBRunResultPipe' as the
  * 'szStdInBuf' parameter to a subsequent 'WBRunResultPipe' call.
  *
  * Header File:  platform_helper.h
**/
char * WBRunResultPipe(const char *szStdInBuf, const char *szAppName, ...);


/** \ingroup process
  * \brief Run an application asynchronously, specifying file handles for STDIN, STDOUT, and STDERR
  *
  * \param hStdIn A WB_FILE_HANDLE for STDIN, or WB_INVALID_FILE_HANDLE
  * \param hStdOut A WB_FILE_HANDLE for STDOUT, or WB_INVALID_FILE_HANDLE
  * \param hStdErr A WB_FILE_HANDLE for STDERR, or WB_INVALID_FILE_HANDLE.  This can be the same handle as hStdErr, though interleaved output may not occur as expected.
  * \param szAppName A const pointer to a character string containing the path to the application
  * \returns A valid process ID or process handle, depending upon the operating system
  *
  * Use this function to spawn an asynchronous process in which you want to track STDIN, STDOUT,
  * and/or STDERR.  The function returns an invalid process ID or process handle
  * on error.  If the process ID is an allocated resource, the caller must free it.
  * Each additional parameter passed to this function will become a parameter that is to be passed to the program.
  * The final parameter in the list must be NULL to mark the end of the list, so any call to this function will
  * need to have at least 5 parameters.\n
  * If you do not want to re-direct a file handle, pass 'WB_INVALID_FILE_HANDLE' for its value.  It is
  * also possible to pass the SAME file handle for hStdIn, hStdOut, and hStdErr provided that it has
  * the correct read/write access available.  File handled passed to this function will be duplicated,
  * but not closed.  It is also safe to close the original file handles immediately after calling this
  * function.\n
  * You can monitor 'WB_PROCESS_ID' to find out if the process is running.  Additionally, you can use
  * the output of hStdOut and hStdErr by re-directing them to anonymous pipes and monitoring their activity.
  *
  * Header File:  platform_helper.h
**/
WB_PROCESS_ID WBRunAsyncPipe(WB_FILE_HANDLE hStdIn, WB_FILE_HANDLE hStdOut, WB_FILE_HANDLE hStdErr,
                             const char *szAppName, ...);


/** \ingroup process
  * \brief Run an application asynchronously, specifying file handles for STDIN, STDOUT, and STDERR, using a va_list for the program's parameters
  *
  * \param hStdIn A WB_FILE_HANDLE for STDIN, or WB_INVALID_FILE_HANDLE
  * \param hStdOut A WB_FILE_HANDLE for STDOUT, or WB_INVALID_FILE_HANDLE
  * \param hStdErr A WB_FILE_HANDLE for STDERR, or WB_INVALID_FILE_HANDLE.  This can be the same handle as hStdErr, though interleaved output may not occur as expected.
  * \param szAppName A const pointer to a character string containing the path to the application
  * \param va A va_list of the arguments (the final one must be NULL)
  * \returns A valid process ID or process handle, depending upon the operating system
  *
  * This function is identical to WBRunAsyncPipe() except that the variable argument list is passed as a va_list.\n
  * Use this function to spawn an asynchronous process in which you want to track STDIN, STDOUT,
  * and/or STDERR.  The function returns an invalid process ID or process handle
  * on error.  If the process ID is an allocated resource, the caller must free it.
  * Parameters passed to this function as part of the va_list are parameters that are to be passed to the program.
  * The final parameter in the va_list must be NULL to mark the end of the list.\n
  * If you do not want to re-direct a file handle, pass 'WB_INVALID_FILE_HANDLE' for its value.  It is
  * also possible to pass the SAME file handle for hStdIn, hStdOut, and hStdErr provided that it has
  * the correct read/write access available.  File handles passed to this function will be duplicated,
  * but not closed.  It is also safe to close the original file handles immediately after calling this
  * function.\n
  * You can monitor 'WB_PROCESS_ID' to find out if the process is running.  Additionally, you can use
  * the output of hStdOut and hStdErr by re-directing them to anonymous pipes and monitoring their activity.
  *
  * This function is used internally by the other process control functions, and is defined here in case
  * you need to write a customized version of one of the process control functions.  A typical example might
  * be the use of stderr rather than stdout for WBRunResult().
  *
  * Header File:  platform_helper.h
**/
WB_PROCESS_ID WBRunAsyncPipeV(WB_FILE_HANDLE hStdIn, WB_FILE_HANDLE hStdOut, WB_FILE_HANDLE hStdErr,
                              const char *szAppName, va_list va);




///////////////////////////////////////////////////////////////////////
//   ____  _   _    _    ____  _____ ____    _     ___ ____ ____     //
//  / ___|| | | |  / \  |  _ \| ____|  _ \  | |   |_ _| __ ) ___|    //
//  \___ \| |_| | / _ \ | |_) |  _| | | | | | |    | ||  _ \___ \    //
//   ___) |  _  |/ ___ \|  _ <| |___| |_| | | |___ | || |_) |__) |   //
//  |____/|_| |_/_/   \_\_| \_\_____|____/  |_____|___|____/____/    //
//                                                                   //
///////////////////////////////////////////////////////////////////////

/** \ingroup process
  * \brief Loads a shared library, DLL, module, or whatever you call it on your operating system
  *
  * \param szModuleName A const pointer to a character string containing the path for the library, module, DLL, or whatever
  * \returns A valid WB_MODULE module handle, depending upon the operating system
  *
  * This function is identical to LoadLibrary() under Windows, and calls 'dlopen()' on POSIX systems
  *
  * Header File:  platform_helper.h
**/
WB_MODULE WBLoadLibrary(const char *szModuleName); // load a library module (shared lib, DLL, whatever)

/** \ingroup process
  * \brief Frees a shared library, DLL, module, or whatever, that was loaded via 'WBLoadLibrary()'
  *
  * \param hModule A valid WB_MODULE module handle, as returned by WBLoadLibrary()
  *
  * This function is identical to FreeLibrary() under Windows, and calls 'dlfree()' on POSIX systems
  *
  * Header File:  platform_helper.h
**/
void WBFreeLibrary(WB_MODULE hModule);

/** \ingroup process
  * \brief Loads a shared library, DLL, module, or whatever you call it on your operating system
  *
  * \param hModule A valid WB_MODULE module handle, as returned by WBLoadLibrary()
  * \param szProcName A const pointer to a character string containing the proc name
  * \returns A valid WB_MODULE module handle, depending upon the operating system
  *
  * This function is identical to GetProcAddress() under Windows, and calls 'dlproc()' on POSIX systems
  *
  * Header File:  platform_helper.h
**/
WB_PROCADDRESS WBGetProcAddress(WB_MODULE hModule, const char *szProcName);



//////////////////////////////////////////////////////
//   _____ _   _ ____  _____    _    ____  ____     //
//  |_   _| | | |  _ \| ____|  / \  |  _ \/ ___|    //
//    | | | |_| | |_) |  _|   / _ \ | | | \___ \    //
//    | | |  _  |  _ <| |___ / ___ \| |_| |___) |   //
//    |_| |_| |_|_| \_\_____/_/   \_\____/|____/    //
//                                                  //
//////////////////////////////////////////////////////

/** \ingroup threads
  * \brief Allocate 'thread local' storage
  *
  * \returns The 'key' that identifies the thread local storage data slot
  *
  * Allocate thread local storage, returning the identifier to that local storage slot
  *
  * Header File:  platform_helper.h
**/
WB_THREAD_KEY WBThreadAllocLocal(void);

/** \ingroup threads
  * \brief Free 'thread local' storage allocated by WBThreadAllocLocal()
  *
  * \returns The 'key' that identifies the thread local storage data slot
  *
  * Free an allocate thread local storage slot
  *
  * Header File:  platform_helper.h
**/
void WBThreadFreeLocal(WB_THREAD_KEY keyVal);

/** \ingroup threads
  * \brief Get 'thread local' data identified by 'keyVal'
  *
  * \param keyVal the 'WB_THREAD_KEY' identifier of the thread local data - see WBThreadAllocLocal()
  * \returns The stored thread-specific data value, or NULL if not assigned
  *
  * Get the data associated with a thread local storage slot
  *
  * Header File:  platform_helper.h
**/
void * WBThreadGetLocal(WB_THREAD_KEY keyVal);

/** \ingroup threads
  * \brief Get 'thread local' data identified by 'keyVal'
  *
  * \param keyVal the 'WB_THREAD_KEY' identifier of the thread local data - see WBThreadAllocLocal()
  * \param pValue the value to assign for thread local data
  *
  * Assign (set) the data associated with a thread local storage slot
  *
  * Header File:  platform_helper.h
**/
void WBThreadSetLocal(WB_THREAD_KEY keyVal, void *pValue);


// simplified thread support (cross-platform)

/** \ingroup threads
  * \brief Get 'current thread' identifier
  *
  * \returns The WB_THREAD associated with the current thread
  *
  * Returns a 'WB_THREAD' resource representing the current thread.  This returned value should
  * NOT be free'd using WBThreadClose(), nor waited on with WBThreadWait().
  *
  * Header File:  platform_helper.h
**/
WB_THREAD WBThreadGetCurrent(void);

/** \ingroup threads
  * \brief Create a new thread, returning its WB_THREAD identifier
  *
  * \param function A pointer to the callback function that runs the thread
  * \param pParam The parameter to be passed to 'function' when it start
  * \returns A WB_THREAD thread identifier, or INVALID_HANDLE_VALUE on error
  *
  * Call this function to create a new thread using standard attributes.
  *
  * Header File:  platform_helper.h
**/
WB_THREAD WBThreadCreate(void *(*function)(void *), void *pParam);

/** \ingroup threads
  * \brief Wait for a specified threat to exit
  *
  * \param hThread the WB_THREAD identifier
  * \returns The return value from the thread's thread proc or 'WBThreadExit()'
  *
  * Call this function to wait for a thread to complete and/or obtain its exit code.
  * This function will block until the thread has terminated or is canceled (pthreads only).
  *
  * Header File:  platform_helper.h
**/
void *WBThreadWait(WB_THREAD hThread);        // closes hThread, returns exit code, waits for thread to terminate (blocks)

/** \ingroup threads
  * \brief Determine whether a thread is running (can be suspended)
  *
  * \param hThread the WB_THREAD identifier
  * \returns A value > 0 if the thread is running, < 0 on error, == 0 if the thread has ended and has a return code.
  *
  * Use this function to determine whether a thread is still running.  For a thread that has exited, it will return 0
  * indicating that there is an exit code available.  If the thread has terminated (invalidating its WB_THREAD identifier)
  * the function will return a value < 0.  otherwise, The return value is > 0 indicating the thread is still active.\n
  * NOTE:  an active thread that has been suspended will return a value > 0.
  *
  * Header File:  platform_helper.h
**/
int WBThreadRunning(WB_THREAD hThread);

/** \ingroup threads
  * \brief Exit the current thread immediately, specifying return code
  *
  * \param pRval The return code for the exiting thread
  *
  * Call this function to exit the current thread immediately, specifying a return code\n
  * NOTE:  when the thread proc returns, it implies a call to WBThreadExit() on completion, using the return
  *        value as the exit code.
  *
  * Header File:  platform_helper.h
**/
void WBThreadExit(void *pRval);

/** \ingroup threads
  * \brief Close the specified WB_THREAD identifier
  *
  * \param hThread the WB_THREAD identifier
  *
  * Call this function to close the WB_THREAD thread identifier specified by 'hThread'.  Not closing the
  * thread identifier can result in a 'zombie' thread that consumes resources.  By closing the handle, you
  * can allow a thread to run to its completion, and automatically delete the associated resources on exit.
  * You should not call this function after a call to WBThreadWait()\n
  * NOTE:  internally it calls either pthread_detach or CloseHandle (depending)
  *
  * Header File:  platform_helper.h
**/
void WBThreadClose(WB_THREAD hThread);


/** \ingroup threads
  * \brief Create a signallable condition
  *
  * \param pCond A pointer to the WB_COND that will be created (could be a struct or just a pointer)
  * \returns A zero value if successful; non-zero on error
  *
  * Use this function to create a 'condition' that can be signaled using WBCondSignal()\n
  * This is roughly the equivalent of an 'Event' object on MS Windows
  *
  * Header File:  platform_helper.h
**/
int WBCondCreate(WB_COND *pCond);

/** \ingroup threads
  * \brief Create a lockable mutex
  *
  * \param pMtx A pointer to the WB_MUTEX that will be created (could be a struct or just a pointer)
  * \returns A zero value if successful; non-zero on error
  *
  * Use this function to create a 'mutex' synchronization object that can be locked by only a single thread at a time
  *
  * Header File:  platform_helper.h
**/
int WBMutexCreate(WB_MUTEX *pMtx);

/** \ingroup threads
  * \brief Free a signallable condition
  *
  * \param pCond a pointer to the WB_COND signallable condition
  *
  * Use this function to free a WB_COND that was previously allocated with WBCondCreate()
  *
  * Header File:  platform_helper.h
**/
void WBCondFree(WB_COND *pCond);

/** \ingroup threads
  * \brief Free a lockable mutex
  *
  * \param pMtx a pointer to the WB_MUTEX lockable mutex object
  *
  * Use this function to free a WB_MUTEX that was previously allocated with WBMutexCreate()
  *
  * Header File:  platform_helper.h
**/
void WBMutexFree(WB_MUTEX *pMtx);

/** \ingroup threads
  * \brief Wait for and lock a mutex, blocking until it is available
  *
  * \param pMtx a pointer to the WB_MUTEX lockable mutex object
  * \param nTimeout the timeout period in microseconds, or a negative value to indicate 'INFINITE'
  * \returns A zero if the lock succeeded, a value > 0 if the lock period timed out, or a negative value indicating error
  *
  * This function attempts to lock the WB_MUTEX and returns a zero value if it succeeds, blocking for the period
  * of time specified by 'nTimeout' (in microseconds).  A negative 'nTimeout' causes an infinite waiting period.
  * The function will return a positive value if the timeout period was exceeded, or a negative value on error.
  *
  * Header File:  platform_helper.h
**/
int WBMutexLock(WB_MUTEX *pMtx, int nTimeout);

/** \ingroup threads
  * \brief Unlock a previously locked mutex
  *
  * \param pMtx a pointer to the WB_MUTEX lockable mutex object
  * \returns A zero if the unlock succeeded, non-zero on error
  *
  * This function unlocks a previously locked mutex
  *
  * Header File:  platform_helper.h
**/
int WBMutexUnlock(WB_MUTEX *pMtx);

/** \ingroup threads
  * \brief Signal a condition (event)
  *
  * \param pCond a pointer to the WB_COND condition object
  * \returns A zero if the signal succeeded, or non-zero on error
  *
  * This function signals a condition so that a waiting process will 'wake up'
  * see WBCondWait() and WBCondWaitMutex()
  *
  * Header File:  platform_helper.h
**/
int WBCondSignal(WB_COND *pCond);

/** \ingroup threads
  * \brief Wait for a signal on a condition (event)
  *
  * \param pCond a poiner to the WB_COND condition object
  * \param nTimeout the timeout (in microseconds), or a value < 0 to indicate 'INFINITE'
  * \returns A zero if the condition was triggered, a value > 0 on timeout, or a value < 0 on error
  *
  * This function waits up to a specified time (in microseconds), or indefinitely if the specified
  * wait time is negative, until the condition object 'hCond' has been signaled.  See WBCondSignal()
  *
  * Header File:  platform_helper.h
**/
int WBCondWait(WB_COND *pCond, int nTimeout);

/** \ingroup threads
  * \brief Wait for a signal on a condition (event)
  *
  * \param pCond a pointer to the WB_COND condition object
  * \param pMtx a pointer to a locked WB_MUTEX object
  * \param nTimeout the timeout (in microseconds), or a value < 0 to indicate 'INFINITE'
  * \returns A zero if the condition was triggered, a value > 0 on timeout, or a value < 0 on error
  *
  * This function waits up to a specified time (in microseconds), or indefinitely if the specified
  * wait time is negative, until the condition object 'hCond' has been signaled.  See WBCondSignal()\n
  * Additionally, when the waiting process begins, the WB_MUTEX referenced by 'hMtx' will be unlocked,
  * until the condition referenced by 'hCond' has been signaled, or the timeout period has been exceeded.
  * At that point, the mutex 'hMtx' will be re-locked (waiting indefinitely for the lock to be successful)\n
  * Upon return, 'hMtx' will be locked again by the calling thread.  'hMtx' must be already locked before
  * calling this function.  It will remain unlocked during the wait state.
  *
  * Header File:  platform_helper.h
**/
int WBCondWaitMutex(WB_COND *pCond, WB_MUTEX *pMtx, int nTimeout);


/** \ingroup threads
  * \brief Interlocked 'atomic' decrement of an unsigned integer
  *
  * \param pValue - a pointer to an 'unsigned int' to be decremented atomically.  Must be a valid pointer
  * \returns The new value stored in 'pValue' after decrementing
  *
  * This function performs an interlocked 'atomic' decrement of an unsigned integer,
  * guaranteeing that at the time the value is decremented, no other thread is allowed
  * to read or modify the value until the function returns.
  *
  * Header File:  platform_helper.h
**/
WB_UINT32 WBInterlockedDecrement(volatile WB_UINT32 *pValue);


/** \ingroup threads
  * \brief Interlocked 'atomic' increment of an unsigned integer
  *
  * \param pValue - a pointer to an 'unsigned int' to be incremented atomically.  Must be a valid pointer
  * \returns The new value stored in 'pValue' after incrementing
  *
  * This function performs an interlocked 'atomic' increment of an unsigned integer,
  * guaranteeing that at the time the value is incremented, no other thread is allowed
  * to read or modify the value until the function returns.
  *
  * Header File:  platform_helper.h
**/
WB_UINT32 WBInterlockedIncrement(volatile WB_UINT32 *pValue);


/** \ingroup threads
  * \brief Interlocked 'atomic' exchange of an unsigned integer with a specified value
  *
  * \param pValue - a pointer to an 'unsigned int' to be exchanged with the specified value.  Must be a valid pointer.
  * \param nNewVal - the new value to assign to 'pValue' atomically
  * \returns The old value previously stored in 'pValue' after exchanging
  *
  * This function performs an interlocked 'atomic' assignment of an unsigned integer,
  * guaranteeing that at the time the value is assigned, no other thread is allowed
  * to read or modify the value until the function returns.  The previous value is returned
  * by the function, effectively 'exchanging' the value with one that you specify.
  *
  * Header File:  platform_helper.h
**/
WB_UINT32 WBInterlockedExchange(volatile WB_UINT32 *pValue, WB_UINT32 nNewVal);


/** \ingroup threads
  * \brief Interlocked 'atomic' read of an unsigned integer
  *
  * \param pValue - a pointer to an 'unsigned int' to be read.  Must be a valid pointer.
  * \returns The value stored in 'pValue' after reading.  The value will be read while write operations have been 'locked out'
  *
  * This function performs an interlocked 'atomic' read of an unsigned integer,
  * guaranteeing that at the time the value is read, no other thread is allowed
  * to modify the value.  Once read, the value can still change; however, the value
  * as-read will be 'atomic' i.e. not a partially changed value.
  *
  * Header File:  platform_helper.h
**/
WB_UINT32 WBInterlockedRead(volatile WB_UINT32 *pValue);



//////////////////////////////////////////////////////
//   ____  ____  ___ _   _ _____ ___ _   _  ____    //
//  |  _ \|  _ \|_ _| \ | |_   _|_ _| \ | |/ ___|   //
//  | |_) | |_) || ||  \| | | |  | ||  \| | |  _    //
//  |  __/|  _ < | || |\  | | |  | || |\  | |_| |   //
//  |_|   |_| \_\___|_| \_| |_| |___|_| \_|\____|   //
//                                                  //
//////////////////////////////////////////////////////

// NOTE:  the POSIX world uses postscript, particularly with CUPS.  So does this library.

/** \ingroup printer
  * \brief Send postscript file to a printer (using lpr-cups or lpr on POSIX systems)
  *
  * \param szPrinterName the unique (system) name of the printer
  * \param szFileName the name of the file containing the postscript data
  * \returns Zero on success, non-zero on error.
  *
  * Use this function to send pre-prepared postscript data to a printer.  On POSIX
  * systems, it invokes 'lpr-cups' or 'lpr'.  On non-POSIX systems, its operation is
  * system-dependent.  The version of 'lpr' that is run will be the CUPS version,
  * whenever it is installed.  On some systems this may require installing the 'bsd'
  * compatible CUPS utilities\n
  * NOTE: This function may need to translate the postscript data into the
  * raw printer format on non-POSIX systems, as needed.  The 'ghostscript' package
  * can do this, if present.  Other options may be added as required.  Entries in
  * the 'printcap' file can configure the ghostscript filter for raster printers.\n
  * NOTE 2:  some Linux packages require installing the cups version of lpr separately
  * and possibly EXCLUSIVELY from the system version, example debian 'cups-bsd' vs 'lpr'.\n
  * NOTE 3:  newer Linux versions don't support printcap mods based on CUPS.  Using the
  * IPP protocol to discover printers is probably a better idea.\n
  * NOTE 4:  may need to dynamically link to CUPS libraries, as needed, or invoke
  * ghostscript and/or lpd directly.  Additional support for PDF, etc. may be in order.\n
  * NOTE 5:  'ipptool' may be the best CUPS method of sending files to a printer\n
  * example:  ipptool -4 -t http://localhost:631/printers/printername get-printer-attributes.test
  *
  * Header File:  platform_helper.h
**/
int WBPrintPostScriptFile(const char *szPrinterName, const char *szFileName);

/** \ingroup printer
  * \brief Get a list of printer names
  *
  * \returns a 'WBAlloc() pointer to a list of zero-byte terminated strings containing the printer names, ending with 2 zero-bytes
  *
  * Use this function to get a list of printer names that can be used with WBPrintPostScriptFile().
  * On POSIX systems, it will be information from '/usr/local/etc/printcap' or '/etc/printcap'.
  * When CUPS is installed, the '/usr/local/etc/printcap' or '/etc/printcap' file is maintained by CUPS.
  * On non-POSIX systems, this function generates a system-dependent list of printers, which might
  * consist of port names, or actual printer names, or a combination thereof.\n
  * NOTE:  for IPP see RFC2911 section 4.4 and other related RFCs to request printer info.  'ipptest' may help
  * resolve how to make these things work.\n
  * NOTE 2:  for CUPS, use 'lpstat -s' and filter the output to get the printer names.  URL should be
  *          http://localhost:631/printers/printername\n
  * NOTE 3:  fallback to /etc/printcap /usr/local/etc/printcap and other sources
  *
  * Header File:  platform_helper.h
**/
char *WBGetPrinterList(void);

// TODO:  complete IPP support for cups and network-capable printers

// TODO:  printer capabilities in a binary structure

// TODO:  support for port 515 'printer' TCP/UDP printer services (i.e. cups-lpd or lpd)

// TODO:  dynamically load CUPS API when available. see 'cups-config' application docs



#ifdef __cplusplus
};
#endif // __cplusplus


#endif // _PLATFORM_HELPER_H_INCLDUED_

