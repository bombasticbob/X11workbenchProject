//////////////////////////////////////////////////////////////////////////////////////////
//                                  __     _            _          _                    //
//               ___  ___   _ __   / _|   | |__    ___ | | _ __   | |__                 //
//              / __|/ _ \ | '_ \ | |_    | '_ \  / _ \| || '_ \  | '_ \                //
//             | (__| (_) || | | ||  _|   | | | ||  __/| || |_) |_| | | |               //
//              \___|\___/ |_| |_||_|_____|_| |_| \___||_|| .__/(_)_| |_|               //
//                                  |_____|               |_|                           //
//                                                                                      //
//                helper API for 'conf' files (global and per-user)                     //
//                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2016 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no waranties, either implied or explicit.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/


// conf file format:
// [section header]
// data identifier=data value

/** \file conf_help.h
  * \brief 'configuration helper' main header file for the X11 Work Bench Toolkit API
  *
  * X11 Work Bench Toolkit Toolkit API
**/

/** \defgroup conf_file Configuration File Utilities
  * \ingroup conf_help
  *
  * \brief Configuration File Utilities, for application or user-defined config files
**/

/** \defgroup desktop_settings Desktop Settings utilities
  * \ingroup conf_help
  *
  * \brief Desktop Settings Utilities, to query desktop-defined settings like fonts, colors, mouse click times, etc.
**/

/** \defgroup text_xml XML-specific Text Utilities
  * \ingroup text
  *
  * \brief Specialized text utility functions for parsing XML data
**/


#ifndef CONF_HELPER_H_INCLUDED
#define CONF_HELPER_H_INCLUDED

#include "platform_helper.h" /* this also includes the X11 headers */

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


#ifndef GLOBAL_PATH /* this can be defined by the config script */
#warning "GLOBAL_PATH not defined, assuming /usr/local/etc"
#define GLOBAL_PATH "/usr/local/etc"
#endif // GLOBAL_PATH

#ifndef GLOBAL_XPATH /* this can be defined by the config script */
#warning "GLOBAL_XPATH not defined, assuming /usr/X11R6/etc"
#define GLOBAL_XPATH "/usr/X11R6/etc"
// NOTE:  on some systems, like freebsd, /usr/X11R6 is a symlink matching GLOBAL_PATH
#endif // GLOBAL_XPATH

#define LOCAL_PATH  "~/"
#define LOCAL_CONF_NAME "settings" /* local conf name will be ~/.appname/settings.conf, or if that is not possible, ~/appname.conf */

#define CH_OPEN_TIMEOUT 5000 /* wait up to 5000 milliseconds before timing out */


/** \ingroup conf_file
  @{
**/
#define CH_FLAGS_DEFAULT 0    /**< default flags for \ref CHOpenConfFile() */
#define CH_FLAGS_GLOBAL  0x1  /**< set this for 'global only' for \ref CHOpenConfFile() */
#define CH_FLAGS_WRITE   0x2  /**< set this to enable GLOBAL write (local write automatically enabled) for \ref CHOpenConfFile() */
/**
  @}
**/

/** \ingroup startup
  * \brief registers arguments from the command line for later use
  *
  * \param argc The 'argc' as passed-in to main()
  * \param argv The 'argv' as passed-in to main()
  *
  * This function registers the arguments from 'argv' as passed in to the main() for the
  * application, and keeps an independent record of their contents for future use by any
  * part of the program that might have use for this kind of information.
  *
  * Header File:  conf_help.h
**/
void CHRegisterArgs(int argc, char **argv);  // call in 'main'

/** \ingroup startup
  * \brief frees resources used by \ref conf_help
  *
  * call this prior to normal application exit to free resources.  Called by \ref WBExit() .
  *
  * Header File:  conf_help.h
**/
void CHOnExit(void);

/** \ingroup startup
  * \brief retrieves the array of arguments stored by \ref CHRegisterArgs()
  *
  * \returns the 'argv' value stored by \ref CHRegisterArgs()
  *
  * Use this function to retrieve the stored 'argv' value from \ref CHRegisterArgs()
  *
  * Header File:  conf_help.h
**/
const char * const *CHGetArgV(void);

/** \ingroup startup
  * \brief retrieves the argument count stored by \ref CHRegisterArgs()
  *
  * \returns the 'argc' value stored by \ref CHRegisterArgs()
  *
  * Use this function to retrieve the stored 'argc' value from \ref CHRegisterArgs()
  *
  * Header File:  conf_help.h
**/
int CHGetArgC(void);

/** \ingroup desktop_settings
  * \brief Queries desktop resource strings (may become deprecated)
  *
  * \param pDisplay Display pointer (NULL for default)
  * \param szIdentifier The item to query
  * \param szData Output buffer
  * \param cbData Size of the output buffer in bytes
  * \return length of string (excluding zero byte) or -1 if error or no matching identifier
  *
  * This queries string values from the 'Old' resource manager.  This function is deprecated.
  * Some window managers may still supporte it, however, so it's worth keeping for now.
  *
  * Header File:  conf_help.h
**/
int CHGetResourceString(Display *pDisplay,const char *szIdentifier, char *szData, int cbData);

/** \ingroup desktop_settings
  * \brief Queryies desktop resource integer values (from strings) (may become deprecated)
  *
  * \param pDisplay The Display pointer (NULL for default)
  * \param szIdentifier The item to query
  * \return the queried integer value, or 0 if error or no matching identifier
  *
  * This queries integer values from the 'Old' resource manager.  This function is deprecated.
  * Some window managers may still supporte it, however, so it's worth keeping for now.
  *
  * Header File:  conf_help.h
**/
int CHGetResourceInt(Display *pDisplay,const char *szIdentifier);



//////////////////////////////////
// configuration file  management
//////////////////////////////////

/** \ingroup conf_file
  * \brief open configuration file for read/write, optionally creating it, based on application name
  *
  * \param szAppName The name of the application for which a configuration file is to be opened (no extension)
  * \param iFlags One or more of the CH_FLAGS, specifically CH_FLAGS_DEFAULT, CH_FLAGS_GLOBAL, or CH_FLAGS_WRITE
  * \return pointer to a configuration file object that can be queried, or NULL on error
  *
  * open conf file (if it exists), optionally for writing.  Creates file as needed (write mode only)\n
  * write mode for global config may require root privileges\n
  * when done, you must close the returned configuration file object pointer with \ref CHCloseConfFile\n
  * The function may block as needed.  Use \ref CHDestroyConfFile to close AND free memory resources.
  *
  * Header File:  conf_help.h
**/
void * CHOpenConfFile(const char *szAppName, int iFlags);

/** \ingroup conf_file
  * \brief close configuration file opened by \ref CHOpenConfFile(), but does NOT free memory resources
  *
  * \param hFile The configuration file object returned by \ref CHOpenConfFile()
  *
  * Use this function to close the configuration file that was opened by \ref CHOpenConfFile()\n
  * Memory resources will NOT be freed (values will remain cached as needed).  Use this function to simply
  * remove the open file reference but leave the data in memory for later use.
  *
  * Header File:  conf_help.h
**/
void CHCloseConfFile(void * hFile);

/** \ingroup conf_file
  * \brief destroy configuration file opened by \ref CHOpenConfFile(), freeing memory resources (but not the files)
  *
  * \param hFile The configuration file object returned by \ref CHOpenConfFile()
  *
  * This function will close the configuration file and destroy the cached information created by \ref CHOpenConfFile()
  * but does not physically destroy the file on disk.
  *
  * Header File:  conf_help.h
**/
void CHDestroyConfFile(void * hFile);

/** \ingroup conf_file
  * \brief obtain a string from a configuration file
  *
  * \param hFile the configuration file object pointer returned by \ref CHOpenConfFile
  * \param szSection a pointer to an ASCII 0-byte terminated string containing the section name
  * \param szIdentifier a pointer to an ASCII 0-byte terminated string identifying the (unique) data entry
  * \param szData a buffer in which to return the string data
  * \param cbData the size of the buffer pointed to by szData
  * \return the total length of the string (excluding the zero byte), or -1 on error (or if value not found)
  *
  * Use this function to obtain a configuration parameter 'szIdentifier' from section 'szSection', and save
  * the data into 'szData', which is 'cbData' bytes in length.  The function will return the total length
  * of the resulting string.  The function returns -1 on error, or if the data value is not located.
  *
  * Header File:  conf_help.h
**/
int CHGetConfFileString(void * hFile, const char *szSection,
                        const char *szIdentifier, char *szData, int cbData);

/** \ingroup conf_file
  * \brief write a string to a configuration file
  *
  * \param hFile the configuration file object pointer returned by \ref CHOpenConfFile
  * \param szSection a pointer to an ASCII 0-byte terminated string containing the section name
  * \param szIdentifier a pointer to an ASCII 0-byte terminated string identifying the (unique) data entry
  * \param szData a buffer pointer to an ASCII 0-byte terminated string containing the data value
  * \return non-zero value on success, or zero on error
  *
  * Writes a string value to the configuration file for 'szIdentifier' in 'szSection'.  The function returns a
  * non-zero value if successful, or a value of 0 if an error occurred.
  *
  * Header File:  conf_help.h
**/
int CHWriteConfFileString(void * hFile, const char *szSection,
                          const char *szIdentifier, const char *szData);


/** \ingroup conf_file
  * \brief obtain an integer value from a configuration file
  *
  * \param hFile the configuration file object pointer returned by \ref CHOpenConfFile
  * \param szSection a pointer to an ASCII 0-byte terminated string containing the section name
  * \param szIdentifier a pointer to an ASCII 0-byte terminated string identifying the (unique) data entry
  * \return the integer value, or zero on error or if not found
  *
  * Use this function to query an integer value for 'szIdentifier' in 'szSection'.  The function will return
  * a non-zero value on success, or a zero value on error, or if not found.\n
  * If you need to distinguish an actual zero value from an error or 'not found' condition, consider using
  * the \ref CHGetConfFileString() function instead.
  *
  * Header File:  conf_help.h
**/
int CHGetConfFileInt(void * hFile, const char *szSection, const char *szIdentifier);

/** \ingroup conf_file
  * \brief write an integer value to a configuration file
  *
  * \param hFile the configuration file object pointer returned by \ref CHOpenConfFile
  * \param szSection a pointer to an ASCII 0-byte terminated string containing the section name
  * \param szIdentifier a pointer to an ASCII 0-byte terminated string identifying the (unique) data entry
  * \param iData the integer data value
  * \return non-zero value on success, or zero on error
  *
  * Writes an integer value to the configuration file for 'szIdentifier' in 'szSection'.  The function returns a
  * non-zero value if successful, or a value of 0 if an error occurred.
  *
  * Header File:  conf_help.h
**/
int CHWriteConfFileInt(void * hFile, const char *szSection, const char *szIdentifier, int iData);



// XSETTINGS

/** \ingroup desktop_settings
  * \brief refresh the internally cached X settings
  *
  * \param pDisplay The Display pointer (NULL for default)
  *
  * This function will refresh the internally cached X settings using various methods to query the
  * system's parameter storage, some deprecated, some in accordance with the latest window manager specs.
  *
  * Header File:  conf_help.h
**/
void CHSettingsRefresh(Display *pDisplay);  // call this to re-read and re-build XSettings info

// X11 settings collection

/** \ingroup desktop_settings
  * \brief Enumeration for 'XSettingsType' which describes the type of setting being cached
**/
enum XSettingsType
{
  XSettingsTypeInteger = 0, ///< The setting is an integer
  XSettingsTypeString = 1,  ///< The setting is a 0-byte terminated ASCII string
  XSettingsTypeColor = 2    ///< The setting is an RGBA Color stored as \ref XSETTINGS_DATA_COLOR
};


/** \ingroup desktop_settings
  * \struct __XSETTINGS_DATA_COLOR__
  * \copydoc XSETTINGS_DATA_COLOR
**/
/** \ingroup desktop_settings
  * \typedef XSETTINGS_DATA_COLOR
  * \brief Structure for storing configuration color information, \ref XSettingsTypeColor
  *
  * This structure is part of the X11 Window Manager specification, and is defined here for use
  * by the X11Workbench toolkit.
  *
  * \code

  typedef struct __XSETTINGS_DATA_COLOR__ // also used internally by XSettings
  {
    unsigned short sRed;    // 16-bit RGB value for RED
    unsigned short sBlue;   // 16-bit RGB value for Blue
    unsigned short sGreen;  // 16-bit RGB value for Green
    unsigned short sAlpha;  // 16-bit ALPHA value.  If not used, it will be 0xffff
  } __PACKED__ XSETTINGS_DATA_COLOR;

  * \endcode
  *
**/
typedef struct __XSETTINGS_DATA_COLOR__ // also used internally by XSettings
{
  unsigned short sRed;    ///< 16-bit RGB value for RED
  unsigned short sBlue;   ///< 16-bit RGB value for Blue
  unsigned short sGreen;  ///< 16-bit RGB value for Green
  unsigned short sAlpha;  ///< 16-bit ALPHA value.  If not used, it will be 0xffff
} __PACKED__ XSETTINGS_DATA_COLOR;


/** \ingroup desktop_settings
  * \struct _CHXSetting_
  * \copydoc CHXSetting
**/
/** \ingroup desktop_settings
  * \typedef CHXSetting
  * \brief Structure for storing settings information internally
  *
  * This structure is used internally by the \ref conf_help to cache configuration information obtained
  * from the Window Manager or from the (deprecated) system configuration.
  *
  * \code

  typedef struct _CHXSetting_
  {
    const char *szName;              // pointer to the NAME string within memory that follows CHXSettings::aData
    int   iType;                     // The setting type (\ref XSettingsType enumeration)
    int   iLen;                      // length (where applicable)
    unsigned int uiSerial;           // serial # from last XSETTINGS [endian-ized]
    union
    {
      int iData;                     // The data as an integer value
      WB_INT64 llData;               // Reserved element, forces 64-bit size
      XSETTINGS_DATA_COLOR clrData;  // The data as a color value
      void *pData;                   // un-typed pointer to data within string area
      char *szData;                  // 'char' typed pointer to data within string area
    } uData;                         // union of the data alias'
  }  __PACKED__ CHXSetting;

  * \endcode
  *
**/
typedef struct _CHXSetting_
{
  const char *szName;              ///< pointer to the NAME string within memory that follows CHXSettings::aData
  int   iType;                     ///< The setting type (\ref XSettingsType enumeration)
  int   iLen;                      ///< length (where applicable)
  unsigned int uiSerial;           ///< serial # from last XSETTINGS [endian-ized]
  union
  {
    int iData;                     ///< The data as an integer value
    WB_INT64 llData;               ///< Reserved element, forces 64-bit size
    XSETTINGS_DATA_COLOR clrData;  ///< The data as a color value
    void *pData;                   ///< un-typed pointer to data within string area
    char *szData;                  ///< 'char' typed pointer to data within string area
  } uData;                         ///< union of the data alias'
}  __PACKED__ CHXSetting;


/** \ingroup desktop_settings
  * \struct _CHXSettings_
  * \copydoc CHXSettings
**/
/** \ingroup desktop_settings
  * \typedef CHXSettings
  * \brief Array wrapper for \ref CHXSetting cache
  *
  * This structure wraps the array of \ref CHXSetting structures and any variable length data that
  * it might reference.  It is the internal format for the settings array and can be retrieved by
  * calling \ref CHGetXSettings()
  *
  * \code

  typedef struct _CHXSettings_
  {
    Display *pDisplay;      // identifies which display it belongs to (reserved)
    int nSettings;          // the total number of settings in aData
    unsigned int uiSerial;  // serial number from last XSETTINGS query
    CHXSetting aData[1];    // An array of 'nSettings' \ref CHXSetting structures.  Binary and string data directly follows the array.
  } CHXSettings;

  * \endcode
  *
**/
typedef struct _CHXSettings_
{
  Display *pDisplay;      ///< identifies which display it belongs to (reserved)
  int nSettings;          ///< the total number of settings in aData
  unsigned int uiSerial;  ///< serial number from last XSETTINGS query
  CHXSetting aData[1];    ///< An array of 'nSettings' \ref CHXSetting structures.  Binary and string data directly follows the array.
} CHXSettings;


/** \ingroup desktop_settings
  * \brief returns a pointer to the cached X settings
  *
  * \param pDisplay The Display pointer (NULL for default)
  *
  * Returns a (const) pointer to the \ref CHXSettings structure that wraps the cached X settings
  *
  * Header File:  conf_help.h
**/
const CHXSettings * CHGetXSettings(Display *pDisplay);

/** \ingroup desktop_settings
  * \brief returns a pointer to a specific X setting entry by name
  *
  * \param pDisplay The Display pointer (NULL for default)
  * \param szSettingName The name of the setting as a 0-byte terminated string
  * \returns A const pointer to the cached CHXSetting structure
  *
  * Use this function to query a specific CHXSetting structure via the setting name
  *
  * Header File:  conf_help.h
**/
const CHXSetting * CHGetXSetting(Display *pDisplay, const char *szSettingName);


/** \ingroup desktop_settings
  * \brief returns default double click time (from X settings)
  *
  * \param pDisplay The Display pointer (NULL for default)
  * \returns default double-click time in milliseconds
  *
  * Returns default double-click time in milliseconds
  *
  * Header File:  conf_help.h
**/
int CHGetDoubleClickTime(Display *pDisplay);

/** \ingroup desktop_settings
  * \brief returns default double click distance (from X settings)
  *
  * \param pDisplay The Display pointer (NULL for default)
  * \returns default double-click 'slop' distance in pixels
  *
  * Returns double-click 'slop' distance in pixels
  *
  * Header File:  conf_help.h
**/
int CHGetDoubleClickDistance(Display *pDisplay);

/** \ingroup desktop_settings
  * \brief returns default drag threshold (from X settings)
  *
  * \param pDisplay The Display pointer (NULL for default)
  * \returns default drag threshold in pixels
  *
  * Returns default drag threshold in pixels
  *
  * Header File:  conf_help.h
**/
int CHGetDragThreshold(Display *pDisplay);

/** \ingroup desktop_settings
  * \brief returns default cursor blink 'enable' flag (from X settings)
  *
  * \param pDisplay The Display pointer (NULL for default)
  * \returns default cursor blink 'enable' flag (non-zero to enable blink)
  *
  * Returns the default cursor blink 'enable' flag, zero to disable, non-zero to enable.
  *
  * Header File:  conf_help.h
**/
int CHGetCursorBlink(Display *pDisplay);

/** \ingroup desktop_settings
  * \brief returns default cursor blink time (from X settings)
  *
  * \param pDisplay The Display pointer (NULL for default)
  * \returns default cursor blink time in milliseconds
  *
  * Returns the default cursor blink time in milliseconds
  *
  * Header File:  conf_help.h
**/
int CHGetCursorBlinkTime(Display *pDisplay);



// XML help

/** \ingroup text_xml
  * \brief Parses contents of an XML tag, returning as malloc'd string list similar to environment strings
  *
  * \param pTagContents A pointer to the string position just past the tag name
  * \param cbLength The length of the tag contents up the trailing '>'.  Preceding characters
  * (such as '-->' or '/>') will be ignored, as well as the trailing '>'
  * \returns A malloc'd string list, similar in format to 'environ'; i.e. "VALUE=xxxx xxxx xxxx\0"
  * with possible embedded quotes (not doubled or '\'d) ending in a zero byte.
  * The end is marked with an additional '\0'
  *
  * Generic XML tag parsing.  Parse the tag to 'just past the tag name', find the ending '>',
  * and pass that length as 'cbLength'.
  *
  * Header File:  conf_help.h
**/
char *CHParseXMLTagContents(const char *pTagContents, int cbLength);

/** \ingroup text_xml
  * \brief Parses contents of an XML tag to find the end of it
  *
  * \param pTagContents A pointer to the string position just past the tag name
  * \return A pointer to the '>' at the end of the XML tag
  *
  * Generic XML tag parsing.  Parse the tag to find its end.  The returned pointer will
  * either be the end of the string, or a pointer to the ending '>'.
  *
  * Header File:  conf_help.h
**/
const char *CHFindEndOfXMLTag(const char *pTagContents);



// MIME type help

/** \ingroup desktop_settings
  * \brief Get the MIME type for a particular file name or extension
  *
  * \param szFileName A const pointer to a string containing the filename or '.ext' for which to obtain the MIME type
  * \returns 'malloc'd pointer to a zero-byte terminated character string containing the MIME type
  *
  * This function will return NULL on error, or a malloc'd pointer to a string.  Caller must free any non-NULL pointer
  * returned by this function.
  *
  * Header File:  conf_help.h
**/
char *CHGetFileMimeType(const char *szFileName);

/** \ingroup desktop_settings
  * \brief Get the default application for a particular MIME type
  *
  * \param szMimeType A const pointer to a character string containing the MIME type
  * \returns 'malloc'd pointer to a zero-byte terminated character string containing the default application name
  *
  * In the case of a '.desktop' file name being returned, use CHGetDesktopFileInfo() to obtain the actual path name
  * and other information associated with the application.
  *
  * This function will return NULL on error, or a malloc'd pointer to a string.  Caller must free any non-NULL pointer
  * returned by this function.
  *
  * Header File:  conf_help.h
**/
char *CHGetMimeDefaultApp(const char *szMimeType);

/** \ingroup desktop_settings
  * \brief Get the default application for a particular MIME type
  *
  * \param szDesktopFile A const pointer to a character string containing the desktop file name
  * \param szInfo A const pointer to a character string containing the tag for the desired information
  * \returns 'malloc'd pointer to a zero-byte terminated character string containing the desired information
  *
  * This function will return NULL on error, or a malloc'd pointer to a string.  Caller must free any non-NULL pointer
  * returned by this function.
  *
  * Header File:  conf_help.h
**/
char *CHGetDesktopFileInfo(const char *szDesktopFile, const char *szInfo);



// debug
#ifndef NO_DEBUG

/** \ingroup desktop_settings
  * \brief dump config information using debug output functions
  *
  * Debug function to dump config information using the debug output functions
  *
  * Header File:  conf_help.h
**/
void CHDumpConfig(void);

#endif // NO_DEBUG

#ifdef __cplusplus
};
#endif // __cplusplus


#endif // CONF_HELPER_H_INCLUDED

