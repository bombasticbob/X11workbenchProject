//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//    _               _               _      _              _       _       //
//   | |_  ___ __  __| |_       ___  | |__  (_)  ___   ___ | |_    | |__    //
//   | __|/ _ \\ \/ /| __|     / _ \ | '_ \ | | / _ \ / __|| __|   | '_ \   //
//   | |_|  __/ >  < | |_     | (_) || |_) || ||  __/| (__ | |_  _ | | | |  //
//    \__|\___|/_/\_\ \__|_____\___/ |_.__/_/ | \___| \___| \__|(_)|_| |_|  //
//                       |_____|          |__/                              //
//                                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2019 by Bob Frazier (aka 'Big Bad Bombastic Bob')


  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.
               Any claims to alleged functionality or features should be
               considered 'preliminary', and might not function as advertised.

  MIT-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  MIT-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/


/** \file text_object.h
  * \brief A 'C++'-like object for managing text, that can be overridden for custom behavior
  *
  * X11workbench Toolkit API 'text object' for copying and drawing text, determining
  * text extents for rendering, managing edits and undo for a block of text, and
  * so on.  In short it encapsulates the core functionality for managing a block
  * of editable and/or viewable text.
**/

/** \defgroup text_object_definitions Definitions associated with Text Objects
  * \ingroup text_object
  * \brief Definitions associated with Text Objects
  *
  * The definitions associated with Text Objects, including various 'enum' types
**/
/** \defgroup text_object_structures Structures associated with Text Objects
  * \ingroup text_object
  * \brief Structures associated with Text Objects
  *
  * The structures associated with Text Objects, including the 'VTABLE' structure
  * and associated Text Object 'member' functions
**/
/** \defgroup text_object_utils Text Object utility functions
  * \ingroup text_object
  * \brief Utility functions for managing Text Objects
  *
  * Utility functions for managing Text Objects.
**/
/** \defgroup text_object_multibyte Multi-Byte Character Set utility functions
  * \ingroup text_object
  * \brief 'Multi-Byte' Character Set utility functions
  *
  * Utility functions for working with Multi-Byte character sets (MBCS).  These are
  * primarily intended for use with 'Text Objects'.
  *
**/

/** \headerfile <>
**/



#ifndef _TEXT_OBJECT_H_INCLUDED_
#define _TEXT_OBJECT_H_INCLUDED_

#include "window_helper.h"

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


// FILE TYPE CONSTANTS

/** \ingroup text_object_definitions
  * \brief file types for TEXT_OBJECT
  *
  * A list of supported 'file types' for a Text Object.  See also get_filetype(), set_filetype()
  *
**/
enum e_FileType
{
  FileType_PLAIN_TEXT    = 0,       ///< no special handling, no source decorations
  FileType_PROGRAM       = 1,       ///< program source
  FileType_RESOURCE      = 2,       ///< 'resource' file, text-based format
  FileType_XML           = 3,       ///< XML data (includes HTML)
  FileType_MAKEFILE      = 4,       ///< Make Files with special handling (implies 'hard tab', always)

  FileType_CUSTOM_FLAG   = 0x80,    ///< 'custom' file types - 'or' with custom definition (0-0x7f)

  FileType_MASK          = 0xff,    ///< a bitmask for the various file types.  Perform a logical 'and' of the file type value with this, and then you can compare it as being equal to one of the other 'FileType_' constants

  // additional bits are reserved (for now)

  // and now the bit flags
  FileType_HARDTAB       = 0x10000, ///< hard tabs - implied by 'FileType_MAKEFILE', otherwise explicit
  FileType_RESERVED2     = 0x20000, ///< reserved 2
  FileType_RESERVED3     = 0x40000, ///< reserved 3
  FileType_RESERVED4     = 0x80000  ///< reserved 4
};

/** \ingroup text_object_definitions
  * \brief line feed (line ending) types for TEXT_OBJECT
  *
  * This is a list of acceptable line ending types.  See also get_linefeed(), set_linefeed()
**/
enum e_LineFeed
{
  LineFeed_NONE          = -1,  ///< single line
  LineFeed_DEFAULT       = 0,   ///< default for OS
  LineFeed_NEWLINE       = 1,   ///< POSIX newline 0AH
  LineFeed_RETURN        = 2,   ///< OSX return 0DH
  LineFeed_CRLF          = 3,   ///< CRLF 0DH,0AH
  LineFeed_LFCR          = 4,   ///< LFCR 0AH,0DH
  LineFeed_ENTRYCOUNT    = 5    ///< reserved - specifies custom array, indicating the size of the array containing the character values, excluding negative indices
};

/** \ingroup text_object_definitions
  * \brief select mode types for TEXT_OBJECT
  *
  * This is a list of acceptable 'select modes', that determine how multi-line text is selected.  See also get_selmode(), set_selmode()
**/
enum e_SelectMode
{
  SelectMode_DEFAULT    = 0,    ///< DEFAULT (typically CHAR)
  SelectMode_CHAR       = 1,    ///< CHAR (i.e. stream)
  SelectMode_LINE       = 2,    ///< LINE (always selects entire line when spanning multiple lines)
  SelectMode_BOX        = 3     ///< BOX (selects a 'box' using virtual spacing)
};

/** \ingroup text_object_definitions
  * \brief Insert/Overwrite mode for TEXT_OBJECT
  *
  * This is a list of acceptable 'insert/overwrite' modes.  See also get_insmode(), set_insmode()
**/
enum e_InsertMode
{
  InsertMode_DEFAULT     = 0,   ///< system default, usually 'insert'
  InsertMode_INSERT      = 1,   ///< INSERT mode, character inserted at cursor
  InsertMode_OVERWRITE   = 2    ///< OVERWRITE mode, character inserted on top of character to the right of the cursor (if any), else inserted
};

/** \ingroup text_object_definitions
  * \brief State flags for mouse/cursor 'drag' (i.e. selection)
  *
  * This is a list of acceptable "drag states", maintained internally.  See also begin_mouse_drag(), end_mouse_drag()
  * and the use of the 'shift' modifier with cursor keys via begin_highlight() and end_highlight()
**/
enum e_DragState
{
  DragState_NONE         = 0,   ///< no drag in progress
  DragState_CURSOR       = 1,   ///< cursor 'drag' (select mode)
  DragState_MOUSE        = 2    ///< mouse 'drag' (select mode)
};

/** \ingroup text_object_definitions
**/
#define HARD_TAB_CHAR '\xa0' /**< A 'hard tab' is represented internally by this character */

/** \ingroup text_object_definitions
**/
#define DEFAULT_TAB_WIDTH 8 /**< the default width for a hard tab in a TEXT_OBJECT */

/** \ingroup text_object_definitions
**/
#define AUTO_HSCROLL_SIZE 8 /**< the number of characters to auto-hscroll by to get the cursor inside the viewport */

/** \ingroup text_object_definitions
**/
#define MIN_LINE_SPACING 2 /**< the minimum number of pixels by which lines are separated (normally will be 'descent / 2') */

/** \ingroup text_object_definitions
**/
#define MIN_BORDER_SPACING 2 /**< the minimum number of pixels separating the text from the window border (when unspecified) */


// define the interface for the object

//struct s_text_object; // forward declaration
typedef struct s_text_object TEXT_OBJECT; // forward declaration

/** \ingroup text_object_structures
  * \copydoc TEXT_OBJECT_VTABLE
**/
struct s_text_object_vtable
{
  /** \brief Call this prior to de-allocating memory to free up any internal objects or storage
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \return void
  **/
  void (* destroy)(TEXT_OBJECT *pThis);

  /** \brief Call this to initialize or re-initialize an object.  Must call 'destroy' first for an existing object.
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \return void
  **/
  void (* init)(TEXT_OBJECT *pThis);

  /** \brief Call this to assign the highlight colors.  Default colors are WBGC's BG and FG
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param clrHFG The XColor for the highlighted foreground
    * \param clrHBG The XColor for the highlighted background
    * \return void
  **/
  void (* highlight_colors)(TEXT_OBJECT *pThis, XColor clrHFG, XColor clrHBG);

  /** \brief Call this function to get all text, formatted so that it can be saved to a file
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \return A 'WBAlloc'd pointer to the selected text.
    *
    * This function allocates a buffer, then copies all of the text to the buffer using
    * the specified line endings and other information.
  **/
  char * (* get_text)(TEXT_OBJECT *pThis);

  /** \brief Call this function to re-assign all text in the control
    *
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param szText A pointer to the text to replace the selection with (NULL or "" effectively empties the buffer)
    * \param cbLen The length of the text to replace the selection with (zero implies 'zero-byte terminated string' for szText)
    * \return void
    *
    * Typically this is called when a file is (re)loaded or when the 'caption' is changed for the control.
    * Calling this function will perform a number of related functions, such as cursor positioning.\n
    * You should manually force a re-draw of the control displaying the text.  It will not happen automatically.
  **/
  void (* set_text)(TEXT_OBJECT *pThis, const char *szText, unsigned long cbLen);

  /** \brief Call this function to obtain the total number of rows for display purposes
    *
    * \param pThis A const pointer to the TEXT_OBJECT structure
    * \return The total row count including the last row, even if it is blank.  If the text is empty, the return value is zero
    *
    * This function returns the row count.  If the final line is blank, the row count will still include it.
    * The return value is intended to assist scrolling the viewable area, so a final blank line must still
    * be counted.  Single-line text always returns a 1 unless the text is empty.  A zero is always returned
    * whenever there is no text in the object.  This allows you to detect an 'empty' text object.
  **/
  int (* get_rows)(const TEXT_OBJECT *pThis);

  /** \brief Call this function to obtain the estimated column extent of the document.
    *
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \return The total column extent, estimated and periodically re-calculated.  If the text is empty, the value is zero
    *
    * This function returns the estimated column count, the maximum extent of any line within the text object.
    * While editing, if the column count of a single line exceeds the current 'maximum', a new maximum will be
    * calculated in &quot;tab widths&quot;.  Periodically this value will be re-estimated as needed to accomodate
    * changes to the text.\n
    * NOTE:  the pointer to the TEXT_OBJECT cannot be a 'const' in this case, since cached values may need
    * to be re-evaluated as part of the process of obtaining the desired information.
  **/
  int (* get_cols)(TEXT_OBJECT *pThis);

  /** \brief Get the current linefeed type for the object
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \return an integer indicating the current file type, one of the 'file type' definitions
    *
    * A file type of 0 is 'plain text'.  A file type of '-1' is 'Makefile' and by default, preserves hard tabs.
    * Other file types are defined as one of the 'file type' constants
  **/
  int (* get_filetype)(const TEXT_OBJECT *pThis);

  /** \brief Set the current file type for the object
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param iInsMode An integer indicating the new file type, one of the 'file type' definitions
    * \return void
    *
    * A file type of 0 is 'plain text'.  A file type of '-1' is 'Makefile' and by default, preserves hard tabs.
    * Other file types are defined as one of the 'file type' constants
  **/
  void (* set_filetype)(TEXT_OBJECT *pThis, int iLineFeed);

  /** \brief Get the current linefeed type for the object
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \return an integer indicating the current 'linefeed' type for end of line
    *
    * iLineFeed  values:  0 (single line)  1 (newline) 2 (return) 3 (crlf) 4 (lfcr)
  **/
  int (* get_linefeed)(const TEXT_OBJECT *pThis);

  /** \brief Set the current linefeed type for the object
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param iInsMode An integer indicating the new 'linefeed' type for end of line
    * \return void
    *
    * iLineFeed  values:  0 (single line)  1 (newline) 2 (return) 3 (crlf) 4 (lfcr)
  **/
  void (* set_linefeed)(TEXT_OBJECT *pThis, int iLineFeed);

  /** \brief Get the current insert mode for the object
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \return an integer indicating the current insert mode
  **/
  int (* get_insmode)(const TEXT_OBJECT *pThis);

  /** \brief Set the current insert mode for the object
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param iInsMode An integer indicating the new insert mode
    * \return void
  **/
  void (* set_insmode)(TEXT_OBJECT *pThis, int iInsMode);

  /** \brief Get the current selection mode for the object
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \return an integer indicating the current selection mode
  **/
  int (* get_selmode)(const TEXT_OBJECT *pThis);

  /** \brief Set the current selection mode for the object
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param iSelMode An integer indicating the new selection mode
    * \return void
  **/
  void (* set_selmode)(TEXT_OBJECT *pThis, int iSelMode);

  /** \brief Get the current tab type for the object
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \return an integer indicating the current tab type
    *
    * A positive tab type is the column width for a 'hard tab' character.  A negative
    * tab type indicates the tab column width but substitutes spaces for hard tabs.\n
    * NOTE:  Existing hard tabs within the text will be preserved even if a negative tab
    * type is selected, so long as the white space covered by the tab is not modified.\n
    * A tab type of zero uses the 'default' behavior for the application and file type.
  **/
  int (* get_tab)(const TEXT_OBJECT *pThis);

  /** \brief Set the current tab type for the object
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param iTab An integer indicating the new tab type
    * \return void
    *
    * A positive tab type is the column width for a 'hard tab' character.  A negative
    * tab type indicates the tab column width but substitutes spaces for hard tabs.\n
    * NOTE:  Existing hard tabs within the text will be preserved even if a negative tab
    * type is selected, so long as the white space covered by the tab is not modified.\n
    * A tab type of zero uses the 'default' behavior for the application and file type.
  **/
  void (* set_tab)(TEXT_OBJECT *pThis, int iTab);

  /** \brief Get the current scroll mode for the object
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \return an integer indicating the current scroll mode
  **/
  int (* get_scrollmode)(const TEXT_OBJECT *pThis);

  /** \brief Set the current scroll mode for the object
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param iScrollMode An integer indicating the new scroll mode
    * \return void
  **/
  void (* set_scrollmode)(TEXT_OBJECT *pThis, int iScrollMode);

  /** \brief Get the current selection rectangle as WB_RECT
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param pRct A pointer to the destination WB_RECT, receives the return value.  'No select' returns {0,0,0,0}
    * \return void
  **/
  void (* get_select)(const TEXT_OBJECT *pThis, WB_RECT *pRct);

  /** \brief Set the current selection rectangle as WB_RECT
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param pRct A const pointer to the source WB_RECT containing the new selection rectangle, or NULL for 'no selection'
    * \return void
  **/
  void (* set_select)(TEXT_OBJECT *pThis, const WB_RECT *pRct);

  /** \brief Returns a non-zero value if there is currently a 'selection'
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \return A non-zero integer if the selection rectangle is valid and not empty, otherwise zero.
  **/
  int (* has_select)(const TEXT_OBJECT *pThis);

  /** \brief get the current selection rectangle as WB_RECT
    *
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param pRct A const pointer to the source WB_RECT containing the selection rectangle.  NULL uses the current selection.
    * \return A 'WBAlloc'd pointer to the selected text.
    *
    * \details This function returns a 'WBAlloc'd pointer, or NULL on error.  If the returned pointer is not NULL, the caller must free it.\n
    * If the select mode is 'block', individual lines will always end in &lt;LF&gt;, and tabs will expand to &lt;space&gt; characters except
    * for the 'special case' noted below\n
    * In the special case of *pRct == {0,0,0,0}, all of the text will be copied, regardless of the select mode, in a format
    * consistent with saving the text as a file, using the assigned line ending.
  **/
  char* (* get_sel_text)(const TEXT_OBJECT *pThis, const WB_RECT *pRct);

  /** \brief Get the current row cursor for the object
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \return an integer indicating the current row
  **/
  int (* get_row)(const TEXT_OBJECT *pThis);

  /** \brief Set the current row cursor for the object
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param iRow The row position, where 0 is the top row
    * \return void
  **/
  void (* set_row)(TEXT_OBJECT *pThis, int iRow);

  /** \brief Get the current column cursor for the object
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \return an integer indicating the current column (independent of hard tabs or end of line)
  **/
  int (* get_col)(const TEXT_OBJECT *pThis);

  /** \brief Set the current column cursor for the object
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param iCol The column position, where 0 is the left-most column (independent of hard tabs or end of line).
    * \return void
    *
    * Passing '-1' for the 'iCol' parameter will place the cursor on the first non-white-space character on the line (if any).\n
    * Passing '-2' for the 'iCol' parameter will place the cursor at the end of the line, excluding any trailing white space.\n
    * Passing any other negative value is the same as passing '0'.
  **/
  void (* set_col)(TEXT_OBJECT *pThis, int iCol);

  /** \brief Delete the current selection assigned via 'set_select'
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \return void
  **/
  void (* del_select)(TEXT_OBJECT *pThis);

  /** \brief Replace the current selection assigned via 'set_select' with new text
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param szText A pointer to the text to replace the selection with (NULL or "" effectively performs 'del_select')
    * \param cbLen The length of the text to replace the selection with (zero implies 'zero-byte terminated string' for szText)
    * \return void
  **/
  void (* replace_select)(TEXT_OBJECT *pThis, const char *szText, unsigned long cbLen);

  /** \brief Delete 'n' characters from the current cursor.  Negative deletes BEFORE the cursor.  'newline' counts as 1 character.
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param nChar The number of characters to delete. Negative values delete BEFORE the cursor.  Zero does nothing.
    * \return void
  **/
  void (* del_chars)(TEXT_OBJECT *pThis, int nChar); // delete 1 or more chars, negative deletes BEFORE cursor, 0 does nothing

  /** \brief Insert 'n' characters (including new lines) from the current cursor.
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param pChar A pointer to the text to insert.  NULL effectively does nothing.
    * \param nChar The number of characters in the buffer pointed to by 'pChar', or 0 to indicate '0-byte terminated string'
    * \return void
    *
    * The behavior of multi-line insert depends upon the selection mode.  If 'char' or 'line' mode is selected, a 'newline'
    * inserts a new line following the newline character.  "\r\n", "\r", "\n", and "\n\r" are all treated the same.  Multiple
    * LF and CR combinations that vary in order/construct may produce unexpected results.  if 'box' mode is selected,
    * each subsequent line will be inserted at the next line's 'col' position.  Hard tabs will be evaluated during
    * insertion and converted to white space.  It is assumed that the length of each line in 'box' select mode will be
    * identical, but if it is not, the results will follow the length of the actual text.  If the 'box' select length
    * exceeds the last line of the file, the additional lines will be added as if in 'line' mode.
  **/
  void (* ins_chars)(TEXT_OBJECT *pThis, const char *pChar, int nChar);

  /** \brief Indent selected text by 'n' columns
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param nChar The number of characters to indent by.  negative indents left, positive right.  Zero does nothing.
    * \return void
    *
    * indents the selected text by 'n' columns.  Indent starts at the cursor and continues for each line within
    * the selected text.
  **/
  void (* indent)(TEXT_OBJECT *pThis, int nCol);

  /** \brief Indicate whether an 'undo' operation is possible (mostly for menu UI)
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \return An integer indicating whether 'undo' is possible.  A non-zero value is 'TRUE', zero 'FALSE.
  **/
  int (* can_undo)(TEXT_OBJECT *pThis);

  /** \brief Perform a single 'undo' operation
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \return void
  **/
  void (* undo)(TEXT_OBJECT *pThis);

  /** \brief Indicate whether a 'redo' operation is possible (mostly for menu UI)
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \return An integer indicating whether 'undo' is possible.  A non-zero value is 'TRUE', zero 'FALSE.
  **/
  int (* can_redo)(TEXT_OBJECT *pThis);

  /** \brief Perform a single 'redo' operation
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \return void
  **/
  void (* redo)(TEXT_OBJECT *pThis);

  /** \brief Get the current viewport (in characters)\.  The return value is not relevant if the expose method has not (yet) been called.
    *
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param pRct A pointer to a WB_RECT structure that receives the current viewport (in characters)
    * \return void
    *
    * The 'viewport' is the currently visible area (in characters).  It is independent of the cursor's row and column.
  **/
  void (* get_view)(const TEXT_OBJECT *pThis, WB_RECT *pRct);
  /** \brief Set the current viewport (in characters)\. Only 'left' and 'top' are relevant if the expose method has not (yet) been called.
    *
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param pOrig A const pointer to a WB_POINT structure that contains the new viewport origin (in characters)
    * \return void
    *
    * The 'viewport' is the currently visible area (in characters).  It is independent of the cursor's row and column.
    * You cannot assign the viewport size directly using this function.  It is derived from things like the font size
    * and the size of the display window.  You can assign the origin this way, to force the display window to display
    * an area of the text data beginning with the origin point.  This is useful for scrollbar handling.
  **/
  void (* set_view_orig)(TEXT_OBJECT *pThis, const WB_POINT *pOrig);

  /** \brief Begin a highlight block
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param pRct A const pointer to a WB_RECT structure that contains the new highlight block (in characters), or NULL to remove the highlight block
    * \return void
    *
    * This function is essentially a UI helper for cursor select.  When a cursor keystroke should cause a highlight to
    * occur, call this function to start a highlight block.  The current cursor will become the anchor, and subsequent
    * cursor motion will extend the highlight block.  A begin_highlight() will effectively do an end_mouse_drag()
    * but will not clear the current selection.  It is safe to call this function multiple times while selecting with
    * cursor keys from the keyboard; hence, a 'shift' cursor should call this every time to avoid state flag checks.
  **/
  void (* begin_highlight)(TEXT_OBJECT *pThis);
  /** \brief End a highlight block
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param pRct A const pointer to a WB_RECT structure that contains the new highlight block (in characters), or NULL to remove the highlight block
    * \return void
    *
    * This function is essentially a UI helper for cursor select.  Normally a keystroke that is NOT a cursor
    * motion will automatically end the highlighting.  Calling this function does not affect the highlighted area.
    * It is safe to call this function at any time, whether highlighting is taking place or not.
  **/
  void (* end_highlight)(TEXT_OBJECT *pThis);

  // mouse conversion

  /** \brief Translate mouse cursor position into actual row/column\.  This function is irrelevant if the expose method has not (yet) been called.
    *
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param iMouseXDelta The delta X position of the mouse cursor from the upper left corner of the viewport window
    * \param iMouseYDelta The delta Y position of the mouse cursor from the upper left corner of the viewport window
    * \param iType A bit mask indicating the mouse button (typically WB_POINTER_BUTTON1, or 0 for mouse motion during drag)
    * \param iACS A bit mask indicating ALT+CONTROL+SHIFT state (typically 0)
    * \return void
    *
    * Call this function to process mouse clicks properly.  It will cause the cursor to move, or a highlighted
    * area to be extended, depending on the nature of the mouse click.  Use begin_mouse_drag() and end_mouse_drag()
    * to indicate if a mouse drag operation (highlight an area) is in progress.\n
    * Mouse clicks automatically do an end_highlight() and clear the highlight area if a 'drag' is not in progress.
  **/
  void (* mouse_click)(TEXT_OBJECT *pThis, int iMouseXDelta, int iMouseYDelta, int iType, int iACS);

  /** \brief Begin a mouse 'drag' operation.
    *
    * \param pThis A pointer to the TEXT_OBJECT structure
    *
    * This function is essentially a UI helper for mouse drag-select.  Call this function in response to
    * a WB_POINTER_DRAG notification, then call mouse_click() with the WB_POINTER_MOVE notifications.
    * When the WB_POINTER_DROP notification arrives, call end_mouse_drag() to complete the operation.
  **/
  void (* begin_mouse_drag)(TEXT_OBJECT *pThis);
  /** \brief End a mouse 'drag' operation
    *
    * \param pThis A pointer to the TEXT_OBJECT structure
    *
    * This function is essentially a UI helper for mouse drag-select.
    * It is safe to call this function at any time, whether highlighting is taking place or not.
  **/
  void (* end_mouse_drag)(TEXT_OBJECT *pThis);

  // cursor motion

  /** \brief Move the current cursor position up one line
    * \param pThis A pointer to the TEXT_OBJECT structure
  **/
  void (* cursor_up)(TEXT_OBJECT *pThis);

  /** \brief Move the current cursor position down one line
    * \param pThis A pointer to the TEXT_OBJECT structure
  **/
  void (* cursor_down)(TEXT_OBJECT *pThis);

  /** \brief Move the current cursor position left one column
    * \param pThis A pointer to the TEXT_OBJECT structure
  **/
  void (* cursor_left)(TEXT_OBJECT *pThis);

  /** \brief Move the current cursor position right one column
    * \param pThis A pointer to the TEXT_OBJECT structure
  **/
  void (* cursor_right)(TEXT_OBJECT *pThis);

  /** \brief Move the current cursor position up one page
    * \param pThis A pointer to the TEXT_OBJECT structure
  **/
  void (* page_up)(TEXT_OBJECT *pThis);

  /** \brief Move the current cursor position down one page
    * \param pThis A pointer to the TEXT_OBJECT structure
  **/
  void (* page_down)(TEXT_OBJECT *pThis);

  /** \brief Move the current cursor position left one page
    * \param pThis A pointer to the TEXT_OBJECT structure
  **/
  void (* page_left)(TEXT_OBJECT *pThis);

  /** \brief Move the current cursor position right one page
    * \param pThis A pointer to the TEXT_OBJECT structure
  **/
  void (* page_right)(TEXT_OBJECT *pThis);

  /** \brief Move the cursor 'home' (left or BOL)
    * \param pThis A pointer to the TEXT_OBJECT structure
  **/
  void (* cursor_home)(TEXT_OBJECT *pThis);

  /** \brief Move the cursor to 'end' (full doc width or EOL)
    * \param pThis A pointer to the TEXT_OBJECT structure
  **/
  void (* cursor_end)(TEXT_OBJECT *pThis);

  /** \brief Move the cursor to the top line
    * \param pThis A pointer to the TEXT_OBJECT structure
  **/
  void (* cursor_top)(TEXT_OBJECT *pThis);

  /** \brief Move the cursor to the last line
    * \param pThis A pointer to the TEXT_OBJECT structure
  **/
  void (* cursor_bottom)(TEXT_OBJECT *pThis);

  /** \brief Scroll the viewport up/down by the specified number of rows
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param nRows The number of rows to scroll by; negative scrolls up, positive down
  **/
  void (* scroll_vertical)(TEXT_OBJECT *pThis, int nRows);

  /** \brief Scroll the cursor to the right/left a specified number of columns
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param nCols The number of columns to scroll by; negative scrolls left, positive right
  **/
  void (* scroll_horizontal)(TEXT_OBJECT *pThis, int nCols);


  // handling expose events for the text area

  /** \brief Member function to properly render the text in a window (Expose event)
    *
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param pDisplay A pointer to the Display for the window (NULL to use Default)
    * \param wID The Window ID for the window to be painted
    * \param gc The graphics context to use when painting
    * \param pPaintGeom A const pointer to a WB_GEOM structure bounding the invalid area (NULL implies ALL)
    * \param pViewGeom A const pointer to a WB_GEOM structure bounding the paintable area within the window (NULL implies entire window)
    * \param pFont A WB_FONTC to use in lieu of the font assigned to the Window (NULL if the Window's default font is used)
    *
    * Use this function in the Expose event callback for the window in order to properly
    * render the edit text.  Prior to calling this function you will need to assign the
    * correct foreground color, and background color to the WBGC.  If 'pFont' is NULL,
    * then the font must also be already assigned to the WBGC or to the Window; otherwise, the
    * specified font will be used to render the text.  Note that all fonts will be treate as if
    * they are 'fixed pitch' and so a variable pitch font will be rendered "centered" within the
    * character's position.\n
    *
    * The 'pViewGeom' member represents the bounding rectangle of the window 'wID' within which
    * to render the text, excluding any scroll bars.  Changes to this value may require
    * re-calculating the current 'view' area, which will attempt to preserve the relevant
    * area with respect to the current cursor position and/or visible text.\n
    *
    * This function will cache the Window ID as 'wIDOwner' for subsequent use by a number of
    * internal operations.  This ensures the most efficient expose handling.  Callers should
    * only invalidate areas handled by the TEXT_OBJECT when absolutely necessary.
    *
    * NOTE:  text color may be adjusted based on the type of buffer data being stored.  Some
    * buffered text data might have color information associated with it and as such the text
    * will be rendered using the appropriate color.  Color information is object-specific.\n
    *
    * See Also: WBTextObjectSetColorContextCallback()
  **/
  void (* do_expose)(TEXT_OBJECT *pThis, Display *pDisplay, Window wID,
                     WBGC gc, const WB_GEOM *pPaintGeom, const WB_GEOM *pViewGeom,
                     WB_FONTC pFont);

  /** \brief Periodic callback to 'blink' the cursor
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \param bHasFocus A non-zero value if the window has focus (cursor blinks), else zero (no cursor)
    *
    * This function will alter the 'blink' state of the cursor, generating Expose events as needed
    * to re-paint it within the window.  An owning window should call this function using the time
    * period specified by the system settings, but ONLY AFTER at least one 'do_expose' call.
  **/
  void (* cursor_blink)(TEXT_OBJECT *pThis, int bHasFocus);

  /** \brief Set the 'save point' with respect to the undo/redo buffer
    *
    * \param pThis A pointer to the TEXT_OBJECT structure
    *
    * Use this function to inform the text object when you have saved the file, and it
    * is no longer 'modified'.  In conjuction with undo/redo, this helps to maintain
    * the 'modified' state for the text object.
    *
    * use get_modified() to determine whether or not a file has been modified since the last
    * call to set_save_point().
    *
  **/
  void (* set_save_point)(TEXT_OBJECT *pThis);

  /** \brief Set the 'save point' with respect to the undo/redo buffer
    *
    * \param pThis A pointer to the TEXT_OBJECT structure
    * \return A non-zero value if the text object has been 'modified' since the last 'save' operation
    *
    * Use this function to obtain the 'changed' status of the text object.  A text object
    * that has been saved (or was just created) is considered to be 'unmodified'.  Otherwise,
    * anything that writes to the undo buffer/redo buffer that has not directly reverted back
    * to the 'as saved' content is considered "modified".
    *
    * use set_save_point() to mark a file as 'saved' and set it to 'unmodified'
    *
  **/
  int (* get_modified)(TEXT_OBJECT *pThis);


};

/** \ingroup text_object_structures
  * \brief 'vtable' structure for TEXT_OBJECT
  *
  * \code

  struct s_text_object_vtable
  {
    void (* destroy)(TEXT_OBJECT *pThis);
    void (* init)(TEXT_OBJECT *pThis);

    void (* highlight_colors)(TEXT_OBJECT *pThis, XColor clrHFG, XColor clrHBG);

    char * (* get_text)(TEXT_OBJECT *pThis);
    void (* set_text)(TEXT_OBJECT *pThis, const char *szText, unsigned long cbLen);

    int (* get_rows)(const TEXT_OBJECT *pThis);
    int (* get_cols)(TEXT_OBJECT *pThis);

    int (* get_filetype)(const TEXT_OBJECT *pThis);
    void (* set_filetype)(TEXT_OBJECT *pThis, int iLineFeed);

    int (* get_linefeed)(const TEXT_OBJECT *pThis);
    void (* set_linefeed)(TEXT_OBJECT *pThis, int iLineFeed);

    int (* get_insmode)(const TEXT_OBJECT *pThis);
    void (* set_insmode)(TEXT_OBJECT *pThis, int iInsMode);

    int (* get_selmode)(const TEXT_OBJECT *pThis);
    void (* set_selmode)(TEXT_OBJECT *pThis, int iSelMode);

    int (* get_tab)(const TEXT_OBJECT *pThis);
    void (* set_tab)(TEXT_OBJECT *pThis, int iTab);

    int (* get_scrollmode)(const TEXT_OBJECT *pThis);
    void (* set_scrollmode)(TEXT_OBJECT *pThis, int iScrollMode);

    void (* get_select)(const TEXT_OBJECT *pThis, WB_RECT *pRct);
    void (* set_select)(TEXT_OBJECT *pThis, const WB_RECT *pRct);
    int (* has_select)(TEXT_OBJECT *pThis);

    char* (* get_sel_text)(const TEXT_OBJECT *pThis, const WB_RECT *pRct);

    int (* get_row)(const TEXT_OBJECT *pThis);
    void (* set_row)(TEXT_OBJECT *pThis, int iRow);

    int (* get_col)(const TEXT_OBJECT *pThis);
    void (* set_col)(TEXT_OBJECT *pThis, int iCol);

    void (* del_select)(TEXT_OBJECT *pThis);
    void (* replace_select)(TEXT_OBJECT *pThis, const char *szText, unsigned long cbLen);

    void (* del_chars)(TEXT_OBJECT *pThis, int nChar);
    void (* ins_chars)(TEXT_OBJECT *pThis, const char *pChar, int nChar);

    void (* indent)(TEXT_OBJECT *pThis, int nCol);

    int (* can_undo)(TEXT_OBJECT *pThis);
    void (* undo)(TEXT_OBJECT *pThis);
    int (* can_redo)(TEXT_OBJECT *pThis);
    void (* redo)(TEXT_OBJECT *pThis);

    void (* get_view)(const TEXT_OBJECT *pThis, WB_RECT *pRct);
    void (* set_view_orig)(TEXT_OBJECT *pThis, const WB_POINT *pOrig);

    void (* begin_highlight)(TEXT_OBJECT *pThis);
    void (* end_highlight)(TEXT_OBJECT *pThis);

    // mouse conversion

    void (* mouse_click)(TEXT_OBJECT *pThis, int iMouseXDelta, int iMouseYDelta, int iType, int iACS);
    void (* begin_mouse_drag)(TEXT_OBJECT *pThis);
    void (* end_mouse_drag)(TEXT_OBJECT *pThis);

    // cursor motion

    void (* cursor_up)(TEXT_OBJECT *pThis);
    void (* cursor_down)(TEXT_OBJECT *pThis);
    void (* cursor_left)(TEXT_OBJECT *pThis);
    void (* cursor_right)(TEXT_OBJECT *pThis);

    void (* page_up)(TEXT_OBJECT *pThis);
    void (* page_down)(TEXT_OBJECT *pThis);
    void (* page_left)(TEXT_OBJECT *pThis);
    void (* page_right)(TEXT_OBJECT *pThis);

    void (* cursor_home)(TEXT_OBJECT *pThis);
    void (* cursor_end)(TEXT_OBJECT *pThis);
    void (* cursor_top)(TEXT_OBJECT *pThis);
    void (* cursor_bottom)(TEXT_OBJECT *pThis);

    void (* scroll_vertical)(TEXT_OBJECT *pThis, int nRows);
    void (* scroll_horizontal)(TEXT_OBJECT *pThis, int nCols);

    // handling expose events for the text area

    void (* do_expose)(const TEXT_OBJECT *pThis, Display *pDisplay, Window wID,
                       WBGC gc, const WB_GEOM *pPaintGeom, const WB_GEOM *pViewGeom,
                       WB_FONTC pFont);

    void (* cursor_blink)(TEXT_OBJECT *pThis, int bHasFocus);

    void (* set_save_point)(TEXT_OBJECT *pThis);
    int (* get_modified)(TEXT_OBJECT *pThis);

  };

  typedef struct s_text_object_vtable TEXT_OBJECT_VTABLE;

  * \endcode
**/
typedef struct s_text_object_vtable TEXT_OBJECT_VTABLE;



/** \ingroup text_object_utils
  * \brief returns the default vtable for a TEXT_OBJECT structure
  *
  * Use this function to get a copy of the pointer to the default 'TEXT_OBJECT' vtable.
  *
**/
static __inline__ const TEXT_OBJECT_VTABLE *WBGetDefaultTextObjectVTable(void)
{
extern const TEXT_OBJECT_VTABLE WBDefaultTextObjectVTable;

 return &WBDefaultTextObjectVTable;
}


/** \ingroup text_object_definitions
  * \brief The 'tag' for a TEXT_OBJECT structure
**/
#define TEXT_OBJECT_TAG (*((const unsigned int *)"WBTX"))


/** \ingroup text_object_structures
  * \copydoc TEXT_OBJECT
**/
struct s_text_object
{
  const TEXT_OBJECT_VTABLE *vtable;  ///< method function pointers (similar to C++ virtual member functions)

  unsigned int ulTag;        ///< tag word, always assigned to TEXT_OBJECT_TAG
  Window wIDOwner;           ///< owner window (cached from paint/expose handling and/or cursor blink)
  WB_RECT rctSel;            ///< select boundary in characters, {0,0,0,0} implies NONE, {-1,x,x,x} implies ALL.  if top == bottom, assume single-line
  WB_RECT rctHighLight;      ///< highlight rect {0,0,0,0} implies NONE

  XColor clrHFG;             ///< highlight FG color
  XColor clrHBG;             ///< highlight BG color

  int iFileType;             ///< file type - -1=Makefile, 0=plain text, others are 'file type' constants, bit flags to preserve hard tabs, etc.
  enum e_LineFeed iLineFeed; ///< linefeed type (see enum).  LineFeed_NONE implies SINGLE LINE
  int iInsMode;              ///< insert mode - 0=overwrite, 1=insert
  int iSelMode;              ///< selection mode - 0=normal, 1=line, 2=box
  int iScrollMode;           ///< scroll mode - 0=normal, 1='scroll lock'
  int iTab;                  ///< tab width in characters (0 = system default)

  // cursor position
  int iRow;                  ///< current row (cursor)
  int iCol;                  ///< current col (cursor)
  int iPos;                  ///< position within buffer (reserved, MBCS may require it)

  int iCursorX;              ///< X position of cursor as last drawn in expose event
  int iCursorY;              ///< Y position of cursor as last drawn in expose event (top of cursor)
  int iCursorHeight;         ///< height of cursor as last drawn in expose event (always 1 if 'overwrite' cursor)

  int iBlinkState;           ///< cursor blink state
  int iDragState;            ///< if '1' bit is set, cursor drag.  if '2' bit is set, mouse drag

  int iAsc;                  ///< font height ascension
  int iDesc;                 ///< font height descension
  int iFontWidth;            ///< average width of font in pixels (mostly for fixed pitch) - cached by 'expose' handler
  int iMaxFontWidth;         ///< maximum width of font in pixels (mostly for proportional pitch) - cached by 'expose' handler

  // viewport

  WB_RECT rctView;           ///< viewport, in characters (rctView.top is the top visible line, always)
  WB_RECT rctWinView;        ///< viewport, in window coordinates, or 'empty' if unknown

  // these are maintained internally - do not use
  WB_RECT rctViewOld;        ///< previous viewport [for invalidating window efficiently]
  WB_RECT rctWinViewOld;     ///< previous viewport, in window coordinates [for invalidating window efficiently]

  // the data

  void *pText;               ///< pointer to (abstracted) object containing the text.  void pointer allows abstraction.  member functions must handle correctly

  void *pUndo;               ///< pointer to 'undo' buffer.  NULL if empty.
  void *pRedo;               ///< pointer to 'redo' buffer.  NULL if empty.

  // special callback entries
  void *pColorContext;       ///< a user-controlled 'color context' pointer - can be anything, however
  unsigned long (*pColorContextCallback)(TEXT_OBJECT *,
                                         int, int); ///< callback function to get the context color of a character.  default is NULL.
};

/** \ingroup text_object_structures
  * \brief 'base class' structure for TEXT_OBJECT
  *
  * \code

  typedef struct s_text_object
  {
    const TEXT_OBJECT_VTABLE *vtable;  // method function pointers (similar to C++ virtual members)

    unsigned int ulTag;        // tag word, always assigned to TEXT_OBJECT_TAG
    Window wIDOwner;           // owner window (cached from paint/expose handling and/or cursor blink)
    WB_RECT rctSel;            // select boundary in characters
    WB_RECT rctHighLight;      // highlight rect

    XColor clrHFG;             // highlight FG color
    XColor clrHBG;             // highlight BG color

    int iFileType;             // file type - -1=Makefile, 0=plain text, others are 'file type' constants
    enum e_LineFeed iLineFeed; // linefeed type (see enum)
    int iInsMode;              // insert mode - 0=overwrite, 1=insert
    int iSelMode;              // selection mode - 0=normal, 1=line, 2=box
    int iScrollMode;           // scroll mode - 0=normal, 1='scroll lock'
    int iTab;                  // tab width in characters (0 = system default)

    // cursor position
    int iRow;                  // current row (cursor)
    int iCol;                  // current col (cursor)
    int iPos;                  // position within buffer

    int iCursorX;              // X position of cursor as last drawn in expose event
    int iCursorY;              // Y position of cursor as last drawn in expose event (top of cursor)
    int iCursorHeight;         // height of cursor as last drawn in expose event

    int iBlinkState;           // cursor blink state
    int iDragState;            // if '1' bit is set, cursor drag.  if '2' bit is set, mouse drag

    int iAsc;                  // font height ascension (cached)
    int iDesc;                 // font height descension (cached)
    int iFontWidth;            // average width of font in pixels (mostly for fixed pitch) - cached by 'expose' handler
    int iMaxFontWidth;         // maximum width of font in pixels (mostly for proportional pitch) - cached by 'expose' handler

    // viewport

    WB_RECT rctView;           // viewport, in characters
    WB_RECT rctWinView;        // viewport, in window coordinates, or 'empty' if unknown

    // these are maintained internally - do not use
    WB_RECT rctViewOld;        // previous viewport [for invalidating window efficiently]
    WB_RECT rctWinViewOld;     // previous viewport, in window coordinates [for invalidating window efficiently]

    // the data

    void *pText;               // pointer to (abstracted) object containing the text.  void pointer
                               // allows abstraction.  member functions must handle correctly

    void *pUndo;               // pointer to 'undo' buffer.  NULL if empty.
    void *pRedo;               // pointer to 'redo' buffer.  NULL if empty.

    void *pColorContext;       // a user-controlled 'color context' pointer - can be anything, however
    unsigned long (*pColorContextCallback)(TEXT_OBJECT *,
                                           int, int); // callback function to get the context color of a character.  default is NULL.
  };

  typedef struct s_text_object TEXT_OBJECT;

  * \endcode
  *
**/
typedef struct s_text_object TEXT_OBJECT;

/** \ingroup text_object_utils
  * \brief 'TEXT_OBJECT' validator
  * \param pObj A const pointer to a (possible) TEXT_OBJECT structure
  * \return non-zero if the object is a valid TEXT_OBJECT, zero otherwise
  *
  * Header File:  text_object.h
**/
static __inline__ int WBIsValidTextObject(const TEXT_OBJECT *pObj)
{
  return pObj && pObj->ulTag == TEXT_OBJECT_TAG;
}

/** \ingroup text_object_utils
  * \brief initialize an 'in-place' TEXT_OBJECT structure
  *
  * \param pTextObject A pointer to the TEXT_OBJECT structure to be initialized
  * \param wIDOwner The owning window's Window ID.  Can be 'None'
  *
  * Use this function to initialize a TEXT_OBJECT as an automatic variable or as part of an array.
  *
  * Make sure you call WBDestroyInPlaceTextObject() right before de-allocating it.
  *
  * Header File:  text_object.h
**/
static __inline__ void WBInitializeInPlaceTextObject(TEXT_OBJECT *pTextObject, Window wIDOwner)
{
  if(pTextObject)
  {
    bzero(pTextObject, sizeof(*pTextObject)); // most contained things will accept 'nulling' as "unassigned"

    pTextObject->vtable = WBGetDefaultTextObjectVTable();
    pTextObject->vtable->init(pTextObject);

    pTextObject->wIDOwner = wIDOwner;
  }
}

/** \ingroup text_object_utils
  * \brief Destroy a previously initialized 'in-place' TEXT_OBJECT structure
  *
  * \param pTextObject A pointer to the TEXT_OBJECT structure to be initialized
  *
  * Use this function to destroy an in-place TEXT_OBJECT that is an automatic variable or
  * a part of an array.
  *
  * \sa WBInitializeInPlaceTextObject()
  *
  * Header File:  text_object.h
**/
static __inline__ void WBDestroyInPlaceTextObject(TEXT_OBJECT *pTextObject)
{
  if(pTextObject &&
     WBIsValidTextObject(pTextObject) &&
     pTextObject->vtable &&
     pTextObject->vtable->destroy)
  {
    pTextObject->vtable->destroy(pTextObject);
  }
}

#define TEXT_BUFFER_LINE_CACHE_SIZE 32

/** \ingroup text_object_structures
  * \brief 'base class' structure for TEXT_OBJECT
  * \copydoc TEXT_BUFFER
**/
struct s_text_buffer
{
  unsigned long nArraySize; ///< allocated size of aLines array
  unsigned long nEntries;   ///< number of entries currently in the array - call WBCheckReAllocTextBuffer() before increasing

  // cached information
  unsigned int nMaxCol;     ///< The maximum column number for any line, rounded up by 'DEFAULT_TAB_WIDTH'
  unsigned int nMinMaxCol;  ///< The 'smallest maximum' recorded in 'aLineCache'
  unsigned long aLineCache[TEXT_BUFFER_LINE_CACHE_SIZE];
                            ///< An array of line indices, sorted longest to least, for the 'longest lines'
  unsigned int aLineCacheLen[TEXT_BUFFER_LINE_CACHE_SIZE];
                            ///< The actual line lengths associated with 'aLineCache' (zero if unused)

  char * aLines[2];         ///< array of 'lines'.  each pointer is suballocated via WBAlloc()

};

/** \ingroup text_object_structures
  * \brief 'base class' structure for TEXT_OBJECT
  *
  * \code
  typedef struct s_text_buffer
  {
    unsigned long nArraySize; // allocated size of aLines array
    unsigned long nEntries;   // number of entries currently in the array

    // cached information
    unsigned int nMaxCol;     // The maximum column number for any line, rounded up by 'DEFAULT_TAB_WIDTH'
    unsigned int nMinMaxCol;  // The 'smallest maximum' recorded in 'aLineCache'
    unsigned long aLineCache[TEXT_BUFFER_LINE_CACHE_SIZE];
                              // An array of line indices, sorted longest to least, for the 'longest lines'
    unsigned int aLineCacheLen[TEXT_BUFFER_LINE_CACHE_SIZE];
                              // The actual line lengths associated with 'aLineCache' (zero if unused)

    char * aLines[2];         // array of 'lines' suballocated via WBAlloc()

  };

  typedef struct s_text_buffer TEXT_BUFFER;

  * \endcode
  *
  * The structure is assumed to have a variable length array 'aLines' at the end, which extends
  * beyond the length of the base structure.  'nArraySize' indicates the maximum size of this array,
  * and 'nEntries' indicates the (contiguous) actual size of the array, starting at element [0].\n
  * This is a simple array structure, and to insert a line in the middle you will need to use 'memmove()'
  * following a call to WBCheckReAllocTextBuffer(), and then re-assign 'nEntries' as needed.  New
  * entries must be allocated via 'WBAlloc()'.\n
  * To allocate a new structure, call WBAllocTextBuffer().  To free an allocated structure, call WBFreeTextBuffer().\n
  * The 'cached information' data members are maintained internally.  You should not alter them.  You can
  * re-evaluate them at any time by calling WBTextBufferLineChange() and WBTextBufferRefreshCache()
**/
typedef struct s_text_buffer TEXT_BUFFER;


/** \ingroup text_object_utils
  * \brief Generic constructor for a TEXT_BUFFER using defaults
  *
  * \param pBuf Optional initializer text.  Can be NULL or 'blank', which will pre-allocate space for a default number of lines
  * \param cbBufSize Length of data pointed to by 'pBuf'.  Zero implies zero-byte terminated string
  * \return A 'WBAlloc'd pointer to a TEXT_BUFFER object.  Use 'WBFreeTextBuffer' to free it safely.
  *
  * Header File:  text_object.h
**/
TEXT_BUFFER * WBAllocTextBuffer(const char *pBuf, unsigned int cbBufSize);

/** \ingroup text_object_utils
  * \brief Re-allocator for TEXT_BUFFER object
  *
  * \param ppBuf A pointer to a TEXT_BUFFER pointer that may be re-assigned (as needed).
  * \param nLinesToAdd The number of additional lines that need to be added [or have space reserved for]
  * \return A non-zero value on error, or zero on success
  *
  * Header File:  text_object.h
**/
int WBCheckReAllocTextBuffer(TEXT_BUFFER **ppBuf, int nLinesToAdd);

/** \ingroup text_object_utils
  * \brief Re-allocator for TEXT_BUFFER object, returns ZERO on success.  Pointer may be modified (or not).
  *
  * \param pBuf A pointer to a TEXT_BUFFER that has been previously allocated.  It assumes that valid 'aLines' entries contain pointers allocated via 'WBAlloc'
  * \return void
  *
  * Header File:  text_object.h
**/
void WBFreeTextBuffer(TEXT_BUFFER *pBuf);

/** \ingroup text_object_utils
  * \brief Text buffer 'cached information' query function indicating a line's cached length
  *
  * \param pBuf A pointer to a TEXT_BUFFER object
  * \param nLine The 0-based line (row) number within the 'aLines' array
  * \return The current cached length of the line.
  *
  * This function returns the cached line length for the specified line.  If you do something that
  * might change this value, you can check first by calling this function to obtain the cached
  * value, and then use WBTextBufferRefreshCache() to update it (as needed).
  *
  * Header File:  text_object.h
**/
int WBTextBufferLineLength(TEXT_BUFFER *pBuf, unsigned long nLine);

/** \ingroup text_object_utils
  * \brief Text buffer 'cached information' update function indicating a change to a line's length
  *
  * \param pBuf A pointer to a TEXT_BUFFER object
  * \param nLine The 0-based line (row) number within the 'aLines' array
  * \param nNewLen The new line length, or -1 if the line is being deleted.
  *
  * Whenever you modify the length of a line, or delete a line, you should call this function to
  * automatically update the internally cached information specifying the maximum column number.\n
  * For complex edits, use WBTextBufferRefreshCache().\n
  * If you join a pair of lines, call this function once for the deleted line, then again
  * for the new (joined) line.
  *
  * Header File:  text_object.h
**/
void WBTextBufferLineChange(TEXT_BUFFER *pBuf, unsigned long nLine, int nNewLen);

/** \ingroup text_object_utils
  * \brief Text buffer 'cached information' refresh function
  *
  * \param pBuf A pointer to a TEXT_BUFFER object
  * \return void
  *
  * Call this function to completely re-evaluate the cached information regarding line
  * lengths.  In some cases this can be time-consuming, but on a modern processor it's
  * not likely to be noticable for documents smaller than 1Mb in size.\n
  * You should call this function following an 'undo' or other complex edit operation,
  * in lieu of WBTextBufferLineChange().  Also, for single-line edits, it may be better
  * to ALWAYS use this function.
  *
  * Header File:  text_object.h
**/
void WBTextBufferRefreshCache(TEXT_BUFFER *pBuf);

/** \ingroup text_object_utils
  * \brief assign callback function for 'color context' for a given character
  * \param pThis A pointer to the TEXT_OBJECT structure
  * \param callback A function pointer to a 'color context' callback function (see below).  This value may be NULL.
  * \param pColorContextPointer A pointer to non-specific user-maintained data.  Its value will be stored in pColorContext.  May be NULL.
  *
  * Use 'WBTextObjectSetColorContextCallback()' to assign a color context callback function that returns the correct
  * color of a character, given its row ('nRow') and column ('nCol') values, as a pixel (unsigned long) color value.
  * The color context callback function should use the 'text object' pointer 'pThis' to perform whatever operations
  * it needs to do in order to determine the correct color.
  *
  * The color callback function should return the 'default' color (from the TEXT_OBJECT) when no specific color is
  * to be assigned to a particular character.  Otherwise it returns the correct 'XColor' pixel value based on
  * the context-related color assignment.
  *
  * The 'pColorContextPointer' value is stored directly as-is in the pColorContext member of the TEXT_OBJECT structure.
  * It does not have to be a valid pointer (it can be a 'Window' cast to a pointer, for example).  The value is simply
  * available to the callback function whenever it is invoked, through the TEXT_OBJECT.
  *
  * The callback function 'callback' will be invoked internally by passing a pointer to the TEXT_OBJECT as the first
  * parameter, followed by the row and column values.  The callback function must assume that a multi-byte character
  * qualifies as a single column, and handle character spacing accordingly.
  *
  * To notify the callback function that something has changed, it can be invoked with an 'nCol' value of -1.  This
  * should force the re-evaluation of all context colors starting with row 'nRow'.  'nRow' can also be a negative value
  * to indicate that the entire file should be re-evaluated.  Once completed, it should invalidate the window
  * that is displaying the text, so that the correct colors will be painted.  Additionally, any background thread
  * that might be re-evaluating the context color should be re-startable (whenever the callback is re-invoked), and
  * cause the window displaying the text object to be re-painted when complete.
  *
  * Upon assignment, the callback will be evoked with 'nRow' and 'nCol' as -1, so that the re-evaluation will happen
  * immediately.  As such, it's usually important to assign the callback function before assigning any data.
  *
  * See Also:  RGB_TO_XCOLOR(), RGB255_TO_XCOLOR(), PXM_RGBToPixel(), PXM_PixelToRGB()
**/
void WBTextObjectSetColorContextCallback(TEXT_OBJECT *pThis,
                                         unsigned long (*callback)(TEXT_OBJECT *pThis, int nRow, int nCol),
                                         void *pColorContextPointer);


/** \ingroup text_object_utils
  * \brief Generic constructor for a TEXT_OBJECT using defaults
  *
  * \param cbStructSize The size of the 'TEXT_OBJECT' structure itself
  * \param szText The text to pre-assign the object with, or NULL
  * \param cbLen The length of 'szText', 0 to indicate zero-byte terminated
  * \param wIDOwner The owner window in which to display the text, or 'None'
  * \return A 'WBAlloc'd and initialized TEXT_OBJECT pointer - call WBTextObjectDestructor to destroy it
  *
  * This is being implemented as an object, similar to a C++ class with virtual member functions,
  * for the purpose of being able to re-assign the vtable and thereby overload its functionality.
  *
  * Header File:  text_object.h
**/
TEXT_OBJECT *WBTextObjectConstructor(unsigned long cbStructSize, const char *szText, unsigned long cbLen, Window wIDOwner);


/** \ingroup text_object_utils
  * \brief Generic detructor for a TEXT_OBJECT
  *
  * \param pObj A pointer to the TEXT_OBJECT structure
  * \return void
  *
  * Use this function to SAFELY destroy an object allocated using WBTextObjectConstructor
  *
  * Header File:  text_object.h
**/
void WBTextObjectDestructor(TEXT_OBJECT *pObj);


/** \ingroup text_object_utils
  * \brief Calculate the correct per-line height (in pixels) for a specified font ascent and descent
  *
  * \param iAscent The 'ascent' for the display font
  * \param iDescent The 'descent' for the display font
  * \return A calculated line height (in pixels) that includes the line spacing.
  *
  * Use this function to consistently get the line height from font information.  The Text Object expose
  * handler uses this calculation exclusively.  Sometimes owning objects need to know exactly how this
  * is being calculated to properly handle scrolling, etc. and this function returns the same results that
  * the expose handler will use to determine where to draw text in the display geometry.
  *
  * Header File:  text_object.h
**/
int WBTextObjectCalculateLineHeight(int iAscent, int iDescent);



// MBCS-related utilities

/** \ingroup text_object_multibyte
  * \brief Insert multi-byte characters into a WBAlloc'd string, at a specified column
  *
  * \param pString A pointer to a WBAlloc'd buffer containing a multi-byte character string.  The string must terminate with a zero byte.
  * \param iCol A zero-based column at which point to insert the text.
  * \param pszMBString A pointer to a buffer containing the multi-byte characters to insert.   It must NOT contain any return or line feed characters.  Tabs will be translated as specified.  Other control characters will become spaces (including line feeds, if present)
  * \param cbString The length of the multi-byte character string (in bytes, not characters), or -1 to use a terminating zero byte as 'end of string'
  * \param fTab An integer indicating how tabs should be handled.  A value of 0 indicates 'no tabs', '-1' is the 'default' tab, and any other value, the number of spaces that a tab will align with.
  * \param fOverwrite Non-zero to 'overwrite' rather than insert the characters.  Overwrite can extend the length of the string.
  * \param piNewCol A pointer to an integer to receive the 0-based 'new' column at which the cursor is pointing after the insert.  See 'WBSplitMBLine()' for a method to insert a line feed at this point.
  * \param ppInserted An optional pointer to a char * that will be assigned a WBAlloc'd pointer to a string containing the inserted characters.  May be NULL.  The caller must free any non-NULL returned value via WBFree()
  * \return A pointer to a WBAlloc'd string containing the results.  If different from 'pString', the 'pString' pointer value will no longer be valid.  On error, it will return NULL
  *
  * This function performs the somewhat complicated 'insert a multi-byte character' functionality in a consistent
  * AND column-based manner, so that a string that has multi-byte characters can be edited in the same way as a string
  * that has characters with consistent length.  In this way, ANY multi-byte character that is available at a future
  * point in time can be supported.  The alternative would be to convert to "a unicode format", which may limit the character
  * set that could be used; as an example, 16-bit unicode characters won't include characters that are available in the
  * 24-bit Unicode character set.  Having a ridiculously large bit-length for a single character is not much of a consolation,
  * and so this function (and others) will deal with multiple byte characters as they are, in an independent manner.
  *
  * It is the caller's responsibility to filter out line feed characters, and insert new lines into a line buffer.
  *
  * If a 'ppInserted' pointer value is specified, this function will store the inserted text in a buffer allocated
  * via WBAlloc().  The caller must free any non-NULL value returned by this function using WBFree().  The data that
  * is stored in this allocated buffer can be used to support 'undo' and 'redo'.
  *
  * Header File:  text_object.h
**/
char * WBInsertMBChars(char *pString, int iCol, const char *pszMBString, int cbString,
                       int fTab, int fOverwrite, int *piNewCol, char **ppInserted);


/** \ingroup text_object_multibyte
  * \brief Split a multi-byte characters into a WBAlloc'd string, at a specified column, terminating the original string at that column with a zero byte
  *
  * \param pString A pointer to a WBAlloc'd buffer containing a multi-byte character string.  The string must terminate with a zero byte.
  * \param iCol A zero-based column at which point to split the line.
  * \return A pointer to a WBAlloc'd string containing the next line to insert.  On error, it will return NULL without any changes being made.
  *
  * This function will 'split' a string at a particular column, returning a WBAlloc'd pointer to the 'remainder' of the line,
  * which is intended to be inserted as a new line.  The new line will NOT be indented, and leading white space will be left 'as-is'.
  * Trailing white space on the original line, however, will automatically be trimmed.
  *
  * The caller is expected to insert the returned string pointer as the 'next' line, following the line split.  The caller is
  * also responsible for any 'auto indent' functionality that might be needed for a line split.
**/
char * WBSplitMBLine(char *pString, int iCol);


/** \ingroup text_object_multibyte
  * \brief Split a multi-byte characters into a WBAlloc'd string, at a specified column, terminating the original string at that column with a zero byte
  *
  * \param pString A pointer to a WBAlloc'd buffer containing a multi-byte character string.  The string must terminate with a zero byte.
  * \param iCol A 0-based column index value.  If the value is greater than the length of 'pString', then 'pString' will be padded with spaces up to that column before 'joining'.
  * \param pJoin A (const) poitner to a buffer containing a multi-byte character string, terminated with a zero byte.  This
  * \return A pointer to a WBAlloc'd string containing the resulting 'join'ed string.  If different from 'pString', the 'pString' pointer value will no longer be valid.  On error, it will return NULL
  *
  * This function will 'join' a 2nd string to an existing (WBAlloc'd) multi-byte character string, optionally at a specified column
  * (padding it with white space, as needed).  The 'pString' pointer must have been allocated via WBAlloc for this to function properly.
  * However, the 'pJoin' string can be from any source.
  *
  * The caller is expected to remove the subsequent string pointer from being the 'next' line, as needed, following the line join.
  *
**/
char * WBJoinMBLine(char *pString, int iCol, const char *pJoin);


/** \ingroup text_object_multibyte
  * \brief Delete a specified number of multi-byte characters from a string 'in place', starting at a specified column
  *
  * \param pString A pointer to a buffer containing a multi-byte character string.  The string must terminate with a zero byte.
  * \param iCol A zero-based column at which point to delete the text.
  * \param nDel An integer indicating the number of multi-byte characters to delete.  A negative number will delete 'backspace' style, starting with the PREVIOUS character.  Positive deletes beginning with the character at 'iCol'.
  * \param piNewCol An optional pointer to an integer that receives the new column that the cursor is on after the operation completes.  May be NULL.
  * \param ppDeleted An optional pointer to a char * that will be assigned a WBAlloc'd pointer to a string containing the deleted characters.  May be NULL.  The caller must free any non-NULL returned value via WBFree()
  * \returns The number of deletions remaining (preserving the sign of 'nDel') after the operation completes.
  *
  * This function performs the somewhat complicated 'delete a multi-byte character' functionality in a consistent
  * AND column-based manner, so that a string that has multi-byte characters can be edited in the same way as a string
  * that has characters with consistent length.  It also returns the number of delete operations remaining.
  *
  * In many cases, a series of 'backspaces' or 'deletes' may extend into a previous or subsequent line.  In these cases,
  * they must be handled in a separate call involving the previous or next line's multi-byte character buffer.  The caller
  * is responsible for handlnig this, as well as for collapsing the lines or joining them together.
  *
  * If a 'ppDeleted' pointer value is specified, this function will store the deleted text in a buffer allocated
  * via WBAlloc().  The caller must free any non-NULL value returned by this function using WBFree().  The data that
  * is stored in this allocated buffer can be used to support 'undo' and 'redo'.
  *
  * Header File:  text_object.h
**/
int WBDelMBChars(char *pString, int iCol, int nDel, int *piNewCol, char **ppDeleted);


/** \ingroup text_object_multibyte
  * \brief Obtain the length of a multi-byte character string in 'characters' (not bytes)
  *
  * \param pString A pointer to a buffer containing a multi-byte character string.  The string must terminate with a zero byte.
  * \returns The length of the multi-byte character string in 'characters'
  *
  * Header File:  text_object.h
**/
int WBGetMBLength(const char *pString);


/** \ingroup text_object_multibyte
  * \brief Obtain the pointer to a specific multi-byte character within a multi-byte character string, by specifying it's column
  *
  * \param pString A pointer to a buffer containing a multi-byte character string.  The string must terminate with a zero byte.
  * \param iCol A zero-based column at which point to return a pointer to the multi-byte character
  * \param pcbLen A pointer to an integer that receives the length of the character being pointed to by the return value.  This pointer may be NULL
  * \returns A pointer to the multi-byte character located at the 'iCol' position within the string.  If 'iCol' is out range, the return value will point to the terminating zero byte.  On error, the return value will be NULL.
  *
  * Header File:  text_object.h
**/
char * WBGetMBCharPtr(char *pString, int iCol, int *pcbLen);

/** \ingroup text_object_multibyte
  * \brief Obtain the column index from a pointer within a multi-byte character string
  *
  * \param pString A pointer to a buffer containing a multi-byte character string.  The string must terminate with a zero byte.
  * \param pChar A (const) pointer to a character within 'pString'.  This must be a pointer to the start of a valid UTF-8 character within 'pString'.
  * \returns The zero-based column index of the character pointed to by 'pChar' within 'pString.  If 'pChar' is out range, or points to an invalid character, the return value will be zero.
  *
  * Header File:  text_object.h
**/
int WBGetMBColIndex(const char *pString, const char *pChar);


#ifdef __cplusplus
};
#endif // __cplusplus

#endif // _TEXT_OBJECT_H_INCLUDED_


