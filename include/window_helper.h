//////////////////////////////////////////////////////////////////////////////////////////////
//            _             _                     _            _                     _      //
// __      __(_) _ __    __| |  ___ __      __   | |__    ___ | | _ __    ___  _ __ | |__   //
// \ \ /\ / /| || '_ \  / _` | / _ \\ \ /\ / /   | '_ \  / _ \| || '_ \  / _ \| '__|| '_ \  //
//  \ V  V / | || | | || (_| || (_) |\ V  V /    | | | ||  __/| || |_) ||  __/| | _ | | | | //
//   \_/\_/  |_||_| |_| \__,_| \___/  \_/\_/_____|_| |_| \___||_|| .__/  \___||_|(_)|_| |_| //
//                                         |_____|               |_|                        //
//                                                                                          //
//                       basic window creation and message handling                         //
//                                                                                          //
//    Copyright (c) 2010-2016 by 'Big Bad Bombastic Bob' Frazier - all rights reserved.     //
//   You may use this file in any way you see fit provided that any copy or derived work    //
//   includes the above copyright notice.                                                   //
//                                                                                          //
//              NOTE:  'WB' is for 'Work Bench', aka 'X11workbench Toolkit'                 //
//                                                                                          //
//////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2016 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no waranties, either implied or explicit.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/


//////////////////////////////////////////
//      - DOXYGEN RELATED STUFF -       //
//////////////////////////////////////////

/** \file window_helper.h
  * \brief 'window helper' main header file for the X11workbench Toolkit API
  *
  * X11workbench Toolkit Toolkit API
  * This file defines the main 'Window Helpers' including
  *   API initialization
  *   the main 'Event loop'
  *   window callback procedures
  *   upper level font management
  *   Expose and GC management
  *   Window context/state management
  *   X11 API 'wrapper' functions
**/

// doxygen top-level stuff has been moved to doxy_comments.dox

//////////////////////////////////////////
//    - END DOXYGEN RELATED STUFF -     //
//////////////////////////////////////////



// window helpers - defines manager for callback procs, font, GC, and a generic event dispatcher

#ifndef WINDOW_HELPER_H_INCLUDED
#define WINDOW_HELPER_H_INCLUDED

// headers that must be included or I break

#include <string.h>   // for memset, mostly

#include "platform_helper.h"

#include "font_helper.h"

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/** \ingroup core
  * \brief The default window cursor (this is what xterm uses)
*/
#define WB_DEFAULT_CURSOR XC_left_ptr
/** \ingroup core
  * \brief The 'wait' cursor (this is what xterm uses)
**/
#define WB_WAIT_CURSOR XC_watch /*XC_clock*/
/** \ingroup font
  * \brief The default X11 font name (currently "fixed")
**/
#define WB_DEFAULT_FONT    "fixed"
/** \ingroup font
  * \brief The default X11 font size (currently 13)
**/
#define WB_DEFAULT_FONT_SIZE 13 /* override via settings */
/** \ingroup font
  * \brief The 'window data' array size (currently 4 void pointers)
**/
#define WINDOW_DATA_SIZE 4 /* size of a 'void *' array that stores per-window data */

/** \ingroup font
  * \brief An event mask for ALL events, with bits 0 through 24 set - see X.h which only defines bits 0 to 24 for an event mask
**/
#define EVENT_ALL_MASK 0x01ffffffL /* 2^24 | 2^23 ... 2^0 - see X.h */


/** \ingroup core
  * \brief A bit mask for ALL GC properties (used when copying a GC)
**/
#define GCAll (GCFunction | GCPlaneMask | GCForeground | GCBackground | GCLineWidth | \
               GCLineStyle | GCCapStyle | GCJoinStyle | GCFillStyle | GCFillRule | \
               GCTile | GCStipple | GCTileStipXOrigin | GCTileStipYOrigin | GCFont | \
               GCSubwindowMode | GCGraphicsExposures | GCClipXOrigin | GCClipYOrigin | \
               GCClipMask | GCDashOffset | GCDashList | GCArcMode)



// debug helpers (to be eliminated at some point)

/** \ingroup debug
  * \brief debug helper variable tracking the function calling into the X11 library
**/
extern const char *sz_xcall_func;
/** \ingroup debug
  * \brief debug helper variable indicating the line number of the function calling into the X11 library
**/
extern int i_xcall_line;
/** \ingroup debug
  * \def BEGIN_XCALL_DEBUG_WRAPPER()
  * \brief wrapper macro for calls into the X11 library.  This macro precedes the call(s)
**/
#define BEGIN_XCALL_DEBUG_WRAPPER { const char *szOldXCallFunc = sz_xcall_func; int iOldXCallLine = i_xcall_line; sz_xcall_func = __FUNCTION__;  i_xcall_line = __LINE__;
/** \ingroup debug
  * \def END_XCALL_DEBUG_WRAPPER()
  * \brief wrapper macro for calls into the X11 library.  This macro follows the call(s)
**/
#define END_XCALL_DEBUG_WRAPPER  sz_xcall_func = szOldXCallFunc;  i_xcall_line = iOldXCallLine; }


/** \typedef WBWinEvent
  * \ingroup events
  * \brief event callback function type for window events
  *
  * \param wID The Window ID for the window receiving the event notification
  * \param pEvent A pointer to the XEvent structure passed to the callback function
  * \return Event-specific value.  Typically returns zero if the event was not processed, non-zero if further processing is not necessary
  *
  * Event callbacks for windows should be declared according to this defined type
  *
  * Header File:  window_helper.h
**/
typedef int (* WBWinEvent)(Window wID, XEvent *pEvent);
/** \typedef WBAppEvent
  * \ingroup events
  * \brief event callback function type for application events
  *
  * \param pEvent A pointer to the XEvent structure passed to the callback function
  * \return Event-specific value.  Typically returns zero if the event was not processed, non-zero if further processing is not necessary
  *
  * An event callback for the application should be declared according to this defined type
  *
  * Header File:  window_helper.h
**/
typedef int (* WBAppEvent)(XEvent *pEvent);

/** \typedef WB_RECT
  * \brief internal wrapper struct for 'rectangle' definition
  *
  * The rectangle structure has been defined primarily for convenience,
  * so that specific coding methods that work well in GUI environments
  * that use rectangles (instead of 'geometry') can easily be ported
  * into this environment.
  *
  * \code
  typedef struct _WBRect_
  {
    int left, top, right, bottom;
  } WB_RECT;
  * \endcode
  *
  * Note that this is different from an XRectangle, which is defined as
  *
  * \code
  typedef struct
  {
    short x, y;
    unsigned short width, height;
  } XRectangle;
  * \endcode
  *
*/
typedef struct _WBRect_
{
  int left;   /**< X coordinate for rectangle upper left corner */
  int top;    /**< Y coordinate for rectangle upper left corner */
  int right;  /**< X coordinate for rectangle lower right corner */
  int bottom; /**< Y coordinate for rectangle lower right corner */
} WB_RECT;

/** \typedef WB_GEOM
  * \brief internal wrapper struct for X11 'geometry' definition
  *
  * The geometry structure is a wrapper for the X11 functions that specify
  * the individual parameters for a geometry, such as XGetGeometry.  Instead
  * of passing 5 integers, you pass the pointer to a structure for the
  * X11workbench API functions.  This provides many advantages over the
  * 'individual parameter' method as well as providing a structure
  * for cacheing geometry information.
  *
  * \code
  typedef struct _WBGeom_
  {
    int x, y;
    unsigned int width, height, border;
  } WB_GEOM;
  * \endcode
  *
  * Use of 'int' for each parameter is consistent with the various 'Geom' functions
  * which typically use 'int *' for returned parameters, such as:
  *
  * \code
  Status XGetGeometry(Display *display, Drawable d, Window *root_return,
                      int *x_return, int *y_return,
                      unsigned int *width_return, unsigned int *height_return,
                      unsigned int *border_return, unsigned int *depth_return);
  * \endcode
  *
*/
typedef struct _WBGeom_
{
  int x; /**< X coordinate for geometry upper left corner (excluding border) */
  int y; /**< Y coordinate for geometry upper left corner (excluding border) */
  unsigned int width; /**< width of geometry */
  unsigned int height; /**< height of geometry */
  unsigned int border; /**< border width of geometry */
} WB_GEOM;

/** \ingroup startup
  * \hideinitializer
  * \var bQuitFlag
  * \brief 'Quit' Flag - you should check this periodically in your main message loop and exit whenever it is TRUE (non-zero)
  *
  * \c Quit \c Flag - assign to TRUE (non-zero) when it's time to exit.  This may be done asynchronously at any point in time.\n
  * Signal procs that terminate the application, as well as the main frame window's 'Destroy' handler,
  * and any 'Exit' functions, should all set this to TRUE (non-zero) to force the application to exit.
  *
  * \code
  extern int bQuitFlag;
  * \endcode
  *
**/
extern int bQuitFlag;


///////////////////
// initialization
///////////////////

/** \ingroup startup
  * \brief initializes default objects for the specified Display (required)
  *
  * \param szDisplayName A null-byte terminated ASCII string containing the DISPLAY name, or NULL\n
  *        NULL values causes the display to initialize using \ref GetStartupDisplayName()
  * \return A pointer to the Display, or NULL on error
  *
  * Call this function before any other to create a display and initialize the X11 WorkBench Toolkit.
  * Alternately you can create the display yourself and call \ref WBInitDisplay().  \ref WBExit() will
  * free the assigned Display pointer for you by calling XCloseDisplay().\n
  * The returned pointer can be retrieved at any time by calling 'WBGetDefaultDisplay()'.\n
  *
  * Header File:  window_helper.h
**/
Display *WBInit(const char *szDisplayName);

/** \ingroup startup
  * \brief initializes default objects for the specified Display
  *
  * \param pDisplay A pointer to an open Display object, to become the default display for the X11 WorkBench Toolkit.
  * \return Zero value on success, non-zero on error.
  *
  * Call this function before any other to assign the default Display pointer and initialize the
  * X11 WorkBench Toolkit.  A number of internal objects are initialized by this function.
  * On error the function returns a non-zero value.\n
  * The preferred method for initialization is to use \ref WBInit() with a display name (or NULL).
  * However, in some cases you may wish to open the display yourself, and pass the pointer to this
  * function instead.  Typical reasons for that may be security-related, use of firewalls, proxies, and
  * any other kind of possible and/or unusual method for opening a display.
  *
  * Header File:  window_helper.h
**/
int WBInitDisplay(Display *pDisplay);

/** \ingroup startup
  * \brief initializes clipboard sub-system
  *
  * \param pDisplay The 'Display' associated with this clipboard (reserved, must match 'WBInitDisplay' call or be NULL)
  * \param szDisplayName A null-byte terminated ASCII string containing the DISPLAY name, or NULL\n
  *        NULL values causes the display to initialize using \ref GetStartupDisplayName()
  * \return Zero value on success, non-zero on error.
  *
  * Call this function to initialize the 'Clipboard' sub-system, after initializing the 'Display'.  This function
  * is automatically called internally by WBInitDisplay() so there should be no need to invoke it directly.\n
  * It will spawn a new thread that runs in the background to process clipboard-related messages, internally
  * using a separate Display object, so that the main thread is not impacted (nor deadlocked) by clipboard handling.\n
  * The 'pDisplay' parameter is reserved for future use, for when multiple displays are supported.\n
  * If a thread uses the same display name that was passed to 'WBInit' then it refers to the same Display as the
  * main thread, and you will not need to re-initialize the clipboard for that Display.
  *
  * Header File:  window_helper.h
**/
int WBInitClipboardSystem(Display *pDisplay, const char *szDisplayName);

/** \ingroup startup
  * \brief deletes any remaining global objects, frees the Display pointer, and terminates event processing
  *
  * This function deletes any remaining global objects, frees the Display pointer, and terminates event
  * processing, freeing up any remaining resources for the entire toolkit.  You should call this function
  * in your application right before it terminates.
  *
  * Header File:  window_helper.h
**/
void WBExit(void);

/** \ingroup startup
  * \brief Shut down the clipboard sub-system
  *
  * Shuts down the clipboard sub-system.  Called internally by WBExit()
  *
  * Header File:  window_helper.h
**/
void WBExitClipboardSystem(Display *pDisplay);

/** \ingroup startup
  * \brief initializes default Display for a thread (must call WBInit() first)
  *
  * \return A pointer to the Display, or NULL on error
  *
  * Call this function to create a thread-specific Display object when you need to process
  * a message loop or create windows within that thread.  You must call WBThreadFreeDisplay()
  * to free up resources before exiting the thread.
  *
  * Header File:  window_helper.h
**/
Display *WBThreadInitDisplay(void);

/** \ingroup startup
  * \brief un-initializes a Display for a thread that was allocated by WBThreadInitDisplay()
  *
  * \param pThreadDisplay a Display pointer that was created via WBThreadInitDisplay()
  *
  * Call this function to free a thread-specific Display object that was created by WBThreadInitDisplay()
  * to free up resources before exiting the thread.
  *
  * Header File:  window_helper.h
**/
void WBThreadFreeDisplay(Display *pThreadDisplay);


/** \ingroup startup
  * \brief parses standard C arguments as passed to 'main()'
  *
  * In order to support a large number of default switches and parameters that are
  * supported by the X11workbench Toolkit API, you should pass pointers to the
  * parameters that were passed to 'main()' by the C startup code to this function.\n
  * Returns 0 on success, non-zero (or error code) otherwise.\n
  * The values for 'argc' (as *pargc) 'argv' (as *pargv) and 'envp' (as *penvp) will
  * likely be modified from their original values as part of the processing.  If you
  * want to retain the original values, pass 'copies' to this function and use the
  * copies for normal argument processing (as with 'getarg').
  *
  * Header File:  window_helper.h
**/
int WBParseStandardArguments(int *pargc, char ***pargv, char ***penvp);

/** \ingroup startup
  * \brief Displays 'usage' for toolkit options to stderr
  *
  * Header File:  window_helper.h
**/
void WBToolkitUsage(void);

/** \ingroup startup
  * \brief returns a pointer to a copy of the application name from argv[0]
  *
  * \returns A const pointer to a zero-byte terminated string containing a copy of the application name
  *
  * This function is only valid if you call WBParseStandardArguments() on startup
  *
  * Header File:  window_helper.h
**/
const char *GetStartupAppName(void);

/** \ingroup startup
  * \brief returns character name of the display to be opened and passed to WBInit
  *
  * Gets the display name associated with the current (default) display, or the
  * display specified in the command line arguments passed to WBParseStandardArguments().
  * This name should be used in a call to XOpenDisplay(), and the resulting Display
  * should then be passed to WBInit()
  *
  * Header File:  window_helper.h
**/
const char *GetStartupDisplayName(void);

/** \ingroup startup
  * \brief returns the startup geometry based on command line parameters
  *
  * Returns the desired geometry to be applied to the main window on startup.
  * The value is based on a prior call to \ref WBParseStandardArguments(), and should
  * not be relied upon otherwise.
  *
  * Header File:  window_helper.h
**/
void GetStartupGeometry(WB_GEOM *pGeom);
/** \ingroup startup
  * \brief returns the min/max/normal window state for startup
  *
  * Following a call to \ref WBParseStandardArguments(), this function will return the
  * desired startup window state, either minimized (< 0), maximized (> 0), or normal (= 0).
  *
  * Header File:  window_helper.h
**/
int GetStartupMinMax(void);

/** \ingroup startup
  * \brief returns the default colormap for the default screen of the specified display
  *
  * Convenience function that returns the default colormap for the default screen of the
  * specified display.  Helps to clean up the initialization code and make it more 'modular'.
  *
  * Header File:  window_helper.h
**/
static __inline__ Colormap WBDefaultColormap(Display *pDisplay)
{
  return DefaultColormap(pDisplay, DefaultScreen(pDisplay));
}

/** \ingroup startup
  * \brief initializes the XSetWIndowAttributes structure with minimal attributes
  *
  * \param pXSWA A pointer to the (un-initialized) XSetWindowAttributes structure
  * \param lBorderPixel The color value for the border pixel
  * \param lBackgroundPixel The color value for the background pixel
  * \param clrMap The colormap, typically the value returned by \ref WBDefaultColormap()
  * \param iBitGravity The 'bit gravity' of the window.  Typical value is 'CenterGravity'
  *
  * Convenience function to assign the minimal window attributes to the XSetWindowAttributes
  * structure.  Helps to clean up the initialization code and make it more 'modular'.
  * For more information on window attributes, see the X11 API Documentation, section 3.3 .
  *
  * Header File:  window_helper.h
**/
void WBInitWindowAttributes(XSetWindowAttributes *pXSWA, unsigned long lBorderPixel,
                            unsigned long lBackgroundPixel, Colormap clrMap, int iBitGravity);

/** \ingroup startup
  * \brief initializes the XSizeHints structure with standard attributes
  *
  * \param pSH Pointer to the XSizeHints structure
  * \param pDisplay Pointer to the Display (NULL for default)
  * \param iMinHeight Minimum height of the window
  * \param iMinWidth Minimum width of the window
  *
  * Convenience function that assigns the default window size on application startup.
  * Takes into consideration the screen dimensions and min width/height if the user did
  * not specify window geometry on startup.  See the X11 API Reference, sections
  * 9.1.6 and 10.3 for more information on XSizeHints
  *
  * Header File:  window_helper.h
**/
void WBInitSizeHints(XSizeHints *pSH, Display *pDisplay, int iMinHeight, int iMinWidth);


//////////////////////////////////////////////////////////////////////////////////////////////
//   ____   _____  ____   _   _   ____    _   _  _____  _      ____   _____  ____   ____    //
//  |  _ \ | ____|| __ ) | | | | / ___|  | | | || ____|| |    |  _ \ | ____||  _ \ / ___|   //
//  | | | ||  _|  |  _ \ | | | || |  _   | |_| ||  _|  | |    | |_) ||  _|  | |_) |\___ \   //
//  | |_| || |___ | |_) || |_| || |_| |  |  _  || |___ | |___ |  __/ | |___ |  _ <  ___) |  //
//  |____/ |_____||____/  \___/  \____|  |_| |_||_____||_____||_|    |_____||_| \_\|____/   //
//                                                                                          //
//////////////////////////////////////////////////////////////////////////////////////////////


/** \ingroup debug
  * \brief set debug level
  *
  * This function should typically be called once, at the beginning of the program.
  * Any changes made to the debug level will be applied 'live'
  *
  * Pass the debug level as 'iLevel'
  *   0 for none, 1 for minimal, 2 for more, etc. up to 7
  *
  * Header File:  window_helper.h
**/
void WBSetDebugLevel(unsigned int iLevel);


/** \ingroup debug
  * \brief Returns the current debug level assigned by WBSetDebugLevel
  *
  * \return The current debug level and flags
  *
  * Various 'debug print' macros need to know what the current debug level
  * is in order to filter their output.  This function provides a standard
  * way in which to obtain the debug level.  It is defined 'inline' to
  * minimize any performance impact and to allow optimization.
  *
  *
  * Header File:  window_helper.h
**/

#ifdef __GNUC__
static __inline__ unsigned int WBGetDebugLevel(void)
{
extern unsigned int iWBDebugLevel;

  return iWBDebugLevel;
}
#else // __GNUC__
unsigned int WBGetDebugLevel(void);
#endif // __GNUC__

/** \ingroup debug
  * \brief conditional debug message output
  *
  * \param pFmt A pointer to a 'printf' compatible format string
  *
  * Additional parameters are those required by the format string
  *
  * Conditionally sends output to the 'debug device' which is (by default) stderr
  * using a function call convention similar to 'printf'.  When debug is disabled
  * this function has no effect.
  *
  * Header File:  window_helper.h
**/
#ifdef __GNUC__
void WBDebugPrint(const char *pFmt, ...) __attribute__ ((format(printf, 1, 2)));
#else // __GNUC__
void WBDebugPrint(const char *pFmt, ...);
#endif // __GNUC__

/** \ingroup debug
  * \brief conditionally dumps binary data to debug message output
  *
  * \param szTitle The title of the debug dump
  * \param pData A pointer to the data to be dumped
  * \param cbData the number of bytes to dump
  *
  * Allows you to generate a custom 'binary data dump' in an easily
  * readable hex/ASCII format, using the debug message output
  *
  *
  * Header File:  window_helper.h
**/
void WBDebugDump(const char *szTitle, void *pData, int cbData); // dump binary data

/** \ingroup debug
  * \brief dumps a GC's settings
  *
  * \param pDisplay A pointer to the display
  * \param hGC The graphics context to dump
  *
  * Debug function that dumps out all of the settings for a GC that can be
  * retrieved using normal API functions.
  *
  * Header File:  window_helper.h
**/
void WBDebugDumpGC(Display *pDisplay, GC hGC);


/** \ingroup debug
  * \brief dumps the contents of an XEvent
  *
  * \param pEvent an Event structure obtained via 'XNextEvent' or similar
  *
  * Debug function that dumps out all of the members of the XNextEvent.  It assumes
  * that the event is genuine; that is, the 'display' 'window' etc. are valid.
  *
  * Header File:  window_helper.h
**/
void WBDebugDumpEvent(XEvent *pEvent);



// NOTE:  The debug code will be included when NO_DEBUG is *NOT* defined

#ifdef NO_DEBUG /* assign this to disable debugging - most likely a -D in Makefile */
#define WB_DEBUG_PRINT(...)
#define WB_DEBUG_DUMP(L,X,Y,Z)
#define WB_IF_DEBUG_LEVEL(L) if(0) /* TODO:  turn off the warning? */
#else // NO_DEBUG

// NOTE:  this macro is the preferred method of implementing debug output.
/** \ingroup debug
  * \brief Preferred method of implementing conditional debug output
  *
  * \param L Debug level (bitmask of \ref DebugLevel enumeration)
  *
  * The remaining parameters are passed as-is to \ref WBDebugPrint()
  *
  * This macro conditionally generates debug output via WBDebugPrint().
  * Bits that are set in the debug level enable you to determine which debug messages
  * you see and which ones remain 'hidden'.  This macro easily allows you to implement
  * filtered debug output.  The first paramater, 'L', is the debug level (0 to 7)
  * along with (optional) bits indicating which subsystems are applicable to this message.
  * Specifying NO subsystem bits assumes ALL subsystems.\n
  * The remaining parameters, format string (and a variable number of parameters), are
  * passed along to the WBDebugPrint function.\n
  * \sa \ref DebugLevel
**/
#define WB_DEBUG_PRINT(L, ...) \
  if(WB_UNLIKELY((WBGetDebugLevel() & DebugLevel_MASK) >= ((L) & DebugLevel_MASK))) \
  { \
    if(!((L) & DebugSubSystem_MASK) || !(WBGetDebugLevel() & DebugSubSystem_MASK) \
       || (((L) & WBGetDebugLevel()) & DebugSubSystem_MASK) != 0) \
    { \
      WBDebugPrint(__VA_ARGS__); \
    } \
  }
/** \ingroup debug
  * \brief Preferred method of implementing conditional debug 'dump' output
  *
  * \param L Debug level (bitmask of \ref DebugLevel enumeration)
  * \param X A const pointer to a 0-byte terminated string containing the 'title' string
  * \param Y A const void pointer to the data to be dumped
  * \param Z An unsigned integer indicating the number of bytes to display
  *
  * The remaining parameters are passed as-is to \ref WBDebugDump()
  *
  * Similar to \ref WB_DEBUG_PRINT, this macro will conditionally dump binary data
  * via the WBDebugDump() function.  The first parameter, 'L', is the debug level
  * (0 to 7) along with (optional) bits indicating which subsystems are applicable
  * to this debug output.  Specifying NO subsystem bits assumes ALL subsystems.\n
  * The remainng 3 parameters are passed to WBDebugDump as the title, data pointer,
  * and size of the data (in bytes).\n
  * \sa \ref DebugLevel
**/
#define WB_DEBUG_DUMP(L,X,Y,Z) \
  if(WB_UNLIKELY((WBGetDebugLevel() & DebugLevel_MASK) >= ((L) & DebugLevel_MASK))) \
  { \
    if(!((L) & DebugSubSystem_MASK) || !(WBGetDebugLevel() & DebugSubSystem_MASK) \
       || (((L) & WBGetDebugLevel()) & DebugSubSystem_MASK) != 0) \
    { \
      WBDebugDump(X,Y,Z); \
    } \
  }

/** \ingroup debug
  * \brief Preferred method of implementing conditional debug 'if block' code
  *
  * \param L Debug level (bitmask of \ref DebugLevel enumeration)
  *
  * Similar to \ref WB_DEBUG_PRINT, this macro will conditionally execute a statement
  * or block of code that follows.  Example:
  *
  * \code
  WB_IF_DEBUG_LEVEL(DebugLevel_WARN | DebugSubSystem_Keyboard)
  {
    // do something for warnings or higher debug level
  }
  * \endcode
  * \sa \ref DebugLevel
**/
#define WB_IF_DEBUG_LEVEL(L) if(WB_UNLIKELY((WBGetDebugLevel() & DebugLevel_MASK) >= ((L) & DebugLevel_MASK)) && \
                                (!((L) & DebugSubSystem_MASK) || !(WBGetDebugLevel() & DebugSubSystem_MASK) \
                                   || (((L) & WBGetDebugLevel()) & DebugSubSystem_MASK) != 0))

#endif // NO_DEBUG


/** \ingroup debug
  * \brief Preferred method of implementing a 'warning level' debug message for all subsystems
  *
  * Preferred method of implementing a 'warning level' debug message for all subsystems
**/
#define WB_WARN_PRINT(...) WB_DEBUG_PRINT(DebugLevel_WARN, __VA_ARGS__)

/** \ingroup debug
  * \brief Preferred method of implementing an 'error level' debug message for all subsystems
  *
  * Preferred method of implementing an 'error level' debug message for all subsystems
**/
#define WB_ERROR_PRINT(...) WB_DEBUG_PRINT(DebugLevel_ERROR, __VA_ARGS__)

/** \ingroup debug
  * \brief Preferred method of implementing a 'warning level' binary dump for all subsystems
  *
  * \param X A const pointer to a 0-byte terminated string containing the 'title' string
  * \param Y A const void pointer to the data to be dumped
  * \param Z An unsigned integer indicating the number of bytes to display
  *
  * Preferred method of implementing a 'warning level' binary dump for all subsystems
**/
#define WB_WARN_DUMP(X,Y,Z) WB_DEBUG_DUMP(DebugLevel_WARN, X,Y,Z)

/** \ingroup debug
  * \brief Preferred method of implementing an 'error level' binary dump for all subsystems
  *
  * \param X A const pointer to a 0-byte terminated string containing the 'title' string
  * \param Y A const void pointer to the data to be dumped
  * \param Z An unsigned integer indicating the number of bytes to display
  *
  * Preferred method of implementing an 'error level' binary dump for all subsystems
**/
#define WB_ERROR_DUMP(X,Y,Z) WB_DEBUG_DUMP(DebugLevel_ERROR, X,Y,Z)

/** \ingroup debug
  * \enum DebugLevel
  * \brief Debug level enumeration
  *
  * Debug Level enumeration and subsystem idetification enumeration
  *
  * Bits 0 to 3 identify the level (0 = none, 7 = excessive)\n
  * The remaining bits identify the subsystem filters (no bits set for ALL)
**/
enum DebugLevel
{
  DebugLevel_None = 0,      //!< none (no debug output)
  DebugLevel_ERROR = 0,     //!< errors (output whenever debug cmopiled in)
  DebugLevel_WARN = 1,      //!< warnings (all debug levels)

                            // criteria for selecting debug output
  DebugLevel_Minimal = 1,   //!< minimal, implies warnings and important information
  DebugLevel_Light = 2,     //!< light, implies basic process/flow information
  DebugLevel_Medium = 3,    //!< medium, implies process/flow tracing
  DebugLevel_Heavy = 4,     //!< heavy, implies detailed process/flow tracing
  DebugLevel_Chatty = 5,    //!< chatty, implies details about flow decisions
  DebugLevel_Verbose = 6,   //!< verbose, implies details regarding information used for decision making
  DebugLevel_Excessive = 7, //!< excessive, implies more information that you probably want
  DebugLevel_MASK = 7,      //!< mask for allowed 'level' values (none through Excessive)

  // next are subsystem masks for additional debugging
  DebugSubSystem_ALL         = 0,           //!< 'ALL' is the default unless masked bits are non-zero
  DebugSubSystem_RESTRICT    = 0x80000000,  //!< only show specific subsystems (prevents zero masked value)
  DebugSubSystem_BITSHIFT    = 3,           //!< bit # for 'lowest' subsystem bit
  DebugSubSystem_Init        = 0x00000008,  //!< initialization/termination
  DebugSubSystem_Application = 0x00000010,  //!< application-level
  DebugSubSystem_Window      = 0x00000020,  //!< generic window processing
  DebugSubSystem_Menu        = 0x00000040,  //!< generic menu processing
  DebugSubSystem_Event       = 0x00000080,  //!< generic event processing
  DebugSubSystem_Dialog      = 0x00000100,  //!< dialog box (container window)
  DebugSubSystem_DialogCtrl  = 0x00000200,  //!< dialog controls
  DebugSubSystem_Frame       = 0x00000400,  //!< Frame windows
  DebugSubSystem_Keyboard    = 0x00000800,  //!< generic keyboard processing
  DebugSubSystem_Mouse       = 0x00001000,  //!< generic mouse event processing
  DebugSubSystem_Font        = 0x00002000,  //!< font manager
  DebugSubSystem_Settings    = 0x00004000,  //!< settings manager
  DebugSubSystem_Selection   = 0x00008000,  //!< selection processing

  DebugSubSystem_MASK = ~7L  //!< mask for allowed 'subsystem' bits
};



////////////////////////////////////////////////////////////
//   ____   _____  _____  _    _   _  _    _____  ____    //
//  |  _ \ | ____||  ___|/ \  | | | || |  |_   _|/ ___|   //
//  | | | ||  _|  | |_  / _ \ | | | || |    | |  \___ \   //
//  | |_| || |___ |  _|/ ___ \| |_| || |___ | |   ___) |  //
//  |____/ |_____||_| /_/   \_\\___/ |_____||_|  |____/   //
//                                                        //
////////////////////////////////////////////////////////////

/** \ingroup core
  * \defgroup defaults Default Parameters
  * Functions and variables associated with default parameters
**/

/** \ingroup defaults
  * \brief Returns the default Display
  *
  * The default display is usually the ONLY display in use by the
  * application.  This function returns that Display pointer, which
  * can be used in any case where the current display is not known
  *
  * \sa  WBGetWindowDisplay()
  *
  * Header File:  window_helper.h
**/
static __inline__ Display * WBGetDefaultDisplay(void)
{
  extern Display *pDefaultDisplay;
  return pDefaultDisplay;
}

/** \ingroup defaults
  * \brief Returns a pointer to the default font's XFontStruct
  *
  * The default XFontStruct is allocated at startup.  This function
  * returns a pointer to this XFontStruct, which can be used in a
  * case where the 'in use' XFontStruct is not known, or when an
  * overriding font has not been specified.
  *
  * Header File:  window_helper.h
**/
XFontStruct *WBGetDefaultFont(void);

/** \ingroup defaults
  * \brief Returns a special 'hidden' window used for information purposes
  *
  * This function returns a special window that was created for information
  * purposes.  If you need a window for query purposes that belongs to the
  * default display, you can use the one returned by this function.
  *
  * Header File:  window_helper.h
**/
Window WBGetHiddenHelperWindow(void);  // if you need "a window" for the default display, use this




///////////////////////////////////////////////////////////////////////////////////////
//    ____  _      ___   ____     _     _           _   _____  ___   __  __  ____    //
//   / ___|| |    / _ \ | __ )   / \   | |         / \ |_   _|/ _ \ |  \/  |/ ___|   //
//  | |  _ | |   | | | ||  _ \  / _ \  | |        / _ \  | | | | | || |\/| |\___ \   //
//  | |_| || |___| |_| || |_) |/ ___ \ | |___    / ___ \ | | | |_| || |  | | ___) |  //
//   \____||_____|\___/ |____//_/   \_\|_____|  /_/   \_\|_|  \___/ |_|  |_||____/   //
//                                                                                   //
///////////////////////////////////////////////////////////////////////////////////////

// global atoms (for convenience they are referenced directly via global variables)

#if !defined(_WINDOW_HELPER_C_) && !defined(_CLIPBOARD_HELPER_C)
     /* this declares the atoms 'const' outside of window_helper.c, and does NOT declare them in clipboard_helper.c */
     /* These atoms are GLOBAL variables, assigned by the DEFAULT Display, and may not work for other threads.      */
extern const Atom aMENU_COMMAND;     // commands sent by menus via ClientMessage
extern const Atom aMENU_UI_COMMAND;  // UI notification sent by menus to owning frame windows via ClientMessage using WBWindowDispatch
extern const Atom aRESIZE_NOTIFY;    // notification of window re-size via ClientMessage
extern const Atom aDESTROY_NOTIFY;   // notify parent that child is being destroyed
extern const Atom aCONTROL_NOTIFY;   // dialog control and child window notification messages
                                     // l[0] contains control ID or -1, l[1] is notify code, l[2] is window ID
extern const Atom aDLG_FOCUS;        // dialog focus messages: l[0] is <,0,> for prev, 'set to', next.  For 'set to' l[1] is control ID
extern const Atom aSET_FOCUS;        // 'set focus' messages (send/post to application)
extern const Atom aWM_CHAR;          // character notifications (generated by API; avoids key up/down handling)
extern const Atom aWM_TIMER;         // timer notifications (generated by API)
extern const Atom aWM_POINTER;       // pointer notifications (generated by API)

// things used by window managers
extern const Atom aWM_PROTOCOLS;     // WM supported protocols (see 'freedesktop.org' WM docs)
extern const Atom aWM_DELETE_WINDOW; // WM command to delete a window (a click on the 'x')
extern const Atom aWM_TAKE_FOCUS;    // WM protocol (part of WM_PROTOCOLS spec, ICCCM, assoc with focus bit in WM_HINTS)

// things used by the clipboard
extern const Atom aCLIPBOARD;        // Atom for 'CLIPBOARD'
extern const Atom aPRIMARY;          // Atom for 'PRIMARY'
extern const Atom aSECONDARY;        // Atom for 'SECONDARY'
extern const Atom aMANAGER;          // Atom for 'MANAGER'
extern const Atom aTARGET;           // Atom for 'TARGET'
extern const Atom aINCR;             // Atom for 'INCR' (incremental transfers)
extern const Atom aWINDOW;           // Atom for 'WINDOW'
extern const Atom aBITMAP;           // Atom for 'BITMAP'
extern const Atom aDRAWABLE;         // Atom for 'DRAWABLE'
extern const Atom aCOLORMAP;         // Atom for 'COLORMAP'
extern const Atom aPIXEL;            // Atom for 'PIXEL'
extern const Atom aPIXMAP;           // Atom for 'PIXMAP'
extern const Atom aTEXT;             // Atom for 'TEXT'
extern const Atom aSTRING;           // Atom for 'STRING'
extern const Atom aUTF8_STRING;      // Atom for 'UTF8_STRING'
extern const Atom aC_STRING;         // Atom for 'C_STRING'
extern const Atom aCOMPOUND_TEXT;    // Atom for 'COMPOUND_TEXT'
extern const Atom aTARGETS;          // Atom for 'TARGETS'
extern const Atom aMULTIPLE;         // Atom for 'MULTIPLE'
extern const Atom aTIMESTAMP;        // Atom for 'TIMESTAMP'
extern const Atom aNULL;             // Atom for 'NULL'
#endif // !_WINDOW_HELPER_C, !_CLIPBOARD_HELPER_C



/////////////////////////////////////////////////////////
//    ____  ___   ____   _____       _     ____  ___   //
//   / ___|/ _ \ |  _ \ | ____|     / \   |  _ \|_ _|  //
//  | |   | | | || |_) ||  _|      / _ \  | |_) || |   //
//  | |___| |_| ||  _ < | |___    / ___ \ |  __/ | |   //
//   \____|\___/ |_| \_\|_____|  /_/   \_\|_|   |___|  //
//                                                     //
/////////////////////////////////////////////////////////

/** \ingroup core
  * \defgroup wcore Window 'Core'
  *
  * These functions and definitions comprise the CORE WINDOW HANDLING functionality
  * for the X11workbench Toolkit API.  This includes information and initialization
  * functions, but not event nor class-specific functionality.
**/

/** \ingroup core
  * \defgroup events Event Handling
  *
  * Event handling in X11 involves an event handler loop and methods by which
  * the various events can be dispatched to window callback functions, or to the
  * application's event handler. The X11workbench Toolkit API has provisinos for
  * event prioritization, asynchronous processing, and the generation of 'internal
  * events' (see \ref aWM_CHAR, \ref aWM_POINTER, \ref aWM_TIMER).
**/

/** \ingroup core
  * \defgroup keyboard Keyboard event handling
  *
  * The X11workbench Toolkit API provides for mid-level keyboard event handling via
  * WM_CHAR ClientMessage notification events.\n
  * See \ref aWM_CHAR for more info.
**/

/** \ingroup core
  * \defgroup pointer Mouse Pointer event handling
  *
  * The X11workbench Toolkit API provides for mid-level pointer event handling via
  * WM_POINTER ClientMessage notification events.\n
  * See \ref aWM_POINTER for more info.
**/

/** \ingroup wcore
  * \brief 'Standard' input mask, bit flag for window creation
  *
  * 'Standard' input mask.  Use this as a parameter to XSelectInput to enable standard events to be sent to the window\n
  * This bit mask may be 'or'd with other bit masks as needed.
**/
#define WB_STANDARD_INPUT_MASK (FocusChangeMask | PropertyChangeMask | ExposureMask | StructureNotifyMask | VisibilityChangeMask | SubstructureNotifyMask)

/** \ingroup wcore
  * \brief 'Keyboard' input mask, bit flag for window creation
  *
  * 'Keyboard' input mask.  Use this as a parameter to XSelectInput to enable keyboard events to be sent to the window\n
  * This bit mask may be 'or'd with other bit masks as needed.
**/
#define WB_KEYBOARD_INPUT_MASK (KeyPressMask | KeyReleaseMask)

/** \ingroup wcore
  * \brief 'Mouse' input mask, bit flag for window creation
  *
  * 'Mouse' input mask.  Use this as a parameter to XSelectInput to enable mouse events to be sent to the window\n
  * This bit mask may be 'or'd with other bit masks as needed.
**/
#define WB_MOUSE_INPUT_MASK (ButtonPressMask | ButtonReleaseMask | PointerMotionMask | EnterWindowMask | LeaveWindowMask)


/** \ingroup wcore
  * \hideinitializer
  * \brief Window type enumeration.  Reserved for future implementation.
  *
  * reserved for future implementation
**/
enum WMPropertiesWindowType
{
  // must be ONLY ONE of the items below
  WMPropertiesWindowType_TypeMask     = 0x3f,
  WMPropertiesWindowType_Normal       = 0,
  WMPropertiesWindowType_Desktop      = 1,
  WMPropertiesWindowType_Dock         = 2,
  WMPropertiesWindowType_ToolBar      = 3,
  WMPropertiesWindowType_Menu         = 4,
  WMPropertiesWindowType_Utility      = 5,
  WMPropertiesWindowType_Splash       = 6,
  WMPropertiesWindowType_Dialog       = 7,
  WMPropertiesWindowType_DropDownMenu = 8,
  WMPropertiesWindowType_PopupMenu    = 9,
  WMPropertiesWindowType_ToolTip      = 10,
  WMPropertiesWindowType_Notification = 11,
  WMPropertiesWindowType_Combo        = 12,
  WMPropertiesWindowType_Drag_N_Drop  = 13,
  WMPropertiesWindowType_Reserved14   = 14,
  WMPropertiesWindowType_Reserved15   = 15,


  // may be A COMBINATION of the items below
  WMPropertiesWindowType_StateMask        = 0xfffC0,

  WMPropertiesWindowType_NoState          = 0,
  WMPropertiesWindowType_Modal            = 0x00040,
  WMPropertiesWindowType_Sticky           = 0x00080,
  WMPropertiesWindowType_VMax             = 0x00100,
  WMPropertiesWindowType_HMax             = 0x00200,
  WMPropertiesWindowType_FullScreen       = 0x00400,
  WMPropertiesWindowType_Hidden           = 0x00800,
  WMPropertiesWindowType_Shaded           = 0x01000,
  WMPropertiesWindowType_SkipTaskbar      = 0x02000,
  WMPropertiesWindowType_SkipPager        = 0x04000,
  WMPropertiesWindowType_Above            = 0x08000,
  WMPropertiesWindowType_Below            = 0x10000,
  WMPropertiesWindowType_Focused          = 0x20000,
  WMPropertiesWindowType_DemandsAttention = 0x40000,
  WMPropertiesWindowType_Reserved80000    = 0x80000,


  // TODO:  other stuff

  WMPropertiesWindowType_Max = 0x80000000
};

/** \ingroup wcore
  * \hideinitializer
  * \brief Window WMProtocols support enumeration.
  *
  * Bit flags indicating support for known WM_PROTOCOLS window manager features
**/
enum WMPropertiesWMProtocols
{
  // The following flags indicate WM_PROTOCOLS support
  // Assigning these directly can have unexpected consequences
  WMPropertiesWMProtocols_Mask            = 0xff,
  WMPropertiesWMProtocols_None            = 0x0,  // the default
  WMPropertiesWMProtocols_DeleteWindow    = 0x01,
  WMPropertiesWMProtocols_Reserved2       = 0x02,
  WMPropertiesWMProtocols_Reserved3       = 0x04,
  WMPropertiesWMProtocols_Reserved4       = 0x08,
  WMPropertiesWMProtocols_Reserved5       = 0x10,
  WMPropertiesWMProtocols_Reserved6       = 0x20,
  WMPropertiesWMProtocols_Reserved7       = 0x40,
  WMPropertiesWMProtocols_Reserved8       = 0x80,
};



/** \ingroup wcore
  * \brief Create a window
  *
  * \param pDisplay A pointer to the display
  * \param wIDParent The parent window, or 'None'
  * \param pProc A pointer to the event handler proc
  * \param szClass The name of the window's class (mostly for debugging)
  * \param iX The X position of the window
  * \param iY The Y position of the window
  * \param iWidth The width of the window
  * \param iHeight The height of the window
  * \param iBorder The border width of the window
  * \param iIO The I/O type of the window (Input, InputOutput, etc.)
  * \param iFlags The flags indicating which bits are valid in the XSetWindowAttributes structure
  * \param pXSWA A pointer to the XSetWindowAttributes structure
  * \return A valid Window ID, or 'None' on error
  *
  * Call this function to create a window, in lieu of XCreateWindow.  It will automatically
  * register the callback function and the class name, and sets up a few default parameters
  * for you automatically.\n
  * The window is created with the default visual and depth for the specified display with
  * default screen and a default set of WM_HINTS.
  *
  * Header File:  window_helper.h
**/
Window WBCreateWindow(Display *pDisplay, Window wIDParent,
                      WBWinEvent pProc, const char *szClass,
                      int iX, int iY, int iWidth, int iHeight, int iBorder, int iIO,
                      int iFlags, XSetWindowAttributes *pXSWA);

/** \ingroup wcore
  * \brief Destroy a window
  *
  * Call this function to destroy a window, rather than XDestroyWindow
  *
  * Header File:  window_helper.h
**/
void WBDestroyWindow(Window wID);

/** \ingroup wcore
  * \brief Destroy a window
  *
  * \return The application window's Window ID, or 'None'
  *
  * Call this function to get the 'Application' window's ID registered via WBSetApplicationWindow().
  * There can be only one.
  *
  * Header File:  window_helper.h
**/
Window WBGetApplicationWindow(void);

/** \ingroup wcore
  * \brief Destroy a window
  *
  * \param wID The Window identifier of the 'application' window, or None
  *
  * Call this function to set the 'Application' window's ID.  There can be only one.
  * Make sure the window has an assigned callback already, or the assignment will fail.
  * Once the application window's callback has been unregistered, the application window
  * ID will be reset to 'None' automatically.
  *
  * Header File:  window_helper.h
**/
void WBSetApplicationWindow(Window wID);

/** \ingroup wcore
  * \brief implements the default window event callback behavior
  *
  * Header File:  window_helper.h
**/
int WBDefault(Window wID, XEvent *pEvent);

/** \ingroup wcore
  * \brief implements the default application event callback behavior
  *
  * Header File:  window_helper.h
**/
int WBAppDefault(XEvent *pEvent);

/** \ingroup wcore
  * \brief Registers a callback function for application events
  *
  * To handle events sent to the application ('no window' events), register a callback
  * function using this API.  The callback function you register should call WBAppDefault()
  * for any events that it does not process.
  *
  * Header File:  window_helper.h
**/
void WBRegisterAppCallback(WBAppEvent pCallback);

/** \ingroup wcore
  * \brief unregister callback function for application events
  *
  * Header File:  window_helper.h
**/
void WBUnregisterAppCallback();

/** \ingroup wcore
  * \brief register callback function for a window (required)
  *
  * Header File:  window_helper.h
**/
void WBRegisterWindowCallback(Window wID, WBWinEvent pCallback);

/** \ingroup wcore
  * \brief un-register the window's callback function (implies resource destruction)
  *
  * Header File:  window_helper.h
**/
void WBUnregisterWindowCallback(Window wID);

/** \ingroup wcore
  * \brief assign standard WM (Window Manager) properties via XSetWMProperties
  *
  * \param wID The Window ID for the window
  * \param szTitle A const pointer to a character string containing the window title
  * \param pNormalHints The pointer to the XSiteHints data, or NULL
  * \param pWMHints The pointer to the XWMHints data, or NULL
  * \param pClassHints The pointer to the XClassHint data, or NULL
  *
  * Header File:  window_helper.h
**/
void WBSetWMProperties(Window wID, const char *szTitle, XSizeHints *pNormalHints,
                       XWMHints *pWMHints, XClassHint *pClassHints);
/** \ingroup wcore
  * \brief assign window (and icon) title
  *
  * \param wID The Window ID for the window
  * \param szTitle A const pointer to a character string containing the window title
  *
  * Header File:  window_helper.h
**/
void WBSetWindowTitle(Window wID, const char *szTitle);

/** \ingroup wcore
  * \brief assign standard WM (Window Manager) 'window type' properties BEFORE mapping it (reserved)
  *
  * \param wID The Window ID for the window
  * \param wmProp An inclusive set of enumerated bit values from the WMPropertiesWindowType enumeration
  *
  * \sa <a href="http://standards.freedesktop.org/wm-spec/wm-spec-latest.html">latest WM spec</a>
  * <a href="http://standards.freedesktop.org/freedesktop-platform-specs/1.0/wm-spec-1.3/"> WM spec v 1.3</a>
  *
  * Header File:  window_helper.h
**/
void WBSetWMPropertiesWindowType(Window wID, enum WMPropertiesWindowType wmProp);

/** \ingroup wcore
  * \brief re-assign standard WM (Window Manager) 'window type' properties and notify the root window (reserved)
  *
  * \param wID The Window ID for the window
  * \param wmPropSet A set of enumerated bit values from the WMPropertiesWindowType enumeration
  * \param wmChangeMask A mask for the enumerated bit values to change from the WMPropertiesWindowType enumeration
  *
  * \sa <a href="http://standards.freedesktop.org/wm-spec/wm-spec-latest.html">latest WM spec</a>
  * <a href="http://standards.freedesktop.org/freedesktop-platform-specs/1.0/wm-spec-1.3/"> WM spec v 1.3</a>
  *
  * Header File:  window_helper.h
**/
void WBChangeWMPropertiesWindowType(Window wID, enum WMPropertiesWindowType wmPropSet, enum WMPropertiesWindowType wmChangeMask);


/** \ingroup wcore
  * \brief re-assign standard WM (Window Manager) 'window type' properties and notify the root window (reserved)
  *
  * \param wID The Window ID for the window
  * \return A bitmask consisting of WMPropertiesWindowType enumeration values.
  *
  * These values are cached from WBSetWMPropertiesWindowType() and WBChangeWMPropertiesWindowType()
  *
  * Header File:  window_helper.h
**/
enum WMPropertiesWindowType WBGetWMPropertiesWindowType(Window wID);

/** \ingroup wcore
  * \brief re-assign standard WM (Window Manager) 'window type' properties and notify the root window (reserved)
  *
  * \param wID The Window ID for the window
  * \param aProperty The atoms to be assigned to the supported WM Protocols list
  *
  * Additional parameters are all Atom values, the last one being 'None' to mark the end of the list.
  * These Atoms will be assigned to the WM_PROTOCOLS property via XSetWMProtocols().  In some cases,
  * the behavior of the toolkit will change depending on the atoms that are assigned.  This assignment
  * should ONLY be done on top-level windows, and only at the time of window creation.
  *
  * Header File:  window_helper.h
**/
void WBSetWMProtocols(Window wID, Atom aProperty, ...);


/** \ingroup wcore
  * \brief callback definition for WBLocateWindow
  *
  * \param wID The ID of the window being enumerated
  * \param pData The pointer specified in the call to WBLocateWindow
  * \return A value > 0 to indicate a match, < 0 to stop enumerating, 0 to continue enumerating
  *
  * Header File:  window_helper.h
**/
typedef int (*WBLocateWindowCallback)(Window wID, void *pData);

/** \ingroup wcore
  * \brief Locate a window by enumerating with a callback function
  *
  * \param callback A pointer to a callback function to call for each enumerated window - see \ref WBLocateWindowCallback
  * \param pData A void pointer that is passed to the callback function as its 2nd parameter
  * \return The Window ID being enumerated when the callback returns a value > 0, or None
  *
  * loops through all known windows passing the window ID and pData
  * to the callback function.  The callback function then determines
  * whether this is the window (droids?) you are looking for.
  *
  * The callback must return > 0 if found, 0 if not found, < 0 to quit enumerating
  *
  * WBLocateWindow then returns either 0 (None) or a valid window ID
  *
  * \sa  \ref WBLocateWindowCallback
  *
  * Header File:  window_helper.h
**/
Window WBLocateWindow(WBLocateWindowCallback callback, void *pData);

/** \ingroup wcore
  * \brief set input focus to a specific window
  *
  * \param wID The Window ID to assign the focus
  *
  * Call this function to assign the input focus to a specific window.  The 'revert'
  * window will be the previous focus window.
  *
  * Header File:  window_helper.h
**/
void WBSetInputFocus(Window wID);

/** \ingroup wcore
  * \brief returns the Display associated with a window
  *
  * \param wID The Window ID from which to obtain the Display pointer
  * \return A Display pointer corresponding to the Window ID, or NULL on error
  *
  * Header File:  window_helper.h
**/
Display * WBGetWindowDisplay(Window wID);

/** \ingroup wcore
  * \brief assigns an icon resource (by ID) to a window
  *
  * \param wID The Window ID from which to return the default cursor
  * \param idIcon The resource ID for the window's icon
  *
  * Header File:  window_helper.h
**/
void WBSetWindowIcon(Window wID, int idIcon);

/** \ingroup wcore
  * \brief assigns the default XFontStruct to a window
  *
  * \param wID The Window ID from which to return the default cursor
  * \param pFontStruct A pointer to an XFontStruct that describes the font
  *
  * Header File:  window_helper.h
**/
void WBSetWindowFontStruct(Window wID, XFontStruct *pFontStruct);

/** \ingroup wcore
  * \brief Assigns a default cursor (by ID) to a window
  *
  * \param wID The Window ID from which to return the default cursor
  * \param idStandardCursor The default Cursor ID to assign (Typically an XC_ definition from X11/cursorfont.h).  A value of '-1' equates to 'None'
  *
  * Header File:  window_helper.h
**/
void WBSetWindowDefaultCursor(Window wID, int idStandardCursor);

/** \ingroup wcore
  * \brief returns the default cursor ID for a window
  *
  * \param wID The Window ID from which to return the default cursor
  * \return The Cursor ID (Typically an XC_ definition from X11/cursorfont.h).  A value of '-1' equates to 'None'
  *
  * Header File:  window_helper.h
**/
int WBGetWindowDefaultCursor(Window wID);

/** \ingroup wcore
  * \brief creates a default GC for a window
  *
  * \param wID The Window ID for which to assign the colors
  * \param clrFG The foreground color
  * \param clrBG The background color
  *
  * Header File:  window_helper.h
**/
void WBCreateWindowDefaultGC(Window wID, unsigned long clrFG, unsigned long clrBG);

/** \ingroup wcore
  * \brief assigns a default GC to a window
  *
  * \param wID The Window ID for which to assign the GC
  * \param hGC The GC to assign
  *
  * Header File:  window_helper.h
**/
void WBSetWindowDefaultGC(Window wID, GC hGC);

/** \ingroup wcore
  * \brief makes a copy of the default GC so that it can be modified
  *
  * \param wID The Window ID from which to copy the GC
  * \return A copy of the default GC for the specified window
  *
  * Header File:  window_helper.h
**/
GC WBGetWindowCopyGC(Window wID);

/** \ingroup wcore
  * \brief makes a copy of the specified GC for the desired window
  *
  * \param wID The Window ID for which to copy the GC
  * \param gcSrc The source 'GC'
  * \return A copy of the GC for the specified window
  *
  * Essentially, it works the same as WBGetWindowCopyGC() except it uses gcSrc
  * instead of the window's 'default GC'.
  *
  * Header File:  window_helper.h
**/
GC WBGetWindowCopyGC2(Window wID, GC gcSrc);

/** \ingroup wcore
  * \brief return a copy of the XFontStruct that was assigned to a GC
  *
  * \param pDisplay A pointer to the Display
  * \param gc The GC to be queried
  * \returns A pointer to an XFontStruct, or NULL on error.  non-NULL values must be freed via XFreeFont()
  *
  * Call this function to determine the font that has been assigned to a GC.  If
  * there has been NO font assigned, the system default font information will be
  * returned.  The return value is always a new pointer to an XFontStruct, or
  * NULL on error.  The caller must free non-NULL return values via XFreeFont().
  *
  * Header File:  window_helper.h
**/
XFontStruct * WBGetGCFont(Display *pDisplay, GC gc);

/** \ingroup wcore
  * \brief assign 'data pointer' for a window and specified index value
  *
  * \param wID The Window ID to which to assign the data pointer
  * \param iIndex The 0-based index that identifies the entry
  * \param pData The data pointer to assign (may be NULL)
  *
  * Header File:  window_helper.h
**/
void WBSetWindowData(Window wID, int iIndex, void *pData);

/** \ingroup wcore
  * \brief increment 'wait cursor' count, set cursor to WB_WAIT_CURSOR
  *
  * \param wID The Window ID to which the wait cursor needs to be assigned
  *
  * Header File:  window_helper.h
**/
void WBBeginWaitCursor(Window wID);

/** \ingroup wcore
  * \brief decrement 'wait cursor' count, restore to default when zero
  *
  * \param wID The Window ID to which the cursor needs to be restored
  *
  * Header File:  window_helper.h
**/
void WBEndWaitCursor(Window wID);

/** \ingroup wcore
  * \brief immediately set the window cursor
  *
  * \param wID The Window ID to which the cursor needs to be assigned
  * \param idCursor The Cursor ID (Typically an XC_ definition from X11/cursorfont.h).  A value of '-1' equates to 'None'
  *
  * Header File:  window_helper.h
**/
void WBSetWindowCursor(Window wID, int idCursor);

/** \ingroup wcore
  * \brief restore the default cursor
  *
  * \param wID The Window ID to which the default cursor needs to be restored
  *
  * Header File:  window_helper.h
**/
void WBRestoreDefaultCursor(Window wID);

/** \ingroup wcore
  * \brief Returns the default GC currently assigned to the window
  *
  * \param wID The Window ID from which to obtain the default GC
  * \return The default GC associated with the specified window.  This is the actual GC, not a copy.
  *
  * Each window that is mapped within the API will have a 'default GC' associated with it.
  * This GC should not be modified unless you want the changes to remain for the next time a GC
  * is required.  A preferred method is to re-assign a new default GC with the new settings, or
  * create a copy of the default GC as a 'starting point', then modify the copy as needed to
  * perform the desired operation.  This, in fact, will happen every time you use the API to
  * handle Expose events, via the WBBeginPaint() and WBEndPaint() functions, where the paint
  * GC is a modified version of the default GC.
  *
  * Header File:  window_helper.h
**/
GC WBGetWindowDefaultGC(Window wID);

/** \ingroup wcore
  * \brief Returns the current XFontStruct pointer assigned to the window (may be NULL)
  *
  * \param wID The Window ID from which to obtain the current XFontStruct pointer
  * \return A pointer to the assigned XFontStruct, or NULL
  *
  * Header File:  window_helper.h
**/
XFontStruct *WBGetWindowFontStruct(Window wID);

/** \ingroup wcore
  * \brief Returns the currently assigned foreground color
  *
  * \param wID The Window ID from which to obtain the foreground color
  * \return The current foreground color for the window
  *
  * Header File:  window_helper.h
**/
unsigned long WBGetWindowFGColor(Window wID);

/** \ingroup wcore
  * \brief Returns the currently assigned background color
  *
  * \param wID The Window ID from which to obtain the background color
  * \return The current background color for the window
  *
  * Header File:  window_helper.h
**/
unsigned long WBGetWindowBGColor(Window wID);

/** \ingroup wcore
  * \brief returns the currently assigned foreground color for a GC
  *
  * \param pDisplay A pointer to the Display
  * \param gc The GC to be queried
  * \returns The currently assigned foreground color
  *
  * If the current foreground color cannot be determined, this function will
  * return the pre-defined color for BLACK on the specified Display and default screen
  *
  * Header File:  window_helper.h
**/
unsigned long WBGetGCFGColor(Display *pDisplay, GC gc);

/** \ingroup wcore
  * \brief returns the currently assigned background color for a GC
  *
  * \param pDisplay A pointer to the Display
  * \param gc The GC to be queried
  * \returns The currently assigned background color
  *
  * If the current background color cannot be determined, this function will
  * return the pre-defined color for WHITE on the specified Display and default screen
  *
  * Header File:  window_helper.h
**/
unsigned long WBGetGCBGColor(Display *pDisplay, GC gc);

/** \ingroup wcore
  * \brief Assignes the window's class name pointer
  *
  * \param wID The Window ID to assign a 'class name' to
  * \param szClassName A const pointer to a 0-byte terminated string containing the class name.  The actual pointer is assigned internally.
  *
  * Assigns a pointer to a persistent character string that identifies the
  * 'window class' for debug and tracing purposes.  The pointer must be 'persistent', neither
  * allocated via 'malloc()' or on the stack, since it is assigned directly 'as-is' to the
  * internal structure, without copying the string data.
  *
  * Header File:  window_helper.h
**/
void WBSetWindowClassName(Window wID, const char *szClassName);

/** \ingroup wcore
  * \brief Returns the window's assigned class name pointer
  *
  * \param wID The Window ID to obtain a 'class name' from
  * \return A const pointer to a 0-byte terminated character string containing the window's class name, or NULL if there is none
  *
  * The windows 'class name' is a persistent string pointer that is optionally
  * assigned by calling WBSetWindowClassName().  This function returns the assigned
  * pointer.  Its primary use is for debugging and tracing.
  *
  * Header File:  window_helper.h
**/
const char *WBGetWindowClassName(Window wID);

/** \ingroup wcore
  * \brief Gets the data associated with this window and the specified index
  *
  * \param wID The Window ID to obtain window data for
  * \param iIndex The 0-based index for the window's data
  * \return A void pointer assigned to the specified index for the specified window, or NULL if there is no data.
  *
  * Each window has up to WINDOW_DATA_SIZE void pointers that can be stored within
  * the internal data structure associated with each window.  For many standard
  * windows and controls defined in the API, the first entry (index zero) is reserved.
  * Any unused entries can be made use of in any way necessary.  It is important to
  * keep in mind that these values are not automatically checked, nor are any resources
  * automatically deleted when the window is destroyed.
  *
  * Header File:  window_helper.h
**/
void *WBGetWindowData(Window wID, int iIndex);

/** \ingroup wcore
  * \brief Returns the RAW geometry of the window as reported by the window manager
  *
  * \param wID The Window ID to obtain the WB_GEOM data for
  * \param pGeom A pointer to the WB_GEOM structure to receive the data
  *
  * Header File:  window_helper.h
**/
void WBGetWindowGeom(Window wID, WB_GEOM *pGeom);

/** \ingroup wcore
  * \brief Returns the geometry of the window relative to the root window
  *
  * \param wID The Window ID to obtain the WB_GEOM data for
  * \param pGeom A pointer to the WB_GEOM structure to receive the data
  *
  * Header File:  window_helper.h
**/
void WBGetWindowGeom2(Window wID, WB_GEOM *pGeom);


/** \ingroup wcore
  * \brief Returns the ABSOLUTE window geometry relative the screen
  *
  * \param wID The Window ID to obtain the WB_GEOM data for
  * \param pGeom A pointer to the WB_GEOM structure to receive the data
  *
  * The 'ABSOLUTE' window geometry is the position of the window relative to the
  * origin point (the upper left corner of the screen).  Window managers typically
  * cook all of the XEvent and API data that relates to window positioning, such that
  * a top level frame window's upper left corner is nearly always reported as 0,0 (or similar).
  * Not all window managers behave the same in this regard.  To ensure that an ABSOLUTE
  * window position is known (helpful for centering on screen, etc.), the absolute coordinates
  * are frequently cached within the internal data structure associated with the window.
  * Those cached values are returned by this function.
  *
  * Header File:  window_helper.h
**/
void WBGetWindowGeom0(Window wID, WB_GEOM *pGeom);  // absolute window geometry (from latest notification)

/** \ingroup wcore
  * \brief Returns the WB_RECT (rectangle) defined by the window's geometry, including the border area
  *
  * \param wID The Window ID to obtain the WB_RECT data for
  * \param pRect A pointer to the WB_RECT structure to receive the data
  *
  * Header File:  window_helper.h
**/
void WBGetWindowRect(Window wID, WB_RECT *pRect);

/** \ingroup wcore
  * \brief Returns the WB_RECT (rectangle) defined by the window's geometry, excluding the border area
  *
  * \param wID The Window ID to obtain the WB_RECT data for
  * \param pRect A pointer to the WB_RECT structure to receive the data
  *
  * Header File:  window_helper.h
**/
void WBGetClientRect(Window wID, WB_RECT *pRect);


/** \ingroup wcore
  * \brief Returns the window's parent (or None if there is no parent)
  *
  * \param wID The Window ID to obtain the parent for
  * \return The Window ID of the parent, or None
  *
  * Header File:  window_helper.h
**/
Window WBGetParentWindow(Window wID);


/** \ingroup wcore
  * \brief Assigns the parent to the specified window within the internal structure
  *
  * \param wID The Window ID of the target
  * \param wIDParent The parent Window ID to assign to the internal structure
  *
  * Call this function to assign the specified parent window ID to the internal
  * structure for the target window.  This does NOT re-parent the window!
  *
  * If you want to change the owner window you should call \ref WBReparentWindow() instead.
  * NOTE:  this function should NOT be called for top level windows.
  *
  * Header File:  window_helper.h
**/
void WBSetParentWindow(Window wID, Window wIDParent);

/** \ingroup wcore
  * \brief Assigns a new parent to the specified window (aka 'Re-parent')
  *
  * \param wID The Window ID of the target (to be adopted) window
  * \param wIDParent The new parent Window ID.  Congratulations, it's a Window!
  * \param iX The new X location for the window specified by wID (see XReparentWindow)
  * \param iY The new Y location for the window specified by wID (see XReparentWindow)
  *
  * Call this function to re-assign the parent window via XReparentWindow.  Using this
  * function will ensure that internal information remains synchronized.\n
  *
  * NOTE:  this function should NOT be called for top level windows.
  *
  * Header File:  window_helper.h
**/
int WBReparentWindow(Window wID, Window wIDParent, int iX, int iY); // keeps internal info up to date

/** \ingroup wcore
  * \brief Returns non-zero if wIDParent is in a parent relationsihp with wIDChild
  *
  * \param wIDParent The Window ID for the 'test' parent window
  * \param wIDChild The Window ID for the 'test' child window
  * \return A non-zero value if wIDParent is in a parent/child relatinship with wIDChild; otherwise it returns zero
  *
  * Rather than checking for the parent window ID and doing a 'direct match', this
  * function checks all parent windows of 'wIDChild' to see if 'wIDParent' is
  * one of them, and returns a non-zero value if it is.  Otherwise, the function
  * returns zero.
  *
  * Header File:  window_helper.h
**/
int WBIsChildWindow(Window wIDParent, Window wIDChild);  // non-zero if 'wIDParent' is in a parent relationship with 'wIDChild'

/** \ingroup wcore
  * \brief Returns logical TRUE if the point (X,Y) is within the borders of the rectangle 'R'
  * \param X The X value to check for
  * \param Y The Y value to check for
  * \param R A WB_RECT structure bounding the area to check
  * \return logical TRUE if (X,Y) lies within 'R', FALSE otherwise
  *
**/
#define WBPointInRect(X,Y,R) ((X) >= (R).left && (X) < (R).right && (Y) >= (R).top && (Y) < (R).bottom)

/** \ingroup wcore
  * \brief Returns logical TRUE if the point (X,Y) is within the borders of the geometry 'G'
  * \param X The X value to check for
  * \param Y The Y value to check for
  * \param G A WB_GEOM structure bounding the area to check
  * \return logical TRUE if (X,Y) lies within 'G', FALSE otherwise
**/
#define WBPointInGeom(X,Y,G) ((X) >= (G).x && (X) < ((G).x + (G).width) && (Y) >= (G).y && (Y) < ((G).y + (G).height))

/** \ingroup wcore
  * \brief Returns logical TRUE if the rectangle R1 overlaps/intersects R2
  * \param R1 A WB_RECT structure bounding the first area to check
  * \param R2 A second WB_RECT structure bounding the second area to check
  * \return logical TRUE if the two WB_RECTs intersect, FALSE otherwise
**/
#define WBRectOverlapped(R1,R2) \
  ((((R1).left >= (R2).left && (R1).left < (R2).right) || \
    ((R2).left >= (R1).left && (R2).left < (R1).right)) && \
   (((R1).top >= (R2).top && (R1).top < (R2).bottom) || \
    ((R2).top >= (R1).top && (R2).top < (R1).bottom)))

/** \ingroup wcore
  * \brief Returns logical TRUE if the geometry G1 overlaps/intersects G2
  * \param G1 A WB_GEOM structure bounding the first area to check
  * \param G2 A second WB_GEOM structure bounding the second area to check
  * \return logical TRUE if the two WB_GEOMs intersect, FALSE otherwise
**/
#define WBGeomOverlapped(G1,G2) \
  ((((G1).x >= (G2).x && (G1).x < (G2).x + (G2).width) || \
    ((G2).x >= (G1).x && (G2).x < (G1).x + (G1).width)) && \
   (((G1).y >= (G2).y && (G1).y < (G2).y + (G2).height) || \
    ((G2).y >= (G1).y && (G2).y < (G1).y + (G1).height)))

/** \ingroup wcore
  * \brief Translate X,Y point coordinates relative to a window
  *
  * \param wIDSrc The source Window ID
  * \param iXSrc The X coordinate within wIDSrc
  * \param iYSrc The Y coordinate within wIDSrc
  * \param wIDDest The destination Window ID
  * \param piXDest A pointer to an integer to receive the translated X coordinate
  * \param piYDest A pointer to an integer to receive the translated Y coordinate
  *
  * For many operations, coordinates relative to one window must be translated into
  * coordinates relative to a different window so that they can be used for the
  * new window's processing.\n
  * To translate from screen coordinates, pass 'None' for 'wIDSrc'\n
  *
  * Header File:  window_helper.h
**/
void WBXlatCoordPoint(Window wIDSrc, int iXSrc, int iYSrc, Window wIDDest, int *piXDest, int *piYDest);

/** \ingroup wcore
  * \brief Translate geometry coordinates relative to a window
  *
  * \param wIDSrc The source Window ID
  * \param pGeomSrc A const pointer to a WB_GEOM structure containing the coordinates to translate
  * \param wIDDest The destination Window ID
  * \param pGeomDest A pointer to a WB_GEOM structure that receives the translated coordinates
  *
  * For many operations, coordinates relative to one window must be translated into
  * coordinates relative to a different window so that they can be used for the
  * new window's processing.\n
  * To translate from screen coordinates, pass 'None' for 'wIDSrc'\n
  *
  * Header File:  window_helper.h
**/
void WBXlatCoordGeom(Window wIDSrc, const WB_GEOM *pGeomSrc, Window wIDDest, WB_GEOM *pGeomDest);

/** \ingroup wcore
  * \brief Translate rectangle coordinates relative to a window
  *
  * \param wIDSrc The source Window ID
  * \param pRectSrc A const pointer to a WB_RECT structure containing the coordinates to translate
  * \param wIDDest The destination Window ID
  * \param pRectDest A pointer to a WB_RECT structure that receives the translated coordinates
  *
  * For many operations, coordinates relative to one window must be translated into
  * coordinates relative to a different window so that they can be used for the
  * new window's processing.\n
  * To translate from screen coordinates, pass 'None' for 'wIDSrc'\n
  *
  * Header File:  window_helper.h
**/
void WBXlatCoordRect(Window wIDSrc, const WB_RECT *pRectSrc, Window wIDDest, WB_RECT *pRectDest);

/** \ingroup wcore
  * \brief Returna a non-zero value if X,Y coordinates relative to the reference window are within the query window
  *
  * \param wIDRef The reference Window ID
  * \param iX The X coordinates relative to wIDRef
  * \param iY The Y coordinates relative to wIDRef
  * \param wIDQuery The Window ID of the window to test the translated X and Y values against
  * \return Non-zero if the (X,Y) coordinates are within wIDQuery, zero otherwise.
  *
  * Use this function to see if coordinates relative to one window also fall within another window.
  * Typical use includes 'hover' detection, drag/drop operations, and child window activation
  * To specify X,Y screen coordinates, pass 'None' for 'wIDRef'\n
  *
  * Header File:  window_helper.h
**/
int WBPointInWindow(Window wIDRef, int iX, int iY, Window wIDQuery);

// keyboard translation helpers

/** \ingroup keyboard
  * \brief 'AltCtrlShift' bit flag for 'VK_' keys for WBKeyEventProcessKey()
**/
#define WB_KEYEVENT_KEYSYM 8 /* bit flags for 'piAltCtrlShift' below */

/** \ingroup keyboard
  * \brief 'AltCtrlShift' bit flag for ALT modifier for WBKeyEventProcessKey()
**/
#define WB_KEYEVENT_ALT    4

/** \ingroup keyboard
  * \brief 'AltCtrlShift' bit flag for Control modifier for WBKeyEventProcessKey()
**/
#define WB_KEYEVENT_CTRL   2

/** \ingroup keyboard
  * \brief 'AltCtrlShift' bit flag for Shift modifier for WBKeyEventProcessKey()
**/
#define WB_KEYEVENT_SHIFT  1

/** \ingroup keyboard
  * \brief 'AltCtrlShift' bit mask for Alt+Ctrl+Shift bits for WBKeyEventProcessKey()
**/
#define WB_KEYEVENT_ACSMASK 7


/** \ingroup keyboard
  * \brief Generic keyboard event translation utility
  *
  * \param pEvent A const pointer to an XKeyEvent structure to process
  * \param pBuf A buffer to receive translated keystroke information (may be NULL, see below)
  * \param pcbLen A pointer to an integer (pre-assigned to the length of pBuf) that receives the actual data length (see below) (may be NULL)
  * \param piAltCtrlShift A pointer to an integer that receives bit flags associated with CTRL ALT and SHIFT states (may be NULL)
  * \return The first byte of the character string when 'pBuf' is NOT NULL, or a translated UTF character of 1, 2, or 4 bytes when pBuf is NULL
  *
  * generic utility to process a keystroke.  'pcbLen' must be pre-assigned to size of 'pBuf'
  * if 'pBuf' is to be written to.  Any parameter other than 'pEvent' may be NULL.
  * when pBuf is NULL, pcbLen (if not NULL) receives the required length in bytes
  * when pcbLen is NULL and pBuf is not, length is assumed to be 1 byte
  * return value is the first byte of the character string when 'pBuf' is NOT NULL, or a
  * translated UTF character of 1, 2 or 4 bytes (when pBuf is NULL).
  *
  * \sa  \ref aWM_CHAR, \ref aWM_POINTER
  *
  * Header File:  window_helper.h
**/
int WBKeyEventProcessKey(const XKeyEvent *pEvent, char *pBuf, int *pcbLen, int *piAltCtrlShift);
  // NOTE:  WM_CHAR notification messages (related to WBKeyEventProcessKey)
  // message_type == aWM_CHAR
  // data.l[0] is return frmo WBKeyEventProcessKey
  // data.l[1] is *piAltCtrlShift from WBKeyEventProcessKey
  // data.l[2] is number of characters decoded into data.l[3..4]
  // data.l[3..4] (as char[]) is decode buffer (at least 8 chars long, possibly 16 for 64-bit)



// pointer event definitions - WM_POINTER
// data.l[0] is notification code (below)
// data.l[1] is bitmap of mouse button state (button 1 is bit 0, button 2 is bit 1, etc.)
// data.l[2] is 'WB_KEYEVENT_' mask for CTRL+ALT+SHIFT
// data.l[3] is translated X coordinate
// data.l[4] is translated Y coordinate

/** \ingroup pointer
  * \brief Unspecified event, possible motion or state-chagne notification
**/
#define WB_POINTER_UNSPECIFIED 0 /* possible motion or state-change notifications */

/** \ingroup pointer
  * \brief Mouse 'click' event
**/
#define WB_POINTER_CLICK       1

/** \ingroup pointer
  * \brief WM_POINTER 'double-click' event, send in lieu of WB_POINTER_CLICK for double-click
**/
#define WB_POINTER_DBLCLICK    2

/** \ingroup pointer
  * \brief WM_POINTER 'drag' event, window proc MUST return the window ID to auto-support drag/drop
**/
#define WB_POINTER_DRAG        3 /* window proc returns window ID to support drag/drop */

/** \ingroup pointer
  * \brief WM_POINTER 'drop' event, only sent if drag/drop supported AND was not 'canceled'; see WB_POINTER_CANCEL
**/
#define WB_POINTER_DROP        4 /* may not happen if drag is canceled */

/** \ingroup pointer
  * \brief WM_POINTER 'move' event, for motion notification during drag/drop
**/
#define WB_POINTER_MOVE        5 /* motion notify while dragging */

/** \ingroup pointer
  * \brief WM_POINTER 'cancel' event, cancels an ongoing operation, such as drag/drop (useful for resource cleanup)
**/
#define WB_POINTER_CANCEL      6 /* reservedly any kind of cancellation, but for now, 'drag cancel' */

/** \ingroup pointer
  * \brief WM_POINTER 'scroll up' event, caused by mouse button 4
**/
#define WB_POINTER_SCROLLUP    7 /* scroll event, mouse button 4 */

/** \ingroup pointer
  * \brief WM_POINTER 'scroll down' event, caused by mouse button 5
 **/
#define WB_POINTER_SCROLLDOWN  8 /* scroll event, mouse button 5 */

/** \ingroup pointer
  * \brief WM_POINTER button bitmask  indicating that button 1 is pressed
**/
#define WB_POINTER_BUTTON1 1 /* these are bitmasks */
/** \ingroup pointer
  * \brief WM_POINTER button bitmask  indicating that button 2 is pressed
**/
#define WB_POINTER_BUTTON2 2
/** \ingroup pointer
  * \brief WM_POINTER button bitmask  indicating that button 3 is pressed
**/
#define WB_POINTER_BUTTON3 4
/** \ingroup pointer
  * \brief WM_POINTER button bitmask  indicating that button 4 (scroll wheel 'up') is pressed
**/
#define WB_POINTER_BUTTON4 8
/** \ingroup pointer
  * \brief WM_POINTER button bitmask  indicating that button 5 (scroll wheel 'down') is pressed
**/
#define WB_POINTER_BUTTON5 16

// (you can add multiple menus to multiple windows)
/** \ingroup wcore
  * \brief (internal) Register a MENU callback for a window
  *
  * Header File:  window_helper.h
**/
void WBRegisterMenuCallback(Window wID, WBWinEvent pCallback);

/** \ingroup wcore
  * \brief Add a MENU WINDOW to a (frame) window - more than one is possible, only one currently supported
  *
  * \param wID The Window ID to which a menu window will be added (typically only one)
  * \param wIDMenu The Window ID of the menu window to add/assign to wID
  *
  * Header File:  window_helper.h
**/
void WBAddMenuWindow(Window wID, Window wIDMenu);
/** \ingroup wcore
  * \brief Returns the Window ID of the (first) menu window assigned to a (frame) window
  *
  * \param wID The Window ID for which to query the menu Window ID
  * \return The Window ID for the Menu window assigned to wID (only one may be assigned for this to work)
  *
  * Header File:  window_helper.h
**/
Window WBGetMenuWindow(Window wID);  // returns ID of menu window assigned by above (one only)
/** \ingroup wcore
  * \brief Remove (detach) the specified menu window from a (frame) window
  *
  * \param wID The Window ID for which to remove a menu Window ID
  * \param wIDMenu The Window ID of the menu window to remove
  *
  * Header File:  window_helper.h
**/
void WBRemoveMenuWindow(Window wID, Window wIDMenu);

/** \ingroup xcore
  * \brief returns non-zero if 'valid' (i.e. 'not destroyed')
  *
  * \param pDisplay The Display pointer associated with the specified window
  * \param wID A Window ID to test 'valid'
  * \return Non-zero value if the internal window information exists and the window has not been destroyed, else zero
  *
  * This function works ONLY for windows that have been registered with a callback.
  * It checks to see if the internal window information exists and returns
  * a non-zero value if the internal information exists AND the window itself has not
  * been destroyed.  This works whether or not the window was ever mapped.
  *
  * Header File:  window_helper.h
**/
int WBIsValid(Display *pDisplay, Window wID);



////////////////////////////////////////////////////
//   _____ __     __ _____  _   _  _____  ____    //
//  | ____|\ \   / /| ____|| \ | ||_   _|/ ___|   //
//  |  _|   \ \ / / |  _|  |  \| |  | |  \___ \   //
//  | |___   \ V /  | |___ | |\  |  | |   ___) |  //
//  |_____|   \_/   |_____||_| \_|  |_|  |____/   //
//                                                //
////////////////////////////////////////////////////

// message loop helpers

/** \ingroup events
  * \brief Main message loop, high level API to check for and retrieve the next event
  *
  * \return The 'Time' value for the last event that had a server timestamp
  *
  * In some cases it's necessary to know an approximate value of the X server's timestamp.
  * The message loop will capture the timestamp value whenever it can.  Use this function to
  * return the best known server time value for the default Display.
  *
  * Header File:  window_helper.h
**/
Time WBGetLastEventTime(void);


/** \ingroup events
  * \brief Main message loop, high level API to check for and retrieve the next event
  *
  * \param pDisplay A pointer to the Display to query events on
  * \param pEvent A pointer to an XEvent structure to receive the event data
  * \return A non-zero value if there is an event to be processed, otherwise zero
  *
  * Implementation of the X11workbench Toolkit API is centered around the API's event
  * loop processing.  The main application should implement its message loop by repeatedly
  * calling WBCheckGetEvent and passing any retrieved event to \ref WBDispatch().
  * Internall this function calls the X___CheckEvent functions correctly, dispatches Expose
  * events for asynchronous processing, translates keyboard and pointer events, and handles
  * internally queued events (such as timers and 'posted' events).
  *
  * The function returns a non-zero value if there is an event is to be processed.
  *
  * To correctly implement a message loop, your code should be similar to the following:\n
  * \code
  XEvent event;

  while ( !bQuitFlag )
  {
    if( !WBCheckGetEvent(pX11Display, &event) )
    {
      // as needed, perform an iteration of background processing here

      // With nothing else to do, SLEEP if there is no event in the message queue
      // and no background processing to be performed

// implementations that support 'nanosleep' should use it
#ifdef HAVE_NANOSLEEP
      struct timespec tsp;
      tsp.tv_sec = 0;
      tsp.tv_nsec = 100000;  // wait for .1 msec

      nanosleep(&tsp, NULL);
#else  // HAVE_NANOSLEEP

      usleep(100);  // 100 microsecs - a POSIX alternative to 'nanosleep'

#endif // HAVE_NANOSLEEP
      continue;
    }

    WBDispatch(&event);
  }
  * \endcode
  *
  * Header File:  window_helper.h
**/
int WBCheckGetEvent(Display *pDisplay, XEvent *pEvent);

/** \ingroup events
  * \brief Generic Event Dispatcher, using message type to dispatch
  *
  * \param pEvent A pointer to an XEvent structure to process
  *
  * Call this function to generically dispatch an XEvent.  The application will
  * need to check for a 'quit' state independently.
  * See WBWindowDispatch(), WBAppDispatch()
  *
  * Header File:  window_helper.h
**/
void WBDispatch(XEvent *pEvent);

/** \ingroup events
  * \brief Dispatches an application XEvent.  May be called directly
  *
  * \param pEvent A pointer to an XEvent structure to process
  *
  * Application events have a window ID of None, and are dispatched to
  * the registered Application callback.  In the absence of a callback,
  * default processing is performed.
  *
  * Header File:  window_helper.h
**/
int WBAppDispatch(XEvent *pEvent);

/** \ingroup events
  * \brief Dispatches a window XEvent.  May be called directly
  *
  * \param wID The Window ID that will be 'dispatched' the event, regardless of the event structure contents
  * \param pEvent A pointer to an XEvent structure to process
  *
  * Dispatches an XEvent for the specified window.  Normally, WBDispatch will
  * call this function using the window ID from the XEvent itself, and pass
  * that ID as the first parameter.  A caller may choose to send the event
  * to a different window, specifying its window ID instead.  This is similar
  * to a modal 'Event Send' and can be useful to have a parent or child widnow
  * handle a particular type of event (rather than the destined window).
  *
  * Header File:  window_helper.h
**/
int WBWindowDispatch(Window wID, XEvent *pEvent);

/** \ingroup events
  * \brief debug function to return the name of an X11 event
  *
  * \param iEventID An event type identifier
  * \return A const pointer to an ASCII 0-byte terminated character string representing the event ID, or NULL
  *
  * Intended primarily for debug messages, it returns a pointer to an ASCII
  * string containing the name of the event, based on its event ID.  The ID of
  * the event is the value of 'type' within the XEvent structure.
  *
  * Header File:  window_helper.h
**/
const char * WBEventName(int iEventID);

/** \ingroup events
  * \brief Shows a 'modal' window by processing events until the window closes
  *
  * \param wID Window to be made modal
  * \param bMenuSplashFlag Tri-state boolean indicating menu/splash/normal.  A value of 0 is normal, > 0 menu, < 0 splash
  * \return -1 on error, or the dialog box's 'WBEndModal()' iReturn value
  *
  * Use this function to show a 'modal' window.  The function returns when the window
  * is closed.  'bMenuFlag' is > 0 if menu semantics need to be applied to the modal
  * window, or < 0 if splash semantics need to be applied.  Otherwise, it is treated
  * as a NORMAL (dialog) window.
  *
  * The return value is -1 on error, or the value specified by 'iReturn' in the call
  * to WBEndModal().
  *
  * Header File:  window_helper.h
**/
int WBShowModal(Window wID, int bMenuSplashFlag);  // modal window - returns 'EndModal' value or -1 on error

/** \ingroup events
  * \brief End a modal window with a specific return value
  *
  * \param wID Window ID of the window that must end its modal loop
  * \param iReturn The 'return' value from the modal loop - see \ref WBShowModal()
  *
  * Call this function from within a modal window's event process to close the window
  * and exit from WBShowModal with the specified value in 'iReturn'
  *
  * Header File:  window_helper.h
**/
void WBEndModal(Window wID, int iReturn);

// client-side message queue (avoids XSendEvent)
// to send a message directly use WBAppDispatch and WBWindowDispatch

/** \ingroup events
  * \brief low-level event queue wrapper.  Implements the client-side event queue
  *
  * \param pDisplay The Display pointer to query events on
  * \param pEvent A pointer to an XEvent structure to receive event info
  * \return a non-zero value if an event was obtained, or zero if no event was available
  *
  * Similar to XNextEvent, this function checks the internal (and external) event
  * queues for an event.  Unlike XNextEvent it does not wait for an event to appear
  * before returning.  The function returns zero if there are no events to be processed.
  *
  * Header File:  window_helper.h
**/
int WBNextEvent(Display *pDisplay, XEvent *pEvent);

/** \ingroup events
  * \brief Places a copy of the specified event at the end of the regular (internal) event queue
  *
  * \param wID The Window ID of the event to be posted.  The default 'Display *' will be used
  * \param pEvent A pointer to an XEvent structure containing the event info
  * \return A non-zero value on error, or zero if successful
  *
  * The preferred method of event processing between windows is to post them to one of the internal
  * event queues, rather than using XSendEvent() or calling WBDispatch() or WBWindowDispatch() directly.\n
  * You should always use this function for asynchronously posting non-priority events, such as
  * notifications and timers, or when recursion may occur.  Note that any pointers or X11 resources
  * that are passed using XEvent may not be valid by the time they are received. If you must pass
  * volatile data to a window, use WBDispatch() or WBWindowDispatch() instead.
  *
  * Header File:  window_helper.h
**/
int WBPostEvent(Window wID, XEvent *pEvent);

/** \ingroup events
  * \brief Places a copy of the specified event at the end of the priority (internal) event queue
  *
  * \param wID The Window ID of the event to be posted.  The default 'Display *' will be used
  * \param pEvent A pointer to an XEvent structure containing the event info
  * \return A non-zero value on error, or zero if successful
  *
  * The preferred method of event processing between windows is to post them to one of the internal
  * event queues, rather than using XSendEvent() or calling WBDispatch() or WBWindowDispatch() directly.\n
  * Use WBPostPriorityEvent for priority events, such as UI handling (where performance is critical)
  *
  * Header File:  window_helper.h
**/
int WBPostPriorityEvent(Window wID, XEvent *pEvent); // like above but it goes at the beginning of the queue

/** \ingroup events
  * \brief Delays placing a copy of the specified event at the end of the regular (internal) event queue by a specified number of milliseconds
  *
  * \param pEvent A pointer to an XEvent structure containing the event info
  * \param nDelay The number of milliseconds to delay posting the event
  *
  * Use this function to effectively delay an event's posting to the internal queue for a specified
  * period of time, in milliseconds.  For application messages, specify 'None' for the Window ID
  * in the XEvent structure (otherwise specify the correct Window ID).
  * After the time delay, the event will be retrieved and returned via WBCheckGetEvent() similar to a timer message.
  * If the window specified in the message is destroyed before the timeout, the message will be ignored.
  *
  * Header File:  window_helper.h
**/
void WBPostDelayedEvent(XEvent *pEvent, unsigned int nDelay);

/** \ingroup events
  * \brief Places a copy of the specified event at the end of the priority (internal) event queue
  *
  * \param pEvent A pointer to an XEvent structure containing the event info
  * \return A non-zero value on error, or zero if successful
  *
  * The preferred method of event processing between windows is to post them to one of the internal
  * event queues, rather than using XSendEvent or calling WBDispatch directly.\n
  * Use WBPostAppEvent for application events (where the window ID is 'None')
  *
  * Header File:  window_helper.h
**/
int WBPostAppEvent(XEvent *pEvent);

/** \ingroup events
  * \brief Creates a 'set focus' ClientMessage event for the application event handler
  *
  * \param pDisplay The Display pointer, or 'None' to use default
  * \param wID The Window ID of the window to be set active, raised, and mapped
  * \param wIDFrom The previous window that was active, or None
  * \param nDelay The delay in milliseconds before this action takes place (useful to prevent race conditions)
  *
  * Causes (reliable) 'Set Active' 'Set Input Focus' 'Raise Window' and 'Map Window' events to be
  * applied to a particular window.  In many cases window managers may differ in their handling
  * of things like 'XSetFocus' to set focus to a window.  By handling this in the application event
  * queue, it is possible to delay events asynchronously in a manner that avoids a race condition from
  * the window manager.  Clicking on a window, or using ALT+Tab, or switching desktops may cause unexpected
  * 'things' to take place.  By forcing the window to be ACTIVE and also using the normal 'XSetInputFocus'
  * function, as well as 'Raising' and mapping the window, THIS method is likely to work everywhere, and
  * in a consistent manner.
  *
  * Header File:  window_helper.h
**/
void WBPostDelayedSetFocusAppEvent(Display *pDisplay, Window wID, Window wIDFrom, unsigned int nDelay);

/** \ingroup events
  * \brief low-level event processing, internal handling of Expose events
  *
  * \param pEvent A pointer to an XExposeEvent structure for an Expose event
  *
  * Instead of passing Expose events directly along to the respective window, they are
  * first consolidated, and then re-prioritized for optimimum display performance.\n
  * Expose events typically come in bunches, and all too frequently.  By delaying their
  * processing, AND consolidating them into a single event, it is possible to minimize the
  * un-necessary re-drawing of windows and improve the 'apparent speed' of your applicatino.
  * Normally this is done within WBCheckGetEvent() automatically.  If you decide to implement
  * the message prioritization yourself, you can use this function to handle Expose events
  * for you, and correctly prioritize them.
  *
  * Header File:  window_helper.h
**/
void WBProcessExposeEvent(XExposeEvent *pEvent);  // paint optimization


///////////////////////////////////////////////////////////////
//    ____ _     ___ ____  ____   ___    _    ____  ____     //
//   / ___| |   |_ _|  _ \| __ ) / _ \  / \  |  _ \|  _ \    //
//  | |   | |    | || |_) |  _ \| | | |/ _ \ | |_) | | | |   //
//  | |___| |___ | ||  __/| |_) | |_| / ___ \|  _ <| |_| |   //
//   \____|_____|___|_|   |____/ \___/_/   \_\_| \_\____/    //
//                                                           //
///////////////////////////////////////////////////////////////

/** \defgroup clipboard Clipboard and Selections
  * \ingroup core
  * 
  * Clipboard and generic 'Selection' helper functions.  Use these
  * to copy data to/from the clipboard or other 'selection'.  They
  * will process the requests asynchronously in a thread, returning
  * results in a convenient format.  This avoids the unnecessary
  * complexity of processing inner message loops and allows for
  * completion callback functions and messages.
**/

/** \ingroup clipboard
  * \brief Get clipboard data of requested type
  *
  * \param pDisplay the Display pointer for the selection (NULL for default)
  * \param paType Pointer to an atom indicating the requested data type ('None' for ANY), and returning the actual data type
  * \param piFormat pointer to the returned format (0, 8, 16, or 32)
  * \param pnData the size of the returned data (number of items, based on *piFormat)
  * \return a pointer to the actual data (must use 'free()' to de-allocate the resource)
  *
  * This function will obtain the clipboard data associated with the specified data type, or
  * whichever data it finds first if 'None' is specified as 'paType'.  Some substitutions may occur,
  * such as 'XA_TEXT' vs 'UTF8' (for example), if data in the requested format is not available.
  * The returned value is a pointer to the actual data of size '*pnData' 'items' (which have a bit
  * length as specified by '*piFormat').  You must call 'free()' to release the resource once you are done with it.
  *
  * Header File:  window_helper.h
**/
void * WBGetClipboardData(Display *pDisplay, Atom *paType, int *piFormat, unsigned long *pnData);

/** \ingroup clipboard
  * \brief Get clipboard data of requested type
  *
  * \param pDisplay the Display pointer for the selection (NULL for default)
  * \param aType an atom indicating the data type
  * \param iFormat the data format (0, 8, 16, or 32)
  * \param pData a pointer to the data to be assigned (can be NULL, indicating you want to clear it)
  * \param nData the size of the data (number of items, based on iFormat)
  * \return a value of zero on success, or non-zero on error
  *
  * This function assigns the clipboard data for the specified type ('aType') and format ('iFormat')
  * to the data specified by 'pData' and 'nData'.
  *
  * Header File:  window_helper.h
**/
int WBSetClipboardData(Display *pDisplay, Atom aType, int iFormat, const void *pData, unsigned long nData);


// lower level functions for 'Selections'

/** \ingroup clipboard
  * \brief Get clipboard data of requested type
  *
  * \param pDisplay the Display pointer for the selection (NULL for default)
  * \param aSelection an Atom for the 'selection' data to acquire (usually 'CLIPBOARD' or XA_PRIMARY)
  * \param paType Pointer to an atom indicating the requested data type ('None' for ANY), and returning the actual data type
  * \param piFormat pointer to the returned format (0, 8, 16, or 32)
  * \param pnData the size of the returned data (number of items, based on *piFormat)
  * \return a pointer to the actual data (must use 'free()' to de-allocate the resource)
  *
  * This function will obtain the selection data associated with the target and specified data type, or
  * whichever data it finds first if 'None' is specified as 'paType'.  Some substitutions may occur,
  * such as 'XA_TEXT' vs 'UTF8' (for example), if data in the requested format is not available.
  * The returned value is a pointer to the actual data of size '*pnData' 'items' (which have a bit
  * length as specified by '*piFormat').  You must call 'free()' to release the resource once you are done with it.
  *
  * Header File:  window_helper.h
**/
void * WBGetSelectionData(Display *pDisplay, Atom aSelection, Atom *paType, int *piFormat, unsigned long *pnData);


/** \ingroup clipboard
  * \brief Get clipboard data of requested type
  *
  * \param pDisplay the Display pointer for the selection (NULL for default)
  * \param aSelection an Atom for the 'selection' data to assign (usually 'CLIPBOARD' or XA_PRIMARY)
  * \param aType an atom indicating the data type
  * \param iFormat the data format (0, 8, 16, or 32)
  * \param pData a pointer to the data to be assigned (can be NULL, indicating you want to clear it)
  * \param nData the size of the data (number of items, based on iFormat)
  * \return a value of zero on success, or non-zero on error
  *
  * This function assigns the selection data for the specified target 'aSelection' and type ('aType') and
  * format ('iFormat') to the data specified by 'pData' and 'nData'.
  *
  * Header File:  window_helper.h
**/
int WBSetSelectionData(Display *pDisplay, Atom aSelection, Atom aType, int iFormat, const void *pData, unsigned long nData);




///////////////////////////////////////////////////////////////
//   _____ __  __ ____    ___   ____   _   _  ____   _____   //
//  | ____|\ \/ /|  _ \  / _ \ / ___| | | | ||  _ \ | ____|  //
//  |  _|   \  / | |_) || | | |\___ \ | | | || |_) ||  _|    //
//  | |___  /  \ |  __/ | |_| | ___) || |_| ||  _ < | |___   //
//  |_____|/_/\_\|_|     \___/ |____/  \___/ |_| \_\|_____|  //
//                                                           //
///////////////////////////////////////////////////////////////

/** \ingroup core
  * \defgroup expose Exposure and Mapping/Visibility
  *
  * Proper handling of Expose events is a performance-critical component
  * of graphical interfaces.  To simplify the handling and processing of
  * Expose events there are a set of APIs and internal states that assist
  * you in determining when to re-draw a window, and what portion of the
  * window needs to be re-drawn.
  *
  * A typical Expose event handler might look like this:\n
  * \code
  // parameters to function are XExposeEvent *pEvent, Window wID

  void MyExposeHandler(Window wID, XExposeEvent *pEvent)
  {
    Display *pDisplay = WBGetWindowDisplay(wID);
    GC gc;
    WB_GEOM geomPaint;

    gc = WBBeginPaint(wID, pEvent, &geomPaint);
    if(!gc)
    {
      return;
    }

    // here is where you modify the GC, change foreground/background colors, drawing modes, etc.
    // and perform necessary erasing within the geometry specified by geomPaint.
    // ideally your code will NOT attempt to draw anything outside of geomPaint.

    XSetForeground(pDisplay, gc, WBGetWindowFGColor(wID)); // example
    XSetBackground(pDisplay, gc, WBGetWindowBGColor(wID)); // example

    XClearArea(pDisplay, wID, geomPaint.x, geomPaint.y, geomPaint.width, geomPaint.height, 0);

    // perform any drawing here

    WBEndPaint(wID, gc);
  }

  * \endcode
*/

/** \ingroup expose
  * \brief Wrapper for XMapWindow, makes window visible
  *
  * \param pDisplay A pointer to the Display
  * \param wID The Window ID for the window to map (i.e. make visible)
  * \return The return value from XMapWindow()
  *
  * Use this function when making a window visible, rather than XMapWindow
  * so that the internal state flags and other information can be updated.
  *
  * Header File:  window_helper.h
**/
int WBMapWindow(Display *pDisplay, Window wID);
/** \ingroup expose
  * \brief wrapper for XMapRaised, makes window visible and moves to top
  *
  * \param pDisplay A pointer to the Display
  * \param wID The Window ID for the window to map (i.e. make visible) and Raise (bring to the front)
  * \return The return value from XMapRaised()
  *
  * Use this function when 'raising' a window, rather than XMapRaised
  * so that the internal state flags and other information can be updated
  *
  * Header File:  window_helper.h
**/
int WBMapRaised(Display *pDisplay, Window wID);
/** \ingroup expose
  * \brief wrapper for XUnmapWindow, makes window invisible without destroying it
  *
  * \param pDisplay A pointer to the Display
  * \param wID The Window ID for the window to unmap (i.e. make INvisible)
  * \return The return value from XUnmapWindow()
  *
  * Use this function when making a window invisible, rather than XUnmapWindow
  * so that the internal state flags and other information can be updated
  *
  * Header File:  window_helper.h
**/
int WBUnmapWindow(Display *pDisplay, Window wID);

/** \ingroup expose
  * \brief Returns non-zero if window has been mapped; zero otherwise
  *
  * \param pDisplay A pointer to the Display
  * \param wID The Window ID for the window to check for visibility
  * \return A non-zero value if the window has been both registered and mapped (i.e. is visible), otherwise zero.
  *
  * This function only works for windows that have been registered with a callback
  * function.  It checks the internal flags to see if the window has been mapped,
  * and if it has, it returns a non-zero value.  It can be helpful to avoid unnecessary
  * signals from the X11 API.
  *
  * Header File:  window_helper.h
**/
int WBIsMapped(Display *pDisplay, Window wID);  // non-zero if mapped, zero otherwise
  // NOTE:  this only works for windows that have been registered with a callback


// paint helpers (working in conjunction with 'WBProcessExposeEvent')

/** \ingroup expose
  * \brief 'Paint' helper, invalidates a geometry for asynchronous Expose event generation
  *
  * \param wID The Window ID for the affected window
  * \param pGeom A pointer to a WB_GEOM structure specifying the invalid area, or NULL (implying the entire window)
  * \param bPaintFlag A non-zero value to force re-paint by generating an Expose message.  Zero simply invalidates the specified area
  *
  * In conjunction with WBProcessExposeEvent it adds a geometry to the 'invalid' region
  * associated with the window, and optionally generates an asynchronous expose event
  * if 'bPaintFlag' is non-zero.\n
  * For a zero 'bPaintFlag' the next Expose event will include this geometry as part of
  * its update region.
  *
  * Header File:  window_helper.h
**/
void WBInvalidateGeom(Window wID, const WB_GEOM *pGeom, int bPaintFlag);
/** \ingroup expose
  * \brief 'Paint' helper, invalidates a region for asynchronous Expose event generation
  *
  * \param wID The Window ID for the affected window
  * \param rgn A Region identifier specifying the invalid area, or None (implying the entire window)
  * \param bPaintFlag A non-zero value to force re-paint by generating an Expose message.  Zero simply invalidates the specified area
  *
  * In conjunction with WBProcessExposeEvent it adds a region to the 'invalid' region
  * associated with the window, and optionally generates an asynchronous expose event
  * if 'bPaintFlag' is non-zero.\n
  * For a zero 'bPaintFlag' the next Expose event will include this region as part of
  * its update region.
  *
  * Header File:  window_helper.h
**/
void WBInvalidateRegion(Window wID, Region rgn, int bPaintFlag);
/** \ingroup expose
  * \brief 'Paint' helper, validates a geometry for asynchronous Expose event generation
  *
  * \param wID The Window ID for the affected window
  * \param pGeom A pointer to a WB_GEOM structure specifying the valid area, or NULL (implying the entire window)
  *
  * In conjunction with WBProcessExposeEvent it removes a geometry from the 'invalid' region
  * associated with the window.  If the resulting 'invalid' region is empty, no subsequent
  * 'Expose' event will be generated, even if one had previously been in the queue, until
  * the next Expose event or 'invalid' region exists for this window.
  *
  * Header File:  window_helper.h
**/
void WBValidateGeom(Window wID, const WB_GEOM *pGeom);
/** \ingroup expose
  * \brief 'Paint' helper, validates a region for asynchronous Expose event generation
  *
  * \param wID The Window ID for the affected window
  * \param rgn A Region identifer specifying the valid area, or NULL (implying the entire window)
  *
  * In conjunction with WBProcessExposeEvent it removes a region from the 'invalid' region
  * associated with the window.  If the resulting 'invalid' region is empty, no subsequent
  * 'Expose' event will be generated, even if one had previously been in the queue, until
  * the next Expose event or 'invalid' region exists for this window.
  *
  * Header File:  window_helper.h
**/
void WBValidateRegion(Window wID, Region rgn);

/** \ingroup expose
  * \brief 'Paint' helper, returns a copy of the invalid region for a window
  *
  * \param wID Window ID
  * \return Copy of 'invalid region' for this window, or None.
  *
  * This function returns a copy of the current invalid region for the window, or None if the
  * window is up-to-date.  The caller must destroy the returned value using XDestroyRegion()
  *
  * Header File:  window_helper.h
**/
Region WBGetInvalidRegion(Window wID);

/** \ingroup expose
  * \brief 'Paint' helper, returns a copy of the current 'paint' region for the window
  *
  * \param wID Window ID
  * \return Copy of 'paint region' for this window, or None. not valid outside of BeginPaint() / EndPaint()
  *
  * This function returns a copy of the current paint region for the window, or None if the
  * window is up-to-date.  The caller must destroy the returned value using XDestroyRegion()\n
  * This function is not valid outside of WBBeginPaint() / WBEndPaint() processing, typically part
  * of an 'Expose' event handler.
  *
  * Header File:  window_helper.h
**/
Region WBGetPaintRegion(Window wID);

/** \ingroup expose
  * \brief 'Paint' helper, converts a WB_RECT structure to a Region.
  *
  * \param pRect A const pointer to the WB_RECT structure
  * \return A region that encompasses the area of the WB_RECT structure, or None on error
  *
  * This function converts a WB_RECT structure to a Region.
  * The caller must destroy the returned value using XDestroyRegion()
  *
  * Header File:  window_helper.h
**/
Region WBRectToRegion(const WB_RECT *pRect);

/** \ingroup expose
  * \brief 'Paint' helper, converts a WB_GEOM structure to a Region.
  *
  * \param pGeom A const pointer to the WB_GEOM structure
  * \return A region that encompasses the area of the WB_GEOM structure, or None on error
  *
  * This function converts a WB_GEOM structure to a Region.
  * The caller must destroy the returned value using XDestroyRegion()
  *
  * Header File:  window_helper.h
**/
Region WBGeomToRegion(const WB_GEOM *pGeom);

/** \ingroup expose
  * \brief 'Paint' helper, generates an asynchronous Expose event for non-empty 'invalid' region
  *
  * Whenever the 'invalid' region is non-empty, you can generate an asynchronous Expose event
  * using this function.  This allows you to invalidate several geometries or regions during
  * normal processing, with the paint flag set to 'false', and then generate a single Expose
  * event after all of the processing has completed.
  *
  * Header File:  window_helper.h
**/
void WBUpdateWindow(Window wID);  // posts an expose event for the specified window

/** \ingroup expose
  * \brief 'Paint' helper, generates an immediate Expose event for non-empty 'invalid' region
  *
  * Whenever the 'invalid' region is non-empty, you can generate an immediate (synchronous)
  * Expose event using this function.  This is useful for a UI related event in which you need
  * to re-paint portions of a window immediately.\n
  * You should make sure that the Expose handler does not cause recursion, since it will be
  * called directly by this function.
  *
  * Header File:  window_helper.h
**/
void WBUpdateWindowImmediately(Window wID);  // sends expose event synchronously (can cause recursion)

/** \ingroup expose
  * \brief 'Paint' helper, creates a GC for use in updating the window in an Expose event handler
  *
  * \param wID Window ID associated with the Expose event
  * \param pEvent Pointer to the Expose event that's being processed
  * \param pgRet The returned bounding geometry for the invalid region being 'painted'
  * \return A GC (graphics context) to be used in handling the Expose event
  *
  * When processing Expose events, you should call WBBeginPaint to obtain the GC needed for all
  * of the operations needed to update (paint) the window.\n
  * This function collects all of the relevant invalid regions associated with the window that fall
  * within the 'Expose' event area, and calculates a bounding WB_GEOM rectangle for it.  It also applies
  * the invalid region as a 'clipping' region for the returned GC.  When you call WBEndPaint(), the
  * entire clipping region will be marked 'valid' automatically, so it is important for your 'paint'
  * function to update the entire WB_GEOM rectangle identified by pgRet.  This includes erasing the
  * background as well as drawing whatever is in the foreground.
  *
  * Header File:  window_helper.h
**/
GC WBBeginPaint(Window wID, XExposeEvent *pEvent, WB_GEOM *pgRet); // GC has invalid region assigned

/** \ingroup expose
  * \brief 'Paint' helper, creates a GC for use in updating the window for a specified rectangular area
  *
  * \param wID Window ID associated with the Expose event
  * \param pgBounds On entry, the bounding WB_GEOM for which to get a graphics context.  On return, the bounding WB_GEOM for the invalid region being 'painted'
  * \return A GC (graphics context) to be used in painting the specific rectangular region
  *
  * When processing Expose events, you should call WBBeginPaint() to obtain the GC needed for all
  * of the operations needed to update (paint) the window.\n
  * This particular function is more suited to updating a specific area outside of a normal Expose callback handler.
  * As an example, a frame window would use this to update the tab area or the status bar area, prior to calling the
  * user callback function.  That way, only the desired region will be 'validated' on call to WBEndPaint(), and
  * not the entire window client area.
  *
  * Header File:  window_helper.h
**/
GC WBBeginPaintGeom(Window wID, WB_GEOM *pgBounds); // GC has invalid region assigned

/** \ingroup expose
  * \brief 'Paint' helper, frees resources and marks the update region 'valid'
  *
  * \param wID Window ID associated with the Expose event and passed to WBBeginPaint()
  * \param gc The GC (graphics context) returned by WBBeginPaint()
  *
  * Call this function, following a call to WBBeginPaint(), once the invalid area of the window
  * has been properly rendered.  It will free resources and mark the invalid (update) region as 'valid'
  *
  * Header File:  window_helper.h
**/
void WBEndPaint(Window wID, GC gc);  // frees the 'paint GC' and also resets the invalid region

/** \ingroup expose
  * \brief 'Paint' helper, erases background by painting the background color within the clipping region
  *
  * \param wID Window ID associated with the Expose event
  * \param gc The GC (graphics context) returned by WBBeginPaint().  
  *
  * Call this function, following a call to WBBeginPaint(), if you want to erase the
  * background of the window.  Call this in lieu of XClearWindow() or XClearArea()
  *
  * Header File:  window_helper.h
**/
void WBClearWindow(Window wID, GC gc);


// RECT versions (as inline)

/** \ingroup expose
  * \brief 'Paint' helper, invalidates a WB_RECT for asynchronous Expose event generation
  *
  * \param wID The Window ID for the affected window
  * \param pRCT A const pointer to a WB_RECT structure specifying the invalid area, or NULL (implying the entire window)
  * \param bPaintFlag A non-zero value to force re-paint by generating an Expose message.  Zero simply invalidates the specified area
  *
  * In conjunction with WBProcessExposeEvent it adds a rectangle to the 'invalid' region
  * associated with the window, and optionally generates an asynchronous expose event
  * if 'bPaintFlag' is non-zero.\n
  * For a zero 'bPaintFlag' the next Expose event will include this geometry as part of
  * its update region.
  *
  * Header File:  window_helper.h
**/
static __inline__ void WBInvalidateRect(Window wID, const WB_RECT *pRCT, int bPaintFlag)
{
  WB_GEOM geom;

  if(!pRCT)
  {
    WBInvalidateGeom(wID, NULL, bPaintFlag);
    return;
  }

  geom.x      = pRCT->left;
  geom.y      = pRCT->top;
  geom.width  = pRCT->right - pRCT->left;
  geom.height = pRCT->bottom - pRCT->top;
  geom.border = 0;

  WBInvalidateGeom(wID, &geom, bPaintFlag);
}

/** \ingroup expose
  * \brief 'Paint' helper, validates a WB_RECT for asynchronous Expose event generation
  *
  * \param wID The Window ID for the affected window
  * \param pRCT A const pointer to a WB_RECT structure specifying the valid area, or NULL (implying the entire window)
  *
  * In conjunction with WBProcessExposeEvent it removes a rectangle from the 'invalid' region
  * associated with the window.  If the resulting 'invalid' region is empty, no subsequent
  * 'Expose' event will be generated, even if one had previously been in the queue, until
  * the next Expose event or 'invalid' region exists for this window.
  *
  * Header File:  window_helper.h
**/
static __inline__ void WBValidateRect(Window wID, WB_RECT *pRCT)
{
  WB_GEOM geom;

  if(!pRCT)
  {
    WBValidateGeom(wID, NULL);
    return;
  }

  geom.x      = pRCT->left;
  geom.y      = pRCT->top;
  geom.width  = pRCT->right - pRCT->left;
  geom.height = pRCT->bottom - pRCT->top;
  geom.border = 0;

  WBValidateGeom(wID, &geom);
}



/////////////////////////////////////////////////
//   _____  ___  __  __  _____  ____   ____    //
//  |_   _||_ _||  \/  || ____||  _ \ / ___|   //
//    | |   | | | |\/| ||  _|  | |_) |\___ \   //
//    | |   | | | |  | || |___ |  _ <  ___) |  //
//    |_|  |___||_|  |_||_____||_| \_\|____/   //
//                                             //
/////////////////////////////////////////////////

/** \ingroup core
  * \defgroup timer Timer Functions
  *
  * The X11workbench Toolkit API has support for one-shot and periodic timer
  * events that are generated via XClientEvent using \ref aWM_TIMER.\n
  * These timer events are NOT hyper-accurate, although the timer event time
  * is expressed in microseconds (for math efficiency and convenience).  The
  * message loop will check for 'crossing an event time' and generate events
  * whenever a limit has been crossed.  This means that event processing time
  * can easily affect timer accuracy.  Additionally, if a timer's period is
  * less than the processing time of an event, a timer may be 'missed' as a
  * a result.  For this reason you should use a worker thread for timing that
  * requires precise accuracy.
*/

/** \ingroup timer
  * \brief Returns the current 'time index' (in microseconds)
  *
  * \return An unsigned 64-bit time index value, in microseconds
  *
  * The 'time index' is the master timer that determines when a timer event will be generated.
  * By design it uses a 64-bit integer that never 'wraps around' to zero.  It is generally
  * derived from the 'gettimeofday' API call for operating systems such as BSD and Linux that
  * support the POSIX standard.
  *
  * Header File:  window_helper.h
**/
WB_UINT64 WBGetTimeIndex(void);  // returns current 'time index' (in microseconds) which never wraps around
                                 // NOTE:  it is derived from the 'gettimeofday' call on BSD, Linux, etc.

/** \ingroup timer
  * \brief Creates a one-shot or periodic timer
  *
  * \param pDisplay The display associated with the specified window
  * \param wID The window that receives the \ref aWM_TIMER XClientEvent (None == application)
  * \param lInterval The timer interval in microseconds
  * \param lID The unique timer identifier
  * \param iPeriodic Non-zero for a recurring timer, zero for a 'one-shot' timer.
  * \return Non-zero on error, zero on success.
  *
  * Timers can either be periodic (recurring), or one-shot.  Use this function to create them.
  * A timer created by this function must be subsequently deleted via \ref DeleteTimer()
  *
  * Header File:  window_helper.h
**/
int CreateTimer(Display *pDisplay, Window wID, unsigned long lInterval, long lID, int iPeriodic);
  // NOTE:  'iPeriodic' non-zero for periodic, zero for one-shot.  'lInterval' is in microseconds
  //        Assign 'lID' to a unique value for the specified pDisplay and wID

/** \ingroup timer
  * \brief Deletes an existing timer's resources
  *
  * \param pDisplay The display associated with the specified window
  * \param wID The window associated with the timer
  * \param lID The unique ID associated with the timer
  *
  * Timers created via CreateTimer() must be subsequently deleted using this function by passing
  * the same Display, Window, and Timer 'unique' ID that were used to create it.
  *
  * Header File:  window_helper.h
**/
void DeleteTimer(Display *pDisplay, Window wID, long lID);  // deletes entry with matching Display, Window, ID



// ****************************************************
//
//            E R R O R   H A N D L I N G
//
// ****************************************************

/** \typedef WB_ERROR_INFO
  * \ingroup error
  * \brief Structure definition for X11 error information
  *
  * \code

  typedef struct __WB_ERROR_INFO__
  {
    Display *pDisplay;     // Display pointer passed into error handler function (NULL if no error)
    const char *pFunc;     // Name of the function as assigned by BEGIN_XCALL_DEBUG_WRAPPER
    int iLine;             // Line number of the function as assigned by BEGIN_XCALL_DEBUG_WRAPPER
    unsigned long serial;  // serial number from XErrorEvent
    int error_code;        // error code from XErrorEvent
    int request_code;      // request code from XErrorEvent
    int minor_code;        // minor code from XErrorEvent
    XID resourceid;        // resource ID (usually a Window) from XErrorEvent
  } WB_ERROR_INFO;

  * \endcode
**/
typedef struct __WB_ERROR_INFO__
{
  Display *pDisplay;     ///< Display pointer passed into error handler function (NULL if no error)
  const char *pFunc;     ///< Name of the function as assigned by BEGIN_XCALL_DEBUG_WRAPPER
  int iLine;             ///< Line number of the function as assigned by BEGIN_XCALL_DEBUG_WRAPPER
  unsigned long serial;  ///< serial number from XErrorEvent
  int error_code;        ///< error code from XErrorEvent
  int request_code;      ///< request code from XErrorEvent
  int minor_code;        ///< minor code from XErrorEvent
  XID resourceid;        ///< resource ID (usually a Window) from XErrorEvent
} WB_ERROR_INFO;



/** \ingroup error
  * \brief Supress X11 XErrorEvent output to stderr
  *
  * Call this function to increment the error output supression counter.  Error output
  * will be restored whenever the supression counter returns to zero.  Each call to
  * this function should be balanced with a call to WBAllowErrorOutput().
  *
  * Header File:  window_helper.h
**/
static __inline__ void WBSupressErrorOutput(void)
{
extern int bIgnoreXErrors;

  bIgnoreXErrors++;
}

/** \ingroup error
  * \brief Restore X11 XErrorEvent output to stderr
  *
  * Call this function to decrement the error output supression counter.  Error output
  * will be restored whenever the supression counter returns to zero.  Each call to the
  * WBSupressErrorOutput() function should be balanced with a call to this function.
  *
  * Header File:  window_helper.h
**/
static __inline__ void WBAllowErrorOutput(void)
{
extern int bIgnoreXErrors;

  if(bIgnoreXErrors > 0)
  {
    bIgnoreXErrors--;
  }
  else
  {
    bIgnoreXErrors = 0;
  }
}


/** \ingroup error
  * \brief Clear the 'last error' information obtained via WBGetLastError()
  *
  * Header File:  window_helper.h
**/
void WBErrorClear(void);

/** \ingroup error
  * \brief Check to see whether or not an X11 error was detected.
  *
  * \return A non-zero value if an error was stored in the internal WB_ERROR_INFO structure, else zero
  *
  * Call this function to check to see if an XErrorEvent has been processed and stored in the internal
  * WB_ERROR_INFO structure.  It is necessary to FIRST call WBErrorClear() before any operation that
  * might result in an error that can THEN be checked for using this function.
  *
  * Header File:  window_helper.h
**/
int WBErrorCheck(void);

/** \ingroup error
  * \brief Check to see whether or not an X11 error was detected AND can be re-tried.
  *
  * \return A non-zero value if a retryable error was stored in the internal WB_ERROR_INFO structure, else zero
  *
  * Call this function to check to see if an XErrorEvent has been processed and stored in the internal
  * WB_ERROR_INFO structure, and if a retry is possible based on the type and condition of the error.
  * It is necessary to FIRST call WBErrorClear() before any operation that might result in an error
  * that can THEN be checked for retryability using this function.
  *
  * Header File:  window_helper.h
**/
int WBErrorCheckRetry(void);

/** \ingroup error
  * \brief Obtain a const pointer to the internal WB_ERROR_INFO structure
  *
  * \return A const pointer to the internal WB_ERROR_INFO structure
  *
  * Call this function to obtain details about the last error from the XErrorEvent passed to the error
  * handler.  If there has been no error event, the 'pDisplay' member will always be NULL.  You should
  * always call WBErrorClear() to clear out this structure before performing an operation that might
  * result in an XErrorEvent.
  *
  * Header File:  window_helper.h
**/
const WB_ERROR_INFO * WBGetLastError(void);



#ifdef __cplusplus
};
#endif // __cplusplus

#endif // WINDOW_HELPER_H_INCLUDED

