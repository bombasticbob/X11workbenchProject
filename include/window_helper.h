//////////////////////////////////////////////////////////////////////////////////////////////
//            _             _                     _            _                     _      //
// __      __(_) _ __    __| |  ___ __      __   | |__    ___ | | _ __    ___  _ __ | |__   //
// \ \ /\ / /| || '_ \  / _` | / _ \\ \ /\ / /   | '_ \  / _ \| || '_ \  / _ \| '__|| '_ \  //
//  \ V  V / | || | | || (_| || (_) |\ V  V /    | | | ||  __/| || |_) ||  __/| | _ | | | | //
//   \_/\_/  |_||_| |_| \__,_| \___/  \_/\_/_____|_| |_| \___||_|| .__/  \___||_|(_)|_| |_| //
//                                         |_____|               |_|                        //
//                                                                                          //
//                       basic window creation and message handling                         //
//                                                                                          //
//              NOTE:  'WB' is for 'Work Bench', aka 'X11workbench Toolkit'                 //
//                                                                                          //
//////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2019 by Bob Frazier (aka 'Big Bad Bombastic Bob')

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.
               Any claims to alleged functionality or features should be
               considered 'preliminary', and might not function as advertised.

  MIT-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  MIT-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/


//////////////////////////////////////////
//      - DOXYGEN RELATED STUFF -       //
//////////////////////////////////////////

/** \file window_helper.h
  * \brief 'window helper' main header file for the X11workbench Toolkit API
  *
  * X11workbench Toolkit Toolkit API
  * This file defines the main 'Window Helpers' including
  *   API initialization
  *   the main 'Event loop'
  *   window callback procedures
  *   upper level font management
  *   Expose and GC management
  *   Window context/state management
  *   X11 API 'wrapper' functions
**/

// doxygen top-level stuff has been moved to doxy_comments.dox

//////////////////////////////////////////
//    - END DOXYGEN RELATED STUFF -     //
//////////////////////////////////////////


// window helpers - defines manager for callback procs, font, GC, and a generic event dispatcher

#ifndef WINDOW_HELPER_H_INCLUDED
#define WINDOW_HELPER_H_INCLUDED


#ifndef WIN32
// the 'incompatible pointer types' is now an error
#pragma GCC diagnostic error "-Wincompatible-pointer-types"
#endif // !WIN32


// headers that must be included or I break

#include <string.h>   // for memset, mostly

#include "platform_helper.h"
#include "debug_helper.h"
#include "font_helper.h"

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/** \ingroup defaults
  * \brief The default window cursor (this is what xterm uses)
*/
#define WB_DEFAULT_CURSOR XC_left_ptr
/** \ingroup defaults
  * \brief The 'wait' cursor (this is what xterm uses)
**/
#define WB_WAIT_CURSOR XC_watch /*XC_clock*/
/** \ingroup defaults
  * \brief The default X11 font name (currently "fixed")
**/
#define WB_DEFAULT_FONT    "fixed"
/** \ingroup defaults
  * \brief The default X11 font size (currently 13)
**/
#define WB_DEFAULT_FONT_SIZE 13 /* override via settings */
/** \ingroup defaults
  * \brief The 'window data' array size (currently 4 void pointers)
**/
#define WINDOW_DATA_SIZE 4 /* size of a 'void *' array that stores per-window data */

/** \ingroup defaults
  * \brief An event mask for ALL events, with bits 0 through 24 set - see X.h which only defines bits 0 to 24 for an event mask
**/
#define EVENT_ALL_MASK 0x01ffffffL /* 2^24 | 2^23 ... 2^0 - see X.h */


/** \ingroup defaults
  * \brief A bit mask for ALL GC properties (used when copying a GC)
**/
#define GCAll (GCFunction | GCPlaneMask | GCForeground | GCBackground | GCLineWidth | \
               GCLineStyle | GCCapStyle | GCJoinStyle | GCFillStyle | GCFillRule | \
               GCTile | GCStipple | GCTileStipXOrigin | GCTileStipYOrigin | GCFont | \
               GCSubwindowMode | GCGraphicsExposures | GCClipXOrigin | GCClipYOrigin | \
               GCClipMask | GCDashOffset | GCDashList | GCArcMode)



// debug helpers (may be eliminated at some point)

/** \ingroup debug
  * \brief debug helper variable tracking the function calling into the X11 library
**/
extern const char *sz_xcall_func;
/** \ingroup debug
  * \brief debug helper variable indicating the line number of the function calling into the X11 library
**/
extern int i_xcall_line;
/** \ingroup debug
  * \def BEGIN_XCALL_DEBUG_WRAPPER()
  * \brief wrapper macro for calls into the X11 library.  This macro precedes the call(s)
**/
#define BEGIN_XCALL_DEBUG_WRAPPER { const char *__szOldXCallFunc__ = sz_xcall_func; int __iOldXCallLine__ = i_xcall_line; sz_xcall_func = __FUNCTION__;  i_xcall_line = __LINE__; {
/** \ingroup debug
  * \def END_XCALL_DEBUG_WRAPPER()
  * \brief wrapper macro for calls into the X11 library.  This macro follows the call(s)
**/
#define END_XCALL_DEBUG_WRAPPER   } sz_xcall_func = __szOldXCallFunc__;  i_xcall_line = __iOldXCallLine__; }


/** \typedef WBWinEvent
  * \ingroup events
  * \brief event callback function type for window events
  *
  * \param wID The Window ID for the window receiving the event notification
  * \param pEvent A pointer to the XEvent structure passed to the callback function
  * \return Event-specific value.  Typically returns zero if the event was not processed, non-zero if further processing is not necessary
  *
  * Event callbacks for windows should be declared according to this defined type
  *
  * Header File:  window_helper.h
**/
typedef int (* WBWinEvent)(Window wID, XEvent *pEvent);
/** \typedef WBAppEvent
  * \ingroup events
  * \brief event callback function type for application events
  *
  * \param pEvent A pointer to the XEvent structure passed to the callback function
  * \return Event-specific value.  Typically returns zero if the event was not processed, non-zero if further processing is not necessary
  *
  * An event callback for the application should be declared according to this defined type
  *
  * Header File:  window_helper.h
**/
typedef int (* WBAppEvent)(XEvent *pEvent);


////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                        //
//    ____                    ____   _                       _                            //
//   / ___| ___   _ __  ___  / ___| | |_  _ __  _   _   ___ | |_  _   _  _ __  ___  ___   //
//  | |    / _ \ | '__|/ _ \ \___ \ | __|| '__|| | | | / __|| __|| | | || '__|/ _ \/ __|  //
//  | |___| (_) || |  |  __/  ___) || |_ | |   | |_| || (__ | |_ | |_| || |  |  __/\__ \  //
//   \____|\___/ |_|   \___| |____/  \__||_|    \__,_| \___| \__| \__,_||_|   \___||___/  //
//                                                                                        //
//                                                                                        //
////////////////////////////////////////////////////////////////////////////////////////////


/** \defgroup core_struct_struct structures
  * \ingroup core_struct
**/

/** \struct _WBGC_
  * \ingroup core_struct_struct
  * \copydoc WBGC
**/
/** \typedef WBGC
  * \ingroup core_struct
  * \brief internal wrapper struct for GC with local cache
  *
  * The WBGC structure has been defined for a couple of reasons:
  * First, it is a similar concept to using 'HDC' in Win32, so it can help
  * to translate all of the GC-related operations in a 1:1 manner for Win32;
  * Second, it enables the toolkit to cache locally EVERYTHING that might
  * enhance performance for X11 implmentations.  Win-Win.
  *
  * The biggest single performance problem in X11 exists when you want to
  * use a remote client and also want to enhance operations beyond the simple
  * features that are natively supported by an X server, things like anti-aliasing
  * and transparency [for example].  In order to simplify implementing these things
  * in a way that does NOT impact performance is to cache everything locally that
  * might otherwise result in an RPC-like call into the X Server.  The single slowest
  * operation in this case is obtaining an XImage from a Pixmap or Window, and so this
  * is specifically cached in the toolkit.  Additionally, functions that can perform
  * operations on these resources locally (rather than remotely) can then leverage the
  * cached information, often giving you a significant performance boost.
  *
  * The only down side is the additional housekeeping needed to track all of this.
  *
  * \code

  typedef struct _WBGC_
  {
    Display *display;   // the Display associated with the WBGC (NULL implies 'Default Display')
    Drawable dw;        // the Drawable for which this WBGC was created (None implies default Window)
    GC gc;              // the associated 'GC'
    XGCValues values;   // cached XGCValues for the GC
    WB_FONT pFont;      // cached default font
    Region clip_rgn;    // clipping region (or None to use clip_image)
    XImage *clip_image; // cached XImage for the GC, for 'clip mask'
    XImage *tile_image; // cached XImage for the GC, for 'tile'
    XImage *stip_image; // cached XImage for the GC, for 'stipple'
  } * WBGC;

  * \endcode
  *
  * The XOrg documentation defines the XGCValues structure as follows:
  *
  * \code

  typedef struct {
         int function;               // logical operation
         unsigned long plane_mask;   // plane mask
         unsigned long foreground;   // foreground pixel
         unsigned long background;   // background pixel
         int line_width;             // line width (in pixels)
         int line_style;             // LineSolid, LineOnOffDash, LineDoubleDash
         int cap_style;              // CapNotLast, CapButt, CapRound, CapProjecting
         int join_style;             // JoinMiter, JoinRound, JoinBevel
         int fill_style;             // FillSolid, FillTiled, FillStippled FillOpaqueStippled
         int fill_rule;              // EvenOddRule, WindingRule
         int arc_mode;               // ArcChord, ArcPieSlice
         Pixmap tile;                // tile pixmap for tiling operations
         Pixmap stipple;             // stipple 1 plane pixmap for stippling
         int ts_x_origin;            // offset for tile or stipple operations
         int ts_y_origin;
         Font font;                  // default text font for text operations
         int subwindow_mode;         // ClipByChildren, IncludeInferiors
         Bool graphics_exposures;    // boolean, should exposures be generated
         int clip_x_origin;          // origin for clipping
         int clip_y_origin;
         Pixmap clip_mask;           // bitmap clipping; other calls for rects
         int dash_offset;            // patterned/dashed line information
         char dashes;
  } XGCValues;

  * \endcode
  *
  * Additional information regarding the drawing of lines
  *
  * The XOrg 'manual page' documentation for XGCValues also includes the
  * following information:
  *
  * \code

    The line-width is measured in pixels and either can be greater than or
    equal to one (wide line) or can be the special value zero (thin line).

    Wide lines are drawn centered on the path described by the graphics
    request.  Unless otherwise specified by the join-style or cap-style,
    the bounding box of a wide line with endpoints [x1, y1], [x2, y2] and
    width w is a rectangle with vertices at the following real coordinates:

    [x1-(w*sn/2), y1+(w*cs/2)], [x1+(w*sn/2), y1-(w*cs/2)],
    [x2-(w*sn/2), y2+(w*cs/2)], [x2+(w*sn/2), y2-(w*cs/2)]

    Here sn is the sine of the angle of the line, and cs is the cosine of
    the angle of the line.  A pixel is part of the line and so is drawn if
    the center of the pixel is fully inside the bounding box (which is
    viewed as having infinitely thin edges).  If the center of the pixel is
    exactly on the bounding box, it is part of the line if and only if the
    interior is immediately to its right (x increasing direction).  Pixels
    with centers on a horizontal edge are a special case and are part of
    the line if and only if the interior or the boundary is immediately
    below (y increasing direction) and the interior or the boundary is
    immediately to the right (x increasing direction).

    Thin lines (zero line-width) are one-pixel-wide lines drawn using an
    unspecified, device-dependent algorithm.  There are only two con-
    straints on this algorithm.

    1.   If a line is drawn unclipped from [x1,y1] to [x2,y2] and if
        another line is drawn unclipped from [x1+dx,y1+dy] to
        [x2+dx,y2+dy], a point [x,y] is touched by drawing the first line
        if and only if the point [x+dx,y+dy] is touched by drawing the
        second line.

    2.   The effective set of points comprising a line cannot be affected
        by clipping.  That is, a point is touched in a clipped line if and
        only if the point lies inside the clipping region and the point
        would be touched by the line when drawn unclipped.

    A wide line drawn from [x1,y1] to [x2,y2] always draws the same pixels
    as a wide line drawn from [x2,y2] to [x1,y1], not counting cap-style
    and join-style.  It is recommended that this property be true for thin
    lines, but this is not required.  A line-width of zero may differ from
    a line-width of one in which pixels are drawn.  This permits the use of
    many manufacturers' line drawing hardware, which may run many times
    faster than the more precisely specified wide lines.

    In general, drawing a thin line will be faster than drawing a wide line
    of width one.  However, because of their different drawing algorithms,
    thin lines may not mix well aesthetically with wide lines.  If it is
    desirable to obtain precise and uniform results across all displays, a
    client should always use a line-width of one rather than a line-width
    of zero.

  * \endcode
  *
  * To be fair, the use of a line width of zero in the X11Workbench Toolkit
  * is NOT recommended.  The XImage code will assume zero implies width=1.
  *
  * Also, an algorithm that allows the 'touching' of the same point many
  * times is not impractical with an XImage; that is, the amount of code
  * needed to check if a point were touched or will be touched is more
  * computationally expensive than 'just touching it anyway'.  As such,
  * the XImage code may 'touch' a point multiple times, depending.  For
  * video hardware, especially accelerated video hardware, this could be
  * a performance hit.  But when using an XImage as a backing store for
  * the window contents, it makes more sense to simply draw it anyway.
  *
  * Additional information can be found in the aforementioned manual page.
  *
*/
typedef struct _WBGC_
{
  Display *display;   ///< the Display associated with the WBGC (NULL implies 'Default Display')
  Drawable dw;        ///< the Drawable for which this WBGC was created (None implies default Window)
  GC gc;              ///< the associated 'GC'
  XGCValues values;   ///< cached XGCValues for the GC
  WB_FONT pFont;      ///< cached default font
  Region clip_rgn;    ///< clipping region (or None to use clip_image) - owned by the object
  XImage *clip_image; ///< cached XImage for the GC, for 'clip mask'
  XImage *tile_image; ///< cached XImage for the GC, for 'tile'
  XImage *stip_image; ///< cached XImage for the GC, for 'stipple'
} * WBGC;

/** \struct _WBPoint_
  * \ingroup core_struct_struct
  * \copydoc WB_POINT
**/
/** \typedef WB_POINT
  * \ingroup core_struct
  * \brief internal wrapper struct for 'point' definition
  *
  * The point structure has been defined primarily for convenience,
  * so that specific coding methods that work well in GUI environments
  * that use 'points' can easily be ported into this environment.
  *
  * \code

  typedef struct _WBPoint_
  {
    int x;   // the 'x' value of the point.  can be negative.
    int y;   // the 'y' value of the point.  can be negative.
  } WB_POINT;

  * \endcode
  *
  * Note that this is different from an XPoint structure, which is defined as
  *
  * \code

  typedef struct
  {
    short x, y;
  } XPoint;

  * \endcode
  *
*/
typedef struct _WBPoint_
{
  int x;   ///< the 'x' value of the point.  can be negative.
  int y;   ///< the 'y' value of the point.  can be negative.
} WB_POINT;

/** \struct _WBExtent_
  * \ingroup core_struct_struct
  * \copydoc WB_EXTENT
**/
/** \typedef WB_EXTENT
  * \ingroup core_struct
  * \brief internal wrapper struct for 'extent' definition
  *
  * The extent structure has been defined primarily for convenience,
  * so that specific coding methods that work well in GUI environments
  * that use 'extents' can easily be ported into this environment.
  *
  * \code

  typedef struct _WBExtent_
  {
    unsigned int width;   // the 'width' value of the extent.
    unsigned int height;  // the 'height' value of the extent.
  } WB_EXTENT;

  * \endcode
  *
  *
*/
typedef struct _WBExtent_
{
  unsigned int width;   ///< the 'width' value of the extent.
  unsigned int height;  ///< the 'height' value of the extent.
} WB_EXTENT;

/** \struct _WBRect_
  * \ingroup core_struct_struct
  * \copydoc WB_RECT
**/
/** \typedef WB_RECT
  * \ingroup core_struct
  * \brief internal wrapper struct for 'rectangle' definition
  *
  * The rectangle structure has been defined primarily for convenience,
  * so that specific coding methods that work well in GUI environments
  * that use rectangles (instead of 'geometry') can easily be ported
  * into this environment.
  *
  * \code

  typedef struct _WBRect_
  {
    int left, top, right, bottom;
  } WB_RECT;

  * \endcode
  *
  * Note that this is different from an XRectangle structure, which is defined as
  *
  * \code

  typedef struct
  {
    short x, y;
    unsigned short width, height;
  } XRectangle;

  * \endcode
  *
*/
typedef struct _WBRect_
{
  int left;   /**< X coordinate for rectangle upper left corner */
  int top;    /**< Y coordinate for rectangle upper left corner */
  int right;  /**< X coordinate for rectangle lower right corner */
  int bottom; /**< Y coordinate for rectangle lower right corner */
} WB_RECT;

/** \struct _WBGeom_
  * \ingroup core_struct_struct
  * \copydoc WB_GEOM
**/
/** \typedef WB_GEOM
  * \ingroup core_struct
  * \brief internal wrapper struct for X11 'geometry' definition
  *
  * The geometry structure is a wrapper for the X11 functions that specify
  * the individual parameters for a geometry, such as XGetGeometry.  Instead
  * of passing 5 integers, you pass the pointer to a structure for the
  * X11workbench API functions.  This provides many advantages over the
  * 'individual parameter' method as well as providing a structure
  * for cacheing geometry information.
  *
  * \code

  typedef struct _WBGeom_
  {
    int x, y;
    unsigned int width, height, border;
  } WB_GEOM;

  * \endcode
  *
  * Use of 'int' and 'unsigned int' for the various parameter is consistent with the various
  * 'Geom' functions, which typically use 'int *' for returned parameters, as shown:
  *
  * \code

  Status XGetGeometry(Display *display, Drawable d, Window *root_return,
                      int *x_return, int *y_return,
                      unsigned int *width_return, unsigned int *height_return,
                      unsigned int *border_return, unsigned int *depth_return);

  * \endcode
  *
*/
typedef struct _WBGeom_
{
  int x; /**< X coordinate for geometry upper left corner (excluding border) */
  int y; /**< Y coordinate for geometry upper left corner (excluding border) */
  unsigned int width; /**< width of geometry */
  unsigned int height; /**< height of geometry */
  unsigned int border; /**< border width of geometry */
} WB_GEOM;



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                               //
//   ____   _                _                      _                _   ____   _             _       _                          //
//  / ___| | |_  __ _  _ __ | |_  _   _  _ __      / \    _ __    __| | / ___| | |__   _   _ | |_  __| |  ___ __      __ _ __    //
//  \___ \ | __|/ _` || '__|| __|| | | || '_ \    / _ \  | '_ \  / _` | \___ \ | '_ \ | | | || __|/ _` | / _ \\ \ /\ / /| '_ \   //
//   ___) || |_| (_| || |   | |_ | |_| || |_) |  / ___ \ | | | || (_| |  ___) || | | || |_| || |_| (_| || (_) |\ V  V / | | | |  //
//  |____/  \__|\__,_||_|    \__| \__,_|| .__/  /_/   \_\|_| |_| \__,_| |____/ |_| |_| \__,_| \__|\__,_| \___/  \_/\_/  |_| |_|  //
//                                      |_|                                                                                      //
//                                                                                                                               //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////
// window-specific initialization
/////////////////////////////////

/** \ingroup startup
  * \brief initializes default objects for the specified Display (required)
  *
  * \param szDisplayName A null-byte terminated ASCII string containing the DISPLAY name, or NULL\n
  *        NULL values causes the display to initialize using \ref GetStartupDisplayName()
  * \return A pointer to the Display, or NULL on error
  *
  * Call this function before any other to create a display and initialize the X11 WorkBench Toolkit.
  * Alternately you can create the display yourself and call \ref WBInitDisplay().  \ref WBExit() will
  * free the assigned Display pointer for you by calling XCloseDisplay().\n
  * The returned pointer can be retrieved at any time by calling 'WBGetDefaultDisplay()'.\n
  *
  * Header File:  window_helper.h
**/
Display *WBInit(const char *szDisplayName);

/** \ingroup startup
  * \brief initializes default objects for the specified Display
  *
  * \param pDisplay A pointer to an open Display object, to become the default display for the X11 WorkBench Toolkit.
  * \return Zero value on success, non-zero on error.
  *
  * Call this function before any other to assign the default Display pointer and initialize the
  * X11 WorkBench Toolkit.  A number of internal objects are initialized by this function.
  * On error the function returns a non-zero value.\n
  * The preferred method for initialization is to use \ref WBInit() with a display name (or NULL).
  * However, in some cases you may wish to open the display yourself, and pass the pointer to this
  * function instead.  Typical reasons for that may be security-related, use of firewalls, proxies, and
  * any other kind of possible and/or unusual method for opening a display.
  *
  * Header File:  window_helper.h
**/
int WBInitDisplay(Display *pDisplay);

/** \ingroup startup
  * \brief initializes clipboard sub-system
  *
  * \param pDisplay The 'Display' associated with this clipboard (reserved, must match 'WBInitDisplay' call or be NULL)
  * \param szDisplayName A null-byte terminated ASCII string containing the DISPLAY name, or NULL\n
  *        NULL values causes the display to initialize using \ref GetStartupDisplayName()
  * \return Zero value on success, non-zero on error.
  *
  * Call this function to initialize the 'Clipboard' sub-system, after initializing the 'Display'.  This function
  * is automatically called internally by WBInitDisplay() so there should be no need to invoke it directly.\n
  * It will spawn a new thread that runs in the background to process clipboard-related messages, internally
  * using a separate Display object, so that the main thread is not impacted (nor deadlocked) by clipboard handling.\n
  * The 'pDisplay' parameter is reserved for future use, for when multiple displays are supported.\n
  * If a thread uses the same display name that was passed to 'WBInit' then it refers to the same Display as the
  * main thread, and you will not need to re-initialize the clipboard for that Display.
  *
  * Header File:  window_helper.h
**/
int WBInitClipboardSystem(Display *pDisplay, const char *szDisplayName);

/** \ingroup startup
  * \brief deletes any remaining global objects, frees the Display pointer, and terminates event processing
  *
  * This function deletes any remaining global objects, frees the Display pointer, and terminates event
  * processing, freeing up any remaining resources for the entire toolkit.  You should call this function
  * in your application right before it terminates.
  *
  * Header File:  window_helper.h
**/
void WBExit(void);

/** \ingroup startup
  * \brief Shut down the clipboard sub-system
  *
  * Shuts down the clipboard sub-system.  Called internally by WBExit()
  *
  * Header File:  window_helper.h
**/
void WBExitClipboardSystem(Display *pDisplay);

/** \ingroup startup
  * \brief initializes default Display for a thread (must call WBInit() first)
  *
  * \return A pointer to the Display, or NULL on error
  *
  * Call this function to create a thread-specific Display object when you need to process
  * a message loop or create windows within that thread.  You must call WBThreadFreeDisplay()
  * to free up resources before exiting the thread.
  *
  * Header File:  window_helper.h
**/
Display *WBThreadInitDisplay(void);

/** \ingroup startup
  * \brief un-initializes a Display for a thread that was allocated by WBThreadInitDisplay()
  *
  * \param pThreadDisplay a Display pointer that was created via WBThreadInitDisplay()
  *
  * Call this function to free a thread-specific Display object that was created by WBThreadInitDisplay()
  * to free up resources before exiting the thread.
  *
  * Header File:  window_helper.h
**/
void WBThreadFreeDisplay(Display *pThreadDisplay);


/** \ingroup startup
  * \brief returns character name of the display to be opened and passed to WBInit
  *
  * Gets the display name associated with the current (default) display, or the
  * display specified in the command line arguments passed to WBParseStandardArguments().
  * This name should be used in a call to XOpenDisplay(), and the resulting Display
  * should then be passed to WBInit()
  *
  * Header File:  window_helper.h
**/
const char *GetStartupDisplayName(void);

/** \ingroup startup
  * \brief returns the startup geometry based on command line parameters
  *
  * Returns the desired geometry to be applied to the main window on startup.
  * The value is based on a prior call to \ref WBParseStandardArguments(), and should
  * not be relied upon otherwise.
  *
  * Header File:  window_helper.h
**/
void GetStartupGeometry(WB_GEOM *pGeom);
/** \ingroup startup
  * \brief returns the min/max/normal window state for startup
  *
  * Following a call to \ref WBParseStandardArguments(), this function will return the
  * desired startup window state, either minimized (< 0), maximized (> 0), or normal (= 0).
  *
  * Header File:  window_helper.h
**/
int GetStartupMinMax(void);

/** \ingroup startup
  * \brief returns the default colormap for the default screen of the specified display
  *
  * Convenience function that returns the default colormap for the default screen of the
  * specified display.  Helps to clean up the initialization code and make it more 'modular'.
  *
  * Header File:  window_helper.h
**/
static __inline__ Colormap WBDefaultColormap(Display *pDisplay)
{
  return DefaultColormap(pDisplay, DefaultScreen(pDisplay));
}

/** \ingroup startup
  * \brief initializes the XSetWIndowAttributes structure with minimal attributes
  *
  * \param pXSWA A pointer to the (un-initialized) XSetWindowAttributes structure
  * \param lBorderPixel The color value for the border pixel
  * \param lBackgroundPixel The color value for the background pixel
  * \param clrMap The colormap, typically the value returned by \ref WBDefaultColormap()
  * \param iBitGravity The 'bit gravity' of the window.  Typical value is 'CenterGravity'
  *
  * Convenience function to assign the minimal window attributes to the XSetWindowAttributes
  * structure.  Helps to clean up the initialization code and make it more 'modular'.
  * For more information on window attributes, see the X11 API Documentation, section 3.3 .
  *
  * You should pass 'iFlags' with 'CWBorderPixel | CWBackPixel | CWColormap | CWBitGravity'
  * to WBCreateWindow(), or use WBCreateWindow_flagsDefault, whenever you use this function
  * to initialize the XSetWindowAttributes structure.
  *
  * Header File:  window_helper.h
**/
void WBInitWindowAttributes(XSetWindowAttributes *pXSWA, unsigned long lBorderPixel,
                            unsigned long lBackgroundPixel, Colormap clrMap, int iBitGravity);

/** \ingroup startup
  * \brief initializes the XSizeHints structure with standard attributes
  *
  * \param pSH Pointer to the XSizeHints structure
  * \param pDisplay Pointer to the Display (NULL for default)
  * \param iMinHeight Minimum height of the window
  * \param iMinWidth Minimum width of the window
  *
  * Convenience function that assigns the default window size on application startup.
  * Takes into consideration the screen dimensions and min width/height if the user did
  * not specify window geometry on startup.  See the X11 API Reference, sections
  * 9.1.6 and 10.3 for more information on XSizeHints
  *
  * Header File:  window_helper.h
**/
void WBInitSizeHints(XSizeHints *pSH, Display *pDisplay, int iMinHeight, int iMinWidth);



////////////////////////////////////////////////////////////
//   ____   _____  _____  _    _   _  _    _____  ____    //
//  |  _ \ | ____||  ___|/ \  | | | || |  |_   _|/ ___|   //
//  | | | ||  _|  | |_  / _ \ | | | || |    | |  \___ \   //
//  | |_| || |___ |  _|/ ___ \| |_| || |___ | |   ___) |  //
//  |____/ |_____||_| /_/   \_\\___/ |_____||_|  |____/   //
//                                                        //
////////////////////////////////////////////////////////////

/** \ingroup defaults
  * \brief Returns the default Display
  *
  * The default display is usually the ONLY display in use by the
  * application.  This function returns that Display pointer, which
  * can be used in any case where the current display is not known
  *
  * \sa  WBGetWindowDisplay()
  *
  * Header File:  window_helper.h
**/
static __inline__ Display * WBGetDefaultDisplay(void)
{
  extern Display *pDefaultDisplay;
  return pDefaultDisplay;
}

/** \ingroup defaults
  * \brief Returns a pointer to the default font WB_FONT for the default display.  This is a shared resource; do NOT free it nor alter it!
  *
  * \returns A pointer to a WB_FONT object (const), or 'NULL' on error.  This is a shared resource; do NOT free it nor alter it!
  *
  * The default WB_FONT is allocated at startup.  This function
  * returns its value (not a copy), which can then be used in a
  * case where the 'in use' WB_FONT is not known, or when an
  * overriding font has not been specified.
  *
  * Header File:  window_helper.h
**/
WB_FONTC WBGetDefaultFont(void);

/** \ingroup defaults
  * \brief Returns a special 'hidden' window used for information purposes
  *
  * This function returns a special window that was created for information
  * purposes.  If you need a window for query purposes that belongs to the
  * default display, you can use the one returned by this function.
  *
  * Header File:  window_helper.h
**/
Window WBGetHiddenHelperWindow(void);  // if you need "a window" for the default display, use this




///////////////////////////////////////////////////////////////////////////////////////
//    ____  _      ___   ____     _     _           _   _____  ___   __  __  ____    //
//   / ___|| |    / _ \ | __ )   / \   | |         / \ |_   _|/ _ \ |  \/  |/ ___|   //
//  | |  _ | |   | | | ||  _ \  / _ \  | |        / _ \  | | | | | || |\/| |\___ \   //
//  | |_| || |___| |_| || |_) |/ ___ \ | |___    / ___ \ | | | |_| || |  | | ___) |  //
//   \____||_____|\___/ |____//_/   \_\|_____|  /_/   \_\|_|  \___/ |_|  |_||____/   //
//                                                                                   //
///////////////////////////////////////////////////////////////////////////////////////

// global atoms (for convenience they are referenced directly via global variables)

#if !defined(_WINDOW_HELPER_C_) && !defined(_CLIPBOARD_HELPER_C)
     /* this declares the atoms 'const' outside of window_helper.c, and does NOT declare them in clipboard_helper.c */
     /* These atoms are GLOBAL variables, assigned by the DEFAULT Display, and may not work for other threads.      */
extern const Atom aMENU_COMMAND;     // commands sent by menus via ClientMessage
extern const Atom aMENU_UI_COMMAND;  // UI notification sent by menus to owning frame windows via ClientMessage using WBWindowDispatch
extern const Atom aRESIZE_NOTIFY;    // notification of window re-size via ClientMessage
extern const Atom aDESTROY_NOTIFY;   // notify parent that child is being destroyed
extern const Atom aCONTROL_NOTIFY;   // dialog control and child window notification messages
                                     // l[0] contains control ID or -1, l[1] is notify code, l[2] is window ID
extern const Atom aSCROLL_NOTIFY;    // specific notification for scrollbars (see enumeration, below)
                                     // data.l[0] is scrollbar enum, data.l[1] is notification enum, data.l[2] is optional position modifier
extern const Atom aQUERY_CLOSE;      // command sent by Client Message - return 0 if ok to close, 1 if not ok to close, -1 on error
extern const Atom aRECALC_LAYOUT;    // notify window that it should re-calculate things like scrollbars and viewports

extern const Atom aDLG_FOCUS;        // dialog focus messages: l[0] is <,0,> for prev, 'set to', next.  For 'set to' l[1] is control ID
extern const Atom aSET_FOCUS;        // 'set focus' messages (send/post to application)
extern const Atom aWB_CHAR;          // character notifications (generated by API; avoids key up/down handling)
extern const Atom aWB_TIMER;         // timer notifications (generated by API)
extern const Atom aWB_POINTER;       // pointer notifications (generated by API)

// things used by window managers
extern const Atom aWM_PROTOCOLS;     // WM supported protocols (see 'freedesktop.org' WM docs)
extern const Atom aWM_DELETE_WINDOW; // WM command to delete a window (a click on the 'x')
extern const Atom aWM_TAKE_FOCUS;    // WM protocol (part of WM_PROTOCOLS spec, ICCCM, assoc with focus bit in WM_HINTS)

// things used by fonts
extern const Atom aAVERAGE_WIDTH;    // Average Character Width (font property)

// things used by the clipboard
extern const Atom aCLIPBOARD;        // Atom for 'CLIPBOARD'
extern const Atom aPRIMARY;          // Atom for 'PRIMARY'
extern const Atom aSECONDARY;        // Atom for 'SECONDARY'
extern const Atom aMANAGER;          // Atom for 'MANAGER'
extern const Atom aTARGET;           // Atom for 'TARGET'
extern const Atom aINCR;             // Atom for 'INCR' (incremental transfers)
extern const Atom aWINDOW;           // Atom for 'WINDOW'
extern const Atom aBITMAP;           // Atom for 'BITMAP'
extern const Atom aDRAWABLE;         // Atom for 'DRAWABLE'
extern const Atom aCOLORMAP;         // Atom for 'COLORMAP'
extern const Atom aPIXEL;            // Atom for 'PIXEL'
extern const Atom aPIXMAP;           // Atom for 'PIXMAP'
extern const Atom aTEXT;             // Atom for 'TEXT'
extern const Atom aSTRING;           // Atom for 'STRING'
extern const Atom aUTF8_STRING;      // Atom for 'UTF8_STRING'
extern const Atom aC_STRING;         // Atom for 'C_STRING'
extern const Atom aCOMPOUND_TEXT;    // Atom for 'COMPOUND_TEXT'
extern const Atom aTARGETS;          // Atom for 'TARGETS'
extern const Atom aMULTIPLE;         // Atom for 'MULTIPLE'
extern const Atom aTIMESTAMP;        // Atom for 'TIMESTAMP'
extern const Atom aNULL;             // Atom for 'NULL'
#endif // !_WINDOW_HELPER_C, !_CLIPBOARD_HELPER_C



// parameter enumerations for aSCROLL_NOTIFY ClientMessage

/** \ingroup events_types
  * \hideinitializer
  * \brief Enumeration for \ref aSCROLL_NOTIFY ClientMessage
  *
  * Enumeration of values used in scroll notification messages.\n
  * \sa  \ref WBScrollBarEvent()
*/
enum WBScrollEventParam
{
  WB_SCROLL_DEFAULT = 0,    ///< 1st parameter (bar) - 'Default Bar', currently not implemented, probably won't be used
  WB_SCROLL_HORIZONTAL = 1, ///< 1st parameter (bar) - The horizontal scroll bar for the control or window
  WB_SCROLL_VERTICAL = 2,   ///< 1st parameter (bar) - The vertical scroll bar for the control or window.

  WB_SCROLL_KNOB = 0,       ///< 2nd parameter (direction) - 'knob track' - pos in data.l[2]
  WB_SCROLL_FORWARD = 1,    ///< 2nd parameter (direction) - down, right
  WB_SCROLL_BACKWARD = -1,  ///< 2nd parameter (direction) - up, left
  WB_SCROLL_PAGEFWD = 2,    ///< 2nd parameter (direction) - pgdn, pgright
  WB_SCROLL_PAGEBACK = -2,  ///< 2nd parameter (direction) - pgup, pgleft
  WB_SCROLL_FIRST = -3,     ///< 2nd parameter (direction) - home, top
  WB_SCROLL_LAST = 3,       ///< 2nd parameter (direction) - bottom, end

  WB_SCROLL_DBLCLICK = 4,   ///< 2nd parameter (direction) - double-clicked item (no selection change info) (sent to list control's owner)

  WB_SCROLL_ABSOLUTE = 99,  ///< 2nd parameter (direction) - absolute scroll - pos in data.l[2]
  WB_SCROLL_RELATIVE = -99, ///< 2nd parameter (direction) - relative scroll - rel pos in data.l[2]

  WB_SCROLL_NA = 0x80000000 ///< generic 'NA' or 'UNDEFINED' value
};







/////////////////////////////////////////////////////////
//    ____  ___   ____   _____       _     ____  ___   //
//   / ___|/ _ \ |  _ \ | ____|     / \   |  _ \|_ _|  //
//  | |   | | | || |_) ||  _|      / _ \  | |_) || |   //
//  | |___| |_| ||  _ < | |___    / ___ \ |  __/ | |   //
//   \____|\___/ |_| \_\|_____|  /_/   \_\|_|   |___|  //
//                                                     //
/////////////////////////////////////////////////////////

/** \ingroup wcore
  * \brief 'Standard' input mask, bit flag for window creation
  *
  * 'Standard' input mask.  Use this as a parameter to XSelectInput to enable standard events to be sent to the window\n
  * This bit mask may be 'or'd with other bit masks as needed.
**/
#define WB_STANDARD_INPUT_MASK (FocusChangeMask | PropertyChangeMask | ExposureMask | StructureNotifyMask | VisibilityChangeMask | SubstructureNotifyMask)

/** \ingroup wcore
  * \brief 'Keyboard' input mask, bit flag for window creation
  *
  * 'Keyboard' input mask.  Use this as a parameter to XSelectInput to enable keyboard events to be sent to the window\n
  * This bit mask may be 'or'd with other bit masks as needed.
**/
#define WB_KEYBOARD_INPUT_MASK (KeyPressMask | KeyReleaseMask)

/** \ingroup wcore
  * \brief 'Mouse' input mask, bit flag for window creation
  *
  * 'Mouse' input mask.  Use this as a parameter to XSelectInput to enable mouse events to be sent to the window\n
  * This bit mask may be 'or'd with other bit masks as needed.
**/
#define WB_MOUSE_INPUT_MASK (ButtonPressMask | ButtonReleaseMask | PointerMotionMask | EnterWindowMask | LeaveWindowMask)


/** \ingroup wcore
  * \hideinitializer
  * \brief Window type enumeration.  Reserved for future implementation.
  *
  * reserved for future implementation
**/
enum WMPropertiesWindowType
{
  // must be ONLY ONE of the items below
  WMPropertiesWindowType_TypeMask     = 0x3f,
  WMPropertiesWindowType_Normal       = 0,
  WMPropertiesWindowType_Desktop      = 1,
  WMPropertiesWindowType_Dock         = 2,
  WMPropertiesWindowType_ToolBar      = 3,
  WMPropertiesWindowType_Menu         = 4,
  WMPropertiesWindowType_Utility      = 5,
  WMPropertiesWindowType_Splash       = 6,
  WMPropertiesWindowType_Dialog       = 7,
  WMPropertiesWindowType_DropDownMenu = 8,
  WMPropertiesWindowType_PopupMenu    = 9,
  WMPropertiesWindowType_ToolTip      = 10,
  WMPropertiesWindowType_Notification = 11,
  WMPropertiesWindowType_Combo        = 12,
  WMPropertiesWindowType_Drag_N_Drop  = 13,
  WMPropertiesWindowType_Reserved14   = 14,
  WMPropertiesWindowType_Reserved15   = 15,


  // may be A COMBINATION of the items below
  WMPropertiesWindowType_StateMask        = 0xfffC0,

  WMPropertiesWindowType_NoState          = 0,
  WMPropertiesWindowType_Modal            = 0x00040,
  WMPropertiesWindowType_Sticky           = 0x00080,
  WMPropertiesWindowType_VMax             = 0x00100,
  WMPropertiesWindowType_HMax             = 0x00200,
  WMPropertiesWindowType_FullScreen       = 0x00400,
  WMPropertiesWindowType_Hidden           = 0x00800,
  WMPropertiesWindowType_Shaded           = 0x01000,
  WMPropertiesWindowType_SkipTaskbar      = 0x02000,
  WMPropertiesWindowType_SkipPager        = 0x04000,
  WMPropertiesWindowType_Above            = 0x08000,
  WMPropertiesWindowType_Below            = 0x10000,
  WMPropertiesWindowType_Focused          = 0x20000,
  WMPropertiesWindowType_DemandsAttention = 0x40000,
  WMPropertiesWindowType_Reserved80000    = 0x80000,


  // TODO:  other stuff

  WMPropertiesWindowType_Max = 0x80000000
};

/** \ingroup wcore
  * \hideinitializer
  * \brief Window WMProtocols support enumeration.
  *
  * Bit flags indicating support for known WM_PROTOCOLS window manager features
**/
enum WMPropertiesWMProtocols
{
  // The following flags indicate WM_PROTOCOLS support
  // Assigning these directly can have unexpected consequences
  WMPropertiesWMProtocols_Mask            = 0xff,
  WMPropertiesWMProtocols_None            = 0x0,  ///< the default
  WMPropertiesWMProtocols_DeleteWindow    = 0x01,
  WMPropertiesWMProtocols_Reserved2       = 0x02,
  WMPropertiesWMProtocols_Reserved3       = 0x04,
  WMPropertiesWMProtocols_Reserved4       = 0x08,
  WMPropertiesWMProtocols_Reserved5       = 0x10,
  WMPropertiesWMProtocols_Reserved6       = 0x20,
  WMPropertiesWMProtocols_Reserved7       = 0x40,
  WMPropertiesWMProtocols_Reserved8       = 0x80,
};

/** \ingroup wcore
  * \hideinitializer
  * \brief WBCreateWindow 'iFlags' additional bits
  *
  * Bit flags for additional properties for 'iFlags' in WBCreateWindow.
**/
enum WBCreateWindow_flags
{
  // The following flags indicate WM_PROTOCOLS support
  // Assigning these directly can have unexpected consequences
  WBCreateWindow_flagsDefault             = 0, ///< equivalent to 'CWBorderPixel | CWBackPixel | CWColormap | CWBitGravity' when specified without any additional 'CW' flags
#ifdef HAS_WB_UINT64_BUILTIN
  WBCreateWindow_flagsNoImageCache      = 0x100000000LL,  ///< do not use a 'backing store' when drawing the window (native X11 calls)
#endif // HAS_WB_UINT64_BUILTIN
};

// TODO:  equivalents for when WBUINT64 is NOT supported as a native 'long long' data type (rare, if ever)


/** \ingroup wcore
  * \brief Create a window
  *
  * \param pDisplay A pointer to the display (or NULL for the default display)
  * \param wIDParent The parent window, or 'None'
  * \param pProc A pointer to the event handler proc
  * \param szClass The name of the window's class (mostly for debugging in X11; for WIN32 this is important for other reasons)
  * \param iX The X position of the window
  * \param iY The Y position of the window
  * \param iWidth The width of the window
  * \param iHeight The height of the window
  * \param iBorder The border width of the window
  * \param iIO The I/O type of the window (Input, InputOutput, etc.)
  * \param iFlags The flags indicating which bits are valid in the XSetWindowAttributes structure, plus additional flags specific to the X11Workbench Toolkit (see below)
  * \param pXSWA A pointer to the XSetWindowAttributes structure.  May be NULL if the lower 32-bits of iFlags is WBCreateWindow_flagsDefault (see below).
  * \return A valid Window ID, or 'None' on error
  *
  * Call this function to create a window, which is similar to XCreateWindow().  It will
  * automatically register the callback function and the class name, and sets up a few
  * default parameters for you automatically.\n
  * The window is created with the default visual and depth for the specified display with
  * default screen and a default set of WM_HINTS.
  *
  * The X11Workbench Toolkit also supports a number of additional bit values for 'iFlags':
  *
  * WBCreateWindow_flagsDefault (which has a value of zero)
  *   When specified alone, this uses the default value CWBorderPixel | CWBackPixel | CWColormap | CWBitGravity .
  *   if the value of 'pXSWA' is NULL, a default XSetWindowAttributes structure will be created and initialized
  *   for you, using WBInitWindowAttributes() and default values.
  *
  *
  *
  * \sa WBInitWindowAttributes()
  *
  * Header File:  window_helper.h
**/
Window WBCreateWindow(Display *pDisplay, Window wIDParent,
                      WBWinEvent pProc, const char *szClass,
                      int iX, int iY, int iWidth, int iHeight, int iBorder, int iIO,
                      WB_UINT64 iFlags, XSetWindowAttributes *pXSWA);

/** \ingroup wcore
  * \brief Destroy a window
  *
  * Call this function to destroy a window, rather than XDestroyWindow
  *
  * Header File:  window_helper.h
**/
void WBDestroyWindow(Window wID);

/** \ingroup wcore
  * \brief Destroy a window
  *
  * \return The application window's Window ID, or 'None'
  *
  * Call this function to get the 'Application' window's ID registered via WBSetApplicationWindow().
  * There can be only one.
  *
  * Header File:  window_helper.h
**/
Window WBGetApplicationWindow(void);

/** \ingroup wcore
  * \brief Destroy a window
  *
  * \param wID The Window identifier of the 'application' window, or None
  *
  * Call this function to set the 'Application' window's ID.  There can be only one.
  * Make sure the window has an assigned callback already, or the assignment will fail.
  * Once the application window's callback has been unregistered, the application window
  * ID will be reset to 'None' automatically.
  *
  * Header File:  window_helper.h
**/
void WBSetApplicationWindow(Window wID);

/** \ingroup wcore
  * \brief implements the default window event callback behavior
  *
  * Header File:  window_helper.h
**/
int WBDefault(Window wID, XEvent *pEvent);

/** \ingroup wcore
  * \brief implements the default application event callback behavior
  *
  * Header File:  window_helper.h
**/
int WBAppDefault(XEvent *pEvent);

/** \ingroup wcore
  * \brief Registers a callback function for application events
  *
  * To handle events sent to the application ('no window' events), register a callback
  * function using this API.  The callback function you register should call WBAppDefault()
  * for any events that it does not process.
  *
  * Header File:  window_helper.h
**/
void WBRegisterAppCallback(WBAppEvent pCallback);

/** \ingroup wcore
  * \brief unregister callback function for application events
  *
  * Header File:  window_helper.h
**/
void WBUnregisterAppCallback();

/** \ingroup wcore
  * \brief register callback function for a window (required)
  *
  * Header File:  window_helper.h
**/
void WBRegisterWindowCallback(Window wID, WBWinEvent pCallback);

/** \ingroup wcore
  * \brief un-register the window's callback function (implies resource destruction)
  *
  * Header File:  window_helper.h
**/
void WBUnregisterWindowCallback(Window wID);

/** \ingroup wcore
  * \brief assign standard WM (Window Manager) properties via XSetWMProperties
  *
  * \param wID The Window ID for the window
  * \param szTitle A const pointer to a character string containing the window title
  * \param pNormalHints The pointer to the XSiteHints data, or NULL
  * \param pWMHints The pointer to the XWMHints data, or NULL
  * \param pClassHints The pointer to the XClassHint data, or NULL
  *
  * Header File:  window_helper.h
**/
void WBSetWMProperties(Window wID, const char *szTitle, XSizeHints *pNormalHints,
                       XWMHints *pWMHints, XClassHint *pClassHints);
/** \ingroup wcore
  * \brief assign window (and icon) title
  *
  * \param wID The Window ID for the window
  * \param szTitle A const pointer to a character string containing the window title
  *
  * Header File:  window_helper.h
**/
void WBSetWindowTitle(Window wID, const char *szTitle);

/** \ingroup wcore
  * \brief assign standard WM (Window Manager) 'window type' properties BEFORE mapping it (reserved)
  *
  * \param wID The Window ID for the window
  * \param wmProp An inclusive set of enumerated bit values from the WMPropertiesWindowType enumeration
  *
  * \sa <a href="http://standards.freedesktop.org/wm-spec/wm-spec-latest.html">latest WM spec</a>
  * <a href="http://standards.freedesktop.org/freedesktop-platform-specs/1.0/wm-spec-1.3/"> WM spec v 1.3</a>
  *
  * Header File:  window_helper.h
**/
void WBSetWMPropertiesWindowType(Window wID, enum WMPropertiesWindowType wmProp);

/** \ingroup wcore
  * \brief re-assign standard WM (Window Manager) 'window type' properties and notify the root window (reserved)
  *
  * \param wID The Window ID for the window
  * \param wmPropSet A set of enumerated bit values from the WMPropertiesWindowType enumeration
  * \param wmChangeMask A mask for the enumerated bit values to change from the WMPropertiesWindowType enumeration
  *
  * \sa <a href="http://standards.freedesktop.org/wm-spec/wm-spec-latest.html">latest WM spec</a>
  * <a href="http://standards.freedesktop.org/freedesktop-platform-specs/1.0/wm-spec-1.3/"> WM spec v 1.3</a>
  *
  * Header File:  window_helper.h
**/
void WBChangeWMPropertiesWindowType(Window wID, enum WMPropertiesWindowType wmPropSet, enum WMPropertiesWindowType wmChangeMask);


/** \ingroup wcore
  * \brief re-assign standard WM (Window Manager) 'window type' properties and notify the root window (reserved)
  *
  * \param wID The Window ID for the window
  * \return A bitmask consisting of WMPropertiesWindowType enumeration values.
  *
  * These values are cached from WBSetWMPropertiesWindowType() and WBChangeWMPropertiesWindowType()
  *
  * Header File:  window_helper.h
**/
enum WMPropertiesWindowType WBGetWMPropertiesWindowType(Window wID);

/** \ingroup wcore
  * \brief re-assign standard WM (Window Manager) 'window type' properties and notify the root window (reserved)
  *
  * \param wID The Window ID for the window
  * \param aProperty The atoms to be assigned to the supported WM Protocols list
  *
  * Additional parameters are all Atom values, the last one being 'None' to mark the end of the list.
  * These Atoms will be assigned to the WM_PROTOCOLS property via XSetWMProtocols().  In some cases,
  * the behavior of the toolkit will change depending on the atoms that are assigned.  This assignment
  * should ONLY be done on top-level windows, and only at the time of window creation.
  *
  * Header File:  window_helper.h
**/
void WBSetWMProtocols(Window wID, Atom aProperty, ...);


/** \ingroup wcore
  * \brief callback definition for WBLocateWindow
  *
  * \param wID The ID of the window being enumerated
  * \param pData The pointer specified in the call to WBLocateWindow
  * \return A value > 0 to indicate a match, < 0 to stop enumerating, 0 to continue enumerating
  *
  * Header File:  window_helper.h
**/
typedef int (*WBLocateWindowCallback)(Window wID, void *pData);

/** \ingroup wcore
  * \brief Locate a window by enumerating with a callback function
  *
  * \param callback A pointer to a callback function to call for each enumerated window - see \ref WBLocateWindowCallback
  * \param pData A void pointer that is passed to the callback function as its 2nd parameter
  * \return The Window ID being enumerated when the callback returns a value > 0, or None
  *
  * loops through all known windows passing the window ID and pData
  * to the callback function.  The callback function then determines
  * whether this is the window (droids?) you are looking for.
  *
  * The callback must return > 0 if found, 0 if not found, < 0 to quit enumerating
  *
  * WBLocateWindow then returns either 0 (None) or a valid window ID
  *
  * \sa  \ref WBLocateWindowCallback
  *
  * Header File:  window_helper.h
**/
Window WBLocateWindow(WBLocateWindowCallback callback, void *pData);

/** \ingroup wcore
  * \brief set input focus to a specific window
  *
  * \param wID The Window ID to assign the focus
  *
  * Call this function to assign the input focus to a specific window.  The 'revert'
  * window will be the previous focus window.
  *
  * Header File:  window_helper.h
**/
void WBSetInputFocus(Window wID);

/** \ingroup wcore
  * \brief returns the Display associated with a window
  *
  * \param wID The Window ID from which to obtain the Display pointer
  * \return A Display pointer corresponding to the Window ID, or NULL on error
  *
  * Header File:  window_helper.h
**/
Display * WBGetWindowDisplay(Window wID);

/** \ingroup wcore
  * \brief assigns an icon resource (by ID) to a window
  *
  * \param wID The Window ID from which to return the default cursor
  * \param idIcon The resource ID for the window's icon
  *
  * Header File:  window_helper.h
**/
void WBSetWindowIcon(Window wID, int idIcon);

/** \ingroup wcore
  * \brief assigns the default WB_FONT object for a window
  *
  * \param wID The Window ID from which to return the default cursor
  * \param pFont The WB_FONTC (or WB_FONT) object for the window.  A copy of this object will be owned by the window.  To use the default font set, you can assign a value of 'NULL'
  *
  * Header File:  window_helper.h
**/
void WBSetWindowFont(Window wID, WB_FONTC pFont);

/** \ingroup wcore
  * \brief Assigns a default cursor (by ID) to a window
  *
  * \param wID The Window ID from which to return the default cursor
  * \param idStandardCursor The default Cursor ID to assign (Typically an XC_ definition from X11/cursorfont.h).  A value of '-1' equates to 'None'
  *
  * Header File:  window_helper.h
**/
void WBSetWindowDefaultCursor(Window wID, int idStandardCursor);

/** \ingroup wcore
  * \brief returns the default cursor ID for a window
  *
  * \param wID The Window ID from which to return the default cursor
  * \return The Cursor ID (Typically an XC_ definition from X11/cursorfont.h).  A value of '-1' equates to 'None'
  *
  * Header File:  window_helper.h
**/
int WBGetWindowDefaultCursor(Window wID);

/** \ingroup wcore
  * \brief creates a default WBGC for a window
  *
  * \param wID The Window ID for which to assign the colors
  * \param clrFG The foreground color
  * \param clrBG The background color
  *
  * Header File:  window_helper.h
**/
void WBCreateWindowDefaultGC(Window wID, unsigned long clrFG, unsigned long clrBG);

/** \ingroup wcore
  * \brief assigns a default WBGC to a window
  *
  * \param wID The Window ID for which to assign the WBGC
  * \param hGC The WBGC to assign
  *
  * Header File:  window_helper.h
**/
void WBSetWindowDefaultGC(Window wID, WBGC hGC);

/** \ingroup wcore
  * \brief makes a copy of the default WBGC so that it can be modified
  *
  * \param wID The Window ID from which to copy the WBGC
  * \return A copy of the default WBGC for the specified window
  *
  * Header File:  window_helper.h
**/
WBGC WBGetWindowCopyGC(Window wID);

/** \ingroup wcore
  * \brief makes a copy of the specified WBGC for the desired window
  *
  * \param wID The Window ID for which to copy the WBGC
  * \param gcSrc The source 'WBGC'
  * \return A copy of the WBGC for the specified window
  *
  * Essentially, it works the same as WBGetWindowCopyGC() except it uses gcSrc
  * instead of the window's 'default WBGC'.  (legacy, use WBCopyDrawableGC() instead)
  *
  * Header File:  window_helper.h
**/
#define WBGetWindowCopyGC2(wID, gcSrc) WBCopyDrawableGC(WBGetWindowDisplay(wID), wID, gcSrc)

/** \ingroup wcore
  * \brief assign 'data pointer' for a window and specified index value
  *
  * \param wID The Window ID to which to assign the data pointer
  * \param iIndex The 0-based index that identifies the entry
  * \param pData The data pointer to assign (may be NULL)
  *
  * Header File:  window_helper.h
**/
void WBSetWindowData(Window wID, int iIndex, void *pData);

/** \ingroup wcore
  * \brief increment 'wait cursor' count, set cursor to WB_WAIT_CURSOR
  *
  * \param wID The Window ID to which the wait cursor needs to be assigned
  *
  * Header File:  window_helper.h
**/
void WBBeginWaitCursor(Window wID);

/** \ingroup wcore
  * \brief decrement 'wait cursor' count, restore to default when zero
  *
  * \param wID The Window ID to which the cursor needs to be restored
  *
  * Header File:  window_helper.h
**/
void WBEndWaitCursor(Window wID);

/** \ingroup wcore
  * \brief immediately set the window cursor
  *
  * \param wID The Window ID to which the cursor needs to be assigned
  * \param idCursor The Cursor ID (Typically an XC_ definition from X11/cursorfont.h).  A value of '-1' equates to 'None'
  *
  * Header File:  window_helper.h
**/
void WBSetWindowCursor(Window wID, int idCursor);

/** \ingroup wcore
  * \brief restore the default cursor
  *
  * \param wID The Window ID to which the default cursor needs to be restored
  *
  * Header File:  window_helper.h
**/
void WBRestoreDefaultCursor(Window wID);

/** \ingroup wcore
  * \brief Returns the default WBGC currently assigned to the window (not a copy)
  *
  * \param wID The Window ID from which to obtain the default WBGC
  * \return The default WBGC associated with the specified window.  This is the actual WBGC, not a copy.
  *
  * Each window that is mapped within the API will have a 'default WBGC' associated with it.
  * This WBGC should not be modified unless you want the changes to remain for the next time a WBGC
  * is required.  A preferred method is to re-assign a new default WBGC with the new settings, or
  * create a copy of the default WBGC as a 'starting point', then modify the copy as needed to
  * perform the desired operation.  This, in fact, will happen every time you use the API to
  * handle Expose events, via the WBBeginPaint() and WBEndPaint() functions, where the paint
  * WBGC is a modified version of the default WBGC.
  *
  * Header File:  window_helper.h
**/
WBGC WBGetWindowDefaultGC(Window wID);

/** \ingroup wcore
  * \brief Returns the WB_FONT assigned to the window (may be NULL), not a copy
  *
  * \param wID The Window ID from which to obtain a copy of the current WB_FONT object
  * \return The assigned WB_FONT, or 'NULL' on error.
  *
  * Header File:  window_helper.h
**/
WB_FONTC WBQueryWindowFont(Window wID);

/** \ingroup wcore
  * \brief Returns a copy of the current WB_FONT assigned to the window (may be NULL)
  *
  * \param wID The Window ID from which to obtain a copy of the current WB_FONT object
  * \return A copy of the assigned WB_FONT, or 'NULL' on error.  A non-null return must be free's using WBFreeFont()
  *
  * Header File:  window_helper.h
**/
WB_FONT WBGetWindowFont(Window wID);

/** \ingroup wcore
  * \brief Returns the currently assigned foreground color
  *
  * \param wID The Window ID from which to obtain the foreground color
  * \return The current foreground color for the window
  *
  * Header File:  window_helper.h
**/
unsigned long WBGetWindowFGColor(Window wID);

/** \ingroup wcore
  * \brief Returns the currently assigned background color
  *
  * \param wID The Window ID from which to obtain the background color
  * \return The current background color for the window
  *
  * Header File:  window_helper.h
**/
unsigned long WBGetWindowBGColor(Window wID);

/** \ingroup wcore
  * \brief returns the currently assigned foreground color for a WBGC
  *
  * \param gc The WBGC to be queried
  * \returns The currently assigned foreground color
  *
  * If the current foreground color cannot be determined, this function will
  * return the pre-defined color for BLACK on the specified Display and default screen
  *
  * Header File:  window_helper.h
**/
unsigned long WBGetGCFGColor(WBGC gc);

/** \ingroup wcore
  * \brief returns the currently assigned background color for a WBGC
  *
  * \param gc The WBGC to be queried
  * \returns The currently assigned background color
  *
  * If the current background color cannot be determined, this function will
  * return the pre-defined color for WHITE on the specified Display and default screen
  *
  * Header File:  window_helper.h
**/
unsigned long WBGetGCBGColor(WBGC gc);

/** \ingroup wcore
  * \brief returns a default XStandardColormap structure for the default screen of the specified display
  *
  * \param pDisplay The display for which to obtain the XStandardColormap.  This will use its default Colormap
  * \param pMap A pointer to an XStandardColormap structure.  This will receive a copy of the XStandardColormap for the specified display
  *
  * This function obtains an XStandardColormap for the default colormap associated with a display.
  * For the defaut display, this value is cached (for performance).  Other displays will 'hit' the
  * X Server to obtain the necessary information.  If there is no default XStandardColormap in the
  * system (which is typical), this function will derive one using the Red, Green, and Blue color
  * pixel values, and the results of using XAllocColor.
  *
  * An XStandardColormap structure is necessary in order to map RGB values to/from 'Pixel' values without
  * calling the time-expensive XAllocColor (and related functions).  If you do any kind of extensive
  * color-related things with your code, you will most likely need a copy of the XStandardColormap .
  *
  * You should also ignore the visualid and killid parameters.  These will both be assigned to 'None'
  *
  * Header File:  window_helper.h
**/
void WBDefaultStandardColormap(Display *pDisplay, XStandardColormap *pMap);

/** \ingroup wcore
  * \brief Assignes the window's class name pointer
  *
  * \param wID The Window ID to assign a 'class name' to
  * \param szClassName A const pointer to a 0-byte terminated string containing the class name.  The actual pointer is assigned internally.
  *
  * Assigns a pointer to a persistent character string that identifies the
  * 'window class' for debug and tracing purposes.  The pointer must be 'persistent', neither
  * allocated via 'malloc()' or on the stack, since it is assigned directly 'as-is' to the
  * internal structure, without copying the string data.
  *
  * Header File:  window_helper.h
**/
void WBSetWindowClassName(Window wID, const char *szClassName);

/** \ingroup wcore
  * \brief Returns the window's assigned class name pointer
  *
  * \param wID The Window ID to obtain a 'class name' from
  * \return A const pointer to a 0-byte terminated character string containing the window's class name, or NULL if there is none
  *
  * The windows 'class name' is a persistent string pointer that is optionally
  * assigned by calling WBSetWindowClassName().  This function returns the assigned
  * pointer.  Its primary use is for debugging and tracing.
  *
  * Header File:  window_helper.h
**/
const char *WBGetWindowClassName(Window wID);

/** \ingroup wcore
  * \brief Gets the data associated with this window and the specified index
  *
  * \param wID The Window ID to obtain window data for
  * \param iIndex The 0-based index for the window's data
  * \return A void pointer assigned to the specified index for the specified window, or NULL if there is no data.
  *
  * Each window has up to WINDOW_DATA_SIZE void pointers that can be stored within
  * the internal data structure associated with each window.  For many standard
  * windows and controls defined in the API, the first entry (index zero) is reserved.
  * Any unused entries can be made use of in any way necessary.  It is important to
  * keep in mind that these values are not automatically checked, nor are any resources
  * automatically deleted when the window is destroyed.
  *
  * Header File:  window_helper.h
**/
void *WBGetWindowData(Window wID, int iIndex);

/** \ingroup wcore
  * \brief Returns the RAW geometry of the window as reported by the window manager
  *
  * \param wID The Window ID to obtain the WB_GEOM data for
  * \param pGeom A pointer to the WB_GEOM structure to receive the data
  *
  * Header File:  window_helper.h
**/
void WBGetWindowGeom(Window wID, WB_GEOM *pGeom);

/** \ingroup wcore
  * \brief Returns the geometry of the window relative to the root window
  *
  * \param wID The Window ID to obtain the WB_GEOM data for
  * \param pGeom A pointer to the WB_GEOM structure to receive the data
  *
  * Header File:  window_helper.h
**/
void WBGetWindowGeom2(Window wID, WB_GEOM *pGeom);


/** \ingroup wcore
  * \brief Returns the ABSOLUTE window geometry relative the screen
  *
  * \param wID The Window ID to obtain the WB_GEOM data for
  * \param pGeom A pointer to the WB_GEOM structure to receive the data
  *
  * The 'ABSOLUTE' window geometry is the position of the window relative to the
  * origin point (the upper left corner of the screen).  Window managers typically
  * cook all of the XEvent and API data that relates to window positioning, such that
  * a top level frame window's upper left corner is nearly always reported as 0,0 (or similar).
  * Not all window managers behave the same in this regard.  To ensure that an ABSOLUTE
  * window position is known (helpful for centering on screen, etc.), the absolute coordinates
  * are frequently cached within the internal data structure associated with the window.
  * Those cached values are returned by this function.
  *
  * Header File:  window_helper.h
**/
void WBGetWindowGeom0(Window wID, WB_GEOM *pGeom);  // absolute window geometry (from latest notification)

/** \ingroup wcore
  * \brief Returns the WB_RECT (rectangle) defined by the window's geometry, including the border area
  *
  * \param wID The Window ID to obtain the WB_RECT data for
  * \param pRect A pointer to the WB_RECT structure to receive the data
  *
  * Header File:  window_helper.h
**/
void WBGetWindowRect(Window wID, WB_RECT *pRect);

/** \ingroup wcore
  * \brief Returns the WB_RECT (rectangle) defined by the window's geometry, excluding the border area
  *
  * \param wID The Window ID to obtain the WB_RECT data for
  * \param pRect A pointer to the WB_RECT structure to receive the data
  *
  * Header File:  window_helper.h
**/
void WBGetClientRect(Window wID, WB_RECT *pRect);


/** \ingroup wcore
  * \brief Returns the window's parent (or None if there is no parent)
  *
  * \param wID The Window ID to obtain the parent for
  * \return The Window ID of the parent, or None
  *
  * Header File:  window_helper.h
**/
Window WBGetParentWindow(Window wID);


/** \ingroup wcore
  * \brief Assigns the parent to the specified window within the internal structure
  *
  * \param wID The Window ID of the target
  * \param wIDParent The parent Window ID to assign to the internal structure
  *
  * Call this function to assign the specified parent window ID to the internal
  * structure for the target window.  This does NOT re-parent the window!
  *
  * If you want to change the owner window you should call \ref WBReparentWindow() instead.
  * NOTE:  this function should NOT be called for top level windows.
  *
  * Header File:  window_helper.h
**/
void WBSetParentWindow(Window wID, Window wIDParent);

/** \ingroup wcore
  * \brief Assigns a new parent to the specified window (aka 'Re-parent')
  *
  * \param wID The Window ID of the target (to be adopted) window
  * \param wIDParent The new parent Window ID.  Congratulations, it's a Window!
  * \param iX The new X location for the window specified by wID (see XReparentWindow)
  * \param iY The new Y location for the window specified by wID (see XReparentWindow)
  *
  * Call this function to re-assign the parent window via XReparentWindow.  Using this
  * function will ensure that internal information remains synchronized.\n
  *
  * NOTE:  this function should NOT be called for top level windows.
  *
  * Header File:  window_helper.h
**/
int WBReparentWindow(Window wID, Window wIDParent, int iX, int iY); // keeps internal info up to date

/** \ingroup wcore
  * \brief Returns non-zero if wIDParent is in a parent relationsihp with wIDChild
  *
  * \param wIDParent The Window ID for the 'test' parent window
  * \param wIDChild The Window ID for the 'test' child window
  * \return A non-zero value if wIDParent is in a parent/child relatinship with wIDChild; otherwise it returns zero
  *
  * Rather than checking for the parent window ID and doing a 'direct match', this
  * function checks all parent windows of 'wIDChild' to see if 'wIDParent' is
  * one of them, and returns a non-zero value if it is.  Otherwise, the function
  * returns zero.
  *
  * Header File:  window_helper.h
**/
int WBIsChildWindow(Window wIDParent, Window wIDChild);  // non-zero if 'wIDParent' is in a parent relationship with 'wIDChild'

/** \ingroup wcore
  * \brief Returns logical TRUE if the point (X,Y) is within the borders of the rectangle 'R'
  * \param X The X value to check for
  * \param Y The Y value to check for
  * \param R A WB_RECT structure bounding the area to check
  * \return logical TRUE if (X,Y) lies within 'R', FALSE otherwise
  *
**/
#define WBPointInRect(X,Y,R) ((X) >= (R).left && (X) < (R).right && (Y) >= (R).top && (Y) < (R).bottom)

/** \ingroup wcore
  * \brief Returns logical TRUE if the point (X,Y) is within the borders of the geometry 'G'
  * \param X The X value to check for
  * \param Y The Y value to check for
  * \param G A WB_GEOM structure bounding the area to check
  * \return logical TRUE if (X,Y) lies within 'G', FALSE otherwise
**/
#define WBPointInGeom(X,Y,G) ((X) >= (G).x && (X) < ((G).x + (G).width) && (Y) >= (G).y && (Y) < ((G).y + (G).height))

/** \ingroup wcore
  * \brief Returns logical TRUE if the rectangle R1 overlaps/intersects R2
  * \param R1 A WB_RECT structure bounding the first area to check
  * \param R2 A second WB_RECT structure bounding the second area to check
  * \return logical TRUE if the two WB_RECTs intersect, FALSE otherwise
**/
#define WBRectOverlapped(R1,R2) \
  ((((R1).left >= (R2).left && (R1).left < (R2).right) || \
    ((R2).left >= (R1).left && (R2).left < (R1).right)) && \
   (((R1).top >= (R2).top && (R1).top < (R2).bottom) || \
    ((R2).top >= (R1).top && (R2).top < (R1).bottom)))

/** \ingroup wcore
  * \brief Returns logical TRUE if the geometry G1 overlaps/intersects G2
  * \param G1 A WB_GEOM structure bounding the first area to check
  * \param G2 A second WB_GEOM structure bounding the second area to check
  * \return logical TRUE if the two WB_GEOMs intersect, FALSE otherwise
**/
#define WBGeomOverlapped(G1,G2) \
  ((((G1).x >= (G2).x && (G1).x < (G2).x + (G2).width) || \
    ((G2).x >= (G1).x && (G2).x < (G1).x + (G1).width)) && \
   (((G1).y >= (G2).y && (G1).y < (G2).y + (G2).height) || \
    ((G2).y >= (G1).y && (G2).y < (G1).y + (G1).height)))

/** \ingroup wcore
  * \brief Translate X,Y point coordinates relative to a window
  *
  * \param wIDSrc The source Window ID
  * \param iXSrc The X coordinate within wIDSrc
  * \param iYSrc The Y coordinate within wIDSrc
  * \param wIDDest The destination Window ID
  * \param piXDest A pointer to an integer to receive the translated X coordinate
  * \param piYDest A pointer to an integer to receive the translated Y coordinate
  *
  * For many operations, coordinates relative to one window must be translated into
  * coordinates relative to a different window so that they can be used for the
  * new window's processing.\n
  * To translate from screen coordinates, pass 'None' for 'wIDSrc'\n
  *
  * Header File:  window_helper.h
**/
void WBXlatCoordPoint(Window wIDSrc, int iXSrc, int iYSrc, Window wIDDest, int *piXDest, int *piYDest);

/** \ingroup wcore
  * \brief Translate geometry coordinates relative to a window
  *
  * \param wIDSrc The source Window ID
  * \param pGeomSrc A const pointer to a WB_GEOM structure containing the coordinates to translate
  * \param wIDDest The destination Window ID
  * \param pGeomDest A pointer to a WB_GEOM structure that receives the translated coordinates
  *
  * For many operations, coordinates relative to one window must be translated into
  * coordinates relative to a different window so that they can be used for the
  * new window's processing.\n
  * To translate from screen coordinates, pass 'None' for 'wIDSrc'\n
  *
  * Header File:  window_helper.h
**/
void WBXlatCoordGeom(Window wIDSrc, const WB_GEOM *pGeomSrc, Window wIDDest, WB_GEOM *pGeomDest);

/** \ingroup wcore
  * \brief Translate rectangle coordinates relative to a window
  *
  * \param wIDSrc The source Window ID
  * \param pRectSrc A const pointer to a WB_RECT structure containing the coordinates to translate
  * \param wIDDest The destination Window ID
  * \param pRectDest A pointer to a WB_RECT structure that receives the translated coordinates
  *
  * For many operations, coordinates relative to one window must be translated into
  * coordinates relative to a different window so that they can be used for the
  * new window's processing.\n
  * To translate from screen coordinates, pass 'None' for 'wIDSrc'\n
  *
  * Header File:  window_helper.h
**/
void WBXlatCoordRect(Window wIDSrc, const WB_RECT *pRectSrc, Window wIDDest, WB_RECT *pRectDest);

/** \ingroup wcore
  * \brief Returna a non-zero value if X,Y coordinates relative to the reference window are within the query window
  *
  * \param wIDRef The reference Window ID
  * \param iX The X coordinates relative to wIDRef
  * \param iY The Y coordinates relative to wIDRef
  * \param wIDQuery The Window ID of the window to test the translated X and Y values against
  * \return Non-zero if the (X,Y) coordinates are within wIDQuery, zero otherwise.
  *
  * Use this function to see if coordinates relative to one window also fall within another window.
  * Typical use includes 'hover' detection, drag/drop operations, and child window activation
  * To specify X,Y screen coordinates, pass 'None' for 'wIDRef'\n
  *
  * Header File:  window_helper.h
**/
int WBPointInWindow(Window wIDRef, int iX, int iY, Window wIDQuery);

// keyboard translation helpers

/** \ingroup keyboard
  * \brief 'AltCtrlShift' bit flag for 'VK_' keys for WBKeyEventProcessKey()
**/
#define WB_KEYEVENT_KEYSYM 8 /* bit flags for 'piAltCtrlShift' below */

/** \ingroup keyboard
  * \brief 'AltCtrlShift' bit flag for ALT modifier for WBKeyEventProcessKey()
**/
#define WB_KEYEVENT_ALT    4

/** \ingroup keyboard
  * \brief 'AltCtrlShift' bit flag for Control modifier for WBKeyEventProcessKey()
**/
#define WB_KEYEVENT_CTRL   2

/** \ingroup keyboard
  * \brief 'AltCtrlShift' bit flag for Shift modifier for WBKeyEventProcessKey()
**/
#define WB_KEYEVENT_SHIFT  1

/** \ingroup keyboard
  * \brief 'AltCtrlShift' bit mask for Alt+Ctrl+Shift bits for WBKeyEventProcessKey()
**/
#define WB_KEYEVENT_ACSMASK 7


/** \ingroup keyboard
  * \brief Generic keyboard event translation utility
  *
  * \param pEvent A const pointer to an XKeyEvent structure to process
  * \param pBuf A buffer to receive translated keystroke information (may be NULL, see below)
  * \param pcbLen A pointer to an integer (pre-assigned to the length of pBuf) that receives the actual data length (see below) (may be NULL)
  * \param piAltCtrlShift A pointer to an integer that receives bit flags associated with CTRL ALT and SHIFT states (may be NULL)
  * \return The first byte of the character string when 'pBuf' is NOT NULL, or a translated UTF character of 1, 2, or 4 bytes when pBuf is NULL
  *
  * generic utility to process a keystroke.  'pcbLen' must be pre-assigned to size of 'pBuf'
  * if 'pBuf' is to be written to.  Any parameter other than 'pEvent' may be NULL.
  * when pBuf is NULL, pcbLen (if not NULL) receives the required length in bytes
  * when pcbLen is NULL and pBuf is not, length is assumed to be 1 byte
  * return value is the first byte of the character string when 'pBuf' is NOT NULL, or a
  * translated UTF character of 1, 2 or 4 bytes (when pBuf is NULL).
  *
  * \sa  \ref aWB_CHAR, \ref aWB_POINTER
  *
  * Header File:  window_helper.h
**/
int WBKeyEventProcessKey(const XKeyEvent *pEvent, char *pBuf, int *pcbLen, int *piAltCtrlShift);
  // NOTE:  WB_CHAR notification messages (related to WBKeyEventProcessKey)
  // message_type == aWB_CHAR
  // data.l[0] is return frmo WBKeyEventProcessKey
  // data.l[1] is *piAltCtrlShift from WBKeyEventProcessKey
  // data.l[2] is number of characters decoded into data.l[3..4]
  // data.l[3..4] (as char[]) is decode buffer (at least 8 chars long, possibly 16 for 64-bit)



// pointer event definitions - WB_POINTER
// data.l[0] is notification code (below)
// data.l[1] is bitmap of mouse button state (button 1 is bit 0, button 2 is bit 1, etc.)
// data.l[2] is 'WB_KEYEVENT_' mask for CTRL+ALT+SHIFT
// data.l[3] is translated X coordinate
// data.l[4] is translated Y coordinate

/** \ingroup pointer
  * \brief Unspecified event, possible motion or state-chagne notification
**/
#define WB_POINTER_UNSPECIFIED 0 /* possible motion or state-change notifications */

/** \ingroup pointer
  * \brief Mouse 'click' event
**/
#define WB_POINTER_CLICK       1

/** \ingroup pointer
  * \brief WB_POINTER 'double-click' event, send in lieu of WB_POINTER_CLICK for double-click
**/
#define WB_POINTER_DBLCLICK    2

/** \ingroup pointer
  * \brief WB_POINTER 'drag' event, window proc MUST return the window ID to auto-support drag/drop
**/
#define WB_POINTER_DRAG        3 /* window proc returns window ID to support drag/drop */

/** \ingroup pointer
  * \brief WB_POINTER 'drop' event, only sent if drag/drop supported AND was not 'canceled'; see WB_POINTER_CANCEL
**/
#define WB_POINTER_DROP        4 /* may not happen if drag is canceled */

/** \ingroup pointer
  * \brief WB_POINTER 'move' event, for motion notification during drag/drop
**/
#define WB_POINTER_MOVE        5 /* motion notify while dragging */

/** \ingroup pointer
  * \brief WB_POINTER 'cancel' event, cancels an ongoing operation, such as drag/drop (useful for resource cleanup)
**/
#define WB_POINTER_CANCEL      6 /* reservedly any kind of cancellation, but for now, 'drag cancel' */

/** \ingroup pointer
  * \brief WB_POINTER 'scroll up' event, caused by mouse button 4
**/
#define WB_POINTER_SCROLLUP    7 /* scroll event, mouse button 4 */

/** \ingroup pointer
  * \brief WB_POINTER 'scroll down' event, caused by mouse button 5
 **/
#define WB_POINTER_SCROLLDOWN  8 /* scroll event, mouse button 5 */

/** \ingroup pointer
  * \brief WB_POINTER button bitmask  indicating that button 1 is pressed
**/
#define WB_POINTER_BUTTON1 1 /* these are bitmasks */
/** \ingroup pointer
  * \brief WB_POINTER button bitmask  indicating that button 2 is pressed
**/
#define WB_POINTER_BUTTON2 2
/** \ingroup pointer
  * \brief WB_POINTER button bitmask  indicating that button 3 is pressed
**/
#define WB_POINTER_BUTTON3 4
/** \ingroup pointer
  * \brief WB_POINTER button bitmask  indicating that button 4 (scroll wheel 'up') is pressed
**/
#define WB_POINTER_BUTTON4 8
/** \ingroup pointer
  * \brief WB_POINTER button bitmask  indicating that button 5 (scroll wheel 'down') is pressed
**/
#define WB_POINTER_BUTTON5 16

// (you can add multiple menus to multiple windows)
/** \ingroup wcore
  * \brief (internal) Register a MENU callback for a window
  *
  * Header File:  window_helper.h
**/
void WBRegisterMenuCallback(Window wID, WBWinEvent pCallback);

/** \ingroup wcore
  * \brief Add a MENU WINDOW to a (frame) window - more than one is possible, only one currently supported
  *
  * \param wID The Window ID to which a menu window will be added (typically only one)
  * \param wIDMenu The Window ID of the menu window to add/assign to wID
  *
  * Header File:  window_helper.h
**/
void WBAddMenuWindow(Window wID, Window wIDMenu);
/** \ingroup wcore
  * \brief Returns the Window ID of the (first) menu window assigned to a (frame) window
  *
  * \param wID The Window ID for which to query the menu Window ID
  * \return The Window ID for the Menu window assigned to wID (only one may be assigned for this to work)
  *
  * Header File:  window_helper.h
**/
Window WBGetMenuWindow(Window wID);  // returns ID of menu window assigned by above (one only)
/** \ingroup wcore
  * \brief Remove (detach) the specified menu window from a (frame) window
  *
  * \param wID The Window ID for which to remove a menu Window ID
  * \param wIDMenu The Window ID of the menu window to remove
  *
  * Header File:  window_helper.h
**/
void WBRemoveMenuWindow(Window wID, Window wIDMenu);

/** \ingroup xcore
  * \brief returns non-zero if 'valid' (i.e. 'not destroyed')
  *
  * \param pDisplay The Display pointer associated with the specified window
  * \param wID A Window ID to test 'valid'
  * \return Non-zero value if the internal window information exists and the window has not been destroyed, else zero
  *
  * This function works ONLY for windows that have been registered with a callback.
  * It checks to see if the internal window information exists and returns
  * a non-zero value if the internal information exists AND the window itself has not
  * been destroyed.  This works whether or not the window was ever mapped.
  *
  * Header File:  window_helper.h
**/
int WBIsValid(Display *pDisplay, Window wID);



////////////////////////////////////////////////////
//   _____ __     __ _____  _   _  _____  ____    //
//  | ____|\ \   / /| ____|| \ | ||_   _|/ ___|   //
//  |  _|   \ \ / / |  _|  |  \| |  | |  \___ \   //
//  | |___   \ V /  | |___ | |\  |  | |   ___) |  //
//  |_____|   \_/   |_____||_| \_|  |_|  |____/   //
//                                                //
////////////////////////////////////////////////////

// message loop helpers

/** \ingroup events
  * \brief Main message loop, high level API to check for and retrieve the next event
  *
  * \return The 'Time' value for the last event that had a server timestamp
  *
  * In some cases it's necessary to know an approximate value of the X server's timestamp.
  * The message loop will capture the timestamp value whenever it can.  Use this function to
  * return the best known server time value for the default Display.
  *
  * Header File:  window_helper.h
**/
Time WBGetLastEventTime(void);


/** \ingroup events
  * \brief Main message loop, high level API to check for and retrieve the next event
  *
  * \param pDisplay A pointer to the Display to query events on
  * \param pEvent A pointer to an XEvent structure to receive the event data
  * \return A non-zero value if there is an event to be processed, otherwise zero
  *
  * Implementation of the X11workbench Toolkit API is centered around the API's event
  * loop processing.  The main application should implement its message loop by repeatedly
  * calling WBCheckGetEvent() or WBNextEvent() and passing any retrieved event to \ref WBDispatch().
  * Internally, WBCheckGetEvent() calls the X___CheckEvent functions correctly, dispatches Expose
  * events for asynchronous processing, translates keyboard and pointer events, and handles
  * internally queued events (such as timers and 'posted' events).
  *
  * The function returns a non-zero value if there is an event is to be processed.
  *
  * To correctly implement a message loop, your code should be similar to the following:\n
  * \code
  XEvent event;

  while ( !bQuitFlag )
  {
    if( !WBCheckGetEvent(pX11Display, &event) )
    {
      // as needed, perform an iteration of background processing here

      // With nothing else to do, SLEEP if there is no event in the message queue
      // and no background processing to be performed.
      // (alternately, you could use WBWaitForEvent() if you do not need periodic
      //  wake-up for background processing)

      WBDelay(100);  // 100 microsecs - 0.1 millisecond

      continue;
    }

    WBDispatch(&event);
  }

  * \endcode
  *
  * NOTE:  If you do not want to do any background processing, consider using
  *        WBWaitForEvent() instead of WBDelay()
  *
  * To only retrieve 'internally queued' events, see WBNextEvent()
  *
  * Header File:  window_helper.h
**/
int WBCheckGetEvent(Display *pDisplay, XEvent *pEvent);

/** \ingroup events
  * \brief Wait for an event, blocking indefinitely
  *
  * \param pDisplay a pointer to the Display on which to wait for events
  *
  * Call this function to wait until a new event is available in the event queue.  This
  * function will block indefinitely until such an event is available.\n
  * NOTE: if 'bQuitFlag' is set, this function will return immediately.
  *
  * See WBNextEvent(), WBCheckGetEvent()
  *
  * Header File:  window_helper.h
**/
void WBWaitForEvent(Display *pDisplay);


/** \ingroup events
  * \brief Generic Event Dispatcher, using message type to dispatch
  *
  * \param pEvent A pointer to an XEvent structure to process
  *
  * Call this function to generically dispatch an XEvent.  The application will
  * need to check for a 'quit' state independently.
  * See WBWindowDispatch(), WBAppDispatch()
  *
  * Header File:  window_helper.h
**/
void WBDispatch(XEvent *pEvent);

/** \ingroup events
  * \brief Dispatches an application XEvent.  May be called directly
  *
  * \param pEvent A pointer to an XEvent structure to process
  *
  * Application events have a window ID of None, and are dispatched to
  * the registered Application callback.  In the absence of a callback,
  * default processing is performed.
  *
  * Header File:  window_helper.h
**/
int WBAppDispatch(XEvent *pEvent);

/** \ingroup events
  * \brief Dispatches a window XEvent.  May be called directly
  *
  * \param wID The Window ID that will be 'dispatched' the event, regardless of the event structure contents
  * \param pEvent A pointer to an XEvent structure to process
  * \returns The integer value returned by the window's event callback
  *
  * Dispatches an XEvent for the specified window.  Normally, WBDispatch will
  * call this function using the window ID from the XEvent itself, and pass
  * that ID as the first parameter.  A caller may choose to send the event
  * to a different window, specifying its window ID instead.  This is similar
  * to a modal 'Event Send' and can be useful to have a parent or child window
  * handle a particular type of event (rather than the destined window).
  *
  * Header File:  window_helper.h
**/
int WBWindowDispatch(Window wID, XEvent *pEvent);

/** \ingroup events
  * \brief debug function to return the name of an X11 event
  *
  * \param iEventID An event type identifier
  * \return A const pointer to an ASCII 0-byte terminated character string representing the event ID, or NULL
  *
  * Intended primarily for debug messages, it returns a pointer to an ASCII
  * string containing the name of the event, based on its event ID.  The ID of
  * the event is the value of 'type' within the XEvent structure.
  *
  * Header File:  window_helper.h
**/
const char * WBEventName(int iEventID);

/** \ingroup events
  * \brief Shows a 'modal' window by processing events until the window closes
  *
  * \param wID Window to be made modal
  * \param bMenuSplashFlag Tri-state boolean indicating menu/splash/normal.  A value of 0 is normal, > 0 menu, < 0 splash
  * \return -1 on error, or the dialog box's 'WBEndModal()' iReturn value
  *
  * Use this function to show a 'modal' window.  The function returns when the window
  * is closed.  'bMenuFlag' is > 0 if menu semantics need to be applied to the modal
  * window, or < 0 if splash semantics need to be applied.  Otherwise, it is treated
  * as a NORMAL (dialog) window.
  *
  * The return value is -1 on error, or the value specified by 'iReturn' in the call
  * to WBEndModal().
  *
  * Header File:  window_helper.h
**/
int WBShowModal(Window wID, int bMenuSplashFlag);  // modal window - returns 'EndModal' value or -1 on error

/** \ingroup events
  * \brief End a modal window with a specific return value
  *
  * \param wID Window ID of the window that must end its modal loop
  * \param iReturn The 'return' value from the modal loop - see \ref WBShowModal()
  *
  * Call this function from within a modal window's event process to close the window
  * and exit from WBShowModal with the specified value in 'iReturn'
  *
  * Header File:  window_helper.h
**/
void WBEndModal(Window wID, int iReturn);

// client-side message queue (avoids XSendEvent)
// to send a message directly use WBAppDispatch and WBWindowDispatch

/** \ingroup events
  * \brief low-level event queue wrapper.  Implements the client-side event queue.  Does not block if no events available.
  *
  * \param pDisplay The Display pointer to query events on
  * \param pEvent A pointer to an XEvent structure to receive event info
  * \return a non-zero value if an event was obtained, or zero if no event was available
  *
  * Similar to XNextEvent, this function checks the internal event queues for an event.
  * Unlike XNextEvent it does not wait for an event to be available before returning.
  * The function returns zero if there are no events to be processed.
  *
  * This function will not pull events out of the X server's event queue.  It ONLY manages
  * 'internal' queued events, prioritizing them as needed.
  *
  * See WBCheckGetEvent(), WBWaitForEvent()
  *
  * Header File:  window_helper.h
**/
int WBNextEvent(Display *pDisplay, XEvent *pEvent);

/** \ingroup events
  * \brief Places a copy of the specified event at the end of the regular (internal) event queue
  *
  * \param wID The Window ID of the event to be posted.  The default 'Display *' will be used
  * \param pEvent A pointer to an XEvent structure containing the event info
  * \return A non-zero value on error, or zero if successful
  *
  * The preferred method of event processing between windows is to post them to one of the internal
  * event queues, rather than using XSendEvent() or calling WBDispatch() or WBWindowDispatch() directly.\n
  * You should always use this function for asynchronously posting non-priority events, such as
  * notifications and timers, or when recursion may occur.  Note that any pointers or X11 resources
  * that are passed using XEvent may not be valid by the time they are received. If you must pass
  * volatile data to a window, use WBDispatch() or WBWindowDispatch() instead.
  *
  * Header File:  window_helper.h
**/
int WBPostEvent(Window wID, XEvent *pEvent);

/** \ingroup events
  * \brief Places a copy of the specified event at the end of the priority (internal) event queue
  *
  * \param wID The Window ID of the event to be posted.  The default 'Display *' will be used
  * \param pEvent A pointer to an XEvent structure containing the event info
  * \return A non-zero value on error, or zero if successful
  *
  * The preferred method of event processing between windows is to post them to one of the internal
  * event queues, rather than using XSendEvent() or calling WBDispatch() or WBWindowDispatch() directly.\n
  * Use WBPostPriorityEvent for priority events, such as UI handling (where performance is critical)
  *
  * Header File:  window_helper.h
**/
int WBPostPriorityEvent(Window wID, XEvent *pEvent); // like above but it goes at the beginning of the queue

/** \ingroup events
  * \brief Delays placing a copy of the specified event at the end of the regular (internal) event queue by a specified number of milliseconds
  *
  * \param pEvent A pointer to an XEvent structure containing the event info
  * \param nDelay The number of milliseconds to delay posting the event
  *
  * Use this function to effectively delay an event's posting to the internal queue for a specified
  * period of time, in milliseconds.  For application messages, specify 'None' for the Window ID
  * in the XEvent structure (otherwise specify the correct Window ID).
  * After the time delay, the event will be retrieved and returned via WBCheckGetEvent(), or WBNextEvent(), similar to a timer message.
  * If the window specified in the message is destroyed before the timeout, the message will be ignored.
  *
  * Header File:  window_helper.h
**/
void WBPostDelayedEvent(XEvent *pEvent, unsigned int nDelay);

/** \ingroup events
  * \brief Places a copy of the specified event at the end of the priority (internal) event queue
  *
  * \param pEvent A pointer to an XEvent structure containing the event info
  * \return A non-zero value on error, or zero if successful
  *
  * The preferred method of event processing between windows is to post them to one of the internal
  * event queues, rather than using XSendEvent or calling WBDispatch directly.\n
  * Use WBPostAppEvent for application events (where the window ID is 'None')
  *
  * Header File:  window_helper.h
**/
int WBPostAppEvent(XEvent *pEvent);

/** \ingroup events
  * \brief Creates a 'set focus' ClientMessage event for the application event handler
  *
  * \param pDisplay The Display pointer, or 'None' to use default
  * \param wID The Window ID of the window to be set active, raised, and mapped
  * \param wIDFrom The previous window that was active, or None
  * \param nDelay The delay in milliseconds before this action takes place (useful to prevent race conditions)
  *
  * Causes (reliable) 'Set Active' 'Set Input Focus' 'Raise Window' and 'Map Window' events to be
  * applied to a particular window.  In many cases window managers may differ in their handling
  * of things like 'XSetInputFocus' to set focus to a window.  By handling this in the application event
  * queue, it is possible to delay events asynchronously in a manner that avoids a race condition from
  * the window manager.  Clicking on a window, or using ALT+Tab, or switching desktops may cause unexpected
  * 'things' to take place.  By forcing the window to be ACTIVE and also using the normal 'XSetInputFocus'
  * function, as well as 'Raising' and mapping the window, THIS method is likely to work everywhere, and
  * in a consistent manner.
  *
  * Header File:  window_helper.h
**/
void WBPostDelayedSetFocusAppEvent(Display *pDisplay, Window wID, Window wIDFrom, unsigned int nDelay);

/** \ingroup events
  * \brief low-level event processing, internal handling of Expose events
  *
  * \param pEvent A pointer to an XExposeEvent structure for an Expose event
  *
  * Instead of passing Expose events directly along to the respective window, they are
  * first consolidated, and then re-prioritized for optimimum display performance.\n
  * Expose events typically come in bunches, and all too frequently.  By delaying their
  * processing, AND consolidating them into a single event, it is possible to minimize the
  * un-necessary re-drawing of windows and improve the 'apparent speed' of your applicatino.
  * Normally this is done within WBCheckGetEvent() automatically.  If you decide to implement
  * the message prioritization yourself, you can use this function to handle Expose events
  * for you, and correctly prioritize them.
  *
  * Header File:  window_helper.h
**/
void WBProcessExposeEvent(XExposeEvent *pEvent);  // paint optimization



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//            _   _  ___   _   _        _                                   //
//           | | | ||_ _| | | | |  ___ | | _ __    ___  _ __  ___           //
//           | | | | | |  | |_| | / _ \| || '_ \  / _ \| '__|/ __|          //
//           | |_| | | |  |  _  ||  __/| || |_) ||  __/| |   \__ \          //
//            \___/ |___| |_| |_| \___||_|| .__/  \___||_|   |___/          //
//                                        |_|                               //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


/** \ingroup events
  * \brief low-level event processing, internal handling of Expose events
  *
  * \param pDisplay The display for the mouse activity.  A value of NULL uses the default display, either for 'wID', or the system default if wID is 'None'.
  * \param wID The window to post the 'WB_POINTER_CANCEL' message to.  This window should have the input focus.  A value of 'None' indicates the window with the input focus.
  *
  * Call this function to effectively 'cancel' any operation involving the mouse.
  * This will un-do any 'drag' operations and send a WB_POINTER Client Message event
  * with the 'WB_POINTER_CANCEL', and optionally un-grab the mouse (and keyboard,
  * as needed).  In the case of a Modal operation, this may differ from normal
  * Asynchronous operations.  Additionally, if there are any mouse messages already
  * in the queue, this will not remove them.  It will be up to the caller to deal
  * with that.  This function ONLY fixes the status and capture of the mouse.
  *
  * Header File:  window_helper.h
**/
void WBMouseCancel(Display *pDisplay, Window wID);




///////////////////////////////////////////////////////////////
//    ____ _     ___ ____  ____   ___    _    ____  ____     //
//   / ___| |   |_ _|  _ \| __ ) / _ \  / \  |  _ \|  _ \    //
//  | |   | |    | || |_) |  _ \| | | |/ _ \ | |_) | | | |   //
//  | |___| |___ | ||  __/| |_) | |_| / ___ \|  _ <| |_| |   //
//   \____|_____|___|_|   |____/ \___/_/   \_\_| \_\____/    //
//                                                           //
///////////////////////////////////////////////////////////////

/** \ingroup clipboard
  * \brief Get clipboard data of requested type
  *
  * \param pDisplay the Display pointer for the selection (NULL for default)
  * \param paType Pointer to an atom indicating the requested data type ('None' for ANY), and returning the actual data type
  * \param piFormat pointer to the returned format (0, 8, 16, or 32)
  * \param pnData the size of the returned data (number of items, based on *piFormat)
  * \return a pointer to the actual data (must use 'WBFree()' to de-allocate the resource)
  *
  * This function will obtain the clipboard data associated with the specified data type, or
  * whichever data it finds first if 'None' is specified as 'paType'.  Some substitutions may occur,
  * such as 'XA_TEXT' vs 'UTF8' (for example), if data in the requested format is not available.
  * The returned value is a pointer to the actual data of size '*pnData' 'items' (which have a bit
  * length as specified by '*piFormat').  You must call 'WBFree()' to release the resource once you are done with it.
  *
  * Header File:  window_helper.h
**/
void * WBGetClipboardData(Display *pDisplay, Atom *paType, int *piFormat, unsigned long *pnData);

/** \ingroup clipboard
  * \brief Get clipboard data of requested type
  *
  * \param pDisplay the Display pointer for the selection (NULL for default)
  * \param aType an atom indicating the data type
  * \param iFormat the data format (0, 8, 16, or 32)
  * \param pData a pointer to the data to be assigned (can be NULL, indicating you want to clear it)
  * \param nData the size of the data (number of items, based on iFormat)
  * \return a value of zero on success, or non-zero on error
  *
  * This function assigns the clipboard data for the specified type ('aType') and format ('iFormat')
  * to the data specified by 'pData' and 'nData'.
  *
  * Header File:  window_helper.h
**/
int WBSetClipboardData(Display *pDisplay, Atom aType, int iFormat, const void *pData, unsigned long nData);


// lower level functions for 'Selections'

/** \ingroup clipboard
  * \brief Get clipboard data of requested type
  *
  * \param pDisplay the Display pointer for the selection (NULL for default)
  * \param aSelection an Atom for the 'selection' data to acquire (usually 'CLIPBOARD' or XA_PRIMARY)
  * \param paType Pointer to an atom indicating the requested data type ('None' for ANY), and returning the actual data type
  * \param piFormat pointer to the returned format (0, 8, 16, or 32)
  * \param pnData the size of the returned data (number of items, based on *piFormat)
  * \return a pointer to the actual data (must use 'WBFree()' to de-allocate the resource)
  *
  * This function will obtain the selection data associated with the target and specified data type, or
  * whichever data it finds first if 'None' is specified as 'paType'.  Some substitutions may occur,
  * such as 'XA_TEXT' vs 'UTF8' (for example), if data in the requested format is not available.
  * The returned value is a pointer to the actual data of size '*pnData' 'items' (which have a bit
  * length as specified by '*piFormat').  You must call 'WBFree()' to release the resource once you are done with it.
  *
  * Header File:  window_helper.h
**/
void * WBGetSelectionData(Display *pDisplay, Atom aSelection, Atom *paType, int *piFormat, unsigned long *pnData);


/** \ingroup clipboard
  * \brief Get clipboard data of requested type
  *
  * \param pDisplay the Display pointer for the selection (NULL for default)
  * \param aSelection an Atom for the 'selection' data to assign (usually 'CLIPBOARD' or XA_PRIMARY)
  * \param aType an atom indicating the data type
  * \param iFormat the data format (0, 8, 16, or 32)
  * \param pData a pointer to the data to be assigned (can be NULL, indicating you want to clear it)
  * \param nData the size of the data (number of items, based on iFormat)
  * \return a value of zero on success, or non-zero on error
  *
  * This function assigns the selection data for the specified target 'aSelection' and type ('aType') and
  * format ('iFormat') to the data specified by 'pData' and 'nData'.
  *
  * Header File:  window_helper.h
**/
int WBSetSelectionData(Display *pDisplay, Atom aSelection, Atom aType, int iFormat, const void *pData, unsigned long nData);




///////////////////////////////////////////////////////////////
//   _____ __  __ ____    ___   ____   _   _  ____   _____   //
//  | ____|\ \/ /|  _ \  / _ \ / ___| | | | ||  _ \ | ____|  //
//  |  _|   \  / | |_) || | | |\___ \ | | | || |_) ||  _|    //
//  | |___  /  \ |  __/ | |_| | ___) || |_| ||  _ < | |___   //
//  |_____|/_/\_\|_|     \___/ |____/  \___/ |_| \_\|_____|  //
//                                                           //
///////////////////////////////////////////////////////////////

/** \ingroup expose
  * \brief Wrapper for XMapWindow, makes window visible
  *
  * \param pDisplay A pointer to the Display
  * \param wID The Window ID for the window to map (i.e. make visible)
  * \return The return value from XMapWindow()
  *
  * Use this function when making a window visible, rather than XMapWindow
  * so that the internal state flags and other information can be updated.
  *
  * Header File:  window_helper.h
**/
int WBMapWindow(Display *pDisplay, Window wID);
/** \ingroup expose
  * \brief wrapper for XMapRaised, makes window visible and moves to top
  *
  * \param pDisplay A pointer to the Display
  * \param wID The Window ID for the window to map (i.e. make visible) and Raise (bring to the front)
  * \return The return value from XMapRaised()
  *
  * Use this function when 'raising' a window, rather than XMapRaised
  * so that the internal state flags and other information can be updated
  *
  * Header File:  window_helper.h
**/
int WBMapRaised(Display *pDisplay, Window wID);
/** \ingroup expose
  * \brief wrapper for XUnmapWindow, makes window invisible without destroying it
  *
  * \param pDisplay A pointer to the Display
  * \param wID The Window ID for the window to unmap (i.e. make INvisible)
  * \return The return value from XUnmapWindow()
  *
  * Use this function when making a window invisible, rather than XUnmapWindow
  * so that the internal state flags and other information can be updated
  *
  * Header File:  window_helper.h
**/
int WBUnmapWindow(Display *pDisplay, Window wID);

/** \ingroup expose
  * \brief Returns non-zero if window has been mapped; zero otherwise
  *
  * \param pDisplay A pointer to the Display
  * \param wID The Window ID for the window to check for visibility
  * \return A non-zero value if the window has been both registered and mapped (i.e. is visible), otherwise zero.
  *
  * This function only works for windows that have been registered with a callback
  * function.  It checks the internal flags to see if the window has been mapped,
  * and if it has, it returns a non-zero value.  It can be helpful to avoid unnecessary
  * signals from the X11 API.
  *
  * Header File:  window_helper.h
**/
int WBIsMapped(Display *pDisplay, Window wID);  // non-zero if mapped, zero otherwise
  // NOTE:  this only works for windows that have been registered with a callback


// paint helpers (working in conjunction with 'WBProcessExposeEvent')

/** \ingroup expose
  * \brief 'Paint' helper, invalidates a geometry for asynchronous Expose event generation
  *
  * \param wID The Window ID for the affected window
  * \param pGeom A pointer to a WB_GEOM structure specifying the invalid area, or NULL (implying the entire window)
  * \param bPaintFlag A non-zero value to force re-paint by generating an Expose message.  Zero simply invalidates the specified area
  *
  * In conjunction with WBProcessExposeEvent it adds a geometry to the 'invalid' region
  * associated with the window, and optionally generates an asynchronous expose event
  * if 'bPaintFlag' is non-zero.\n
  * For a zero 'bPaintFlag' the next Expose event will include this geometry as part of
  * its update region.
  *
  * Header File:  window_helper.h
**/
void WBInvalidateGeom(Window wID, const WB_GEOM *pGeom, int bPaintFlag);
/** \ingroup expose
  * \brief 'Paint' helper, invalidates a region for asynchronous Expose event generation
  *
  * \param wID The Window ID for the affected window
  * \param rgn A Region identifier specifying the invalid area, or None (implying the entire window)
  * \param bPaintFlag A non-zero value to force re-paint by generating an Expose message.  Zero simply invalidates the specified area
  *
  * In conjunction with WBProcessExposeEvent it adds a region to the 'invalid' region
  * associated with the window, and optionally generates an asynchronous expose event
  * if 'bPaintFlag' is non-zero.\n
  * For a zero 'bPaintFlag' the next Expose event will include this region as part of
  * its update region.
  *
  * Header File:  window_helper.h
**/
void WBInvalidateRegion(Window wID, Region rgn, int bPaintFlag);
/** \ingroup expose
  * \brief 'Paint' helper, validates a geometry for asynchronous Expose event generation
  *
  * \param wID The Window ID for the affected window
  * \param pGeom A pointer to a WB_GEOM structure specifying the valid area, or NULL (implying the entire window)
  *
  * In conjunction with WBProcessExposeEvent it removes a geometry from the 'invalid' region
  * associated with the window.  If the resulting 'invalid' region is empty, no subsequent
  * 'Expose' event will be generated, even if one had previously been in the queue, until
  * the next Expose event or 'invalid' region exists for this window.
  *
  * Header File:  window_helper.h
**/
void WBValidateGeom(Window wID, const WB_GEOM *pGeom);
/** \ingroup expose
  * \brief 'Paint' helper, validates a region for asynchronous Expose event generation
  *
  * \param wID The Window ID for the affected window
  * \param rgn A Region identifer specifying the valid area, or NULL (implying the entire window)
  *
  * In conjunction with WBProcessExposeEvent it removes a region from the 'invalid' region
  * associated with the window.  If the resulting 'invalid' region is empty, no subsequent
  * 'Expose' event will be generated, even if one had previously been in the queue, until
  * the next Expose event or 'invalid' region exists for this window.
  *
  * Header File:  window_helper.h
**/
void WBValidateRegion(Window wID, Region rgn);

/** \ingroup expose
  * \brief 'Paint' helper, returns a copy of the invalid region for a window
  *
  * \param wID Window ID
  * \return Copy of 'invalid region' for this window, or None.
  *
  * This function returns a copy of the current invalid region for the window, or None if the
  * window is up-to-date.  The caller must destroy the returned value using XDestroyRegion()
  *
  * Header File:  window_helper.h
**/
Region WBGetInvalidRegion(Window wID);

/** \ingroup expose
  * \brief 'Paint' helper, returns a copy of the current 'paint' region for the window
  *
  * \param wID Window ID
  * \return Copy of 'paint region' for this window, or None. not valid outside of BeginPaint() / EndPaint()
  *
  * This function returns a copy of the current paint region for the window, or None if the
  * window is up-to-date.  The caller must destroy the returned value using XDestroyRegion()\n
  * This function is not valid outside of WBBeginPaint() / WBEndPaint() processing, typically part
  * of an 'Expose' event handler.
  *
  * Header File:  window_helper.h
**/
Region WBGetPaintRegion(Window wID);

/** \ingroup expose
  * \brief 'Paint' helper, converts a WB_RECT structure to a Region.
  *
  * \param pRect A const pointer to the WB_RECT structure
  * \return A region that encompasses the area of the WB_RECT structure, or None on error
  *
  * This function converts a WB_RECT structure to a Region.
  * The caller must destroy the returned value using XDestroyRegion()
  *
  * Header File:  window_helper.h
**/
Region WBRectToRegion(const WB_RECT *pRect);

/** \ingroup expose
  * \brief 'Paint' helper, converts a WB_GEOM structure to a Region.
  *
  * \param pGeom A const pointer to the WB_GEOM structure
  * \return A region that encompasses the area of the WB_GEOM structure, or None on error
  *
  * This function converts a WB_GEOM structure to a Region.
  * The caller must destroy the returned value using XDestroyRegion()
  *
  * Header File:  window_helper.h
**/
Region WBGeomToRegion(const WB_GEOM *pGeom);

/** \ingroup expose
  * \brief Simple utility to copy a region
  *
  * \param rgnSource A source region to copy
  * \return A region that is a union of the source region with itself; i.e. a copy
  *
  * This function makes a simple copy of a region by doing a union with itself, returning the result.
  * The caller must destroy the returned value using XDestroyRegion()
  *
  * Header File:  window_helper.h
**/
Region WBCopyRegion(Region rgnSource);

/** \ingroup expose
  * \brief 'Paint' helper, generates an asynchronous Expose event for non-empty 'invalid' region
  *
  * Whenever the 'invalid' region is non-empty, you can generate an asynchronous Expose event
  * using this function.  This allows you to invalidate several geometries or regions during
  * normal processing, with the paint flag set to 'false', and then generate a single Expose
  * event after all of the processing has completed.
  *
  * Header File:  window_helper.h
**/
void WBUpdateWindow(Window wID);  // posts an expose event for the specified window

/** \ingroup expose
  * \brief 'Paint' helper, generates an immediate Expose event for non-empty 'invalid' region
  *
  * Whenever the 'invalid' region is non-empty, you can generate an immediate (synchronous)
  * Expose event using this function.  This is useful for a UI related event in which you need
  * to re-paint portions of a window immediately.\n
  * You should make sure that the Expose handler does not cause recursion, since it will be
  * called directly by this function.
  *
  * Header File:  window_helper.h
**/
void WBUpdateWindowImmediately(Window wID);  // sends expose event synchronously (can cause recursion)

/** \ingroup expose
  * \brief 'Paint' helper, creates a WBGC for use in updating the window in an Expose event handler
  *
  * \param wID Window ID associated with the Expose event
  * \param pEvent Pointer to the Expose event that's being processed
  * \param pgRet The returned bounding geometry for the invalid region being 'painted'
  * \return A WBGC (graphics context) to be used in handling the Expose event
  *
  * When processing Expose events, you should call WBBeginPaint to obtain the WBGC needed for all
  * of the operations needed to update (paint) the window.\n
  * This function collects all of the relevant invalid regions associated with the window that fall
  * within the 'Expose' event area, and calculates a bounding WB_GEOM rectangle for it.  It also applies
  * the invalid region as a 'clipping' region for the returned WBGC.  When you call WBEndPaint(), the
  * entire clipping region will be marked 'valid' automatically, so it is important for your 'paint'
  * function to update the entire WB_GEOM rectangle identified by pgRet.  This includes erasing the
  * background as well as drawing whatever is in the foreground.
  *
  * Header File:  window_helper.h
**/
WBGC WBBeginPaint(Window wID, XExposeEvent *pEvent, WB_GEOM *pgRet); // WBGC has invalid region assigned

/** \ingroup expose
  * \brief 'Paint' helper, creates a WBGC for use in updating the window for a specified rectangular area
  *
  * \param wID Window ID associated with the Expose event
  * \param pgBounds On entry, the bounding WB_GEOM for which to get a graphics context.  On return, the bounding WB_GEOM for the invalid region being 'painted'
  * \return A WBGC (graphics context) to be used in painting the specific rectangular region
  *
  * When processing Expose events, you should call WBBeginPaint() to obtain the WBGC needed for all
  * of the operations needed to update (paint) the window.\n
  * This particular function is more suited to updating a specific area outside of a normal Expose callback handler.
  * As an example, a frame window would use this to update the tab area or the status bar area, prior to calling the
  * user callback function.  That way, only the desired region will be 'validated' on call to WBEndPaint(), and
  * not the entire window client area.
  *
  * Header File:  window_helper.h
**/
WBGC WBBeginPaintGeom(Window wID, WB_GEOM *pgBounds); // WBGC has invalid region assigned

/** \ingroup expose
  * \brief 'Paint' helper, frees resources and marks the update region 'valid'
  *
  * \param wID Window ID associated with the Expose event and passed to WBBeginPaint()
  * \param gc The WBGC (graphics context) returned by WBBeginPaint()
  *
  * Call this function, following a call to WBBeginPaint(), once the invalid area of the window
  * has been properly rendered.  It will free resources and mark the invalid (update) region as 'valid'.
  *
  * Additionally, if a cached XImage is being used for this window, the display will be updated
  * using the cached image during the call to this function.
  *
  * Header File:  window_helper.h
  *
  * \sa WBBeginPaint() WBAssignWindowImage()
**/
void WBEndPaint(Window wID, WBGC gc);  // frees the 'paint WBGC' and also resets the invalid region

/** \ingroup expose
  * \brief 'Paint' helper, erases background by painting the background color within the clipping region
  *
  * \param wID Window ID associated with the Expose event
  * \param gc The WBGC (graphics context) returned by WBBeginPaint().
  *
  * Call this function, following a call to WBBeginPaint(), if you want to erase the
  * background of the window.  Call this in lieu of XClearWindow() or XClearArea()
  *
  * Header File:  window_helper.h
**/
void WBClearWindow(Window wID, WBGC gc);


// RECT versions (as inline)

/** \ingroup expose
  * \brief 'Paint' helper, invalidates a WB_RECT for asynchronous Expose event generation
  *
  * \param wID The Window ID for the affected window
  * \param pRCT A const pointer to a WB_RECT structure specifying the invalid area, or NULL (implying the entire window)
  * \param bPaintFlag A non-zero value to force re-paint by generating an Expose message.  Zero simply invalidates the specified area
  *
  * In conjunction with WBProcessExposeEvent it adds a rectangle to the 'invalid' region
  * associated with the window, and optionally generates an asynchronous expose event
  * if 'bPaintFlag' is non-zero.\n
  * For a zero 'bPaintFlag' the next Expose event will include this geometry as part of
  * its update region.
  *
  * Header File:  window_helper.h
**/
static __inline__ void WBInvalidateRect(Window wID, const WB_RECT *pRCT, int bPaintFlag)
{
  WB_GEOM geom;

  if(!pRCT)
  {
    WBInvalidateGeom(wID, NULL, bPaintFlag);
    return;
  }

  geom.x      = pRCT->left;
  geom.y      = pRCT->top;
  geom.width  = pRCT->right - pRCT->left;
  geom.height = pRCT->bottom - pRCT->top;
  geom.border = 0;

  WBInvalidateGeom(wID, &geom, bPaintFlag);
}

/** \ingroup expose
  * \brief 'Paint' helper, validates a WB_RECT for asynchronous Expose event generation
  *
  * \param wID The Window ID for the affected window
  * \param pRCT A const pointer to a WB_RECT structure specifying the valid area, or NULL (implying the entire window)
  *
  * In conjunction with WBProcessExposeEvent it removes a rectangle from the 'invalid' region
  * associated with the window.  If the resulting 'invalid' region is empty, no subsequent
  * 'Expose' event will be generated, even if one had previously been in the queue, until
  * the next Expose event or 'invalid' region exists for this window.
  *
  * Header File:  window_helper.h
**/
static __inline__ void WBValidateRect(Window wID, WB_RECT *pRCT)
{
  WB_GEOM geom;

  if(!pRCT)
  {
    WBValidateGeom(wID, NULL);
    return;
  }

  geom.x      = pRCT->left;
  geom.y      = pRCT->top;
  geom.width  = pRCT->right - pRCT->left;
  geom.height = pRCT->bottom - pRCT->top;
  geom.border = 0;

  WBValidateGeom(wID, &geom);
}



/////////////////////////////////////////////////////////////////////////////////////////////////
//    ____                     _      _               ____               _               _     //
//   / ___| _ __  __ _  _ __  | |__  (_)  ___  ___   / ___| ___   _ __  | |_  ___ __  __| |_   //
//  | |  _ | '__|/ _` || '_ \ | '_ \ | | / __|/ __| | |    / _ \ | '_ \ | __|/ _ \\ \/ /| __|  //
//  | |_| || |  | (_| || |_) || | | || || (__ \__ \ | |___| (_) || | | || |_|  __/ >  < | |_   //
//   \____||_|   \__,_|| .__/ |_| |_||_| \___||___/  \____|\___/ |_| |_| \__|\___|/_/\_\ \__|  //
//                     |_|                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////

/** \ingroup graphics
  * \brief Creates a WBGC, wrapper for XCreateGC()
  *
  * \param pDisplay A pointer to the Display, or NULL to use the default Display
  * \param Drawable dw The Drawable for which to create the WBGC
  * \param valuemask A bitwise mask of values to assign to the new WBGC from 'values'
  * \param values A pointer to an XGCValues structure describing values to be assigned (may be NULL)
  * \return A copy of the new WBGC
  *
  * Header File:  window_helper.h
**/
WBGC WBCreateGC(Display *pDisplay, Drawable dw, unsigned long valuemask,
                const XGCValues *values);

/** \ingroup graphics
  * \brief Change a WBGC, a wrapper for XChangeGC()
  *
  * \param hGC The WBGC which is to be modified
  * \param valuemask A bitwise mask of values to assign to the new WBGC from 'values'
  * \param values A pointer to an XGCValues structure describing values to be assigned (may be NULL)
  * \return An integer indicating success or fail
  *
  * Header File:  window_helper.h
**/
int WBChangeGC(WBGC hGC, unsigned long valuemask,
               const XGCValues *values);

/** \ingroup graphics
  * \brief Change a WBGC, a wrapper for XGetGCValues()
  *
  * \param hGC The WBGC which is to be queried
  * \param valuemask A bitwise mask of values to assign to the new WBGC from 'values'
  * \param values A pointer to an XGCValues structure describing values to be assigned (may be NULL)
  * \returns A Status indicating success or fail
  *
  * Header File:  window_helper.h
**/
Status WBGetGCValues(WBGC hGC, unsigned long valuemask,
                     XGCValues *values);

/** \ingroup graphics
  * \brief return the WB_FONTC object that was assigned to a WBGC
  *
  * \param gc The WBGC to be queried
  * \returns A pointer to a WB_FONTC object, or NULL on error.
  *
  * Call this function to determine the font that has been assigned to a WBGC.  If
  * there has been NO font assigned, the system default font information will be
  * returned.  A value of NULL is returned on error, or if no font is assigned.
  *
  * Header File:  window_helper.h
**/
WB_FONTC WBQueryGCFont(WBGC gc);

/** \ingroup graphics
  * \brief return a copy of the WB_FONT object that was assigned to a WBGC
  *
  * \param pDisplay A pointer to the Display
  * \param gc The WBGC to be queried
  * \returns A pointer to a WB_FONT object, or NULL on error.  non-NULL values must be freed via WBFreeFont()
  *
  * Call this function to determine the font that has been assigned to a WBGC.  If
  * there has been NO font assigned, the system default font information will be
  * returned.  The return value is always a new pointer to a WB_FONT, or
  * NULL on error.  The caller must free non-NULL return values via WBFreeFont().
  *
  * Header File:  window_helper.h
**/
WB_FONT WBGetGCFont(Display *pDisplay, WBGC gc);

/** \ingroup graphics
  * \brief makes a copy of a WBGC, a more sensible wrapper for XCopyGC()
  *
  * \param hGCOrig The WBGC which is to be copied
  * \return A copy of the original WBGC
  *
  * Header File:  window_helper.h
**/
WBGC WBCopyGC(WBGC hGCOrig);

/** \ingroup graphics
  * \brief makes a copy of a WBGC, a wrapper for XCopyGC()
  *
  * \param hGCOrig The WBGC which is to be copied
  * \param unsigned long valuemask A bitwise mask of values to assign to the new WBGC from the original
  * \param hGCDest The destination WBGC to copy to
  * \return An integer indicating success or fail
  *
  * Header File:  window_helper.h
**/
int WBCopyGC2(WBGC hGCOrig, unsigned long valuemask, WBGC hGCDest);

/** \ingroup graphics
  * \brief makes a copy of the specified WBGC for the desired 'Drawable'
  *
  * \param pDisplay A pointer to the 'Display' for the drawable.  NULL implies the default display.
  * \param dw The 'Drawable' for which to copy the original WBGC (NULL/None uses the 'default' window)
  * \param hGCOrig The source 'WBGC'
  * \return A copy of the WBGC for the specified 'Drawable'
  *
  * Makes a copy of the specified WBGC.  Useful if you want to make temporary modifications to a WBGC
  * for a particular drawing operation, but don't want to actually modify the original WBGC.
  *
  * Header File:  window_helper.h
**/
WBGC WBCopyDrawableGC(Display *pDisplay, Drawable dw, WBGC hGCOrig);

/** \ingroup graphics
  * \brief Free resources for a WBGC, wrapper for XFreeGC()
  *
  * \param hGC The WBGC which is to be freed
  *
  * Header File:  window_helper.h
**/
void WBFreeGC(WBGC hGC);

/** \ingroup graphics
  * \brief Free resources for a WBGC, wrapper for XFreeGC()
  *
  * \param hGC The WBGC which is to be freed
  * \returns a GContext indicating the saved graphics context associated with the WBGC
  *
  * Header File:  window_helper.h
**/
GContext WBGContextFromGC(WBGC hGC);

/** \ingroup graphics
  * \brief Assign clipping region, wrapper for XSetRegion()
  *
  * \param hGC The WBGC to assign a clipping Region to
  * \param rgnClip The clipping region to assign to the WBGC
  * \returns an integer indicating success or fail
  *
  * Header File:  window_helper.h
**/
int WBSetRegion(WBGC hGC, Region rgnClip);

/** \ingroup graphics
  * \brief Set clip origin, a wrapper for XSetClipOrigin()
  *
  * \param hGC The WBGC to assign a clipping Region to
  * \param clip_x_origin The 'x' clipping origin
  * \param clip_y_origin The 'y' clipping origin
  * \returns an integer indicating success or fail
  *
  * Header File:  window_helper.h
**/
int WBSetClipOrigin(WBGC hGC, int clip_x_origin, int clip_y_origin);

/** \ingroup graphics
  * \brief Set clip mask, a wrapper for XSetClipMask()
  *
  * \param hGC The WBGC to assign a clipping Region to
  * \param pixmap A pixmap containing the clipping mask
  * \returns an integer indicating success or fail
  *
  * Header File:  window_helper.h
**/
int WBSetClipMask(WBGC hGC, Pixmap pixmap);

/** \ingroup graphics
  * \brief Set the 'function' for the WBGC, a wrapper for XSetFunction()
  *
  * \param hGC The WBGC to assign a clipping Region to
  * \param function The 'function' for the GC - for more information, see XSetFunction()
  * \returns an integer indicating success or fail
  *
  * Header File:  window_helper.h
**/
int WBSetFunction(WBGC hGC, int function);

/** \ingroup graphics
  * \brief Assign foreground color, a wrapper for XSetForeground()
  *
  * \param hGC The WBGC to assign a clipping Region to
  * \param foreground The foreground color
  * \returns an integer indicating success or fail
  *
  * Header File:  window_helper.h
**/
int WBSetForeground(WBGC hGC, unsigned long foreground);

/** \ingroup graphics
  * \brief Assign background color, a wrapper for XSetForeground()
  *
  * \param hGC The WBGC to assign a clipping Region to
  * \param background The background color
  * \returns an integer indicating success or fail
  *
  * Header File:  window_helper.h
**/
int WBSetBackground(WBGC hGC, unsigned long background);

/** \ingroup graphics
  * \brief Assign font to a WBGC, a wrapper for XSetFont()
  *
  * \param hGC The WBGC to assign a clipping Region to
  * \param pFont The WB_FONTC to assign to the WBGC (makes a copy of it)
  * \returns an integer indicating success or fail
  *
  * Header File:  window_helper.h
**/
int WBSetFont(WBGC hGC, WB_FONTC pFont);

/** \ingroup graphics
  * \brief Assign font to a WBGC, a wrapper for XSetFont()
  *
  * \param hGC The WBGC to assign a clipping Region to
  * \param pFont The WB_FONT to assign to the WBGC directly without copying
  * \returns an integer indicating success or fail
  *
  * The assigned WB_FONT will be stored directly into the WBGC and not copied first.
  * This means that the WBGC will 'take ownership' of the WB_FONT immediately after making this
  * call. The caller must ensure that it is safe for the WBGC object to own such a WB_FONT.
  *
  * Header File:  window_helper.h
**/
int WBSetFontNoCopy(WBGC hGC, WB_FONT pFont);

/** \ingroup graphics
  * \brief Assign font to a WBGC, a wrapper for XSetLineAttributes()
  *
  * \param hGC The WBGC to assign a clipping Region to
  * \param line_width The line width, in pixels
  * \param line_style The line style - see XSetLineAttributes()
  * \param cap_style The cap style - see XSetLineAttributes()
  * \param join_style The join style - see XSetLineAttributes()
  * \returns an integer indicating success or fail
  *
  * Header File:  window_helper.h
**/
int WBSetLineAttributes(WBGC hGC, unsigned int line_width,
                        int line_style, int cap_style, int join_style);

/** \ingroup graphics
  * \brief Assign font to a WBGC, a wrapper for XSetFont()
  *
  * \param hGC The WBGC to assign a clipping Region to
  * \param dash_offset The 'dash offset' for creating dashes
  * \param dash_list An array of 'char' values containing the dash info
  * \param n The number of entries in 'dash_list'
  * \returns an integer indicating success or fail
  *
  * Header File:  window_helper.h
**/
int WBSetDashes(WBGC hGC, int dash_offset, const char dash_list[], int n);



/////////////////////////////////////////////////////////////////////
//   ___                               ____           _            //
//  |_ _|_ __ ___   __ _  __ _  ___   / ___|__ _  ___| |__   ___   //
//   | || '_ ` _ \ / _` |/ _` |/ _ \ | |   / _` |/ __| '_ \ / _ \  //
//   | || | | | | | (_| | (_| |  __/ | |__| (_| | (__| | | |  __/  //
//  |___|_| |_| |_|\__,_|\__, |\___|  \____\__,_|\___|_| |_|\___|  //
//                       |___/                                     //
//                                                                 //
/////////////////////////////////////////////////////////////////////


/** \ingroup expose
  * \brief Obtain an XImage for the entire window
  *
  * \param pDisplay The display associated with the specified window
  * \param wID The window that receives the \ref aWB_TIMER XClientEvent (None == application)
  * \return A pointer to an XImage, or NULL on error
  *
  * Returns the cached XImage for the window.  If none exists, one will be created
  * and stored within the internal stuctures for the window.  Actual changes to the image
  * will not be reflected on the display until you call WBUpdateWindowWithImage().
  *
  * NOTE:  You should not destroy nor cache the XImage pointer returned by this function.  It is owned by the window's internal structures.
  *
  * Whenever graphics operations make use of the cached image, an implicit call to WBUpdateWindowWithImage()
  * will be made within the call to WBEndPaint().
  *
  * Header File:  window_helper.h
  *
  * \sa WBBeginPaint() WBEndPaint()
**/
XImage *WBGetWindowImage(Display *pDisplay, Window wID);

/** \ingroup expose
  * \brief Assign an XImage for the entire window
  *
  * \param pDisplay The display associated with the specified window
  * \param wID The window that receives the \ref aWB_TIMER XClientEvent (None == application)
  * \param pImage The XImage to assign to the window's internal information.  On success, after the function call, this pointer is 'owned' by the window and should not be destroyed.
  * \returns A value of zero on success.  A non-zero value indicates an error.
  *
  * Calling this function assigns a new cached XImage as 'backing store' for the window.  It must be large enough to include the entire window's display area.
  * On success, the assigned image will replace any existing image.  Assigning a value of 'NULL' deletes any existing cached image.
  * If an image is too small, the function call will fail, and ownership of the XImage remains as-is.
  * Your call to this function needs to check for errors so that any resources can be properly cleaned up, as the XImage will not be owned nor destroyed.
  *
  * Whenever graphics operations make use of the cached image, an implicit call to WBUpdateWindowWithImage()
  * will be made within the call to WBEndPaint().
  *
  * Header File:  window_helper.h
  *
  * \sa WBBeginPaint() WBEndPaint()
**/
int WBAssignWindowImage(Display *pDisplay, Window wID, XImage *pImage);

/** \ingroup expose
  * \brief Copy an XImage into the cached XImage for the entire window
  *
  * \param pDisplay The display associated with the specified window
  * \param wID The window that receives the \ref aWB_TIMER XClientEvent (None == application)
  * \param pImage The XImage to copy into the cached XImage for the window.  Must be a pointer to a valid XImage. The specified XImage will not be changed, owned, nor destroyed.
  * \param xSrc The 'x' offset within the source XImage to begin copying from
  * \param ySrc The 'y' offset within the source XImage to begin copying from
  * \param width The width within the source XImage to copy from.  a value of '-1' copies as much as possible to the destination image
  * \param height The height within the source XImage to copy from.  a value of '-1' copies as much as possible to the destination image
  * \param xDst The 'x' offset within the window's cached XImage to begin copying to
  * \param yDst The 'y' offset within the window's cached XImage to begin copying to
  * \returns A value of zero on success.  A non-zero value indicates an error.
  *
  * Calling this function copies the specified XImage's data into the cached image of the window.  If the window does not already have a cached
  * image, one will be created that containing the window's visible display data.
  * On success, the assigned image will replace that portion of the existing image as specified by the source offset, source size, and destination offset.
  * Images that are too large to fit into the destination will be limited within the appropriate dimensions, based on the destination image size.
  *
  * Whenever graphics operations make use of the cached image, an implicit call to WBUpdateWindowWithImage()
  * will be made within the call to WBEndPaint().
  *
  * Header File:  window_helper.h
  *
  * \sa WBBeginPaint() WBEndPaint()
**/
int WBCopyIntoWindowImage(Display *pDisplay, Window wID, XImage *pSrcImage,
                          int xSrc, int ySrc, int width, int height,
                          int xOffs, int yOffs);

/** \ingroup expose
  * \brief Update the window's appearance with the contents of the cached XImage
  *
  * \param pDisplay The display associated with the specified window
  * \param wID The window that receives the \ref aWB_TIMER XClientEvent (None == application)
  *
  * Calling this function will update the window's display area with the contents of the cached image.
  * If there is no cached image, this function will have no effect.
  *
  * Whenever graphics operations make use of the cached image, an implicit call to WBUpdateWindowWithImage()
  * will be made within the call to WBEndPaint().
  *
  * Header File:  window_helper.h
  *
  * \sa WBBeginPaint() WBEndPaint()
**/
void WBUpdateWindowWithImage(Display *pDisplay, Window wID);



////////////////////////////////////////////////////////////////////////////////////////////////
//    ____                     _      _              _   _        _                           //
//   / ___| _ __  __ _  _ __  | |__  (_)  ___  ___  | | | |  ___ | | _ __    ___  _ __  ___   //
//  | |  _ | '__|/ _` || '_ \ | '_ \ | | / __|/ __| | |_| | / _ \| || '_ \  / _ \| '__|/ __|  //
//  | |_| || |  | (_| || |_) || | | || || (__ \__ \ |  _  ||  __/| || |_) ||  __/| |   \__ \  //
//   \____||_|   \__,_|| .__/ |_| |_||_| \___||___/ |_| |_| \___||_|| .__/  \___||_|   |___/  //
//                     |_|                                          |_|                       //
//                                                                                            //
//  Wrapper functions for X11 'primitive' operations that can use a window's cached XImage    //
//                                                                                            //
////////////////////////////////////////////////////////////////////////////////////////////////


/** \ingroup expose
  * \brief Wrapper for XDrawPoint()
  *
  * \param pDisplay The display associated with the specified window
  * \param d The Drawable (or window) I'm painting.  If a window, this may use the XImage cache
  * \param gc The Graphics context of the operation
  * \param x The origin 'x' coordinate of the line
  * \param y The origin 'y' coordinate of the line
  * \returns An integer indicating success or failure
  *
  * This function draws a point, similar to XDrawPoint(), on the specified Drawable,
  * with the specified graphics context indicating foreground and background colors.
  *
  * Header File:  window_helper.h
  *
**/

int WBDrawPoint(Display *display, Drawable d, WBGC gc, int x, int y);


/** \ingroup expose
  * \brief Wrapper for XDrawPoints()
  *
  * \param pDisplay The display associated with the specified window
  * \param d The Drawable (or window) I'm painting.  If a window, this may use the XImage cache
  * \param gc The Graphics context of the operation
  * \param points A pointer to an array of XPoint structures describing the line vertices
  * \param npoints The number of entries in the 'points' array
  * \param mode A constant indicating the coordinate mode, either CoordModeOrigin or CoordModePrevious - see XDrawLines().
  * \returns An integer indicating success or failure
  *
  * This function draws one or more points, similar to XDrawPoints(), on the specified Drawable,
  * with the specified graphics context indicating foreground and background colors.
  *
  * Header File:  window_helper.h
  *
**/

int WBDrawPoints(Display *display, Drawable d, WBGC gc, XPoint *points,
                 int npoints, int mode);


/** \ingroup expose
  * \brief Wrapper for XDrawLines()
  *
  * \param pDisplay The display associated with the specified window
  * \param d The Drawable (or window) I'm painting.  If a window, this may use the XImage cache
  * \param gc The Graphics context of the operation
  * \param x1 The origin 'x' coordinate of the line
  * \param y1 The origin 'y' coordinate of the line
  * \param x2 The final 'x' coordinate of the line
  * \param y2 The final 'y' coordinate of the line
  * \returns An integer indicating success or failure
  *
  * This function draws a line, similar to XDrawLines(), on the specified Drawable,
  * with the specified graphics context indicating foreground and background colors.
  *
  * Header File:  window_helper.h
  *
**/

int WBDrawLine(Display *display, Drawable d, WBGC gc,
               int x1, int y1, int x2, int y2);


/** \ingroup expose
  * \brief Wrapper for XDrawLine()
  *
  * \param pDisplay The display associated with the specified window
  * \param d The Drawable (or window) I'm painting.  If a window, this may use the XImage cache
  * \param gc The Graphics context of the operation
  * \param points A pointer to an array of XPoint structures describing the line vertices
  * \param npoints The number of entries in the 'points' array
  * \param mode A constant indicating the coordinate mode, either CoordModeOrigin or CoordModePrevious - see XDrawLines().
  * \returns An integer indicating success or failure
  *
  * This function draws one or more lines, similar to XDrawLines(), on the specified Drawable,
  * with the specified graphics context indicating foreground and background colors.
  *
  * Header File:  window_helper.h
  *
**/

int WBDrawLines(Display *display, Drawable d, WBGC gc, XPoint *points,
                int npoints, int mode);


/** \ingroup expose
  * \brief Wrapper for XDrawRectangle()
  *
  * \param pDisplay The display associated with the specified window
  * \param d The Drawable (or window) I'm painting.  If a window, this may use the XImage cache
  * \param gc The Graphics context of the operation
  * \param x The origin x of the operation
  * \param y The origin y of the operation
  * \param width The width of the rectangle
  * \param height The height of the rectangle
  * \returns An integer indicating success or failure
  *
  * This function draws a rectangle, similar to XDrawRectangle(), on the specified Drawable,
  * with the specified graphics context indicating foreground and background colors.
  *
  * Header File:  window_helper.h
  *
**/

int WBDrawRectangle(Display *display, Drawable d, WBGC gc, int x, int y,
                    unsigned int width, unsigned int height);


/** \ingroup expose
  * \brief Wrapper for XFillRectangle()
  *
  * \param pDisplay The display associated with the specified window
  * \param d The Drawable (or window) I'm painting.  If a window, this may use the XImage cache
  * \param gc The Graphics context of the operation
  * \param x The origin x of the operation
  * \param y The origin y of the operation
  * \param width The width of the rectangle
  * \param height The height of the rectangle
  * \returns An integer indicating success or failure
  *
  * This function draws a filled rectangle, similar to XFillRectangle(), on the specified Drawable,
  * with the specified graphics context indicating foreground, fill, and background colors.
  *
  * Header File:  window_helper.h
  *
**/

int WBFillRectangle(Display *display, Drawable d, WBGC gc, int x, int y,
                    unsigned int width, unsigned int height);


/** \ingroup expose
  * \brief Wrapper for XDrawArc()
  *
  * \param pDisplay The display associated with the specified window
  * \param d The Drawable (or window) I'm painting.  If a window, this may use the XImage cache
  * \param gc The Graphics context of the operation
  * \param x The origin x of the operation
  * \param y The origin y of the operation
  * \param width The width of the arc's elipse
  * \param height The height of the arc's elipse
  * \param angle1 The starting angle of the arc
  * \param angle2 The ending angle of the arc
  * \returns An integer indicating success or failure
  *
  * This function draws an arc, similar to XDrawArc(), on the specified Drawable,
  * with the specified graphics context indicating foreground and background colors.
  *
  * Header File:  window_helper.h
  *
**/

int WBDrawArc(Display *display, Drawable d, WBGC gc, int x, int y,
              unsigned int width, unsigned int height,
              int angle1, int angle2);


/** \ingroup expose
  * \brief Wrapper for XFillArc()
  *
  * \param pDisplay The display associated with the specified window
  * \param d The Drawable (or window) I'm painting.  If a window, this may use the XImage cache
  * \param gc The Graphics context of the operation
  * \param x The origin x of the operation
  * \param y The origin y of the operation
  * \param width The width of the arc's elipse
  * \param height The height of the arc's elipse
  * \param angle1 The starting angle of the arc
  * \param angle2 The ending angle of the arc
  * \returns An integer indicating success or failure
  *
  * This function draws a filled arc, similar to XFillArc(), on the specified Drawable,
  * with the specified graphics context indicating foreground, fill, and background colors.
  *
  * Header File:  window_helper.h
  *
**/

int WBFillArc(Display *display, Drawable d, WBGC gc, int x, int y,
              unsigned int width, unsigned int height,
              int angle1, int angle2);


/** \ingroup expose
  * \brief Wrapper for XFillPolygon()
  *
  * \param pDisplay The display associated with the specified window
  * \param d The Drawable (or window) I'm painting.  If a window, this may use the XImage cache
  * \param gc The Graphics context of the operation
  * \param points A pointer to an array of XPoint structures describing the polygon line vertices
  * \param npoints The number of entries in the 'points' array
  * \param shape A constant indicating the general shape, either Convex, Nonconvex, or Complex - see XFillPolygon()
  * \param mode A constant indicating the coordinate mode, either CoordModeOrigin or CoordModePrevious - see XFillPolygon().
  * \returns An integer indicating success or failure
  *
  * This function draws a filled polygon, similar to XFillPolygon(), on the specified Drawable,
  * with the specified graphics context indicating foreground, fill, and background colors.
  *
  * Header File:  window_helper.h
  *
**/

int WBFillPolygon(Display *display, Drawable d, WBGC gc, XPoint *points,
                  int npoints, int shape, int mode);


/** \ingroup expose
  * \brief wrapper for XDrawString()
  *
  * \param pDisplay A pointer to the display to use for rendering the text
  * \param d The 'Drawable' object upon which to render the text
  * \param gc The graphics context 'WBGC' for rendering the text
  * \param x The 'x' coordinate for the text alignment (left)
  * \param y The 'y' coordinate for the text alignment (bottom)
  * \param string A const pointer to a UTF-8 or multi-byte string
  * \param length The BYTE LENGTH of the UTF-8 or mult-byte string (not character length)
  * \returns An integer indicating success or failure
  *
  * Use this function in lieu of XDrawString() to draw text in a platform-independent manner,
  * using the specified font, upon the specified 'Drawable'.  This function is the equivalent
  * of the X11 library's XDrawString().  Internally, it calls DTDrawString().
  *
  * Header File:  draw_text.h
**/

int WBDrawString(Display *display, Drawable d, WBGC gc, int x, int y,
                 const char *string, int length);



/////////////////////////////////////////////////
//   _____  ___  __  __  _____  ____   ____    //
//  |_   _||_ _||  \/  || ____||  _ \ / ___|   //
//    | |   | | | |\/| ||  _|  | |_) |\___ \   //
//    | |   | | | |  | || |___ |  _ <  ___) |  //
//    |_|  |___||_|  |_||_____||_| \_\|____/   //
//                                             //
/////////////////////////////////////////////////

/** \ingroup timer
  * \brief Creates a one-shot or periodic timer
  *
  * \param pDisplay The display associated with the specified window
  * \param wID The window that receives the \ref aWB_TIMER XClientEvent (None == application)
  * \param lInterval The timer interval in microseconds
  * \param lID The unique timer identifier
  * \param iPeriodic Non-zero for a recurring timer, zero for a 'one-shot' timer.
  * \return Non-zero on error, zero on success.
  *
  * Timers can either be periodic (recurring), or one-shot.  Use this function to create them.
  * A timer created by this function must be subsequently deleted via \ref DeleteTimer()
  *
  * Header File:  window_helper.h
  *
  * \sa aWB_TIMER
**/
int CreateTimer(Display *pDisplay, Window wID, unsigned long lInterval, long lID, int iPeriodic);
  // NOTE:  'iPeriodic' non-zero for periodic, zero for one-shot.  'lInterval' is in microseconds
  //        Assign 'lID' to a unique value for the specified pDisplay and wID

/** \ingroup timer
  * \brief Deletes an existing timer's resources
  *
  * \param pDisplay The display associated with the specified window
  * \param wID The window associated with the timer
  * \param lID The unique ID associated with the timer
  *
  * Timers created via CreateTimer() must be subsequently deleted using this function by passing
  * the same Display, Window, and Timer 'unique' ID that were used to create it.
  *
  * Header File:  window_helper.h
  *
  * \sa aWB_TIMER
**/
void DeleteTimer(Display *pDisplay, Window wID, long lID);  // deletes entry with matching Display, Window, ID



// ****************************************************
//
//            E R R O R   H A N D L I N G
//
// ****************************************************

/** \struct __WB_ERROR_INFO__
  * \ingroup error
  * \copydoc WB_ERROR_INFO
**/
/** \typedef WB_ERROR_INFO
  * \ingroup error
  * \brief Structure definition for X11 error information
  *
  * \code

  typedef struct __WB_ERROR_INFO__
  {
    Display *pDisplay;     // Display pointer passed into error handler function (NULL if no error)
    const char *pFunc;     // Name of the function as assigned by BEGIN_XCALL_DEBUG_WRAPPER
    int iLine;             // Line number of the function as assigned by BEGIN_XCALL_DEBUG_WRAPPER
    unsigned long serial;  // serial number from XErrorEvent
    int error_code;        // error code from XErrorEvent
    int request_code;      // request code from XErrorEvent
    int minor_code;        // minor code from XErrorEvent
    XID resourceid;        // resource ID (usually a Window) from XErrorEvent
  } WB_ERROR_INFO;

  * \endcode
**/
typedef struct __WB_ERROR_INFO__
{
  Display *pDisplay;     ///< Display pointer passed into error handler function (NULL if no error)
  const char *pFunc;     ///< Name of the function as assigned by BEGIN_XCALL_DEBUG_WRAPPER
  int iLine;             ///< Line number of the function as assigned by BEGIN_XCALL_DEBUG_WRAPPER
  unsigned long serial;  ///< serial number from XErrorEvent
  int error_code;        ///< error code from XErrorEvent
  int request_code;      ///< request code from XErrorEvent
  int minor_code;        ///< minor code from XErrorEvent
  XID resourceid;        ///< resource ID (usually a Window) from XErrorEvent
} WB_ERROR_INFO;



/** \ingroup error
  * \brief Supress X11 XErrorEvent output to stderr
  *
  * Call this function to increment the error output supression counter.  Error output
  * will be restored whenever the supression counter returns to zero.  Each call to
  * this function should be balanced with a call to WBAllowErrorOutput().
  *
  * Header File:  window_helper.h
**/
static __inline__ void WBSupressErrorOutput(void)
{
extern int bIgnoreXErrors;

  // TODO:  serialize this with a mutex or other sync object?
  bIgnoreXErrors++;
}

/** \ingroup error
  * \brief Restore X11 XErrorEvent output to stderr
  *
  * Call this function to decrement the error output supression counter.  Error output
  * will be restored whenever the supression counter returns to zero.  Each call to the
  * WBSupressErrorOutput() function should be balanced with a call to this function.
  *
  * Header File:  window_helper.h
**/
static __inline__ void WBAllowErrorOutput(void)
{
extern int bIgnoreXErrors;

  // TODO:  serialize this with a mutex or other sync object?
  if(bIgnoreXErrors > 0)
  {
    bIgnoreXErrors--;
  }
  else
  {
    bIgnoreXErrors = 0;
  }
}


/** \ingroup error
  * \brief Clear the 'last error' information obtained via WBGetLastError()
  *
  * Header File:  window_helper.h
**/
void WBErrorClear(void);

/** \ingroup error
  * \brief Check to see whether or not an X11 error was detected.
  *
  * \return A non-zero value if an error was stored in the internal WB_ERROR_INFO structure, else zero
  *
  * Call this function to check to see if an XErrorEvent has been processed and stored in the internal
  * WB_ERROR_INFO structure.  It is necessary to FIRST call WBErrorClear() before any operation that
  * might result in an error that can THEN be checked for using this function.
  *
  * Header File:  window_helper.h
**/
int WBErrorCheck(void);

/** \ingroup error
  * \brief Check to see whether or not an X11 error was detected AND can be re-tried.
  *
  * \return A non-zero value if a retryable error was stored in the internal WB_ERROR_INFO structure, else zero
  *
  * Call this function to check to see if an XErrorEvent has been processed and stored in the internal
  * WB_ERROR_INFO structure, and if a retry is possible based on the type and condition of the error.
  * It is necessary to FIRST call WBErrorClear() before any operation that might result in an error
  * that can THEN be checked for retryability using this function.
  *
  * Header File:  window_helper.h
**/
int WBErrorCheckRetry(void);

/** \ingroup error
  * \brief Obtain a const pointer to the internal WB_ERROR_INFO structure
  *
  * \return A const pointer to the internal WB_ERROR_INFO structure
  *
  * Call this function to obtain details about the last error from the XErrorEvent passed to the error
  * handler.  If there has been no error event, the 'pDisplay' member will always be NULL.  You should
  * always call WBErrorClear() to clear out this structure before performing an operation that might
  * result in an XErrorEvent.
  *
  * Header File:  window_helper.h
**/
const WB_ERROR_INFO * WBGetLastError(void);



#ifdef __cplusplus
};
#endif // __cplusplus

#endif // WINDOW_HELPER_H_INCLUDED

