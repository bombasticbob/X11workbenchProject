/////////////////////////////////////////////////////////////////////////////////////////
//  __  __ _  _                        _     _                         _               //
//  \ \/ // |/ |__      __ ___   _  _ | | __| |__    ___  _ __    ___ | |__      ___   //
//   \  / | || |\ \ /\ / // _ \ | '__|| |/ /| '_ \  / _ \| '_ \  / __|| '_ \    / __|  //
//   /  \ | || | \ V  V /| (_) || |   |   < | |_) ||  __/| | | || (__ | | | | _| (__   //
//  /_/\_\|_||_|  \_/\_/  \___/ |_|   |_|\_\|_.__/  \___||_| |_| \___||_| |_|(_)\___|  //
//                                                                                     //
//                          'main' source for X11workbench                             //
//                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2018 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.
               Any claims to alleged functionality or features should be
               considered 'preliminary', and might not function as advertised.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <signal.h>
#include <time.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>

// project includes
#include "X11workbench.h"
#include "gizzard.h"
#include "gdb_helper.h"
#include "refactor.h"

// X11workbench toolkit library includes
#include "window_helper.h"
#include "pixmap_helper.h"  // pixmap helpers, including pre-defined icons
#include "frame_window.h"
#include "edit_window.h"    // edit (client) window
#include "dialog_window.h"
#include "file_help.h"
#include "conf_help.h"
#include "draw_text.h"

// pixmap data
#include "application_icon.xpm" /* 19x19 icon presented to the OS for alt-tab etc. */
#include "icon_app.xpm"   /* application icon that's the same size as the others, 36x36 */
#include "textfiledoc.xpm"
#include "newdoc.xpm"
#include "clangdoc.xpm"
#include "makefiledoc.xpm"


//#define NO_SPLASH /* temporary, later put it as a configure option - need to get 'gleam' to work better */

#define STRING  "Hello, world"
#define BORDER  32 /* was 1 */
#define FONT    "fixed"

#define APP_NAME "X11workbench"


#ifndef NO_SPLASH
#include "splash.xpm" // splash pixmap
#endif // NO_SPLASH


// function prototypes

static int do_main(int argc, char *argv[], char *envp[]);
static void usage(void);
static void SetSignalHandlers(void);
static int MyWindowCallback(Window wID, XEvent *pEvent);
static int FileExitHandler(XClientMessageEvent *);
static int FileNewHandler(XClientMessageEvent *);
static int FileOpenHandler(XClientMessageEvent *);
static int FileSaveHandler(XClientMessageEvent *);
static int FileSaveUIHandler(WBMenu *, WBMenuItem *);
static int FileSaveAsHandler(XClientMessageEvent *);
static int FileSaveAsUIHandler(WBMenu *, WBMenuItem *);
static int FileSaveAllHandler(XClientMessageEvent *);
static int FileSaveAllUIHandler(WBMenu *, WBMenuItem *);
static int FileCloseHandler(XClientMessageEvent *);

static int HelpAboutHandler(XClientMessageEvent *);
static int HelpContentsHandler(XClientMessageEvent *);
static int HelpContextHandler(XClientMessageEvent *);

static int TabLeftHandler(XClientMessageEvent *);
static int TabRightHandler(XClientMessageEvent *);
static int TabMoveLeftHandler(XClientMessageEvent *);
static int TabMoveRightHandler(XClientMessageEvent *);
static int TabUIHandler(WBMenu *, WBMenuItem *);

static int ToolBoxHandler(XClientMessageEvent *pEvent);
static int ToolBoxUIHandler(WBMenu *pMenu, WBMenuItem *pMenuItem);

int DoFileOpen(WBFrameWindow *pMainFrame, const char *szFileName);
WBFILE_TYPE GetFileType(const char *szFileName); // return one of the WBFILE_TYPE constants



int main(int argc, char *argv0[], char *envp0[])
{
int iRval = 1;
char **argv = argv0; // re-define as char ** so I can re-allocate it as needed
char **envp = envp0;

  if(!WBParseStandardArguments(&argc, &argv, &envp))
  {
    iRval = do_main(argc, argv, envp);

    if(envp && envp != envp0)
    {
      WBFree(envp);
    }

    if(argv && argv != argv0)
    {
      WBFree(argv);
    }
  }
  else
  {
    usage();
  }

  return iRval;
}


// global variables

static Display       *pX11Display = NULL;            /* X server connection */
static WBFrameWindow *pMainFrame = NULL;
static XColor         clrGreen;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//   _____                          __        ___           _                 ____  _                   _         //
//  |  ___| __ __ _ _ __ ___   ___  \ \      / (_)_ __   __| | _____      __ / ___|| |_ _ __ _   _  ___| |_ ___   //
//  | |_ | '__/ _` | '_ ` _ \ / _ \  \ \ /\ / /| | '_ \ / _` |/ _ \ \ /\ / / \___ \| __| '__| | | |/ __| __/ __|  //
//  |  _|| | | (_| | | | | | |  __/   \ V  V / | | | | | (_| | (_) \ V  V /   ___) | |_| |  | |_| | (__| |_\__ \  //
//  |_|  |_|  \__,_|_| |_| |_|\___|    \_/\_/  |_|_| |_|\__,_|\___/ \_/\_/   |____/ \__|_|   \__,_|\___|\__|___/  //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// application menu and the application menu handler structure 'main_menu_handlers'

///////////////////////////////////////////////////////////////////////
// default application menu - what I see when there's no open document
///////////////////////////////////////////////////////////////////////
static char szAppMenu[]="1\n"
                        "_File\tpopup\t2\n"
                        "_Tools\tpopup\t5\n"
                        "\tseparator\n"
                        "_Help\tpopup\t3\n"
                        "\n"
                        "2\n"
                        "_New File\tIDM_FILE_NEW\tNew File\tCtrl+N\n"
                        "_Open File\tIDM_FILE_OPEN\tOpen File\tCtrl+O\n"
                        "\tseparator\n"
                        "E_xit\tIDM_FILE_EXIT\tClose Application\tAlt+F4\n"
                        "\n"
                        "3\n"
                        "_Contents\tIDM_HELP_CONTENTS\tHelp Contents\tAlt+F1\n"
                        "Conte_xt\tIDM_HELP_CONTEXT\tContext Help\tF1\n"
                        "\tseparator\n"
                        "_About X11workbench\tIDM_HELP_ABOUT\tAbout X11workbench\tAlt+F1\n"
                        "\n"
                        "5\n"
                        "_Toolbox\tIDM_TOOLBOX\tDisplay (or hide) the Toolbox\n"
                        "_Options\tIDM_TOOLS_OPTIONS\tDisplay Options Editor\n"
                        "\n";

////////////////////////////////////////////////////////////
// edit menu - what I see when there's a child frame active
////////////////////////////////////////////////////////////
static char szEditMenu[]="1\n"
                        "_File\tpopup\t2\n"
                        "_Edit\tpopup\t4\n"
                        "_Tools\tpopup\t5\n"
                        "\tseparator\n"
                        "_Window\tpopup\t6\n"
                        "\tseparator\n"
                        "_Help\tpopup\t3\n"
                        "\n"
                        "2\n"
                        "_New File\t" FW_FILE_NEW_MENU "\tNew File\t" FW_FILE_NEW_ACCEL "\n"
                        "_Open File\t" FW_FILE_OPEN_MENU "\tOpen File\t" FW_FILE_OPEN_ACCEL "\n"
                        "_Save File\t" FW_FILE_SAVE_MENU "\tSave File\t" FW_FILE_SAVE_ACCEL "\n"
                        "Save _As\t" FW_FILE_SAVE_AS_MENU "\tSave As\t" FW_FILE_SAVE_AS_ACCEL "\n"
                        "Save A_ll\t" FW_FILE_SAVE_ALL_MENU "\tSave All\t" FW_FILE_SAVE_ALL_ACCEL "\n"
                        "\tseparator\n"
                        "_Close File\t" FW_FILE_CLOSE_MENU "\tClose File\tCtrl+F4\n"
                        "\tseparator\n"
                        "E_xit\tIDM_FILE_EXIT\tClose Application\tAlt+F4\n"
                        "\n"
                        "3\n"
                        "_Contents\tIDM_HELP_CONTENTS\tHelp Contents\tAlt+F1\n"
                        "Conte_xt\tIDM_HELP_CONTEXT\tContext Help\tF1\n"
                        "\tseparator\n"
                        "_About X11workbench\tIDM_HELP_ABOUT\tAbout X11workbench\tAlt+F1\n"
                        "\n"
                        "4\n"
                        "_Undo\tIDM_EDIT_UNDO\tUn-do last action\tCtrl+Z\n"
                        "_Redo\tIDM_EDIT_REDO\tRe-do last action\tShift+Ctrl+Z\n"
                        "\tseparator\n"
                        "Cu_t\t" FW_EDIT_CUT_MENU "\tCut to Clipboard\t" FW_EDIT_CUT_ACCEL "\n"
                        "_Copy\t" FW_EDIT_COPY_MENU "\tCopy to Clipboard\t" FW_EDIT_COPY_ACCEL "\n"
                        "_Paste\t" FW_EDIT_PASTE_MENU "\tPaste from Clipboard\t" FW_EDIT_PASTE_ACCEL "\n"
                        "_Delete\t" FW_EDIT_DELETE_MENU "\tDelete selection\n"
                        "\tseparator\n"
                        "Select _All\t" FW_EDIT_SELECT_ALL_MENU "\tSelect All in context\t" FW_EDIT_SELECT_ALL_ACCEL "\n"
                        "Select _None\t" FW_EDIT_SELECT_NONE_MENU "\tSelect None in context\t" FW_EDIT_SELECT_NONE_ACCEL "\n"
                        "\tseparator\n"
                        "_Find\tIDM_EDIT_FIND\tFind within Document\tCtrl+F\n"
                        "Find Ne_xt\tIDM_EDIT_FIND_NEXT\tFind next occurence within Document\tCtrl+G\n"
                        "_Project Find\tIDM_EDIT_PROJ_FIND\tFind within entire project\tCtrl+Shift+F\n"
                        "Pro_ject Find Next\tIDM_EDIT_PROJ_FIND_NEXT\tFind next occurrence within entire project\tCtrl+Shift+G\n"
                        "\n"
                        "5\n"
                        "_Toolbox\tIDM_TOOLBOX\tDisplay (or hide) the Toolbox\n"
                        "_Options\tIDM_TOOLS_OPTIONS\tDisplay Options Editor\n"
                        "\n"
                        "6\n"
                        "Tab _Left\tIDM_TAB_LEFT\tScroll Tab Left\tCtrl+Alt+PgUp\n"
                        "Tab _Right\tIDM_TAB_RIGHT\tScroll Tab Right\tCtrl+Alt+PgDown\n"
                        "\tseparator\n"
                        "Re-order Le_ft\tIDM_TAB_MOVE_LEFT\tScroll Tab Left\tCtrl+Alt+Shift+PgUp\n"
                        "Re-order R_ight\tIDM_TAB_MOVE_RIGHT\tScroll Tab Right\tCtrl+Alt+Shift+PgDown\n"
                        "\tseparator\n" // NOTE:  I can add a list of windows here, with hotkeys
                        "\n";


// NOTES ON 'F' KEYS - these were compiled by someone else with respect to winders
// CTRL+ALT (and +SHIFT) any F key in X11 switches to a virtual desktop in console mode
//
// F1 - brings up a help window
//      Alt - system menu
// F2 - in winders, rename selected object.
//      Alt+Ctrl - in MS Orifice, opens documents library (don't do this in X11)
// F3 - in winders, open search box
// F4 - in winders XP, display address bar list (or similar)
//      Alt - close application/window
// F5 - window refresh/update (such as in Firefox)
// F6 - cycle through screen elements of a window
// F7 - turn on/off "caret mode" in Firefox; in MS Weird, spell/grammar checking
// F8 - extend selection (MS orifice)
// F9 - update fields (MS orifice, particularly ExHell)
// F10 - activates the menu
//       SHIFT - pops up a context menu (in X11 at least) like a right-click would
//       ALT - in X11, maximize/normal (retaining window decorations)
// F11 - toggle between "true full-screen" (no window decorations) and normal [works in gnome/mate as well]
// F12 - opens 'save as' dialog (in MS Orifice)




// menu handler, similar to what MFC does
// in theory I can swap in a new menu handler when the window focus changes
// this is the DEFAULT handler, when no 'child frame' has the focus.  It also handles
// all of the OTHER menu stuff, out of convenience

FW_MENU_HANDLER_BEGIN(main_menu_handlers)
  FW_MENU_HANDLER_ENTRY("IDM_FILE_EXIT",FileExitHandler,NULL)
  FW_MENU_HANDLER_ENTRY("IDM_FILE_NEW",FileNewHandler,NULL)
  FW_MENU_HANDLER_ENTRY("IDM_FILE_OPEN",FileOpenHandler,NULL)
  FW_MENU_HANDLER_ENTRY("IDM_FILE_SAVE",FileSaveHandler,FileSaveUIHandler)
  FW_MENU_HANDLER_ENTRY("IDM_FILE_SAVE_AS",FileSaveAsHandler,FileSaveAsUIHandler)
  FW_MENU_HANDLER_ENTRY("IDM_FILE_SAVE_ALL",FileSaveAllHandler,FileSaveAllUIHandler)

  FW_MENU_HANDLER_ENTRY("IDM_FILE_CLOSE",FileCloseHandler,NULL) // TODO:  do a UI handler?

  FW_MENU_HANDLER_ENTRY("IDM_TOOLBOX",ToolBoxHandler,ToolBoxUIHandler)

  FW_MENU_HANDLER_ENTRY("IDM_TAB_LEFT",TabLeftHandler, TabUIHandler)
  FW_MENU_HANDLER_ENTRY("IDM_TAB_RIGHT",TabRightHandler, TabUIHandler)
  FW_MENU_HANDLER_ENTRY("IDM_TAB_MOVE_LEFT",TabMoveLeftHandler, TabUIHandler)
  FW_MENU_HANDLER_ENTRY("IDM_TAB_MOVE_RIGHT",TabMoveRightHandler, TabUIHandler)

  FW_MENU_HANDLER_ENTRY("IDM_HELP_ABOUT",HelpAboutHandler,NULL)
  FW_MENU_HANDLER_ENTRY("IDM_HELP_CONTEXT",HelpContextHandler,NULL)
  FW_MENU_HANDLER_ENTRY("IDM_HELP_CONTENTS",HelpContentsHandler,NULL)

#if 0
  // additional EDIT MENU HANDLERS

  FW_MENU_HANDLER_ENTRY("IDM_EDIT_FIND",EditFindHandler,EditFindUIHandler)
  FW_MENU_HANDLER_ENTRY("IDM_EDIT_FIND_NEXT",EditFindNextHandler,EditFindNextUIHandler)
  FW_MENU_HANDLER_ENTRY("IDM_EDIT_PROJ_FIND",EditProjFindHandler,EditProjFindUIHandler)
  FW_MENU_HANDLER_ENTRY("IDM_EDIT_PROJ_FIND_NEXT",EditProjFindNextHandler,EditProjFindNextUIHandler)
#endif // 0

FW_MENU_HANDLER_END



// end of global variables



static void usage(void)
{
  fputs("X11workbench - Copyright (c) 2010-2018 by S.F.T. Inc. - all rights reserved\n\n"
        "Usage:      X11workbench [options] filename [filename [...]]\n"
        "  where     'filename' represents one or more files or workspaces to be opened on startup\n"
        "\n"
        "Standard X11workbench Options\n"
        "-h          display this message\n"
#ifndef NO_DEBUG
        "-d          dump settings on startup\n"
#endif // NO_DEBUG
#ifndef NO_SPLASH
        "--nosplash  Skip the 'splash' screen on startup\n"
#endif // !NO_SPLASH
        "\n", stderr);

  WBToolkitUsage();
}

static void get_min_window_height_width(int *piMinHeight, int *piMinWidth)
{
  // DEMO CODE - using the 'STRING' size, calculate the minimum width/height and pass that
  //             as parameters to WBInitSizeHints

  // calculating the actual font height for the default font

  unsigned long fth = WBGetDefaultFont()->max_bounds.ascent  // default font height
                    + WBGetDefaultFont()->max_bounds.descent;

  // the pad and border are part of the 'hello world' text and green border displayed for the demo
  unsigned long pad = BORDER; // font padding (only used here)
  unsigned long bw = 1;       // border width (only used here)

  *piMinHeight = fth + pad * 2 + bw * 2;
  *piMinWidth = XTextWidth(WBGetDefaultFont(),     // minimum width (based on text width)
                           STRING,
                           strlen(STRING)) + pad * 2 + bw * 2;
}


///////////////////////////////////////////////
// do_main - initialization, loop, termination
//        (the classic top-down model)
///////////////////////////////////////////////

int do_main(int argc, char *argv[], char *envp[])
{
//unsigned long fg, bg, bd;   /* Pixel values */
XEvent      event;          /* Event received */
XSizeHints  xsh;            /* Size hints for window manager */
//XSetWindowAttributes xswa;  /* Temporary Set Window Attribute struct */
char       szGreen[]="#00FF00";  // text color for green
Colormap   colormap;
int i1, iMinHeight, iMinWidth;
#ifndef NO_DEBUG
int iDebugDumpConfig = 0;
#endif // NO_DEBUG
#ifndef NO_SPLASH
int bNoSplash = 0;
#endif // !NO_SPLASH


  // as opposed to 'getarg' this method is system independent
  // some POSIX systems don't support 'getarg' correctly
  // TODO:  put it in platform_helper.[ch] and use HAVE_GETARG

  while(argc > 1)
  {
    if(argv[1][0] != '-' || !argv[1][1])
    {
      if(argv[1][0] == '-')
      {
        argv++;
        argc--;
      }

      break;
    }

    if(argv[1][1] == '-') // a double-dash
    {
      // double-dash items go here.  only 'one per'

      if(!strcmp(&(argv[1][2]), "nosplash"))
      {
        bNoSplash = 1;
        goto next_argument;
      }

      fprintf(stderr, "Unrecognized option \"%s\"\n", argv[1]);
      usage();

      return 1; // illegal argument
    }

    for(i1=1; argv[1][i1]; i1++)
    {
      if(argv[1][i1] == 'h' ||
         argv[1][i1] == 'H')
      {
        usage();
        return 0;
      }
#ifndef NO_DEBUG
      else if(argv[1][i1] == 'd')
      {
        iDebugDumpConfig = 1;
      }
#endif // NO_DEBUG
      else
      {
        fprintf(stderr, "Unrecognized option \"-%c\"\n", argv[1][i1]);

        usage();
        return 1;
      }
    }

next_argument:
    argv++;
    argc--;
  }

  // initialization - set signal handlers, open display, etc.

  SetSignalHandlers();

  pX11Display = WBInit(NULL); // initialize X11 Work Bench Toolkit and obtain Display pointer
  if(!pX11Display)
  {
    return 1; // can't open display, so byby!
  }

  PXM_RegisterAppIcons(icon_app_xpm, application_icon_xpm);


#ifndef NO_DEBUG
  // This DEBUG section dumps the config data when theh '-d' option was specified on the command line.
  // it requires a Display object so I must do it HERE.  Then I can call WBExit and bail out.

  if(iDebugDumpConfig)
  {
    CHDumpConfig();

    WBExit();
    return 0;
  }
#endif // NO_DEBUG

  // SUPPLEMENTAL INITIALIZATION STUFF

  // color selection

//  bd = WhitePixel(pX11Display, DefaultScreen(pX11Display)); // border
//  bg = BlackPixel(pX11Display, DefaultScreen(pX11Display)); // background
//  fg = WhitePixel(pX11Display, DefaultScreen(pX11Display)); // foreground

  // dont' forget the colormap

  colormap = WBDefaultColormap(pX11Display);

  // additional allocated colors - in this case, GREEN
  XParseColor(pX11Display, colormap, szGreen, &clrGreen);
  XAllocColor(pX11Display, colormap, &clrGreen);  // NOTE:  do I need 'XFreeColors' for 'clrGreen' ?

// 11 bits    U+07FF      110xxxxx 10xxxxxx
// A9 --> 10101001 --> 11000010 10101001 --> C2 A9
#define UTF8_COPYRIGHT "\xc2""\xa9"

#ifndef NO_SPLASH
  if(!bNoSplash)
  {
    DLGSplashScreen(splash_xpm,
//                    "Copyright " UTF8_COPYRIGHT " 2010-2018 by Big Bad Bombastic Bob\nAll Rights Reserved",  // text string with unicode char in it U+00A9
                    "Copyright (c) 2010-2018 by Big Bad Bombastic Bob\nAll Rights Reserved", // 1 or 2 lines only
                    WhitePixel(pX11Display, DefaultScreen(pX11Display))); // white text
  }
#endif // NO_SPLASH

  get_min_window_height_width(&iMinHeight, &iMinWidth);

  // I will need to center the new window, so figure out how to do that

  WBInitSizeHints(&xsh,        // pointer to XSizeHints
                  pX11Display, // Display pointer
                  iMinHeight,  // minimum height (based on font height)
                  iMinWidth);  // minimum width

//  // init window attributes
//
//  WBInitWindowAttributes(&xswa,           // attribute structure
//                         bd,              // border pixel color
//                         bg,              // background window color
//                         colormap,        // colormap
//                         CenterGravity);  // gravity

  // create frame window object (always uses default display)

  pMainFrame = FWCreateFrameWindow("X11workbench",            // title
                                   ID_APPLICATION,           // icon
                                   szAppMenu,                // application menu
                                   xsh.x, xsh.y,             // position
                                   xsh.width, xsh.height,    // size
                                   MyWindowCallback,         // callback
                                   WBFrameWindow_APP_WINDOW  // flags and attributes
                                   | WBFrameWindow_VISIBLE
                                   | WBFrameWindow_STATUS_BAR);

  if(!pMainFrame)
  {
    WB_ERROR_PRINT("%s - Unable to create main frame window\n", __FUNCTION__);

    WBExit();
    return 2;
  }

//  {
//    const char *pNothing = szEditMenu; // to avoid certain warnings - remove later
//
//    pNothing = pNothing;
//  }

  // assign menu handlers to the frame window (this does the callback functions for me)
  // this is part of the frame window functionality for the DEFAULT menu

  FWSetMenuHandlers(pMainFrame, main_menu_handlers);


  // open files specifed on command line

  // TODO:  if project file specified, open files based on project state
  //        Otherwise, open as "single file"

  while(argc > 1)
  {
    // TODO:  is it a project file?

    DoFileOpen(pMainFrame, argv[1]);

    argc--;
    argv++;
  }


  //=========================
  //   MAIN MESSAGE LOOP
  //=========================

  while (!bQuitFlag /*1*/)
  {
    if(!WBCheckGetEvent(pX11Display, &event))
    {
      // SLEEP if no event while in message loop (function returns without blocking)
      // otherwise I can do background tasks during this loop iteration.

      // if I have NO BACKGROUND PROCESSES to do, I can use 'WBWaitForEvent'

      if(1)
      {
        WBWaitForEvent(pX11Display);
      }
      else
      {
#ifdef HAVE_NANOSLEEP
        struct timespec tsp;
        tsp.tv_sec = 0;
        tsp.tv_nsec = 500000;  // wait for .5 msec

        nanosleep(&tsp, NULL);
#else  // HAVE_NANOSLEEP

        usleep(500);  // 100 microsecs - a POSIX alternative to 'nanosleep'

#endif // HAVE_NANOSLEEP
      }

      continue; // skip the 'WBDispatch' since there was no event
    }

    WBDispatch(&event);
  }

  if(pMainFrame)
  {
    WBDestroyWindow(pMainFrame->wID);
  }

  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Application,
                 "%s - Application about to exit\n", __FUNCTION__);

  WBExit();

  return 0;
}



///////////////////////
// CALLBACK FUNCTIONS
///////////////////////

extern void TestFunc(Display *pDisplay, GC gc, Window wID, int iX, int iY);

static int MyWindowCallback(Window wID, XEvent *pEvent)
{
XWindowAttributes xwa;      /* Temp Get Window Attribute struct */
int iRval = 0;

  /*
    * On the last of each group of Expose events,  repaint the entire
    * window.  See Section 8.4.5.1.
    */

  if(pEvent->type == DestroyNotify &&
     pEvent->xdestroywindow.window == wID)
  {
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Application,
                   "%s - DestroyNotify\n", __FUNCTION__);

    if(pMainFrame && pMainFrame->wID == wID)
    {
      pMainFrame = NULL;  // because I'm destroying it
    }

    return 0;  // let remaining default processing happen
  }

  if(pEvent->type == ClientMessage &&
     pEvent->xclient.message_type == aQUERY_CLOSE)
  {
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Application,
                   "%s - QUERY_CLOSE\n", __FUNCTION__);

    if(pEvent->xclient.data.l[0]) // close is imminent if I return 0
    {
      if(pMainFrame && pMainFrame->wID == wID)
      {
        pMainFrame = NULL;  // because I'm destroying it
      }
    }

    return 0; // "ok to close" (let frame window handle anything else)
  }

  if (pEvent->type == Expose && pEvent->xexpose.count == 0)
  {
    GC gc;
    WB_GEOM geom;

// NOTE:  this is managed by the toolkit
//    /*
//      * Remove any other pending Expose events from the queue to
//      * avoid multiple repaints. See Section 8.7.
//      */
//    while(!bQuitFlag && XCheckTypedWindowEvent(pX11Display, wID, Expose, pEvent))
//      ;
//
//    if(bQuitFlag)
//    {
//      iRval = 1;
//      WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Application,
//                     "%s - Quit flag set - returning %d\n", __FUNCTION__, iRval);
//
//      return iRval;  // let default processing happen
//    }

    /*
      * Find out how big the window is now,  so that we can center
      * the text in it.
      */
    if(XGetWindowAttributes(pX11Display, wID, &xwa) == 0)
    {
      WB_ERROR_PRINT("%s - Cannot get correct attributes for window!  Returning %d\n",
                    __FUNCTION__, iRval);
      return iRval;
    }

    gc = WBBeginPaint(wID, &(pEvent->xexpose), &geom);  // begin paint, get a gc for it

    if(gc == None)
    {
      WB_ERROR_PRINT("%s - Cannot get graphics context for paint\n", __FUNCTION__);
      return 0; // not handled
    }

    WBClearWindow(wID, gc);  // does the erase background intelligently


#ifdef DISPLAY_HELLO_WORLD
    {
      XFontStruct *pFont;
      int x, y, x0, y0, x1, y1;

      pFont = WBGetWindowFontStruct(wID);
      if(!pFont)
      {
        WB_ERROR_PRINT("%s - No font - returning %d\n", __FUNCTION__, iRval);
        return iRval;  // let default processing happen
      }

      x0 = XTextWidth(pFont, STRING, strlen(STRING));
      y0 = pFont->max_bounds.ascent
          - pFont->max_bounds.descent;

      x = (xwa.width - x0) / 2;
      y = (xwa.height + pFont->max_bounds.ascent
        - pFont->max_bounds.descent) / 2;

      // adjust new values for X0 and y0 to surround x and y

      x1 = x + x0 + 20;
      x0 = x - 20;

      y1 = y + pFont->max_bounds.descent + 20;
      y0 = y - y0 - 20;

      /*
        * Fill the window with the background color,  and then paint
        * the centered string.
        */

      XSetForeground(pX11Display, gc, WBGetWindowFGColor(wID));
      XDrawString(pX11Display, wID, gc, x, y, STRING, strlen(STRING));

      XSetForeground(pX11Display, gc, clrGreen.pixel);

      // draw my green rectangle

      XDrawRectangle(pX11Display, wID, gc, x0, y0, x1 - x0, y1 - y0);
      XSetForeground(pX11Display, gc, WBGetWindowFGColor(wID));  // restore it at the end
    }
#endif // DISPLAY_HELLO_WORLD

//    TestFunc(pX11Display, gc, wID, x0 - 32, y0 - 32); // TEMPORARY

    WBEndPaint(wID, gc);  // done now [free resources]

    iRval = 1;  // processed

    WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Window,
                   "%s - Expose returning %d\n", __FUNCTION__, iRval);

    return iRval;  // let default processing happen
  }

  // menu events
  if(pEvent->type == ClientMessage && pEvent->xclient.message_type == aMENU_COMMAND)
  {
    iRval = 1;

    WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Window | DebugSubSystem_Menu | DebugSubSystem_Event,
                   "%s - detecting main window menu event %ld\n", __FUNCTION__,
                   pEvent->xclient.data.l[0]);
  }

  WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Window,
                 "%s - Returning %d\n", __FUNCTION__, iRval);

  return iRval;  // let default processing happen if zero, else 'processed'
}


///////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                           //
//   _   _  _    _  _  _  _            _____                     _    _                      //
//  | | | || |_ (_)| |(_)| |_  _   _  |  ___|_   _  _ __    ___ | |_ (_)  ___   _ __   ___   //
//  | | | || __|| || || || __|| | | | | |_  | | | || '_ \  / __|| __|| | / _ \ | '_ \ / __|  //
//  | |_| || |_ | || || || |_ | |_| | |  _| | |_| || | | || (__ | |_ | || (_) || | | |\__ \  //
//   \___/  \__||_||_||_| \__| \__, | |_|    \__,_||_| |_| \___| \__||_| \___/ |_| |_||___/  //
//                             |___/                                                         //
//                                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////

// 'DoFileOpen()' - API to open a file and create a child frame derived tab for it

int DoFileOpen(WBFrameWindow *pMainFrame, const char *szFileName)
{
  WBChildFrame *pCF = NULL;

  if(!pMainFrame || !szFileName || !*szFileName)
  {
    return -1;
  }

  // create a new tab in the frame window using the correct type of child window

//  uint32_t uiFileType = GetFileType(szFileName);
//
//  if(uiFileType == WBFILE_PROJECT)
//  {
//  }
//  else if(uiFileType == WBFILE_RESOURCE)
//  {
//  }
//  else
  {
    // All other files are assumed to be text files.

    // 1st, create a new 'WBEditWindow', attaching it to the frame

    WBEditWindow *pEW = WBCreateEditWindow(pMainFrame, NULL, szEditMenu, main_menu_handlers, 0);

    if(!pEW)
    {
      DLGMessageBox(MessageBox_OK | MessageBox_Error, (Window)-1,
                    "File Open", "'File _Open' unable to create edit window");
    }
    else
    {
      // next, load the contents of the file into it

      if(WBEditWindowLoadFile(pEW, szFileName))
      {
        DLGMessageBox(MessageBox_OK | MessageBox_Error, (Window)-1,
                      "File Open", "'File _Open' unable to read file into edit window");
      }

      pCF = &(pEW->childframe);
    }
  }

  if(pCF)
  {
    const char *pDisplayName;

    // TODO:  set up a few things based on the file type
    //        a) default line ending
    //        b) default unicode/UTF-8 [as required]
    //        c) default tab handling
    //        d) color highlighting
    //        etc.


    // display file name with no path info within tab
    pDisplayName = szFileName + strlen(szFileName);

    while(pDisplayName > szFileName && *(pDisplayName - 1) != '/')
    {
      pDisplayName--;
    }

    FWSetChildFrameDisplayName(pCF, pDisplayName);
  }

  return pCF ? 0 : -1;
}


WBFILE_TYPE GetFileType(const char *szFileName) // return one of the WBFILE_TYPE constants
{
const char *pFN, *pExt;

  pFN = pExt = szFileName + strlen(szFileName);

  while(pFN > szFileName && *(pFN - 1) != '/')
  {
    pFN--;
  }

  while(pExt > szFileName && *(pExt - 1) != '.')
  {
    pExt--;
  }

  if(pExt <= szFileName)
  {
    pExt = NULL; // no extension
  }

  // TODO:  don't just check the extension, read the first few lines, check for
  //        invalid/unprintable characters, etc.

  if(!pExt && !strcasecmp("makefile", pExt))
  {
    return WBFILE_TYPE_MAKEFILE;
  }
  else if(!pExt)
  {
    // TODO: look for hash-bang
  }
  else if(!strcasecmp("mk", pExt)) // '.mk' '.Mk' or '.MK' extension
  {
    return WBFILE_TYPE_MAKEFILE;
  }
  else if(!strcasecmp("h", pExt)) // '.mk' '.Mk' or '.MK' extension
  {
    return WBFILE_TYPE_MAKEFILE;
  }
  else if(!strcmp("c", pExt))
  {
    return WBFILE_TYPE_CPROG;
  }
  else if(!strcmp("g", pExt))
  {
    return WBFILE_TYPE_CHEADER;
  }
  else if(!strcmp("cpp", pExt))
  {
    return WBFILE_TYPE_CPP;
  }
  else if(!strcmp("java", pExt))
  {
    return WBFILE_TYPE_JAVA;
  }
  else if(!strcmp("js", pExt))
  {
    return WBFILE_TYPE_JS;
  }
  else if(!strcmp("pl", pExt))
  {
    return WBFILE_TYPE_PERL;
  }
  else if(!strcmp("py", pExt))
  {
    return WBFILE_TYPE_PYTHON;
  }
  else if(!strcmp("xpm", pExt))
  {
    return WBFILE_TYPE_PIXMAP;
  }
  else if(!strcmp("xwbrc", pExt))
  {
    return WBFILE_TYPE_RESOURCE;
  }
  else if(!strcmp("xwbdlg", pExt))
  {
    return WBFILE_TYPE_DIALOG;
  }
  else if(!strcmp("xwbmenu", pExt))
  {
    return WBFILE_TYPE_MENU;
  }
  else if(!strcmp("xwbbar", pExt))
  {
    return WBFILE_TYPE_TOOLBAR;
  }
  else if(!strcmp("sh", pExt))
  {
    return WBFILE_TYPE_SHELL;
  }
  else if(!strcmp("php", pExt))
  {
    return WBFILE_TYPE_PHP;
  }
  else if(!strcmp("htm", pExt) || !strcmp("html", pExt))
  {
    return WBFILE_TYPE_HTML;
  }


  return WBFILE_TYPE_TEXT; // default
}



////////////////////////////////////////////////////////////////////////////
//   __  __                     ____      _ _ _                _          //
//  |  \/  | ___ _ __  _   _   / ___|__ _| | | |__   __ _  ___| | _____   //
//  | |\/| |/ _ \ '_ \| | | | | |   / _` | | | '_ \ / _` |/ __| |/ / __|  //
//  | |  | |  __/ | | | |_| | | |__| (_| | | | |_) | (_| | (__|   <\__ \  //
//  |_|  |_|\___|_| |_|\__,_|  \____\__,_|_|_|_.__/ \__,_|\___|_|\_\___/  //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

static int FileExitHandler(XClientMessageEvent *pEvent)
{
  // TODO:  'OnExit' processing for open files (files to be saved, etc.)

  bQuitFlag = 1;  // time to die

  return 1; // handled
}

static int FileNewHandler(XClientMessageEvent *pEvent)
{
WBEditWindow *pEW;

  if(!pMainFrame)
  {
    DLGMessageBox(MessageBox_OK | MessageBox_Error, (Window)-1,
                  "File New", "'File _New' and no container window");
    return 1;
  }

  // create a new child frame within the main frame
  // this should be pretty straightforward as I implement it properly

  // 1st, create a new 'WBEditWindow', attaching it to the frame

  pEW = WBCreateEditWindow(pMainFrame, NULL, szEditMenu, main_menu_handlers, 0);

  if(!pEW)
  {
    DLGMessageBox(MessageBox_OK | MessageBox_Error, (Window)-1,
                  "File New", "'File _New' unable to create edit window");
  }

  return 1; // handled
}


static int FileOpenHandler(XClientMessageEvent *pEvent)
{
  Window wIDOwner = pMainFrame ? pMainFrame->wID : -1;
  WBEditWindow *pEW;
  char *pFile;

  pFile = DLGFileDialog(FileDialog_Open, wIDOwner, ".", "",
                        ".txt\tText Files\n"
                        ".c\tC language file\n"
                        ".cpp\tC language file\n"
                        ".h\tC language header\n"
                        "Makefile\tMake Files\n"
                        ".mk\tMake 'include' Files\n"
                        ".am\tAutotools File\n"
                        ".*\tAll Files\n");

  if(pFile)
  {
    DoFileOpen(pMainFrame, pFile);

    WBFree(pFile);  // required resource cleanup
  }

  return 1; // handled
}

static int FileSaveHandler(XClientMessageEvent *pEvent)
{
  Window wIDOwner = pMainFrame ? pMainFrame->wID : -1;

  DLGMessageBox(MessageBox_OK | MessageBox_MiddleFinger, wIDOwner,
                "File Save",
                "'File _Save' not currently implemented");

  return 1; // handled
}

static int FileSaveUIHandler(WBMenu *pMenu, WBMenuItem *pItem)
{
  return -1; // disabled
}

static int FileSaveAsHandler(XClientMessageEvent *pEvent)
{
  Window wIDOwner = pMainFrame ? pMainFrame->wID : -1;

  DLGMessageBox(MessageBox_OK | MessageBox_Warning, wIDOwner,
                "File Save As",
                "'File Save _As' not currently implemented");

  return 1; // handled
}

static int FileSaveAsUIHandler(WBMenu *pMenu, WBMenuItem *pItem)
{
  return -1; // disabled
}

static int FileSaveAllHandler(XClientMessageEvent *pEvent)
{
  Window wIDOwner = pMainFrame ? pMainFrame->wID : -1;

  DLGMessageBox(MessageBox_OK | MessageBox_Warning, wIDOwner,
                "File Save All",
                "'File Save A_ll' not currently implemented");

  return 1; // handled
}

static int FileSaveAllUIHandler(WBMenu *pMenu, WBMenuItem *pItem)
{
  return -1; // disabled
}

static int HelpAboutHandler(XClientMessageEvent *pEvent)
{
  Window wIDOwner = pMainFrame ? pMainFrame->wID : -1;


  DLGMessageBox(MessageBox_OK | /*MessageBox_Info*/ MessageBox_App, wIDOwner,
                "About X11workbench",
                "X11workbench - BBB's answer to a proper development environment for X11");

  return 1; // handled
}

static int FileCloseHandler(XClientMessageEvent *pEvent)
{
  WBChildFrame *pC;

  if(!pMainFrame)
  {
    return 0;
  }

  pC = FWGetFocusWindow(pMainFrame);

  if(pC)
  {
    // TODO:  check for 'safe to close it' ?

    FWRemoveContainedWindow(pMainFrame, pC);

    FWDestroyChildFrame(pC); // this will destroy the super-class as well
  }

  return 1;
}

static int TabLeftHandler(XClientMessageEvent *pEvent)
{
int iIndex;

  if(!pMainFrame)
  {
    return 0;
  }

  iIndex = FWGetChildFrameIndex(pMainFrame, NULL);

  WB_ERROR_PRINT("TEMPORARY:  %s - move left %d\n", __FUNCTION__, iIndex);

  if(iIndex > 0)
  {
    FWSetFocusWindowIndex(pMainFrame, iIndex - 1);
  }

  return 1;
}

static int TabRightHandler(XClientMessageEvent *pEvent)
{
int iIndex;

  if(!pMainFrame)
  {
    return 0;
  }

  iIndex = FWGetChildFrameIndex(pMainFrame, NULL);

  WB_ERROR_PRINT("TEMPORARY:  %s - move right %d\n", __FUNCTION__, iIndex);

  if(iIndex >= 0)
  {
    FWSetFocusWindowIndex(pMainFrame, iIndex + 1);
  }

  return 1;
}

static int TabMoveLeftHandler(XClientMessageEvent *pEvent)
{
  WBChildFrame *pC;

  if(!pMainFrame)
  {
    return 0;
  }

  pC = FWGetFocusWindow(pMainFrame);

  if(pC)
  {
    FWMoveChildFrameTabIndex(pMainFrame, pC, -1);
  }

  return 1;
}

static int TabMoveRightHandler(XClientMessageEvent *pEvent)
{
  WBChildFrame *pC;

  if(!pMainFrame)
  {
    return 0;
  }

  pC = FWGetFocusWindow(pMainFrame);

  if(pC)
  {
    FWMoveChildFrameTabIndex(pMainFrame, pC, -2);
  }

  return 1;
}

static int TabUIHandler(WBMenu *pMenu, WBMenuItem *pMenuItem)
{
  if(FWGetContainedWindowByIndex(pMainFrame, 1) != NULL)
  {
    return 1; // enabled (more than one tab)
  }

  return -1; // disabled (zero or one child frames)
}

static int ToolBoxHandler(XClientMessageEvent *pEvent)
{
  DLGMessageBox(MessageBox_WTF | MessageBox_No, None, "X11workbench - Unimplemented",
                "ToolBox Handler not (yet) implemented");

  return 1; // "handled"
}

static int ToolBoxUIHandler(WBMenu *pMenu, WBMenuItem *pMenuItem)
{
  return 1; // enabled  (TODO:  check # of tabs, etc.)
}



static int HelpContentsHandler(XClientMessageEvent *pEvent)
{
  Window wIDOwner = pMainFrame ? pMainFrame->wID : -1;

  char *pTemp = DLGInputBox(wIDOwner, "Help Contents", "Enter a search term for the documentation", "WBInit", -1, -1);

  if(pTemp)
  {
    DoContextSensitiveHelp(pTemp);

    WBFree(pTemp);
  }
//  else
//  {
//    DLGMessageBox(MessageBox_OK | MessageBox_Bang, wIDOwner,
//                  "Something Bad Happened", "Unexpected 'NULL' return from DLGInputBox");
//  }

  return 1; // handled
}

static int HelpContextHandler(XClientMessageEvent *pEvent)
{
  Window wIDOwner = pMainFrame ? pMainFrame->wID : -1;

  DLGMessageBox(MessageBox_OK | MessageBox_Bang, wIDOwner,
                "Context Help", "TODO:  implement the context-sensitive help");

//  DoContextSensitiveHelp(szWhateverWord);

  return 1; // handled
}




//////////////////////////////
//     SIGNAL HANDLER       //
//////////////////////////////


typedef struct _xsiginfo_
{
  const char *szSignal;
  int nSignal;
} XSIGINFO;

#define SIGINFO_ENTRY(X) { #X, X }
static const XSIGINFO aSigInfo[] =
{
SIGINFO_ENTRY(SIGHUP),   //    terminate process       terminal line hangup
SIGINFO_ENTRY(SIGINT),   //    terminate process       interrupt program
SIGINFO_ENTRY(SIGQUIT),  //    create core image       quit program
SIGINFO_ENTRY(SIGILL),   //    create core image       illegal instruction
SIGINFO_ENTRY(SIGTRAP),  //    create core image       trace trap
SIGINFO_ENTRY(SIGABRT),  //    create core image       abort(3) call (formerly SIGIOT)
#ifdef SIGEMT
SIGINFO_ENTRY(SIGEMT),   //    create core image       emulate instruction executed
#endif // SIGEMT
SIGINFO_ENTRY(SIGFPE),   //    create core image       floating-point exception
////SIGINFO_ENTRY(SIGKILL),  //    terminate process       kill program
SIGINFO_ENTRY(SIGBUS),   //    create core image       bus error
SIGINFO_ENTRY(SIGSEGV),  //    create core image       segmentation violation
SIGINFO_ENTRY(SIGSYS),   //    create core image       non-existent system call invoked
SIGINFO_ENTRY(SIGPIPE),  //    terminate process       write on a pipe with no reader
SIGINFO_ENTRY(SIGALRM),  //    terminate process       real-time timer expired
SIGINFO_ENTRY(SIGTERM),  //    terminate process       software termination signal
SIGINFO_ENTRY(SIGURG),   //    discard signal          urgent condition present on socket
////SIGINFO_ENTRY(SIGSTOP),  //    stop process            stop (cannot be caught or ignored)
//SIGINFO_ENTRY(SIGTSTP),  //    stop process            stop signal generated from keyboard
//SIGINFO_ENTRY(SIGCONT),  //    discard signal          continue after stop
SIGINFO_ENTRY(SIGCHLD),  //    discard signal          child status has changed
SIGINFO_ENTRY(SIGTTIN),  //    stop process            background read attempted from control terminal
SIGINFO_ENTRY(SIGTTOU),  //    stop process            background write attempted to control terminal
SIGINFO_ENTRY(SIGIO),    //    discard signal          I/O is possible on a descriptor (see fcntl(2))
SIGINFO_ENTRY(SIGXCPU),  //    terminate process       cpu time limit exceeded (see setrlimit(2))
SIGINFO_ENTRY(SIGXFSZ),  //    terminate process       file size limit exceeded (see setrlimit(2))
SIGINFO_ENTRY(SIGVTALRM),//    terminate process       virtual time alarm (see setitimer(2))
SIGINFO_ENTRY(SIGPROF),  //    terminate process       profiling timer alarm (see setitimer(2))
SIGINFO_ENTRY(SIGWINCH), //    discard signal          Window size change
#ifdef SIGINFO
SIGINFO_ENTRY(SIGINFO),  //    discard signal          status request from keyboard
#endif // SIGINFO
SIGINFO_ENTRY(SIGUSR1),  //    terminate process       User defined signal 1
SIGINFO_ENTRY(SIGUSR2),  //    terminate process       User defined signal 2
{NULL, 0}  // marks end of list
};


static void signalproc(int iSig)
{
static int bCtrlCFlag = 0; // when I hit ctrl+c multiple times, kill the app anyway in case of infinite loop or something

  int i1;

#if 0 /* this is broken now that I have a worker thread - no longer compatible */
  if(iSig == SIGTSTP) // suspend - special 'way cool' handling here [auto-fork!]
  {

    WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Application,
                   "\n**********************************************"
                   "\nSignal received:  SIGTSTP (detaching via fork)"
                   "\n The process has now gone into the background"
                   "\n  and is still running (i.e. not suspended)."
                   "\n**********************************************\n");
    fflush(stderr);

    // POSSIBLE (ALTERNATE) NON-FORKING METHOD
    // see man termios(4) - change process group of terminal, force me into the background
    // I change the controlling terminal process group to that of the shell that created me
//    {
//      pid_t idgParent;
//      int idParent;
//      idParent = getppid();  // parent PID
//      idgParent = getpgid(idParent);  // get process group ID using parent's process id
//
//      if(idgParent != -1)  // wasn't an error
//        tcsetpgrp(0, idgParent);
//
//      if(idParent != -1)
//        kill(idParent, SIGCHLD);  // child process status changed
//    }

    // to simplify matters, I simply fork the process and exit from the original.
    // This satisfies the shell's need to wait for the original process ID when it's
    // not in the background, and effectively keeps the process running on the GUI.
    //
    // De nada.  Bitte.  You're welcome.

    if(fork()) // non-zero means fork failed or NOT the forked process
    {
      exit(0);
    }
    return;
  }
  else if(iSig == SIGCONT) // continue
  {
    return;  // for now, just do nothing
  }
#endif // 0

  for(i1=0; i1 < sizeof(aSigInfo)/sizeof(aSigInfo[0]); i1++)
  {
    if(!aSigInfo[i1].szSignal)
    {
      break;
    }

    if(aSigInfo[i1].nSignal == iSig)
    {
      WB_DEBUG_PRINT(DebugLevel_ERROR | DebugSubSystem_Application,
                     "\nX11workbench - Signal received:  %s\n", aSigInfo[i1].szSignal);

      // only some signals will actually terminate the application.  I shall look for those now.

      if(iSig == SIGHUP || iSig == SIGINT || iSig == SIGQUIT ||
         iSig == SIGILL || iSig == SIGTRAP || iSig == SIGABRT ||
#ifdef SIGEMT
         iSig == SIGEMT ||
#endif // SIGEMT
         iSig == SIGSYS || iSig == SIGTERM || iSig == SIGSTOP ||
         iSig == SIGXCPU || iSig == SIGXFSZ || iSig == SIGFPE)
      {
        if(bQuitFlag && (iSig == SIGSTOP || iSig == SIGTERM || iSig == SIGINT))
        {
          // this section allows you to use TERM STOP or INT 3 times in a row to guarantee
          // that it will kill the process
          if(!bCtrlCFlag)
          {
            WB_ERROR_PRINT("\n----------------------------------------------------------------------------"
                           "\n                    X11workbench CTRL+C signal handler"
                           "\nINT/STOP/TERM, waiting for soft termination - signal again to terminate NOW!"
                           "\n----------------------------------------------------------------------------\n");
            fflush(stderr); // make sure it flushes output IMMEDIATELY
            bCtrlCFlag = 1; // if I get another, I kill it
          }
          else
          {
            WB_ERROR_PRINT("\n----------------------------------------------------------------------------"
                           "\n                    X11workbench CTRL+C signal handler"
                           "\nINT/STOP/TERM, aborting waiting for soft termination - terminate RIGHT NOW!!"
                           "\n----------------------------------------------------------------------------\n");
            exit(1); // exit with abnormal termination
          }
        }
        else
        {
          bCtrlCFlag = 0; // reset it (quit was aborted??)
        }

        bQuitFlag = TRUE; // soft termination
      }

      if(iSig == SIGKILL || iSig == SIGSEGV)  // special handling, must terminate process
      {
        WB_ERROR_PRINT("caught signal %d, terminating now\n", iSig);

        exit(0);
      }

      if(iSig == SIGBUS)  // might happen
      {
        WB_DEBUG_PRINT(DebugLevel_ERROR | DebugSubSystem_Application,
                       "SIGBUS received (this is usually caused by use of a data pointer instead of a function pointer)\n");
        exit(1);
      }

      return;
    }
  }

  WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Application,
                 "signal proc (%d) (%08xH)\n", iSig, iSig);

//  bQuitFlag = TRUE;
}


static void SetSignalHandlers()
{
  int i1;
  for(i1=0; i1 < sizeof(aSigInfo)/sizeof(aSigInfo[0]); i1++)
  {
    if(!aSigInfo[i1].szSignal)
      break;

    if(signal(aSigInfo[i1].nSignal, signalproc))
    {
      WB_WARN_PRINT("%s - WARNING:  Unable to assign signal proc for %s\n", __FUNCTION__, aSigInfo[i1].szSignal);
    }
  }
}




////////////////////////////////////////////////////////////////
//    ____            _            _     _   _      _         //
//   / ___|___  _ __ | |_ _____  _| |_  | | | | ___| |_ __    //
//  | |   / _ \| '_ \| __/ _ \ \/ / __| | |_| |/ _ \ | '_ \   //
//  | |__| (_) | | | | ||  __/>  <| |_  |  _  |  __/ | |_) |  //
//   \____\___/|_| |_|\__\___/_/\_\\__| |_| |_|\___|_| .__/   //
//                                                   |_|      //
////////////////////////////////////////////////////////////////

// CONTEXT SENSITIVE HELP NOTES using DOXYGEN GENERATED DOCS

// doxygen generates doc/html/group__*.html files that will contain the desired documentation
//
// Each documented item has a tag similar to the following:
//
//   <!-- doxytag: member="window_helper.h::WBSetInputFocus" ref="ga28d82cd699b08cf93278ae26c5ad4788" args="(Window wID)" -->
//
// jumping to the correct HTML link with the anchor set to the 'ref' value will open it up in doxygen, as
//
// file:///usr/local/share/X11workbench/doc/html/group__wcore.html#ga28d82cd699b08cf93278ae26c5ad4788
//

static char * InternalMan2Html(const char *szTerm, const char *szText);

void DoContextSensitiveHelp(const char *szTerm)
{
char szDocFilePath[PATH_MAX * 2], szName[PATH_MAX];
char *p1, *p2, *p3;//, *p5;
const char *p4;
void *pSettings, *pDirList;
int i1;
unsigned long dwAttr;
FILE *pTemp;
WB_FILE_HANDLE hProcess;
static char szLineBuf[4096], szDoxyTag[PATH_MAX * 2 + 512], szHelpBrowser[PATH_MAX];


  // step 1:  get 'docs' directory from settings, and if there isn't a setting for it,
  //          use the current directory + "docs/html"

  bzero(szDocFilePath, sizeof(szDocFilePath));


  pSettings = CHOpenConfFile(APP_NAME, CH_FLAGS_DEFAULT);

  if(pSettings)
  {
    if(0 >= CHGetConfFileString(pSettings, "paths", "browser", szHelpBrowser, sizeof(szHelpBrowser)))
    {
      WB_ERROR_PRINT("ERROR did not find 'paths' 'browser', using default\n");
      goto find_url_opener;
    }
//    else
//    {
//      WB_ERROR_PRINT("TEMPORARY: %s - browser \"%s\"\n", __FUNCTION__, szHelpBrowser);
//    }

    i1 = CHGetConfFileString(pSettings, "paths","documentation",szDocFilePath, sizeof(szDocFilePath) - 2);

    CHCloseConfFile(pSettings);
    pSettings = NULL;
  }
  else
  {
find_url_opener:

    i1 = 0;

    p1 = CHGetMimeDefaultApp("text/html");
    p2 = p3 = NULL;

    if(!p1 || *p1 <= ' ')
    {
      if(p1)
      {
        WBFree(p1);
      }

      p1 = CHGetMimeDefaultApp("x-scheme-handler/http"); // Mate uses this one
    }

    if(p1 && *p1 > ' ')
    {
      if(strlen(p1) > 8 /* strlen(".desktop") */ &&
         !memcmp(p1 + strlen(p1) - 8, ".desktop", 8)) // it's a '.desktop' file
      {
        p2 = p1;
        p1 = CHGetDesktopFileInfo(p2, "Exec");
        // NOTE:  the 'Exec' string will have a '%f' or '%u' or similar in it.  trim that.

        if(!p1)
        {
          p1 = p2; // restore original, hope it still works
        }
        else
        {
          WBFree(p2);
          p2 = p1 + strlen(p1);

          while(p2 > p1 && *(p2 - 1) <= ' ')
          {
            *(--p2) = 0; // right-trim
          }

          if(p2 >= p1 + 2 && *(p2 - 2) == '%' &&
             (*(p2 - 1) == 'u' || *(p2 - 1) == 'U' || *(p2 - 1) == 'f' || *(p2 - 1) == 'F'))
          {
            p2 -= 2;
            *p2 = 0; // trim off argument

            while(p2 > p1 && *(p2 - 1) <= ' ')
            {
              *(--p2) = 0; // right-trim
            }
          }

          // NOTE:  for _NOW_ assume that there are no extra parameters [later I'll fix that...]
        }
      }

      strcpy(szHelpBrowser, p1);
      WBFree(p1);

      p1 = NULL;
      p2 = NULL;
    }
    else
    {
      if(p1)
      {
        WBFree(p1);
      }

      WB_ERROR_PRINT("%s - No default browser available!\n", __FUNCTION__);
      return;
    }
  }

  if(i1 <= 0)
  {
    p1 = WBGetCanonicalPath("doc/html/");
    if(p1)
    {
      strncpy(szDocFilePath, p1, sizeof(szDocFilePath) - 2);
      WBFree(p1);
    }
    else
    {
      strcpy(szDocFilePath, "doc/html/");
    }
  }

  if(szDocFilePath[strlen(szDocFilePath) - 1] != '/')
  {
    strcat(szDocFilePath, "/");
  }

//  WB_ERROR_PRINT("TEMPORARY: %s - szDocFilePath = \"%s\"\n", __FUNCTION__, szDocFilePath);
//  WB_ERROR_PRINT("           %s - szTerm = \"%s\"\n", __FUNCTION__, szTerm);

  p1 = szDocFilePath + strlen(szDocFilePath);

  // now that THAT mess is over with, determine which file has the appropriate term in it,
  // and invoke the default web browser to open that link.  I'll do this using 'xdg-open'.

  strcpy(p1, "group__*.html");

  pDirList = WBAllocDirectoryList(szDocFilePath);

  *p1 = 0; // 'szDocFilePath' is once again, ONLY a path
  szDoxyTag[0] = 0; // it will be a flag

  if(!pDirList)
  {
    WB_ERROR_PRINT("ERROR:  %s no dir list \"%s\"\n", __FUNCTION__, szDocFilePath);
    return;
  }
  else
  {
    while(!WBNextDirectoryEntry(pDirList, szName, sizeof(szName), &dwAttr))
    {
      if(S_ISREG(dwAttr))
      {
        strcpy(p1, szName);

//        WB_ERROR_PRINT("TEMPORARY:  opening \"%s\"\n", szDocFilePath);

        pTemp = fopen(szDocFilePath, "r");
        if(!pTemp)
        {
          WB_ERROR_PRINT("ERROR:  %s - unable to open \"%s\"\n", __FUNCTION__, szDocFilePath);
        }
        else
        {
          *p1 = 0; // file name not needed now, but path name IS needed

          while(!feof(pTemp))
          {
            if(!fgets(szLineBuf, sizeof(szLineBuf), pTemp))
            {
              break;
            }

            // THIS METHOD APPLIES TO Doxygen version 1.8.3.1 and later
            // (it has also been tested with Doxygen 1.8.13.2)
            // If you have an earlier version of doxygen, consider UPGRADING PLEASE!
            // If you cannot upgrade Doxygen, and this API does not work with your
            // generated documentation, consider downloading the pre-built documentation.

            if(NULL != (p2 = strstr(szLineBuf, "class=\"el\"")))
            {
              while(p2 > szLineBuf && *p2 != '<') // search for start of tag
              {
                p2--;
              }

              if(p2 >= szLineBuf && *p2 == '<')
              {
                // parse the tag, find 'href'

                p4 = CHFindEndOfXMLTag(p2, -1); // XML parse helper

                if(*p4 == '>')
                {
                  // the search term will be the 'anchor' term.

                  if(!memcmp(p4 + 1, szTerm, strlen(szTerm)) &&
                     !memcmp(p4 + 1 + strlen(szTerm), "</a>", 4)) // ending tag
                  {
                    p3 = CHParseXMLTagContents(p2, p4 - p2);
                    if(p3)
                    {
                      // now that I have the tag, grab the 'href' member
                      for(p2=p3; *p2; p2 += strlen(p2) + 1)
                      {
                        if(!strncmp(p2, "href=", 5))
                        {
                          strcpy(szDoxyTag, "file://");
                          strcat(szDoxyTag, szDocFilePath); // the path only at this point
                          strcat(szDoxyTag, p2 + 5); // the 'href' text
                          break;
                        }
                      }

                      WBFree(p3);
                      if(szDoxyTag[0])
                      {
                        break;
                      }
                    }
                  }
                }
              }
            }

#if 0 /* this is the OLD way - new method uses '<a class="el" href="">' tags */
            if(strstr(szLineBuf, "doxytag"))
            {
              p2 = strstr(szLineBuf, szTerm);

              if(p2 && p2 > szLineBuf + 10 && *(p2 - 1) == ':' && *(p2 - 2) == ':' &&
                 (p2[strlen(szTerm)] == '"' || p2[strlen(szTerm)] == '\'')) // must be followed by a quote mark
              {
                // grab the entire XML tag
                while(p2 > szLineBuf && (*p2 != '<' || p2[1] != '!' || p2[2] != '-' || p2[3] != '-'))
                {
                  p2--;
                }

                if(*p2 == '<' && p2[1] == '!' && p2[2] == '-' && p2[3] == '-') // doxytag comment block
                {
                  p4 = CHFindEndOfXMLTag(p2 + 4, -1); // point past the '<!--' first, then find the end

                  if(*p4 == '>')
                  {
                    p3 = CHParseXMLTagContents(p2 + 4, p4 - (p2 + 4));
                    if(p3)
                    {
                      // now that I have the tag, grab the 'ref' member
                      for(p2=p3; *p2; p2 += strlen(p2) + 1)
                      {
                        if(!strncmp(p2, "ref=", 4))
                        {
                          strcpy(szDoxyTag, "file://");
                          strcat(szDoxyTag, szDocFilePath);
                          strcat(szDoxyTag, "#");
                          strcat(szDoxyTag, p2 + 4);
                          break;
                        }
                      }

                      WBFree(p3);
                      if(szDoxyTag[0])
                      {
                        break;
                      }
// TODO:  with this much nesting, consider writing utility functions
//        to do some of it and make the code more readable
                    }
                  }
                }
              }
            }
#endif // 0
          }

          fclose(pTemp);
          pTemp = NULL; // by convention
        }
      }
    }
  }

  if(szDoxyTag[0]) // found the right file
  {
//    WB_ERROR_PRINT("TEMPORARY:  %s  spawn %s\n   with \"%s\"\n\n",
//                   __FUNCTION__, szHelpBrowser, szDoxyTag);
    hProcess = WBRunAsync(szHelpBrowser, szDoxyTag, NULL);

    // TODO:  does '--new-instance' work properly?

    if(hProcess != WB_INVALID_FILE_HANDLE)
    {
      // TODO:  display 'wait' cursor and wait for app window to appear ?

      return;
    }

    goto fail_to_run_help;
  }

  // TODO:  other documentation

  // search for related language runtime library MAN pages
  // command line:  man -S 2:3 keyword - pipe output via man2html then open temp html and delete it

  // TODO:  write 'man to HTML' mini-web-server?
  // TODO:  use embedded web client if webkit is available?

  p2 = WBRunResult("man", "-S", "2:3", szTerm, NULL);
  if(!p2 || !*p2)
  {
    if(p2)
    {
      WBFree(p2);
      p2 = NULL;
    }

fail_to_run_man2html:
//      WB_ERROR_PRINT("TEMPORARY:  fail to run man2html \"%s\"\n", p1);

    goto fail_to_run_help;
  }

//    WB_ERROR_PRINT("TEMPORARY:  man output \"%s\"\n", p2);

    // instead of calling an external program to convert, I wrote something
    // that does the conversion as reliably as possible.  external scripts
    // sometimes 'pooch up' the HTML version of the man page, inject garbage,
    // lose large chunks of text, or have issues with hyphenated words.
    // it's possible MY code may exhibit similar problems, but I think I've
    // nailed the issues without too much trouble.  And, if I ever set up a
    // web server for the help system, I'll fix linkage as well.  That would be
    // EVEN MORE interesting, actually... (and it's less troublesome than trying
    // to get groff to work with man consistently across multiple platforms)

  p3 = InternalMan2Html(szTerm, p2);

  WBFree(p2);
  p2 = NULL;

  if(!p3)
  {
    WB_ERROR_PRINT("Failed to run InternalMan2Html in %s\n", __FUNCTION__);
    goto fail_to_run_man2html;
  }

  p2 = WBTempFile(".html"); // temporary HTML file

    // write 'p3' to a temp html file now
  if(!p2) // new temp file name
  {
    WBFree(p3);
    p3 = NULL;

//      WB_ERROR_PRINT("TEMPORARY:  here I am (2)\n");
    goto fail_to_run_man2html;
  }

  if(FBWriteFileFromBuffer(p2, p3, strlen(p3)) < 0)
  {
//      WB_ERROR_PRINT("TEMPORARY:  here I am (3) p2=\"%s\"\n", p2);

    WBFree(p2);
    WBFree(p3);
    p2 = p3 = NULL;

    goto fail_to_run_man2html;
  }

  // p2 contains the ".html" temp file name

  hProcess = WBRunAsync(szHelpBrowser, p2, NULL);

  // TODO:  does '--new-instance' work properly?


  WBFree(p2);
  WBFree(p3);
  p1 = p2 = p3 = NULL;

  if(hProcess != WB_INVALID_FILE_HANDLE)
  {
    // TODO:  display 'wait' cursor and wait for app window to appear ?

    return;
  }



fail_to_run_help:

  p1 = WBCopyString("No help available for \"");
  WBCatString(&p1, szTerm);
  WBCatString(&p1, "\"");

  if(p1)
  {
    Window wIDOwner = pMainFrame ? pMainFrame->wID : -1;

    DLGMessageBox(MessageBox_OK | MessageBox_MiddleFinger, wIDOwner,
                  "Context Help", p1);

    WBFree(p1);
  }
}

static char * CreateNBSPString(const char *szRef, int nLen)
{
static const char szNBSP[]="&nbsp";
int i1, i2;
char *pRval;

#define NBSP_TAB_WIDTH 8

  if(nLen < 0)
  {
    return NULL;
  }

  pRval = WBAlloc(nLen * 8 * (sizeof(szNBSP) - 1) + 2);

  if(pRval)
  {
    char *p2 = pRval;
    const char *p1 = szRef;

    for(i1=0, i2=0; i1 < nLen; p1++, i1++, i2 = (i2 + 1) % NBSP_TAB_WIDTH)
    {
      if(*p1 == '\t')
      {
        for(; i2 < NBSP_TAB_WIDTH; i2++)
        {
          memcpy(p2, szNBSP, sizeof(szNBSP) - 1);
          p2 += sizeof(szNBSP) - 1;
        }
        i2 = NBSP_TAB_WIDTH - 1; // tab position
      }
      else
      {
        memcpy(p2, szNBSP, sizeof(szNBSP) - 1);
        p2 += sizeof(szNBSP) - 1;
      }
    }

    *p2 = 0;
  }

  return pRval;
}



////////////////////////////////////////////////////////////////////
//   __  __    _    _   _   _          _   _ _____ __  __ _       //
//  |  \/  |  / \  | \ | | | |_ ___   | | | |_   _|  \/  | |      //
//  | |\/| | / _ \ |  \| | | __/ _ \  | |_| | | | | |\/| | |      //
//  | |  | |/ ___ \| |\  | | || (_) | |  _  | | | | |  | | |___   //
//  |_|  |_/_/   \_\_| \_|  \__\___/  |_| |_| |_| |_|  |_|_____|  //
//                                                                //
////////////////////////////////////////////////////////////////////

static char * InternalMan2Html(const char *szTerm, const char *szText)
{
char *pRval, *p1, *p2, *pTemp, *pHyphenBuf = NULL;
const char *p3, *p4, *p5;
int i1, i2, cbLineLen, nTabTwist, bNoHyphen = 0;
static const char szNBSP[]="&nbsp;";


  pRval = WBCopyString("<HTML><HEAD><TITLE>X11workbench Help - man ");
  if(pRval)
  {
    WBCatString(&pRval, szTerm);

    if(pRval)
    {
      WBCatString(&pRval, "</TITLE></HEAD><BODY><TT>\r\n");
    }
  }

  if(!pRval)
  {
    return NULL;
  }

  p3 = szText;

  while(*p3 && pRval)
  {
    // skip white space
    p4 = p3;
    nTabTwist = 0;

    while(*p3 && *p3 <= ' ')
    {
      if(*p3 == '\r' || *p3 == '\n' || *p3 == '\f')
      {
        // TODO:  handle tabs?
        pTemp = CreateNBSPString(p4, p3 - p4);
        if(pTemp)
        {
          WBCatString(&pRval, pTemp);
          WBFree(pTemp);
          pTemp = NULL;
        }

        if(pHyphenBuf)
        {
          // rare possibility of hyphenated text on a blank line
          // but I want to indent it past the end of the white space
          if(pRval)
          {
            WBCatString(&pRval, pHyphenBuf);
          }

          WBFree(pHyphenBuf);
          pHyphenBuf = NULL;
        }

        p4 = p3; // to indicate I shouldn't copy anything
        break; // it will fall through to the next part
      }

      if(*p3 == '\t')
      {
        nTabTwist = 0; // reset after a tab
      }
      else
      {
        nTabTwist++;
      }

      p3++;
    }

    nTabTwist = nTabTwist % NBSP_TAB_WIDTH; // 'tab twist' for converting tabs

    if(pRval && p3 > p4)
    {
      pTemp = CreateNBSPString(p4, p3 - p4);
      if(pTemp)
      {
        WBCatString(&pRval, pTemp);
        WBFree(pTemp);
        pTemp = NULL;
      }

      p4 = p3;
    }

    if(!pRval)
    {
      break;
    }

    // at this point 'p3' and 'p4' point to the first non-white-space character
    // and all of the white space (any any 'hyphen buf' stuff) is copied

    while(*p3 && *p3 != '\r' && *p3 != '\n' && *p3 != '\f')
    {
      p3++; // go to the end of the line
    }

    cbLineLen = p3 - p4; // not including CR, LF, or FF

    if(*p3 == '\r' && p3[1] == '\n') // for now just check for <CRLF>
    {
      p3++;
    }

    p3++;

    if(!cbLineLen || pHyphenBuf) // blank line
    {
      // if I have de-hyphenated text, I need to INSERT it into the buffer.  There will be no tabs
      // in it and for NOW I'll assume there's no bolding nor underlining [later I might have to
      // check for this independently and I don't want to complicate this any more]

      if(pHyphenBuf)
      {
        nTabTwist = (nTabTwist + strlen(pHyphenBuf)) % NBSP_TAB_WIDTH;

        WBCatString(&pRval, pHyphenBuf);

        WBFree(pHyphenBuf);
        pHyphenBuf = NULL;
      }

      if(!cbLineLen)
      {
        if(pRval)
        {
          WBCatString(&pRval, "<br>\r\n");
        }

        continue;
      }
    }

    // I need to look for backspaces and handle them as bold-text or underscores (depending)

#define STRSEGCMP(X,Y) strncmp(X,Y,strlen(Y))

    if(!bNoHyphen &&
       (!STRSEGCMP(p4, "SEE ALSO") ||
        !STRSEGCMP(p4, "S\x08""SE\x08""EE\x08""E A\x08""AL\x08""LS\x08""SO\x08""O") ||
        !STRSEGCMP(p4, "S\x08""SE\x08""EE\x08""E \x08 A\x08""AL\x08""LS\x08""SO\x08""O")))
    {
      bNoHyphen = 1;
    }

    p5 = p4; // p4 is the beginning of my line, of 'cbLineLen' characters

    while(p5 < p3 && *p5 != '\x08' && *p5 != '<' && *p5 != '>') // backspace in the line? 'GT'? 'LT'?
    {
      p5++;
    }

    if(p5 >= p3 || !cbLineLen) // no backspaces or zero-length line
    {
      if(cbLineLen)
      {
        // if there are tabs in the line I have to deal with this differently
        p5 = p4;
        i1 = 0;

        while(p5 < p3) // tabs?
        {
          if(*p5 == '\t')
          {
            i1++; // count them
          }

          p5++;
        }
        if(!i1) // no tabs
        {
          WBCatStringN(&pRval, p4, cbLineLen);
        }
        else
        {
          // each tab converts to a variable number of spaces up to NBSP_TAB_WIDTH
          // this is a little silly but it's probably the easiest way to make it work

          pTemp = WBAlloc(i1 * NBSP_TAB_WIDTH * (sizeof(szNBSP) - 1) + cbLineLen + 4);
          if(!pTemp)
          {
            WBFree(pRval);
            pRval = NULL;

            break; // buh-bye (error)
          }

          for(p1=pTemp, p5 = p4, i1 = 0, i2=nTabTwist; i1 < cbLineLen;
              i1++, p5++, i2 = (i2 + 1) % NBSP_TAB_WIDTH)
          {
            if(*p5 == '\t')
            {
              for(; i2 < NBSP_TAB_WIDTH; i2++)
              {
                memcpy(p1, szNBSP, sizeof(szNBSP) - 1);
                p1 += sizeof(szNBSP) - 1;
              }

              i2 = NBSP_TAB_WIDTH - 1; // so when it increments it will be zero
            }
            else
            {
              *(p1++) = *p5;
            }
          }

          *p1 = 0;

          WBCatString(&pRval, pTemp);

          WBFree(pTemp);
          pTemp = NULL;
        }

        // check for hyphenated text

        if(pRval)
        {
          p2 = pRval + strlen(pRval);

          if(bNoHyphen)
          {
            if(*(p2 - 1) == '-')
            {
              p2--;
              *p2 = 0; // trim the dash

              while(p2 > pRval && *(p2 - 1) > ' ' && *(p2 - 1) != '.'
                    && *(p2 - 1) != ',' && *(p2 - 1) != ')' && *(p2 - 1) != ']' && *(p2 - 1) != '}')
              {
                p2--; // decrement until at the beginning of a word
              }

              pHyphenBuf = WBCopyString(p2);
              *p2 = 0; // trim hyphenated partial word off of the string

//              WB_ERROR_PRINT("TEMPORARY:  (d) pHyphenBuf=\"%s\"\n", pHyphenBuf);
            }
            else if(p2 > pRval + 3 && *(p2 - 3) == '\xe2' && *(p2 - 2) == '\x80' && *(p2 - 1) == '\x90')
            {
              // the sequence <E2><80><90> is found on debian's man program, and since they
              // define the gnu standard, it's likely to be elsewhere also

              p2 -= 3; // 3 character sequence (remove it)
              *p2 = 0; // trim the 3 character sequence

              while(p2 > pRval && *(p2 - 1) > ' ' && *(p2 - 1) != '.'
                    && *(p2 - 1) != ',' && *(p2 - 1) != ')' && *(p2 - 1) != ']' && *(p2 - 1) != '}')
              {
                p2--; // decrement until at the beginning of a word
              }

              pHyphenBuf = WBCopyString(p2);
              *p2 = 0; // trim hyphenated partial word off of the string

//              WB_ERROR_PRINT("TEMPORARY:  (e) pHyphenBuf=\"%s\"\n", pHyphenBuf);
            }
          }
          else if(p2 > pRval + 3 && *(p2 - 3) == '\xe2' && *(p2 - 2) == '\x80' && *(p2 - 1) == '\x90')
          {
            // the sequence <E2><80><90> is found on debian's man program, and since they
            // define the gnu standard, it's likely to be elsewhere also

            p2 -= 2; // 3 character sequence (remove it, replace with '-')
            *(p2 - 1) = '-';
            *p2 = 0; // trim the 3 character sequence

//            WB_ERROR_PRINT("TEMPORARY:  (f) pHyphenBuf=\"%s\"\n", pHyphenBuf);
          }
        }
      }

      if(pRval)
      {
        WBCatString(&pRval, "<br>\r\n");
      }
    }
    else
    {
      p5 = p4;
      i1 = 0;

      while(p5 < p3) // tabs?
      {
        if(*p5 == '\t')
        {
          i1++; // count them
        }

        p5++;
      }

      pTemp = WBAlloc(i1 * NBSP_TAB_WIDTH * (sizeof(szNBSP) - 1) + cbLineLen * 12 + 4); // way more than enough space (12 times the length)

      if(!pTemp)
      {
        WBFree(pRval);
        pRval = NULL;
        break;
      }

      memcpy(pTemp, p4, cbLineLen);
      pTemp[cbLineLen] = 0;

      p2 = pTemp;
      i2 = nTabTwist;

      while(*p2)
      {
        if(*p2 == '\x8') // backspace at start of line?
        {
          strcpy(p2, p2 + 1); // just skip it
          continue;
        }

        if(p2[1] == '\x8') // next char is a backspace (this precludes line starting with a backspace
        {
          // there are 2 options possible - one is A<BS>A and the other is _<BS>A or A<BS>_ [either fine]

          if(*p2 == p2[2]) // BOLD
          {
            // Insert a <B> here and overwrite the first 2 characters

            memmove(p2 + 1, p2, strlen(p2) + 1); // 2 chars overwritten, move over 1
            memcpy(p2, "<B>", 3);

            p2 += 3; // point to the original character

            // if the first character in the sequence is a '<' or '>' I have to deal with it FIRST
            if(*p2 == '<' || *p2 == '>')
            {
              char cTemp = *p2;

              memmove(p2 + 3, p2, strlen(p2) + 1); // need room for '&gt;' or '&lt;' overwriting the original

              if(cTemp == '<')
              {
                memcpy(p2, "&lt;", 4);
              }
              else  // if(cTemp == '>')
              {
                memcpy(p2, "&gt;", 4);
              }

              p2 += 4; // increment past the tag
            }
            else
            {
              p2++; // increment past the character
            }

            while(*p2 && p2[1] == '\x8' && *p2 == p2[2])
            {
              if(*p2 == '<' || *p2 == '>')
              {
                char cTemp = *p2;

                memmove(p2 + 1, p2, strlen(p2) + 1); // need room for '&gt;' or '&lt;' and minus 3 chars

                if(cTemp == '<')
                {
                  memcpy(p2, "&lt;", 4);
                }
                else  // if(cTemp == '>')
                {
                  memcpy(p2, "&gt;", 4);
                }

                p2 += 4; // increment past the tag
              }
              else
              {
                memcpy(p2, p2 + 2, strlen(p2 + 2) + 1); // skip the A<BS> and just have A
                p2++;
              }
            }

            // now that I'm at the end of the sequence, insert </B>

            memmove(p2 + 4, p2, strlen(p2) + 1);
            memcpy(p2, "</B>", 4);

            p2 += 4;
            continue;
          }
          else if(*p2 == '_' || p2[2] == '_') // UNDERSCORE
          {
            // Insert a <U> here

            memmove(p2 + 1, p2, strlen(p2) + 1); // 2 chars overwritten, move over 1
            if(*p2 != '_')
            {
              p2[2] = *p2; // move the character to underline "up there"
            }
            memcpy(p2, "<U>", 3);

            p2 += 3; // point to the original 'underscored' character

            // if the first character in the sequence is a '<' or '>' I have to deal with it FIRST
            if(*p2 == '<' || *p2 == '>')
            {
              char cTemp = *p2;

              memmove(p2 + 3, p2, strlen(p2) + 1); // need room for '&gt;' or '&lt;' overwriting the original

              if(cTemp == '<')
              {
                memcpy(p2, "&lt;", 4);
              }
              else  // if(cTemp == '>')
              {
                memcpy(p2, "&gt;", 4);
              }

              p2 += 4; // increment past the tag
            }
            else
            {
              p2++; // increment past the character
            }


            while(*p2 && p2[1] == '\x8' && (*p2 == '_' || p2[2] == '_'))
            {
              if(*p2 == '_')
              {
                *p2 = p2[2]; // move it "back down"
              }

              if(*p2 == '<' || *p2 == '>')
              {
                char cTemp = *p2;

                memmove(p2 + 1, p2, strlen(p2) + 1); // need room for '&gt;' or '&lt;' and minus 3 chars

                if(cTemp == '<')
                {
                  memcpy(p2, "&lt;", 4);
                }
                else  // if(cTemp == '>')
                {
                  memcpy(p2, "&gt;", 4);
                }

                p2 += 4; // increment past the tag
              }
              else
              {
                memcpy(p2, p2 + 2, strlen(p2 + 2) + 1); // skip the A<BS> and just have A
                p2++;
              }
            }

            // now that I'm at the end of the sequence, insert </U>

            memmove(p2 + 4, p2, strlen(p2) + 1);
            memcpy(p2, "</U>", 4);

            p2 += 4;
            continue;
          }
        }
        else if(*p2 == '<' || *p2 == '>')
        {
          memmove(p2 + 3, p2, strlen(p2) + 1); // need room for '&gt;' or '&lt;'

          if(*p2 == '<')
          {
            memcpy(p2, "&lt;", 4);
          }
          else  // if(*p2 == '>')
          {
            memcpy(p2, "&gt;", 4);
          }

          p2 += 3;  // point at the ';' and loop
        }

        // once THAT has been done, check for a tab character and insert '&nbsp;'s
        if(*p2 == '\t')
        {
          p1 = p2; // current position - has a tab in it
          p2 += (sizeof(szNBSP) - 1) * (NBSP_TAB_WIDTH - i2); // next character to process, skips nbsp's

          if(p1[1])
          {
            memmove(p2, p1 + 1, strlen(p1 + 1) + 1); // don't copy the tab, but DO copy everything else (p1 + 1)
          }
          else
          {
            *p2 = 0; // end the string (I'm at the end)
          }

          for(; i2 < NBSP_TAB_WIDTH; i2++)
          {
            memcpy(p1, szNBSP, sizeof(szNBSP) - 1);
            p1 += sizeof(szNBSP) - 1;
          }

          i2 = 0; // no tab twist at the moment
        }
        else
        {
          p2++; // next character
          i2 = (i2 + 1) % NBSP_TAB_WIDTH; // "tab twist"
        }
      }

      // pTemp now contains the entire 'cooked' line.  If I must trim off a trailing hyphen
      // put the text into 'pHyphenBuf'.  Then create a line from the rest

      p2 = pTemp + strlen(pTemp);

      if(bNoHyphen)
      {
        if(*pTemp && *(p2 - 1) == '-') // hyphenated
        {
          p2--;
          *p2 = 0; // trim the dash

          while(p2 > pTemp && *(p2 - 1) > ' ' && *(p2 - 1) != '.'
                && *(p2 - 1) != ',' && *(p2 - 1) != ')' && *(p2 - 1) != ']' && *(p2 - 1) != '}')
          {
            p2--; // decrement until at the beginning of a word
          }

          pHyphenBuf = WBCopyString(p2);
          *p2 = 0; // trim hyphenated partial word off of the string

//          WB_ERROR_PRINT("TEMPORARY:  (b) pHyphenBuf=\"%s\"\n", pHyphenBuf);
        }
        else if(p2 > pTemp + 3 && *(p2 - 3) == '\xe2' && *(p2 - 2) == '\x80' && *(p2 - 1) == '\x90')
        {
          // the sequence <E2><80><90> is found on debian's man program, and since they
          // define the gnu standard, it's likely to be elsewhere also

          p2 -= 3; // 3 character sequence (remove it)
          *p2 = 0; // trim the 3 character sequence

          while(p2 > pTemp && *(p2 - 1) > ' ' && *(p2 - 1) != '.'
                && *(p2 - 1) != ',' && *(p2 - 1) != ')' && *(p2 - 1) != ']' && *(p2 - 1) != '}')
          {
            p2--; // decrement until at the beginning of a word
          }

          pHyphenBuf = WBCopyString(p2);
          *p2 = 0; // trim hyphenated partial word off of the string

//          WB_ERROR_PRINT("TEMPORARY:  (c) pHyphenBuf=\"%s\"\n", pHyphenBuf);
        }
      }
      else  if(p2 > pTemp + 3 && *(p2 - 3) == '\xe2' && *(p2 - 2) == '\x80' && *(p2 - 1) == '\x90')
      {
        // the sequence <E2><80><90> is found on debian's man program, and since they
        // define the gnu standard, it's likely to be elsewhere also

        p2 -= 2; // 3 character sequence (remove it, replace with '-')
        *(p2 - 1) = '-';
        *p2 = 0; // trim the 3 character sequence

//      WB_ERROR_PRINT("TEMPORARY:  (f) pHyphenBuf=\"%s\"\n", pHyphenBuf);
      }

      strcat(pTemp, "<br>\r\n");

      if(pRval)
      {
        WBCatString(&pRval, pTemp);
      }

      WBFree(pTemp);
      pTemp = NULL; // by convention
    }
  }

  if(pRval)
  {
    WBCatString(&pRval, "<br>\r\n<hr size=2>\r\n<p align=\"center\">Generated internally by X11workbench</p>\r\n"
                "</TT></BODY></HTML>\r\n");
  }

  return pRval;
}

