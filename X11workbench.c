/////////////////////////////////////////////////////////////////////////////////////////
//  __  __ _  _                        _     _                         _               //
//  \ \/ // |/ |__      __ ___   _  _ | | __| |__    ___  _ __    ___ | |__      ___   //
//   \  / | || |\ \ /\ / // _ \ | '__|| |/ /| '_ \  / _ \| '_ \  / __|| '_ \    / __|  //
//   /  \ | || | \ V  V /| (_) || |   |   < | |_) ||  __/| | | || (__ | | | | _| (__   //
//  /_/\_\|_||_|  \_/\_/  \___/ |_|   |_|\_\|_.__/  \___||_| |_| \___||_| |_|(_)\___|  //
//                                                                                     //
//                          'main' source for X11workbench                             //
//                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2019 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                           all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is linked with, equivalent to, or derived from any portion of this
  software, along with this paragraph that explains the terms of the license if
  the source is also being made available.  "Linked with" includes the use of a
  portion of any of the source and/or header files, or their compiled binary
  output, as a part of your application or library.   A "derived work"
  describes a work that uses a significant portion of the source files or the
  algorithms that are included with this software.

  EXCLUSIONS

  Specifically excluded from this requirement are files that were generated by
  the software, or anything that is included with the software that is part of
  another package (such as files that were created or added during the
  'configure' process).

  DISTRIBUTION

  The license also covers the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application, in source or
  binary form.  If you do not ship the source, the above copyright statement
  and DISCLAIMER is still required to be placed in a reasonably prominent
  place, such as documentation, splash screens, and/or 'about the application'
  dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README.md files for more information.

  Additionally, this software, in source or binary form, and in whole or in
  part, may be used by explicit permission from the author, without the need
  of a license.

  Additional information at http://sourceforge.net/projects/X11workbench
  and http://bombasticbob.github.io/X11workbench/

******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <signal.h>
#include <time.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>

// project includes
#include "X11workbench.h"
#include "gizzard.h"
#include "gdb_helper.h"
#include "refactor.h"
#include "context_help.h"
#include "resource_edit.h"

// X11workbench toolkit library includes
#include "window_helper.h"
#include "pixmap_helper.h"  // pixmap helpers, including pre-defined icons
#include "frame_window.h"
#include "edit_window.h"    // edit (client) window
#include "dialog_window.h"
#include "file_help.h"
#include "conf_help.h"
#include "draw_text.h"

// pixmap data
#include "application_icon.xpm" /* 19x19 icon presented to the OS for alt-tab etc. */
#include "icon_app.xpm"   /* application icon that's the same size as the others, 36x36 */
#include "textfiledoc.xpm"
#include "newdoc.xpm"
#include "clangdoc.xpm"
#include "makefiledoc.xpm"


//#define NO_SPLASH /* temporary, later put it as a configure option - need to get 'gleam' to work better */

//#define STRING  "Hello, world"
//#define BORDER  32 /* was 1 */
//#define FONT    "fixed"


#ifndef NO_SPLASH
#include "splash.xpm" // splash pixmap
#endif // NO_SPLASH


// copyright string '(c)' or the UTF8 symbol - if I support UTF8, use the circle-c version
#ifdef X_HAVE_UTF8_STRING

// 11 bits    U+07FF      110xxxxx 10xxxxxx
// A9 --> 10101001 --> 11000010 10101001 --> C2 A9
#define UTF8_COPYRIGHT "\xc2""\xa9"

// TODO:  any other UTF8-specific strings can be defined here
#endif // X_HAVE_UTF8_STRING




// function prototypes

static int do_main(int argc, char *argv[], char *envp[]);
static void SetSignalHandlers(void);
static int MyWindowCallback(Window wID, XEvent *pEvent);
static int ApplicationPreferences(XClientMessageEvent *pEvent);
static int FileExitHandler(XClientMessageEvent *);
static int FileNewHandler(XClientMessageEvent *);
static int FileOpenHandler(XClientMessageEvent *);
static int FileSaveHandler(XClientMessageEvent *);
static int FileSaveUIHandler(WBMenu *, WBMenuItem *);
static int FileSaveAsHandler(XClientMessageEvent *);
static int FileSaveAsUIHandler(WBMenu *, WBMenuItem *);
static int FileSaveAllHandler(XClientMessageEvent *);
static int FileSaveAllUIHandler(WBMenu *, WBMenuItem *);
static int FileCloseHandler(XClientMessageEvent *);

static int HelpAboutHandler(XClientMessageEvent *);
static int HelpContentsHandler(XClientMessageEvent *);
static int HelpContextHandler(XClientMessageEvent *);

static int TabLeftHandler(XClientMessageEvent *);
static int TabRightHandler(XClientMessageEvent *);
static int TabMoveLeftHandler(XClientMessageEvent *);
static int TabMoveRightHandler(XClientMessageEvent *);
static int TabUIHandler(WBMenu *, WBMenuItem *);

static int ToolBoxHandler(XClientMessageEvent *pEvent);
static int ToolBoxUIHandler(WBMenu *pMenu, WBMenuItem *pMenuItem);

int DoFileOpen(WBFrameWindow *pMainFrame, const char *szFileName);
WBFILE_TYPE GetFileType(const char *szFileName); // return one of the WBFILE_TYPE constants


// global vars
int nCPU = 0;


int WBMain(int argc, char *argv[], char *envp[])
{
int iRval = 1;

  iRval = do_main(argc, argv, envp);

  if(iRval < 0)
  {
    WBUsage();
  }

  return iRval;
}


// global variables

static Display       *pX11Display = NULL;            /* X server connection */
static WBFrameWindow *pMainFrame = NULL;
static XColor         clrGreen;


Window GetFrameWindowID()
{
  if(!pMainFrame)
  {
    return None;
  }

  return pMainFrame->wID;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//   _____                          __        ___           _                 ____  _                   _         //
//  |  ___| __ __ _ _ __ ___   ___  \ \      / (_)_ __   __| | _____      __ / ___|| |_ _ __ _   _  ___| |_ ___   //
//  | |_ | '__/ _` | '_ ` _ \ / _ \  \ \ /\ / /| | '_ \ / _` |/ _ \ \ /\ / / \___ \| __| '__| | | |/ __| __/ __|  //
//  |  _|| | | (_| | | | | | |  __/   \ V  V / | | | | | (_| | (_) \ V  V /   ___) | |_| |  | |_| | (__| |_\__ \  //
//  |_|  |_|  \__,_|_| |_| |_|\___|    \_/\_/  |_|_| |_|\__,_|\___/ \_/\_/   |____/ \__|_|   \__,_|\___|\__|___/  //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// application menu and the application menu handler structure 'main_menu_handlers'

///////////////////////////////////////////////////////////////////////
// default application menu - what I see when there's no open document
///////////////////////////////////////////////////////////////////////
static char szAppMenu[]="1\n"
                        "_File\tpopup\t2\n"
                        "_Tools\tpopup\t5\n"
                        "\tseparator\n"
                        "_Help\tpopup\t3\n"
                        "\n"
                        "2\n"
                        "_New File\tIDM_FILE_NEW\tNew File\tCtrl+N\n"
                        "_Open File\tIDM_FILE_OPEN\tOpen File\tCtrl+O\n"
                        "\tseparator\n"
                        "_Preferences\tIDM_PREFERENCES\tApplication Preferences\tCtrl+P\n"
                        "\tseparator\n"
                        "E_xit\tIDM_FILE_EXIT\tClose Application\tAlt+F4\n"
                        "\n"
                        "3\n"
                        "_Contents\tIDM_HELP_CONTENTS\tHelp Contents\tAlt+F1\n"
                        "Conte_xt\tIDM_HELP_CONTEXT\tContext Help\tF1\n"
                        "\tseparator\n"
                        "_About X11workbench\tIDM_HELP_ABOUT\tAbout X11workbench\tAlt+F1\n"
                        "\n"
                        "5\n"
                        "_Toolbox\tIDM_TOOLBOX\tDisplay (or hide) the Toolbox\n"
                        "_Options\tIDM_TOOLS_OPTIONS\tDisplay Options Editor\n"
                        "\n";

////////////////////////////////////////////////////////////
// edit menu - what I see when there's a child frame active
////////////////////////////////////////////////////////////
static char szEditMenu[]="1\n"
                        "_File\tpopup\t2\n"
                        "_Edit\tpopup\t4\n"
                        "_Tools\tpopup\t5\n"
                        "\tseparator\n"
                        "_Window\tpopup\t6\n"
                        "\tseparator\n"
                        "_Help\tpopup\t3\n"
                        "\n"
                        "2\n"
                        "_New File\t" FW_FILE_NEW_MENU "\tNew File\t" FW_FILE_NEW_ACCEL "\n"
                        "_Open File\t" FW_FILE_OPEN_MENU "\tOpen File\t" FW_FILE_OPEN_ACCEL "\n"
                        "_Save File\t" FW_FILE_SAVE_MENU "\tSave File\t" FW_FILE_SAVE_ACCEL "\n"
                        "Save _As\t" FW_FILE_SAVE_AS_MENU "\tSave As\t" FW_FILE_SAVE_AS_ACCEL "\n"
                        "Save A_ll\t" FW_FILE_SAVE_ALL_MENU "\tSave All\t" FW_FILE_SAVE_ALL_ACCEL "\n"
                        "\tseparator\n"
                        "_Close File\t" FW_FILE_CLOSE_MENU "\tClose File\tCtrl+F4\n"
                        "\tseparator\n"
                        "_Preferences\tIDM_PREFERENCES\tApplication Preferences\tCtrl+P\n"
                        "\tseparator\n"
                        "E_xit\tIDM_FILE_EXIT\tClose Application\tAlt+F4\n"
                        "\n"
                        "3\n"
                        "_Contents\tIDM_HELP_CONTENTS\tHelp Contents\tAlt+F1\n"
                        "Conte_xt\tIDM_HELP_CONTEXT\tContext Help\tF1\n"
                        "\tseparator\n"
                        "_About X11workbench\tIDM_HELP_ABOUT\tAbout X11workbench\tAlt+F1\n"
                        "\n"
                        "4\n"
                        "_Undo\t" FW_EDIT_UNDO_MENU "\tUn-do last action\t" FW_EDIT_UNDO_ACCEL "\n"
                        "_Redo\t" FW_EDIT_REDO_MENU "\tRe-do last action\t" FW_EDIT_REDO_ACCEL "\n"
                        "\tseparator\n"
                        "Cu_t\t" FW_EDIT_CUT_MENU "\tCut to Clipboard\t" FW_EDIT_CUT_ACCEL "\n"
                        "_Copy\t" FW_EDIT_COPY_MENU "\tCopy to Clipboard\t" FW_EDIT_COPY_ACCEL "\n"
                        "_Paste\t" FW_EDIT_PASTE_MENU "\tPaste from Clipboard\t" FW_EDIT_PASTE_ACCEL "\n"
                        "_Delete\t" FW_EDIT_DELETE_MENU "\tDelete selection\n"
                        "\tseparator\n"
                        "Select _All\t" FW_EDIT_SELECT_ALL_MENU "\tSelect All in context\t" FW_EDIT_SELECT_ALL_ACCEL "\n"
                        "Select _None\t" FW_EDIT_SELECT_NONE_MENU "\tSelect None in context\t" FW_EDIT_SELECT_NONE_ACCEL "\n"
                        "\tseparator\n"
                        "_Find\tIDM_EDIT_FIND\tFind within Document\tCtrl+F\n"
                        "Find Ne_xt\tIDM_EDIT_FIND_NEXT\tFind next occurence within Document\tCtrl+G\n"
                        "_Project Find\tIDM_EDIT_PROJ_FIND\tFind within entire project\tCtrl+Shift+F\n"
                        "Pro_ject Find Next\tIDM_EDIT_PROJ_FIND_NEXT\tFind next occurrence within entire project\tCtrl+Shift+G\n"
                        "\tseparator\n"
                        "Properties\t" FW_EDIT_PROPERTIES_MENU "\tFind next occurrence within entire project\t" FW_EDIT_PROPERTIES_ACCEL "\n"
                        "\n"
                        "5\n"
                        "_Toolbox\tIDM_TOOLBOX\tDisplay (or hide) the Toolbox\n"
                        "_Options\tIDM_TOOLS_OPTIONS\tDisplay Options Editor\n"
                        "\n"
                        "6\n"
                        "Tab _Left\tIDM_TAB_LEFT\tScroll Tab Left\tCtrl+Alt+PgUp\n"
                        "Tab _Right\tIDM_TAB_RIGHT\tScroll Tab Right\tCtrl+Alt+PgDown\n"
                        "\tseparator\n"
                        "Re-order Le_ft\tIDM_TAB_MOVE_LEFT\tScroll Tab Left\tCtrl+Alt+Shift+PgUp\n"
                        "Re-order R_ight\tIDM_TAB_MOVE_RIGHT\tScroll Tab Right\tCtrl+Alt+Shift+PgDown\n"
                        "\tseparator\n" // NOTE:  I can add a list of windows here, with hotkeys
                        "\n";


// NOTES ON 'F' KEYS - these were compiled by someone else with respect to winders
// CTRL+ALT (and +SHIFT) any F key in X11 switches to a virtual desktop in console mode
//
// F1 - brings up a help window
//      Alt - system menu
// F2 - in winders, rename selected object.
//      Alt+Ctrl - in MS Orifice, opens documents library (don't do this in X11)
// F3 - in winders, open search box
// F4 - in winders XP, display address bar list (or similar)
//      Alt - close application/window
// F5 - window refresh/update (such as in Firefox)
// F6 - cycle through screen elements of a window
// F7 - turn on/off "caret mode" in Firefox; in MS Weird, spell/grammar checking
// F8 - extend selection (MS orifice)
// F9 - update fields (MS orifice, particularly ExHell)
// F10 - activates the menu
//       SHIFT - pops up a context menu (in X11 at least) like a right-click would
//       ALT - in X11, maximize/normal (retaining window decorations)
// F11 - toggle between "true full-screen" (no window decorations) and normal [works in gnome/mate as well]
// F12 - opens 'save as' dialog (in MS Orifice)




// menu handler, similar to what MFC does
// in theory I can swap in a new menu handler when the window focus changes
// this is the DEFAULT handler, when no 'child frame' has the focus.  It also handles
// all of the OTHER menu stuff, out of convenience

FW_MENU_HANDLER_BEGIN(main_menu_handlers)
  FW_MENU_HANDLER_ENTRY("IDM_FILE_EXIT",FileExitHandler,NULL)
  FW_MENU_HANDLER_ENTRY("IDM_FILE_NEW",FileNewHandler,NULL)
  FW_MENU_HANDLER_ENTRY("IDM_FILE_OPEN",FileOpenHandler,NULL)
  FW_MENU_HANDLER_ENTRY("IDM_FILE_SAVE",FileSaveHandler,FileSaveUIHandler)
  FW_MENU_HANDLER_ENTRY("IDM_FILE_SAVE_AS",FileSaveAsHandler,FileSaveAsUIHandler)
  FW_MENU_HANDLER_ENTRY("IDM_FILE_SAVE_ALL",FileSaveAllHandler,FileSaveAllUIHandler)

  FW_MENU_HANDLER_ENTRY("IDM_FILE_CLOSE",FileCloseHandler,NULL) // TODO:  do a UI handler?

  FW_MENU_HANDLER_ENTRY("IDM_PREFERENCES", ApplicationPreferences,NULL)

  FW_MENU_HANDLER_ENTRY("IDM_TOOLBOX",ToolBoxHandler,ToolBoxUIHandler)

  FW_MENU_HANDLER_ENTRY("IDM_TAB_LEFT",TabLeftHandler, TabUIHandler)
  FW_MENU_HANDLER_ENTRY("IDM_TAB_RIGHT",TabRightHandler, TabUIHandler)
  FW_MENU_HANDLER_ENTRY("IDM_TAB_MOVE_LEFT",TabMoveLeftHandler, TabUIHandler)
  FW_MENU_HANDLER_ENTRY("IDM_TAB_MOVE_RIGHT",TabMoveRightHandler, TabUIHandler)

  FW_MENU_HANDLER_ENTRY("IDM_HELP_ABOUT",HelpAboutHandler,NULL)
  FW_MENU_HANDLER_ENTRY("IDM_HELP_CONTEXT",HelpContextHandler,NULL)
  FW_MENU_HANDLER_ENTRY("IDM_HELP_CONTENTS",HelpContentsHandler,NULL)

#if 0
  // additional EDIT MENU HANDLERS

  FW_MENU_HANDLER_ENTRY("IDM_EDIT_FIND",EditFindHandler,EditFindUIHandler)
  FW_MENU_HANDLER_ENTRY("IDM_EDIT_FIND_NEXT",EditFindNextHandler,EditFindNextUIHandler)
  FW_MENU_HANDLER_ENTRY("IDM_EDIT_PROJ_FIND",EditProjFindHandler,EditProjFindUIHandler)
  FW_MENU_HANDLER_ENTRY("IDM_EDIT_PROJ_FIND_NEXT",EditProjFindNextHandler,EditProjFindNextUIHandler)
#endif // 0

FW_MENU_HANDLER_END



// end of global variables



void WBUsage(void)
{
  fputs("X11workbench - Copyright (c) 2010-2019 by S.F.T. Inc. - all rights reserved\n\n"
        "Usage:      X11workbench [options] filename [filename [...]]\n"
        "  where     'filename' represents one or more files or workspaces to be opened on startup\n"
        "\n"
        "Standard X11workbench Options\n"
        "-h          display this message\n"
#ifndef NO_DEBUG
        "-d          dump settings on startup\n"
#endif // NO_DEBUG
#ifndef NO_SPLASH
        "--nosplash  Skip the 'splash' screen on startup\n"
#endif // !NO_SPLASH
        "\n", stderr);

  WBToolkitUsage();
}

static void get_min_window_height_width(int *piMinHeight, int *piMinWidth)
{
#if 0 // old code, consider removing this

  // DEMO CODE - using the 'STRING' size, calculate the minimum width/height and pass that
  //             as parameters to WBInitSizeHints

  // calculating the actual font height for the default font

  unsigned long fth = WBGetDefaultFont()->max_bounds.ascent  // default font height
                    + WBGetDefaultFont()->max_bounds.descent;

  // the pad and border are part of the 'hello world' text and green border displayed for the demo
  unsigned long pad = 32 /*BORDER*/; // font padding (only used here) [TODO:  fix this better]
  unsigned long bw = 1;              // border width (only used here)

  *piMinHeight = fth + pad * 2 + bw * 2;
  *piMinWidth = XTextWidth(WBGetDefaultFont(),     // minimum width (based on text width)
                           STRING,
                           strlen(STRING)) + pad * 2 + bw * 2;
#endif // 0

  if(*piMinHeight)
  {
    *piMinHeight = 360; // for now just hard-code it
  }

  if(*piMinWidth)
  {
    *piMinWidth = 512; // for now just hard-code it
  }
}


///////////////////////////////////////////////
// do_main - initialization, loop, termination
//        (the classic top-down model)
///////////////////////////////////////////////

int do_main(int argc, char *argv[], char *envp[])
{
//unsigned long fg, bg, bd;   /* Pixel values */
XEvent      event;          /* Event received */
XSizeHints  xsh;            /* Size hints for window manager */
//XSetWindowAttributes xswa;  /* Temporary Set Window Attribute struct */
char       szGreen[]="#00FF00";  // text color for green
Colormap   colormap;
int i1, iMinHeight, iMinWidth;
#ifndef NO_DEBUG
int iDebugDumpConfig = 0;
#endif // NO_DEBUG
#ifndef NO_SPLASH
int bNoSplash = 0;
#endif // !NO_SPLASH


  // as opposed to 'getarg' this method is system independent
  // some POSIX systems don't support 'getarg' correctly
  // TODO:  put it in platform_helper.[ch] and use HAVE_GETARG

  while(argc > 1)
  {
    if(argv[1][0] != '-' || !argv[1][1])
    {
      if(argv[1][0] == '-')
      {
        argv++;
        argc--;
      }

      break;
    }

    if(argv[1][1] == '-') // a double-dash
    {
      // double-dash items go here.  only 'one per'

      if(!strcmp(&(argv[1][2]), "nosplash"))
      {
        bNoSplash = 1;
        goto next_argument;
      }

      fprintf(stderr, "Unrecognized option \"%s\"\n", argv[1]);

      WBUsage();
      return 1; // illegal argument - show 'WBUsage' and return an error
    }

    for(i1=1; argv[1][i1]; i1++)
    {
      if(argv[1][i1] == 'h' ||
         argv[1][i1] == 'H')
      {
        WBUsage();
        return 0; // show 'WBUsage' but do NOT return an error
      }
#ifndef NO_DEBUG
      else if(argv[1][i1] == 'd')
      {
        iDebugDumpConfig = 1;
      }
#endif // NO_DEBUG
      else
      {
        fprintf(stderr, "Unrecognized option \"-%c\"\n", argv[1][i1]);

        WBUsage();
        return 1; // show 'WBUsage' and return an error
      }
    }

next_argument:
    argv++;
    argc--;
  }

  // initialization - set signal handlers, open display, etc.

  SetSignalHandlers();

  pX11Display = WBInit(NULL); // initialize X11 Work Bench Toolkit and obtain Display pointer
  if(!pX11Display)
  {
    return 1; // can't open display, so byby!
  }

  PXM_RegisterAppIcons(icon_app_xpm, application_icon_xpm);


  nCPU = WBCPUCount(); // get # of CPUs


#ifndef NO_DEBUG
  // This DEBUG section dumps the config data when theh '-d' option was specified on the command line.
  // it requires a Display object so I must do it HERE.  Then I can call WBExit and bail out.

  if(iDebugDumpConfig)
  {
    CHDumpConfig();

    WBExit();
    return 0;
  }
#endif // NO_DEBUG

  // SUPPLEMENTAL INITIALIZATION STUFF

  // color selection

//  bd = WhitePixel(pX11Display, DefaultScreen(pX11Display)); // border
//  bg = BlackPixel(pX11Display, DefaultScreen(pX11Display)); // background
//  fg = WhitePixel(pX11Display, DefaultScreen(pX11Display)); // foreground

  // dont' forget the colormap

  colormap = WBDefaultColormap(pX11Display);

  // additional allocated colors - in this case, GREEN
  XParseColor(pX11Display, colormap, szGreen, &clrGreen);
  XAllocColor(pX11Display, colormap, &clrGreen);  // NOTE:  do I need 'XFreeColors' for 'clrGreen' ?

#ifndef NO_SPLASH


  if(!bNoSplash)
  {
    char *pCopyright = WBCopyString(
#ifdef UTF8_COPYRIGHT
                                    "Copyright " UTF8_COPYRIGHT " 2010-2019 by Big Bad Bombastic Bob\nwww.mrp3.com"  // text string with unicode char in it U+00A9
#else // UTF8_COPYRIGHT
                                    "Copyright (c) 2010-2019 by Big Bad Bombastic Bob\nwww.mrp3.com"
#endif // UTF8_COPYRIGHT
                                   );

    if(pCopyright && nCPU > 0)
    {
      char tbuf[32];

      snprintf(tbuf, sizeof(tbuf), "%d **", nCPU);
      WBCatString(&pCopyright, "\n** CPU Count: ");
      if(pCopyright)
      {
        WBCatString(&pCopyright, tbuf);
      }
    }

    if(pCopyright)
    {
      DLGSplashScreen(splash_xpm,
                      pCopyright, WhitePixel(pX11Display, DefaultScreen(pX11Display))); // white text

      WBFree(pCopyright);
    }
    else
    {
      DLGSplashScreen(splash_xpm,
                      "Copyright (c) 2010-2019 by Big Bad Bombastic Bob\nwww.mrp3.com", // 1 or 2 lines only
                      WhitePixel(pX11Display, DefaultScreen(pX11Display))); // white text
    }
  }
#endif // NO_SPLASH

  get_min_window_height_width(&iMinHeight, &iMinWidth);

  // I will need to center the new window, so figure out how to do that

  WBInitSizeHints(&xsh,        // pointer to XSizeHints
                  pX11Display, // Display pointer
                  iMinHeight,  // minimum height (based on font height)
                  iMinWidth);  // minimum width

//  // init window attributes
//
//  WBInitWindowAttributes(&xswa,           // attribute structure
//                         bd,              // border pixel color
//                         bg,              // background window color
//                         colormap,        // colormap
//                         CenterGravity);  // gravity

  // create frame window object (always uses default display)

  pMainFrame = FWCreateFrameWindow("X11workbench",            // title
                                   ID_APPLICATION,           // icon
                                   szAppMenu,                // application menu
                                   xsh.x, xsh.y,             // position
                                   xsh.width, xsh.height,    // size
                                   MyWindowCallback,         // callback
                                   WBFrameWindow_APP_WINDOW  // flags and attributes
                                   | WBFrameWindow_VISIBLE
                                   | WBFrameWindow_STATUS_BAR);

  if(!pMainFrame)
  {
    WB_ERROR_PRINT("%s - Unable to create main frame window\n", __FUNCTION__);

    WBExit();
    return 2;
  }

//  {
//    const char *pNothing = szEditMenu; // to avoid certain warnings - remove later
//
//    pNothing = pNothing;
//  }

  // assign menu handlers to the frame window (this does the callback functions for me)
  // this is part of the frame window functionality for the DEFAULT menu

  FWSetMenuHandlers(pMainFrame, main_menu_handlers);


  // open files specifed on command line

  // TODO:  if project file specified, open files based on project state
  //        Otherwise, open as "single file"

  WBBeginWaitCursor(pMainFrame->wID);

  while(argc > 1)
  {
    // TODO:  is it a project file?

    DoFileOpen(pMainFrame, argv[1]);

    argc--;
    argv++;
  }

  WBEndWaitCursor(pMainFrame->wID);

  if(FWGetNumContWindows(pMainFrame) > 0) // if I opened anything, set focus to first one
  {
    FWSetFocusWindowIndex(pMainFrame, 0);
  }



  //=========================
  //     MAIN EVENT LOOP
  //=========================

  while (!bQuitFlag /*1*/)
  {
    if(!WBCheckGetEvent(pX11Display, &event))
    {
      // SLEEP if no event while in loop (function returns without blocking)
      // otherwise I can do background tasks during this loop iteration.

      // if I have NO BACKGROUND PROCESSES to do, I can use 'WBWaitForEvent'
      // This function makes for an efficient 'wait for event'.  Otherwise,
      // I'll want to implement something that has WBDelay() calls when there
      // is nothing to do...

//      if(1)
//      {
        WBWaitForEvent(pX11Display);
//      }
//      else
//      {
//        WBDelay(100); // delay 100 microseconds (0.1 milliseconds)
//      }

      continue; // skip the 'WBDispatch' since there was no event
    }

    WBDispatch(&event);
  }

  if(pMainFrame)
  {
    WBDestroyWindow(pMainFrame->wID);
  }

  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Application,
                 "%s - Application about to exit\n", __FUNCTION__);

  WBExit();

  return 0;
}



///////////////////////
// CALLBACK FUNCTIONS
///////////////////////

extern void TestFunc(Display *pDisplay, WBGC gc, Window wID, int iX, int iY);

static int MyWindowCallback(Window wID, XEvent *pEvent)
{
XWindowAttributes xwa;      /* Temp Get Window Attribute struct */
int iRval = 0;

  /*
    * On the last of each group of Expose events,  repaint the entire
    * window.  See Section 8.4.5.1.
    */

  if(pEvent->type == DestroyNotify &&
     pEvent->xdestroywindow.window == wID)
  {
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Application,
                   "%s - DestroyNotify\n", __FUNCTION__);

    if(pMainFrame && pMainFrame->wID == wID)
    {
      pMainFrame = NULL;  // because I'm destroying it
    }

    return 0;  // let remaining default processing happen
  }

  if(pEvent->type == ClientMessage &&
     pEvent->xclient.message_type == aQUERY_CLOSE)
  {
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Application,
                   "%s - QUERY_CLOSE\n", __FUNCTION__);

    if(pEvent->xclient.data.l[0]) // close is imminent if I return 0
    {
      if(pMainFrame && pMainFrame->wID == wID)
      {
        pMainFrame = NULL;  // because I'm destroying it
      }
    }

    return 0; // "ok to close" (let frame window handle anything else)
  }

  if (pEvent->type == Expose && pEvent->xexpose.count == 0)
  {
    WBGC gc;
    WB_GEOM geom;

// NOTE:  this is managed by the toolkit
//    /*
//      * Remove any other pending Expose events from the queue to
//      * avoid multiple repaints. See Section 8.7.
//      */
//    while(!bQuitFlag && XCheckTypedWindowEvent(pX11Display, wID, Expose, pEvent))
//      ;
//
//    if(bQuitFlag)
//    {
//      iRval = 1;
//      WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Application,
//                     "%s - Quit flag set - returning %d\n", __FUNCTION__, iRval);
//
//      return iRval;  // let default processing happen
//    }

    /*
      * Find out how big the window is now,  so that we can center
      * the text in it.
      */
    if(XGetWindowAttributes(pX11Display, wID, &xwa) == 0)
    {
      WB_ERROR_PRINT("%s - Cannot get correct attributes for window!  Returning %d\n",
                    __FUNCTION__, iRval);
      return iRval;
    }

    gc = WBBeginPaint(wID, &(pEvent->xexpose), &geom);  // begin paint, get a gc for it

    if(gc == None)
    {
      WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_Expose,
                     "%s.%d - WBBeginPaint returns 'None'\n",
                    __FUNCTION__, __LINE__);

      return 1; // handled (this is because a None gc means I didn't have anything to update)
    }

    WBClearWindow(wID, gc);  // does the erase background intelligently

#ifdef DISPLAY_HELLO_WORLD
    {
      XFontStruct *pFont;
      int x, y, x0, y0, x1, y1;

      pFont = WBGetWindowFontStruct(wID);
      if(!pFont)
      {
        WB_ERROR_PRINT("%s - No font - returning %d\n", __FUNCTION__, iRval);
        return iRval;  // let default processing happen
      }

      x0 = XTextWidth(pFont, STRING, strlen(STRING));
      y0 = pFont->max_bounds.ascent
          - pFont->max_bounds.descent;

      x = (xwa.width - x0) / 2;
      y = (xwa.height + pFont->max_bounds.ascent
        - pFont->max_bounds.descent) / 2;

      // adjust new values for X0 and y0 to surround x and y

      x1 = x + x0 + 20;
      x0 = x - 20;

      y1 = y + pFont->max_bounds.descent + 20;
      y0 = y - y0 - 20;

      /*
        * Fill the window with the background color,  and then paint
        * the centered string.
        */

      XSetForeground(pX11Display, gc, WBGetWindowFGColor(wID));
      XDrawString(pX11Display, wID, gc, x, y, STRING, strlen(STRING));

      XSetForeground(pX11Display, gc, clrGreen.pixel);

      // draw my green rectangle

      XDrawRectangle(pX11Display, wID, gc, x0, y0, x1 - x0, y1 - y0);
      XSetForeground(pX11Display, gc, WBGetWindowFGColor(wID));  // restore it at the end
    }
#endif // DISPLAY_HELLO_WORLD

//    TestFunc(pX11Display, gc, wID, x0 - 32, y0 - 32); // TEMPORARY

    WBEndPaint(wID, gc);  // done now [free resources]

    iRval = 1;  // processed

    WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Window,
                   "%s - Expose returning %d\n", __FUNCTION__, iRval);

    return iRval;  // let default processing happen
  }

  // menu events
  if(pEvent->type == ClientMessage && pEvent->xclient.message_type == aMENU_COMMAND)
  {
    iRval = 1;

    WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Window | DebugSubSystem_Menu | DebugSubSystem_Event,
                   "%s - detecting main window menu event %ld\n", __FUNCTION__,
                   pEvent->xclient.data.l[0]);
  }

  WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Window,
                 "%s - Returning %d\n", __FUNCTION__, iRval);

  return iRval;  // let default processing happen if zero, else 'processed'
}


///////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                           //
//   _   _  _    _  _  _  _            _____                     _    _                      //
//  | | | || |_ (_)| |(_)| |_  _   _  |  ___|_   _  _ __    ___ | |_ (_)  ___   _ __   ___   //
//  | | | || __|| || || || __|| | | | | |_  | | | || '_ \  / __|| __|| | / _ \ | '_ \ / __|  //
//  | |_| || |_ | || || || |_ | |_| | |  _| | |_| || | | || (__ | |_ | || (_) || | | |\__ \  //
//   \___/  \__||_||_||_| \__| \__, | |_|    \__,_||_| |_| \___| \__||_| \___/ |_| |_||___/  //
//                             |___/                                                         //
//                                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////

// 'DoFileOpen()' - API to open a file and create a child frame derived tab for it

int DoFileOpen(WBFrameWindow *pMainFrame, const char *szFileName)
{
WBFILE_TYPE ft;
WBChildFrame *pCF;
int iTab, iLineEnd;


  if(!pMainFrame || !szFileName || !*szFileName)
  {
    return -1;
  }

  pCF = NULL; // as a flag for later, make sure it's NULL

  // create a new tab in the frame window using the correct type of child window

  ft = GetFileType(szFileName);

  if(ft == WBFILE_TYPE_PROJECT)
  {
    DLGMessageBox(MessageBox_OK | MessageBox_Error, None,
                  "File Open", "'File _Open' project file not (yet) supported");
  }
  else if(ft == WBFILE_TYPE_RESOURCE)
  {
    DLGMessageBox(MessageBox_OK | MessageBox_Error, None,
                  "File Open", "'File _Open' resource file not (yet) supported");
  }
  else if(ft == WBFILE_TYPE_PIXMAP)
  {
    DLGMessageBox(MessageBox_OK | MessageBox_Error, None,
                  "File Open", "'File _Open' pixmap file not (yet) supported");
  }
  else if(ft == WBFILE_TYPE_DIALOG)
  {
    DLGMessageBox(MessageBox_OK | MessageBox_Error, None,
                  "File Open", "'File _Open' dialog resource file not (yet) supported");
  }
  else if(ft == WBFILE_TYPE_MENU)
  {
    DLGMessageBox(MessageBox_OK | MessageBox_Error, None,
                  "File Open", "'File _Open' menu resource file not (yet) supported");
  }
  else if(ft == WBFILE_TYPE_TOOLBAR)
  {
    DLGMessageBox(MessageBox_OK | MessageBox_Error, None,
                  "File Open", "'File _Open' toolbar resource file not (yet) supported");
  }
  else
  {
    // All other files are assumed to be text files and will create a WBEditWindow as a new tab.

    // 1st, create a new 'WBEditWindow', attaching it to the frame

    WBEditWindow *pEW = WBCreateEditWindow(pMainFrame, NULL, szEditMenu, main_menu_handlers, 0);

    if(!pEW)
    {
      DLGMessageBox(MessageBox_OK | MessageBox_Error, None,
                    "File Open", "'File _Open' unable to create edit window");
    }
    else
    {
      pCF = &(pEW->childframe);

      WBBeginWaitCursor(pCF->wID);

      // next, load the contents of the file into it

      if(WBEditWindowLoadFile(pEW, szFileName))
      {
        DLGMessageBox(MessageBox_OK | MessageBox_Error, None,
                      "File Open", "'File _Open' unable to read file into edit window");
      }
    }

    // TODO:  set up a few things based on the file type
    //        a) default line ending
    //        b) default unicode/UTF-8 [as required]
    //        c) default tab handling
    //        d) color highlighting
    //        etc.

    // TODO:  read this info from the config file, with defaults specified
    //        by the utility functions.


    iLineEnd = GetDefaultLineEnding(ft); // read line ending info from config file, default to this
    iTab = GetDefaultTabSetting(ft);     // read tab info from config file, default to this

    // TODO:  scan file to see what the line endings REALLY are?
    pEW->xTextObject.vtable->set_linefeed(&(pEW->xTextObject), iLineEnd);

    if(ft == WBFILE_TYPE_MAKEFILE ||
       ft == WBFILE_TYPE_AUTOCONF)
    {
      pEW->xTextObject.vtable->set_filetype(&(pEW->xTextObject),
                                            FileType_MAKEFILE | FileType_HARDTAB); // always hard tabs
    }
    else if(ft == WBFILE_TYPE_CPROG || ft == WBFILE_TYPE_CPP ||
            ft == WBFILE_TYPE_CHEADER || ft == WBFILE_TYPE_SHELL ||
            ft == WBFILE_TYPE_PYTHON || ft == WBFILE_TYPE_PERL ||
            ft == WBFILE_TYPE_ASM || ft == WBFILE_TYPE_JAVA ||
            ft == WBFILE_TYPE_JS || ft == WBFILE_TYPE_PHP ||
            ft == WBFILE_TYPE_ARDUINO)
    {
      // programming languages
      if(iTab < 0) // hard tabs
      {
        pEW->xTextObject.vtable->set_filetype(&(pEW->xTextObject),
                                              FileType_PROGRAM | FileType_HARDTAB); // use hard tabs
      }
      else
      {
        pEW->xTextObject.vtable->set_filetype(&(pEW->xTextObject),
                                              FileType_PROGRAM); // use spaces
      }
    }
    else if(ft == WBFILE_TYPE_HTML ||
            ft == WBFILE_TYPE_XML)
    {
      // programming languages
      if(iTab < 0) // hard tabs
      {
        pEW->xTextObject.vtable->set_filetype(&(pEW->xTextObject),
                                              FileType_XML | FileType_HARDTAB); // use hard tabs
      }
      else
      {
        pEW->xTextObject.vtable->set_filetype(&(pEW->xTextObject),
                                              FileType_XML); // use spaces
      }
    }
    else // plain text
    {
      if(iTab < 0) // hard tabs
      {
        pEW->xTextObject.vtable->set_filetype(&(pEW->xTextObject),
                                              FileType_PLAIN_TEXT | FileType_HARDTAB); // use hard tabs
      }
      else
      {
        pEW->xTextObject.vtable->set_filetype(&(pEW->xTextObject),
                                              FileType_PLAIN_TEXT); // use spaces
      }
    }

    pEW->xTextObject.vtable->set_tab(&(pEW->xTextObject), abs(iTab));
  }

  if(pCF) // did I create the new child frame??
  {
    const char *pDisplayName;

    // display file name with no path info within tab
    pDisplayName = szFileName + strlen(szFileName);

    while(pDisplayName > szFileName && *(pDisplayName - 1) != '/')
    {
      pDisplayName--;
    }

    FWSetChildFrameDisplayName(pCF, pDisplayName);

    WBEndWaitCursor(pCF->wID);
  }

  return pCF ? 0 : -1;
}


WBFILE_TYPE GetFileType(const char *szFileName) // return one of the WBFILE_TYPE constants
{
const char *pFN, *pExt;

  pFN = pExt = szFileName + strlen(szFileName);

  while(pFN > szFileName && *(pFN - 1) != '/')
  {
    pFN--;
  }

  while(pExt > szFileName && *(pExt - 1) != '.')
  {
    pExt--;
  }

  if(pExt <= szFileName)
  {
    pExt = NULL; // no extension
  }

  // TODO:  don't just check the extension, read the first few lines, check for
  //        invalid/unprintable characters, etc.

  if(pExt && !strcasecmp("makefile", pExt))
  {
    return WBFILE_TYPE_MAKEFILE;
  }
  else if(!pExt)
  {
    // TODO: look for hash-bang
  }
  else if(!strcasecmp("mk", pExt)) // '.mk' '.Mk' or '.MK' (or even '.mK') extension
  {
    return WBFILE_TYPE_MAKEFILE;
  }
  else if(!strcasecmp("h", pExt)) // also allow case-insensitive naming, in case 'windows'
  {
    return WBFILE_TYPE_MAKEFILE;
  }
  else if(!strcasecmp("c", pExt)) // also allow case-insensitive naming, in case 'windows'
  {
    return WBFILE_TYPE_CPROG;
  }
  else if(!strcasecmp("h", pExt)) // also allow case-insensitive naming, in case 'windows'
  {
    return WBFILE_TYPE_CHEADER;
  }
  else if(!strcasecmp("cpp", pExt)) // also allow case-insensitive naming, in case 'windows'
  {
    return WBFILE_TYPE_CPP;
  }
  else if(!strcmp("java", pExt)) // for now I only do the lower-case extension naming here
  {
    return WBFILE_TYPE_JAVA;
  }
  else if(!strcmp("js", pExt)) // for now I only do the lower-case extension naming here
  {
    return WBFILE_TYPE_JS;
  }
  else if(!strcmp("pl", pExt)) // for now I only do the lower-case extension naming here
  {
    return WBFILE_TYPE_PERL;
  }
  else if(!strcasecmp("py", pExt)) // also allow case-insensitive naming, in case 'windows'
  {
    return WBFILE_TYPE_PYTHON;
  }
  else if(!strcmp("xpm", pExt))
  {
    return WBFILE_TYPE_PIXMAP;
  }
  else if(!strcmp("ac", pExt) || !strcmp("am", pExt))
  {
    return WBFILE_TYPE_AUTOCONF;
  }
  else if(!strcasecmp("xwb", pExt)) // also allow case-insensitive naming, in case 'windows'
  {
    return WBFILE_TYPE_PROJECT;
  }
  else if(!strcasecmp("xwbrc", pExt)) // also allow case-insensitive naming, in case 'windows'
  {
    return WBFILE_TYPE_RESOURCE;
  }
  else if(!strcasecmp("xwbdlg", pExt)) // also allow case-insensitive naming, in case 'windows'
  {
    return WBFILE_TYPE_DIALOG;
  }
  else if(!strcasecmp("xwbmenu", pExt)) // also allow case-insensitive naming, in case 'windows'
  {
    return WBFILE_TYPE_MENU;
  }
  else if(!strcasecmp("xwbbar", pExt)) // also allow case-insensitive naming, in case 'windows'
  {
    return WBFILE_TYPE_TOOLBAR;
  }
  else if(!strcmp("sh", pExt))
  {
    return WBFILE_TYPE_SHELL;
  }
  else if(!strcasecmp("php", pExt)) // also allow case-insensitive naming, in case 'windows'
  {
    return WBFILE_TYPE_PHP;
  }
  else if(!strcasecmp("htm", pExt) || !strcasecmp("html", pExt)) // also allow case-insensitive naming, in case 'windows'
  {
    return WBFILE_TYPE_HTML;
  }
  else if(!strcasecmp("xml", pExt)) // also allow case-insensitive naming, in case 'windows'
  {
    return WBFILE_TYPE_XML;
  }
  else if(!strcasecmp("pde", pExt) || !strcasecmp("ino", pExt)) // also allow case-insensitive naming, in case 'windows'
  {
    return WBFILE_TYPE_ARDUINO; // arduino script may require some additional 'special help'
  }


  return WBFILE_TYPE_TEXT; // default
}


int GetDefaultTabSetting(WBFILE_TYPE nFileType)
{
  if(nFileType == WBFILE_TYPE_MAKEFILE || nFileType == WBFILE_TYPE_AUTOCONF)
  {
    return -8; // hard tab, 8 bytes (always)
  }
//  else if(nFileType == WBFILE_TYPE_HTML ||
//          nFileType == WBFILE_TYPE_XML)
//  {
//    // TODO:  read from config
//
//    return 4; // 4 bytes, soft tab
//  }

  // TODO:  read file-type from config and default tab size


  return 4; // 4 bytes, soft tab (the default)
}

int GetDefaultLineEnding(WBFILE_TYPE nFileType)
{
  if(nFileType == WBFILE_TYPE_HTML ||
     nFileType == WBFILE_TYPE_XML)
  {
    return LineFeed_CRLF; // by convention for these (TODO:  check settings?)
  }
  else if(nFileType == WBFILE_TYPE_MAKEFILE || nFileType == WBFILE_TYPE_AUTOCONF)
  {
    // TODO:  what about windows nmake files?

    return LineFeed_NEWLINE;
  }

  return LineFeed_DEFAULT;
}

const char *GetFileTypeDesc(WBFILE_TYPE nFileType)
{
static const char * const aszDesc[] =
{
  "None",
  "Text",
  "C Program Source",
  "C++ Program Source",
  "C/C++ Header File",
  "Make File",
  "Auto-conf File",
  "XWB Project File"
  "Resource File",
  "Pixmap File",
  "Dialog Resource",
  "Menu Resource",
  "Toolbar Resource",
  "Shell Program",
  "Python Program",
  "Perl Program"
  "Assembly Program Source",
  "HTML Source",
  "XML Data",
  "Java Program Source",
  "JavaScript Program",
  "PHP Program",
  "Arduino Script"
};


  if(WBFILE_TYPE_LAST > sizeof(aszDesc)/sizeof(aszDesc[0]))
  {
    WB_WARN_PRINT("WARNING:  %s 'aszDesc' array is too small\n", __FUNCTION__);
  }

  if((int)nFileType >= sizeof(aszDesc)/sizeof(aszDesc[0]) || (int)nFileType < 0)
  {
    return NULL;
  }

  return aszDesc[(int)nFileType];
}


const char *GetFileTypeHighlightInfo(WBFILE_TYPE nFileType)
{
  if(nFileType == WBFILE_TYPE_CPROG ||
     nFileType == WBFILE_TYPE_CPP ||
     nFileType == WBFILE_TYPE_CHEADER ||
     nFileType == WBFILE_TYPE_ARDUINO)
  {
    static const char szC[]=        // parameter: keyword list <LF>  where keyword list is one or more words that might need to be quoted
      "Language: C/C++\n"           // text of language style name
      "Comment: //\n"               // text that begins single-line comment
      "CommentBlockBegin: /*\n"     // text that begins comment block
      "CommentBlockEnd: */\n"       // text that ends comment block
      "ScopeBegin: {\n"             // text that begins scope
      "ScopeEnd: }\n"               // text that ends scope
      "TextBegin: \"\n"             // character that begins a block of text
      "TextEnd: \"\n"               // character that ends a block of text
      "AltTextBegin:\n"             // alternate character that begins a block of text
      "AltTextEnd:\n"               // alternate character that ends a block of text
      "CharBegin: '\n"              // character that begins a single character or block of text
      "CharEnd: '\n"                // character that ends a single character or block of text
      "AltCharBegin:\n"             // alternate character that begins a single character or block of text
      "AltCharEnd:\n"               // alternate character that ends a single character or block of text
      "Variable:\n"                 // character that defines a variable (or parameter substitution)
      "StatementEnd: ;\n"           // character that ends a statement
      "Escapement: \\\n"            // character that performs 'escapement' like \n, etc.
      "IgnoreEscapement:\n"         // quoted strings/chars that ignore 'escapement' (can have more than one)
      "DoubleQuotes:\n"             // quoted string/chars that can have doubled quotes (list all chars like '"` for example)
      "LineContinuation: \\\n"      // character that, at the end of the line, implies a line continuation
      "MacroDefinition: #define\n"  // keyword for macro definition
      "Conditionals: #if #ifdef\n"  // keywords that begin a conditional compile section, etc.
      "ElseCondition: #else\n"      // keyword conditionals for 'else'
      "ElseIfCondition: #elif\n"    // keyword conditionals for 'else if' (must be quoted if they contain white space)
      "EndIfCondition: #endif\n"    // keyword that ends a conditional compile section, etc.
      "AlwaysTrue: \"#if 1\" \"#elif 1\" \"#if !0\" \"#elif !0\"\n"
                                    // conditionals that are always true (must be quoted if they contain white space)

      "AlwaysFalse: \"#if 0\" \"#elif 0\"\n"
                                    // conditionals that are alway false (must be quoted if they contain white space)

      "Keywords: if else for while do goto break switch case default char short long int unsigned const volatile "
                "float double struct class union enum typedef auto register inline "
                "namespace template using try catch except throw\n"
                                    // a comprehensive list of language keywords

      "AltKeywords: __attribute__ __inline __try __catch __except #pragma\n";
                                    // an 'alternate keyword' list

    return szC;
  }
  else if(nFileType == WBFILE_TYPE_JAVA ||
          nFileType == WBFILE_TYPE_JS)
  {
    static const char szJava[]=
      "Language: Java/JavaScript\n"
      "Comment: //\n"
      "CommentBlockBegin: /*\n"
      "CommentBlockEnd: */\n"
      "ScopeBegin: {\n"
      "ScopeEnd: }\n"
      "TextBegin: \"\n"
      "TextEnd: \"\n"
      "AltTextBegin:\n"
      "AltTextEnd:\n"
      "CharBegin: '\n"
      "CharEnd: '\n"
      "AltCharBegin:\n"
      "AltCharEnd:\n"
      "Variable:\n"
      "StatementEnd: ;\n"
      "Escapement: \\\n"
      "IgnoreEscapement:\n"
      "DoubleQuotes:\n"
      "LineContinuation: \\\n"
      "MacroDefinition:\n"
      "Conditionals:\n"
      "ElseCondition:\n"
      "ElseIfCondition:\n"
      "EndIfCondition:\n"
      "AlwaysTrue:\n"
      "AlwaysFalse:\n"
      "Keywords: if else elif for each in while do break switch case default char short long int final variant "
                "float double struct class union enum typedef try catch throw except "
                "finally namespace template using\n"
      "AltKeywords: __attribute__ __inline #pragma\n";

    return szJava;
  }
  else if(nFileType == WBFILE_TYPE_SHELL)
  {
    static const char szShell[]=
      "Language: Shell\n"
      "Comment: #\n"
      "CommentBlockBegin:\n"
      "CommentBlockEnd:\n"
      "ScopeBegin: {\n"
      "ScopeEnd: }\n"
      "TextBegin: \"\n"
      "TextEnd: \"\n"
      "AltTextBegin: `\n"
      "AltTextEnd: `\n"
      "CharBegin: '\n"
      "CharEnd: '\n"
      "AltCharBegin:\n"
      "AltCharEnd:\n"
      "StatementEnd:\n"
      "Escapement: \\\n"
      "IgnoreEscapement: '\n"
      "Variable: $\n"
      "DoubleQuotes:\n"
      "LineContinuation: \\\n"
      "MacroDefinition:\n"
      "Conditionals:\n"
      "ElseCondition:\n"
      "ElseIfCondition:\n"
      "EndIfCondition:\n"
      "AlwaysTrue:\n"
      "AlwaysFalse:\n"
      "Keywords: if fi else elif for in while do done break case local return exit echo\n"
      "AltKeywords:\n";

    return szShell;
  }
  else if(nFileType == WBFILE_TYPE_MAKEFILE ||
          nFileType == WBFILE_TYPE_AUTOCONF) // these too, for now - treat as Makefile for highlight
  {
    static const char szMakefile[]=
      "Language: Shell\n"
      "Comment: #\n"
      "CommentBlockBegin:\n"
      "CommentBlockEnd:\n"
      "ScopeBegin: {\n"
      "ScopeEnd: }\n"
      "TextBegin: \"\n"
      "TextEnd: \"\n"
      "AltTextBegin: `\n"
      "AltTextEnd: `\n"
      "CharBegin: '\n"
      "CharEnd: '\n"
      "AltCharBegin:\n"
      "AltCharEnd:\n"
      "StatementEnd:\n"
      "Escapement: \\\n"
      "IgnoreEscapement: '\n"
      "Variable: $\n"
      "DoubleQuotes:\n"
      "LineContinuation: \\\n"
      "MacroDefinition:\n"
      "Conditionals:\n"
      "ElseCondition:\n"
      "ElseIfCondition:\n"
      "EndIfCondition:\n"
      "AlwaysTrue:\n"
      "AlwaysFalse:\n"
      "Keywords: if fi else elif for in while do done break case local return exit echo\n"
      "AltKeywords: @if -if @for -for @while -while @echo -echo\n";

    return szMakefile;
  }
  else if(nFileType == WBFILE_TYPE_PERL)
  {
    // TODO:  does Perl need syntax highlighting different from shell?
  }
  else if(nFileType == WBFILE_TYPE_PHP)
  {
    // TODO:  does Perl need syntax highlighting different from shell/Perl?
  }
  else if(nFileType == WBFILE_TYPE_PYTHON)
  {
    // TODO:  do python syntax highlighting
  }
  else if(nFileType == WBFILE_TYPE_HTML ||
          nFileType == WBFILE_TYPE_XML)
  {
    // TODO:  does XML or HTML need some kind of syntax highlighting?  it would have
    //        to be different than the normal one...
  }

  return ""; // blank (for now, could do NULL instead but I prefer this)
}




////////////////////////////////////////////////////////////////////////////
//   __  __                     ____      _ _ _                _          //
//  |  \/  | ___ _ __  _   _   / ___|__ _| | | |__   __ _  ___| | _____   //
//  | |\/| |/ _ \ '_ \| | | | | |   / _` | | | '_ \ / _` |/ __| |/ / __|  //
//  | |  | |  __/ | | | |_| | | |__| (_| | | | |_) | (_| | (__|   <\__ \  //
//  |_|  |_|\___|_| |_|\__,_|  \____\__,_|_|_|_.__/ \__,_|\___|_|\_\___/  //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

static int ApplicationPreferences(XClientMessageEvent *pEvent)
{
XColor clr; // temporary

  if(!pMainFrame)
  {
    DLGMessageBox(MessageBox_OK | MessageBox_Error, None,
                  "Application Properties", "'Properties' and no container window");
    return 1;
  }

  clr.pixel = clrGreen.pixel; // temporary

  DLGColorDialog(pMainFrame->wID, NULL, &clr); // for now...

  return 1; // handled
}


static int FileExitHandler(XClientMessageEvent *pEvent)
{
  // TODO:  'OnExit' processing for open files (files to be saved, etc.)

  bQuitFlag = 1;  // time to die

  return 1; // handled
}

static int FileNewHandler(XClientMessageEvent *pEvent)
{
WBEditWindow *pEW;

  if(!pMainFrame)
  {
    DLGMessageBox(MessageBox_OK | MessageBox_Error, None,
                  "File New", "'File _New' and no container window");
    return 1;
  }

  // create a new child frame within the main frame
  // this should be pretty straightforward as I implement it properly

  // 1st, create a new 'WBEditWindow', attaching it to the frame

  pEW = WBCreateEditWindow(pMainFrame, NULL, szEditMenu, main_menu_handlers, 0);

  if(!pEW)
  {
    DLGMessageBox(MessageBox_OK | MessageBox_Error, None,
                  "File New", "'File _New' unable to create edit window");
  }

  return 1; // handled
}


static int FileOpenHandler(XClientMessageEvent *pEvent)
{
  Window wIDOwner = pMainFrame ? pMainFrame->wID : None;
  WBEditWindow *pEW;
  char *pFile;

  pFile = DLGFileDialog(FileDialog_Open, wIDOwner, ".", "",
                        ".txt\tText Files\n"
                        ".c\tC language file\n"
                        ".cpp\tC language file\n"
                        ".h\tC language header\n"
                        "Makefile\tMake Files\n"
                        ".mk\tMake 'include' Files\n"
                        ".am\tAutotools File\n"
                        ".*\tAll Files\n");

  if(pFile)
  {
    DoFileOpen(pMainFrame, pFile);

    WBFree(pFile);  // required resource cleanup
  }

  return 1; // handled
}

static int FileSaveHandler(XClientMessageEvent *pEvent)
{
  Window wIDOwner = pMainFrame ? pMainFrame->wID : None;

  DLGMessageBox(MessageBox_OK | MessageBox_MiddleFinger, wIDOwner,
                "File Save",
                "'File _Save' not currently implemented");

  return 1; // handled
}

static int FileSaveUIHandler(WBMenu *pMenu, WBMenuItem *pItem)
{
  return -1; // disabled
}

static int FileSaveAsHandler(XClientMessageEvent *pEvent)
{
  Window wIDOwner = pMainFrame ? pMainFrame->wID : None;

  DLGMessageBox(MessageBox_OK | MessageBox_Warning, wIDOwner,
                "File Save As",
                "'File Save _As' not currently implemented");

  return 1; // handled
}

static int FileSaveAsUIHandler(WBMenu *pMenu, WBMenuItem *pItem)
{
  return -1; // disabled
}

static int FileSaveAllHandler(XClientMessageEvent *pEvent)
{
  Window wIDOwner = pMainFrame ? pMainFrame->wID : -1;

  DLGMessageBox(MessageBox_OK | MessageBox_Warning, wIDOwner,
                "File Save All",
                "'File Save A_ll' not currently implemented");

  return 1; // handled
}

static int FileSaveAllUIHandler(WBMenu *pMenu, WBMenuItem *pItem)
{
  return -1; // disabled
}

static int HelpAboutHandler(XClientMessageEvent *pEvent)
{
  Window wIDOwner = pMainFrame ? pMainFrame->wID : None;


  DLGMessageBox(MessageBox_OK | /*MessageBox_Info*/ MessageBox_App, wIDOwner,
                "About X11workbench",
                "X11workbench - BBB's answer to a proper development environment for X11");

  return 1; // handled
}

static int FileCloseHandler(XClientMessageEvent *pEvent)
{
  WBChildFrame *pC;

  if(!pMainFrame)
  {
    return 0;
  }

  pC = FWGetFocusWindow(pMainFrame);

  if(pC)
  {
    // TODO:  check for 'safe to close it' ?

    FWRemoveContainedWindow(pMainFrame, pC);

    FWDestroyChildFrame(pC); // this will destroy the super-class as well
  }

  return 1;
}

static int TabLeftHandler(XClientMessageEvent *pEvent)
{
int iIndex;

  if(!pMainFrame)
  {
    return 0;
  }

  iIndex = FWGetChildFrameIndex(pMainFrame, NULL);

  WB_ERROR_PRINT("TEMPORARY:  %s - move left %d\n", __FUNCTION__, iIndex);

  if(iIndex > 0)
  {
    FWSetFocusWindowIndex(pMainFrame, iIndex - 1);
  }

  return 1;
}

static int TabRightHandler(XClientMessageEvent *pEvent)
{
int iIndex;

  if(!pMainFrame)
  {
    return 0;
  }

  iIndex = FWGetChildFrameIndex(pMainFrame, NULL);

  WB_ERROR_PRINT("TEMPORARY:  %s - move right %d\n", __FUNCTION__, iIndex);

  if(iIndex >= 0)
  {
    FWSetFocusWindowIndex(pMainFrame, iIndex + 1);
  }

  return 1;
}

static int TabMoveLeftHandler(XClientMessageEvent *pEvent)
{
  WBChildFrame *pC;

  if(!pMainFrame)
  {
    return 0;
  }

  pC = FWGetFocusWindow(pMainFrame);

  if(pC)
  {
    FWMoveChildFrameTabIndex(pMainFrame, pC, MOVE_CHILD_FRAME_TAB_INDEX_LEFT);
  }

  return 1;
}

static int TabMoveRightHandler(XClientMessageEvent *pEvent)
{
  WBChildFrame *pC;

  if(!pMainFrame)
  {
    return 0;
  }

  pC = FWGetFocusWindow(pMainFrame);

  if(pC)
  {
    FWMoveChildFrameTabIndex(pMainFrame, pC, MOVE_CHILD_FRAME_TAB_INDEX_RIGHT);
  }

  return 1;
}

static int TabUIHandler(WBMenu *pMenu, WBMenuItem *pMenuItem)
{
  if(FWGetNumContWindows(pMainFrame) > 1)
  {
    return 1; // enabled (more than one tab)
  }

  return -1; // disabled (zero or one child frames)
}

static int ToolBoxHandler(XClientMessageEvent *pEvent)
{
  DLGMessageBox(MessageBox_WTF | MessageBox_No, None, "X11workbench - Unimplemented",
                "ToolBox Handler not (yet) implemented");

  return 1; // "handled"
}

static int ToolBoxUIHandler(WBMenu *pMenu, WBMenuItem *pMenuItem)
{
  return 1; // enabled  (TODO:  check # of tabs, etc.)
}



static int HelpContentsHandler(XClientMessageEvent *pEvent)
{
  Window wIDOwner = pMainFrame ? pMainFrame->wID : None;

  char *pTemp = DLGInputBox(wIDOwner, "Help Contents", "Enter a search term for the documentation", "WBInit", -1, -1);

  if(pTemp)
  {
    DoContextSensitiveHelp(pTemp);

    WBFree(pTemp);
  }
//  else
//  {
//    DLGMessageBox(MessageBox_OK | MessageBox_Bang, wIDOwner,
//                  "Something Bad Happened", "Unexpected 'NULL' return from DLGInputBox");
//  }

  return 1; // handled
}

static int HelpContextHandler(XClientMessageEvent *pEvent)
{
  Window wIDOwner = pMainFrame ? pMainFrame->wID : None;

  DLGMessageBox(MessageBox_OK | MessageBox_Bang, wIDOwner,
                "Context Help", "TODO:  implement the context-sensitive help");

//  DoContextSensitiveHelp(szWhateverWord);

  return 1; // handled
}




//////////////////////////////
//     SIGNAL HANDLER       //
//////////////////////////////


typedef struct _xsiginfo_
{
  const char *szSignal;
  int nSignal;
} XSIGINFO;

#define SIGINFO_ENTRY(X) { #X, X }
static const XSIGINFO aSigInfo[] =
{
SIGINFO_ENTRY(SIGHUP),   //    terminate process       terminal line hangup
SIGINFO_ENTRY(SIGINT),   //    terminate process       interrupt program
SIGINFO_ENTRY(SIGQUIT),  //    create core image       quit program
SIGINFO_ENTRY(SIGILL),   //    create core image       illegal instruction
SIGINFO_ENTRY(SIGTRAP),  //    create core image       trace trap
SIGINFO_ENTRY(SIGABRT),  //    create core image       abort(3) call (formerly SIGIOT)
#ifdef SIGEMT
SIGINFO_ENTRY(SIGEMT),   //    create core image       emulate instruction executed
#endif // SIGEMT
SIGINFO_ENTRY(SIGFPE),   //    create core image       floating-point exception
////SIGINFO_ENTRY(SIGKILL),  //    terminate process       kill program
SIGINFO_ENTRY(SIGBUS),   //    create core image       bus error
SIGINFO_ENTRY(SIGSEGV),  //    create core image       segmentation violation
SIGINFO_ENTRY(SIGSYS),   //    create core image       non-existent system call invoked
SIGINFO_ENTRY(SIGPIPE),  //    terminate process       write on a pipe with no reader
SIGINFO_ENTRY(SIGALRM),  //    terminate process       real-time timer expired
SIGINFO_ENTRY(SIGTERM),  //    terminate process       software termination signal
SIGINFO_ENTRY(SIGURG),   //    discard signal          urgent condition present on socket
////SIGINFO_ENTRY(SIGSTOP),  //    stop process            stop (cannot be caught or ignored)
//SIGINFO_ENTRY(SIGTSTP),  //    stop process            stop signal generated from keyboard
//SIGINFO_ENTRY(SIGCONT),  //    discard signal          continue after stop
SIGINFO_ENTRY(SIGCHLD),  //    discard signal          child status has changed
SIGINFO_ENTRY(SIGTTIN),  //    stop process            background read attempted from control terminal
SIGINFO_ENTRY(SIGTTOU),  //    stop process            background write attempted to control terminal
SIGINFO_ENTRY(SIGIO),    //    discard signal          I/O is possible on a descriptor (see fcntl(2))
SIGINFO_ENTRY(SIGXCPU),  //    terminate process       cpu time limit exceeded (see setrlimit(2))
SIGINFO_ENTRY(SIGXFSZ),  //    terminate process       file size limit exceeded (see setrlimit(2))
SIGINFO_ENTRY(SIGVTALRM),//    terminate process       virtual time alarm (see setitimer(2))
SIGINFO_ENTRY(SIGPROF),  //    terminate process       profiling timer alarm (see setitimer(2))
SIGINFO_ENTRY(SIGWINCH), //    discard signal          Window size change
#ifdef SIGINFO
SIGINFO_ENTRY(SIGINFO),  //    discard signal          status request from keyboard
#endif // SIGINFO
SIGINFO_ENTRY(SIGUSR1),  //    terminate process       User defined signal 1
SIGINFO_ENTRY(SIGUSR2),  //    terminate process       User defined signal 2
{NULL, 0}  // marks end of list
};


static void signalproc(int iSig)
{
static int bCtrlCFlag = 0; // when I hit ctrl+c multiple times, kill the app anyway in case of infinite loop or something

  int i1;

#if 0 /* this is broken now that I have a worker thread - no longer compatible */
  if(iSig == SIGTSTP) // suspend - special 'way cool' handling here [auto-fork!]
  {

    WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Application,
                   "\n**********************************************"
                   "\nSignal received:  SIGTSTP (detaching via fork)"
                   "\n The process has now gone into the background"
                   "\n  and is still running (i.e. not suspended)."
                   "\n**********************************************\n");
    fflush(stderr);

    // POSSIBLE (ALTERNATE) NON-FORKING METHOD
    // see man termios(4) - change process group of terminal, force me into the background
    // I change the controlling terminal process group to that of the shell that created me
//    {
//      pid_t idgParent;
//      int idParent;
//      idParent = getppid();  // parent PID
//      idgParent = getpgid(idParent);  // get process group ID using parent's process id
//
//      if(idgParent != -1)  // wasn't an error
//        tcsetpgrp(0, idgParent);
//
//      if(idParent != -1)
//        kill(idParent, SIGCHLD);  // child process status changed
//    }

    // to simplify matters, I simply fork the process and exit from the original.
    // This satisfies the shell's need to wait for the original process ID when it's
    // not in the background, and effectively keeps the process running on the GUI.
    //
    // De nada.  Bitte.  You're welcome.

    if(fork()) // non-zero means fork failed or NOT the forked process
    {
      exit(0);
    }
    return;
  }
  else if(iSig == SIGCONT) // continue
  {
    return;  // for now, just do nothing
  }
#endif // 0

  for(i1=0; i1 < sizeof(aSigInfo)/sizeof(aSigInfo[0]); i1++)
  {
    if(!aSigInfo[i1].szSignal)
    {
      break;
    }

    if(aSigInfo[i1].nSignal == iSig)
    {
      WB_DEBUG_PRINT(DebugLevel_ERROR | DebugSubSystem_Application,
                     "\nX11workbench - Signal received:  %s\n", aSigInfo[i1].szSignal);

      // only some signals will actually terminate the application.  I shall look for those now.

      if(iSig == SIGHUP || iSig == SIGINT || iSig == SIGQUIT ||
         iSig == SIGILL || iSig == SIGTRAP || iSig == SIGABRT ||
#ifdef SIGEMT
         iSig == SIGEMT ||
#endif // SIGEMT
         iSig == SIGSYS || iSig == SIGTERM || iSig == SIGSTOP ||
         iSig == SIGXCPU || iSig == SIGXFSZ || iSig == SIGFPE)
      {
        if(bQuitFlag && (iSig == SIGSTOP || iSig == SIGTERM || iSig == SIGINT))
        {
          // this section allows you to use TERM STOP or INT 3 times in a row to guarantee
          // that it will kill the process
          if(!bCtrlCFlag)
          {
            WB_ERROR_PRINT("\n----------------------------------------------------------------------------"
                           "\n                    X11workbench CTRL+C signal handler"
                           "\nINT/STOP/TERM, waiting for soft termination - signal again to terminate NOW!"
                           "\n----------------------------------------------------------------------------\n");
            fflush(stderr); // make sure it flushes output IMMEDIATELY
            bCtrlCFlag = 1; // if I get another, I kill it
          }
          else
          {
            WB_ERROR_PRINT("\n----------------------------------------------------------------------------"
                           "\n                    X11workbench CTRL+C signal handler"
                           "\nINT/STOP/TERM, aborting waiting for soft termination - terminate RIGHT NOW!!"
                           "\n----------------------------------------------------------------------------\n");
            exit(1); // exit with abnormal termination
          }
        }
        else
        {
          bCtrlCFlag = 0; // reset it (quit was aborted??)
        }

        bQuitFlag = TRUE; // soft termination
      }

      if(iSig == SIGKILL || iSig == SIGSEGV)  // special handling, must terminate process
      {
        signal(iSig, SIG_DFL); // disable recursive signaling

        if(iSig == SIGKILL)  // special handling, must terminate process
        {
          WB_ERROR_PRINT("caught signal %d (SIGKILL), terminating now\n", iSig);
          exit(0); // 'KILL' signal is not considered an error
        }
        else
        {
          WB_ERROR_PRINT("caught signal %d (SIGSEGV), terminating now\n", iSig);

          _exit(1); // calling this version to avoid possible problems with signal handling
                    // it's considered to be 'signal handler safe' though it doesn't flush buffers
                    // nor delete temp files the way 'exit()' would...
        }
      }

      if(iSig == SIGBUS)  // might happen
      {
        WB_DEBUG_PRINT(DebugLevel_ERROR | DebugSubSystem_Application,
                       "SIGBUS received (this is usually caused by use of a data pointer instead of a function pointer)\n");
        _exit(1);
      }

      return;
    }
  }

  WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Application,
                 "signal proc (%d) (%08xH)\n", iSig, iSig);

//  bQuitFlag = TRUE;
}


static void SetSignalHandlers()
{
  int i1;
  for(i1=0; i1 < sizeof(aSigInfo)/sizeof(aSigInfo[0]); i1++)
  {
    if(!aSigInfo[i1].szSignal)
      break;

    if(signal(aSigInfo[i1].nSignal, signalproc))
    {
      WB_WARN_PRINT("%s - WARNING:  Unable to assign signal proc for %s\n", __FUNCTION__, aSigInfo[i1].szSignal);
    }
  }
}





