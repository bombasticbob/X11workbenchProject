////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                //
//       _                                                                        _               _               //
//    __| |  ___ __  __ _   _       ___  ___   _ __ ___   _ __ ___    ___  _ __  | |_  ___     __| |  ___ __  __  //
//   / _` | / _ \\ \/ /| | | |     / __|/ _ \ | '_ ` _ \ | '_ ` _ \  / _ \| '_ \ | __|/ __|   / _` | / _ \\ \/ /  //
//  | (_| || (_) |>  < | |_| |    | (__| (_) || | | | | || | | | | ||  __/| | | || |_ \__ \ _| (_| || (_) |>  <   //
//   \__,_| \___//_/\_\ \__, |_____\___|\___/ |_| |_| |_||_| |_| |_| \___||_| |_| \__||___/(_)\__,_| \___//_/\_\  //
//                      |___/|_____|                                                                              //
//                                                                                                                //
//         This file contains doxygen-specific text that must appear in the right order to work properly          //
//                                                                                                                //
//      Additionally, documentation that does not belong in a source or header file will be contained here.       //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2018 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no waranties, either implied or explicit.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README.md files for more information.


  Additional information at:
    http://sourceforge.net/projects/X11workbench
    http://github.com/bombasticbob/X11workbenchProject
    http://www.mrp3.com/

******************************************************************************/



/** \mainpage X11workbench Toolkit Documentation
  * \tableofcontents
  *
  * Welcome to the main page for the X11workbench Toolkit documentation.  As you will no
  * doubt see, this was generated using Doxygen, using the 'doxy.txt' file that is an
  * integral part of the project.  You are welcome to use and/or customize this documentation
  * to any extent that you might you see fit, in accordance with the Copyright and License Terms.
  * \n
  * \n
  * For \ref mainpage_copyright, see the appropriate section (below).
  * \n
  * \n
  * \section summary Summary and Back Story
  * \details
  *
  * The X11workbench Toolkit is my response to the inadequacies, difficulty in learning, and
  * general overcomplexity of X11 GUI development.  Going back to my roots in OS/2 and Windows
  * programming, I have tried to take what I believe is the best (and simplest) of THAT world
  * and create a toolkit that looks, well, a LOT like what I came from, taylored specifically
  * to the world of X11.\n
  * \n
  * The main goal is to produce a toolkit that can be copied and pasted
  * into just about any GUI project, and then used as-is to provide straightforward no-nonsense
  * windows with easily recognizable features, without carrying around a boatload of extra
  * baggage commonly found in large scale toolkits.\n
  * \n
  * Let's face it, X11 is DIFFICULT to code for natively.  That is, it's difficult to code for
  * unlessyou don't want to do anything besides creating a simple window with nothing in it.
  * The use of a decent toolkit can shave YEARS off of a project.  However, if the toolkit causes
  * load times to become IRRITATING, or use up way too many resources on the computer, or put
  * too many dependency requirements on developers (until it becomes
  * <a href="http://tvtropes.org/pmwiki/pmwiki.php/Main/NightmareFuel">nightmare fuel</a>),
  * it can ultimately lead to frustration and disappointment.\n
  * \n
  * Hence, THIS toolkit was made as an alternative to the "boatload of garbage" that so often
  * ends up being shoved into a 'monolithic toolkit' (or API) that just has to fill every possible
  * set of shoes ever thought up.  It is common to list a projects features in the design phase,
  * such that the most important features are ranked according to importance, in a pareto analysis.
  * And a common principle in this kind of pareto analysis is that the first large chunk of functionality
  * can be taken care of in a small chunk of time with a small chunk of resources.  The remaining
  * functionality (that which pleases the widest possible audience) will typically take up SIGNIFICANTLY
  * more time and resources to implement.  It's sometimes called a 70/30 rule or an 80/20 rule, implying
  * that the first 70% or 80% of functionality can be done in 30% or 20% of the time.  The remaining
  * functionality (a much smaller percentage) consumes an inordinately LARGE amount of the time.  So
  * I will only focus on the 70% or 80% [when compared to other toolkits] for my own toolkit.\n
  * \n
  * After all, if you try to please EVERYBODY by providing EVERY possible functionality they might need,
  * you'll end up with a gigantic monolithic pile of wastefulness that requires way too many resources
  * to write, run, and maintain.  And typically it is CONSTANTLY being updated to the point of insanity.
  * The only reasonable way to make things work well in a 'lightweight' sense, with at least SOME stability,
  * is to pick the key features that MOST people will need (the 70%), plus those that are needed to 'glue'
  * it all together, and ONLY address those.  If the end users or developers want all that other stuff, they
  * are free to use a monolithic, all-encompassing toolkit to do it.  Otherwise, if you want a lean and mean
  * application with a lightweight toolkit that loads fast, runs fast, and doesn't take a whole lot of effort
  * to create an application with, you'll probably want to use the X11workbench Toolkit.
  * \n
  * There are many who ALWAYS say 'do not re-invent the wheel'.  But auto makers do that EVERY YEAR.
  * And this wheel needed to be re-invented, so I DID IT.  It took a while, and nobody came up with anything
  * better during the several YEARS I have been working on this (at least as far as I know).\n
  * \n
  * So, if you were looking for a monolithic toolkit that supports every possible feature on the planet, then you'll want
  * Qt or GTK or similar.  If you prefer C++ objects you might consider Motif or wxWidgets.  Otherwise, have fun with
  * a relatively simple, yet very effective C language toolkit, aka the X11workbench Toolkit.  You're welcome.
  *
  * \n
  * \n
  *
  * \section mainpage_copyright Copyright and License Terms
  * \details
  *
  * \b Copyright \b and \b License \b Terms b for \b the \b X11workbench \b Toolkit
  *
  * <b>COPYRIGHT</b>
  *
  * <PRE>
  *
  *      X11workbench - X11 programmer's 'work bench' application and toolkit
  *       Copyright &copy; 2010-2018 by Bob Frazier (aka 'Big Bad Bombastic Bob')
  *                               all rights reserved
  *
  * DISCLAIMER:  The X11workbench application and toolkit software are supplied
  *              'as-is', with no waranties, either implied or explicit.
  *
  * </PRE>
  *
  * <b>LICENSE TERMS</b>
  *
  * BSD-like license:
  *
  * There is no restriction as to what you can do with this software, so long
  * as you include the above copyright notice and DISCLAIMER for any distributed
  * work that is linked with, equivalent to, or derived from any portion of this
  * software, along with this paragraph that explains the terms of the license if
  * the source is also being made available.  "Linked with" includes the use of a
  * portion of any of the source and/or header files, or their compiled binary output,
  * as a part of your application or library.   A "derived work" describes a work
  * that uses a significant portion of the source files or the algorithms that are
  * included with this software.
  *
  *
  * GPL license:
  *
  * You may distribute this application, or any derived work, under the following
  * GPL licenses:
  *
  * \li [L]GPL v2 or v2.1\n
  * \li [L]GPL v3 or later
  *
  *
  * If you use an unmodified source for the X11workbench Toolkit or the X11workbench
  * application, providing a URL for the official source repository will consistitute
  * compliance with the GPL license requirement of making the source available to
  * anyone receiving a binary copy of this (or any derived) work, so long as all
  * other requirements associated with the license are fulfilled.
  *
  *
  * <b>EXCLUSIONS</b>
  *
  * Specifically excluded from this requirement are files that were generated by the
  * software, or anything that is included with the software that is part of another
  * package (such as files that were created or added during the 'configure' process).
  *
  * <b>DISTRIBUTION</b>
  *
  * The license also covers the use of part or all of any of the X11 workbench
  * toolkit source or header files in your distributed application, in source or
  * binary form.  If you do not ship the source, the above copyright statement and
  * DISCLAIMER is still required to be placed in a reasonably prominent place,
  * such as documentation, splash screens, and/or 'about the application' dialog boxes.
  *
  * Use and distribution are in accordance with GPL, LGPL, and/or the above
  * BSD-like license.  See COPYING and README.md files for more information.
  *
  * Additionally, this software, in source or binary form, and in whole or in part,
  * may be used by explicit permission from the author, without the need of a license.
  *
  * You will find similar language and copyright statements at the beginning of most of the source
  * files (and related files) that comprise the X11workbench and X11workbench Toolkit.  If
  * there is any confusion as to the intent of the license, the above stated license terms take
  * precedence.
  *
  * \n
  * \n
  *
  * \section mainpage_1a Design Goals for the X11workbench Toolkit
  * \details
  *
  * \b Design \b Goals
  *
  * \par Minimal dependencies
  * You shouldn't have to install a bozillian libraries or development files.\n
  * \par Ease of use
  * The basic toolkit should be SO simple that even a 'Newbie' can do it.\n
  * \par Customizable
  * Well, open source HELPS, but the design must be FLEXIBLE enough to allow easy customization.\n
  * \par Practical
  * Unnecessary functionality, with the exception of certain icons, is to be avoided.\n
  * \par Logical
  * No convoluted ideas belong here, like the bass-ackwards programming style you find in _CERTAIN_ languages.\n
  * \par C language
  * For maximum compatibility, the C language is almost universally supported, so that's what I use.\n
  * \par Bulletproof
  * Even if there is a problem, the code should NEVER be 'fragile'.  Validation happens a lot, whenever practical.\n
  * \par Debug Friendly
  * Lots of built-in debug, needed by me to even write the thing after all.\n
  * \par Small (and simple) 'hello world' application
  * The 'hello world' application should be reasonable AND SMALL, and not because special things
  * were written JUST TO MAKE THAT HAPPEN (that is called 'engineering for the demo' and I don't like doing that)\n
  *
  * \n
  * \n
  *
  * \section mainpage_3 Additional Information
  * \details
  *
  * Additional information
  *
  * For more information on the X11workbench application or the X11workbench Toolkit, visit
  *
  * http://sourceforge.net/projects/x11workbench\n
  * http://github.com/bombasticbob/X11workbenchProject\n
  * http://www.mrp3.com/\n
  *
  *
  * The latest official on-line documentation can be found at:
  *
  * http://bombasticbob.github.io/X11workbench
  *
**/

/** \page mainpage_style X11workbench Toolkit Coding Style Guidelines
  *
  * \b CODE \b APPEARANCE
  *
  * \b Coding \b Style for this project uses \b Allman \b Style indenting, NO hard tab characters, and
  * with 2 (two) spaces per indent.  See http://en.wikipedia.org/wiki/Indent_style#Allman_style
  *
  * On FreeBSD, you can rapidly convert 'less readable' code to the 'improved' (and approved) style using
  * the following command:
  *
  * \code
  indent -bl -ncdb -nce -ci3 -cli1 -c1 -d0 -di1 -dj -nfc1 -nfcb -i2 -l255 -lp -npsl -nsc -nut filename.c
  * \endcode
  *
  * With the exception of macros, ALL conditional and loop commands (if, for, while) must be
  * on a line SEPARATE from the opening curly brace, and ALL of them should have curly braces
  * around the conditional or loop body (particularly for a single line of executed code).  The
  * only exception would be a 'for' or 'while' loop that has no body, which can have '{ }'
  * following the 'for' or 'while' to visually indicate that there is no loop body.\n
  *
  * The purpose for this rule is twofold:  First, it is not (easily) possible to set a breakpoint
  * on a conditional statement that is on the same line as an 'if', or within a loop if it is
  * on the same line as a 'for' or 'while'.  Second, the code is a LOT more readable when extra
  * line feeds are thrown in, even though it means you have an 'otherwise blank' line.  If you
  * are THAT concerned about vertical white space, use it by putting a comment after the '{' or '}'.
  *
  * White space between 'if' 'for' 'while' and the leading paranthesis '(' is discouraged.  The
  * same is true for function calls and function definitions.  It does not really add to the
  * readability.  Multiple lines properly indented, however, CAN make things more readable.\n
  *
  * 'else' is NEVER on the same line as '{' or '}'.  NEVER.  Not negotiable.  'else if' is OK.\n
  * But NEVER should '} else {' EVER exist ANYWHERE in this code base.  It's just plain UGLY.\n
  * And for what it's worth, 'if (conditional) {' is nearly as bad.  Put the '{' on its OWN line,
  * as I pointed out above.
  *
  * When the line length of a single code statement exceeds the typical width of an editor
  * (80 to 100 columns), you should split it onto multiple lines.  Indentation of the lines should
  * follow a reasonable method that helps you to 'visually group' things.  Here are a few examples:\n
  * \code

    for(i1=0,p1=buffer,pEnd=buffer + sizeof(buffer);
        p1 < pEnd;
        p1++, i1++)
    {
      ...
    }

    if(p1 &&
       ((*p1 == '\'' && (!p1[1] || p1[1] == '\'')) ||
        (*p1 == '"' && (!p1[1] || p1[1] == '"'))))
    {
      ...
    }

  * \endcode
  *
  * \b SECURITY \b AND \b PERFORMANCE
  *
  * Avoid ANY possibility of buffer overruns.  Use 'fgets' and not 'gets', do parameter checking
  * and parse 'the hard way' instead of using scanf or sscanf for string parameters, etc.\n
  * If 'proof of concept' or 'under development' code temporarily uses 'the wrong method', mark
  * the code with a 'TODO' comment to indicate that it needs to be re-factored for reliability.
  *
  * Avoid excessive use of allocated memory.  If you need a lot of small memory blocks, create a structure
  * instead, and allocate THAT way.  If the structure has an array in it, the array should be the final
  * member of the structure, declared with a single element, and the actual size of the structure
  * should be large enough to accomodate the entire array.  There are already a lot of examples of
  * dynamically sized array structures within the code that behave this way.\n
  *
  * In cases where an object may be accessed by a worker thread after the main thread has
  * destroyed it, you should use reference counting to prevent accessing 'free'd memory blocks.
  *
  * There is a set of generic platform-independent sub-allocation utilities, WBAlloc(), WBReAlloc() and WBFree().
  * In those cases where you really DO need to allocate a lot of dynamic memory blocks, use these functions
  * in lieu of 'malloc()' 'realloc()' or 'free()'.  Contributed code should not abuse these functions,
  * but INSTEAD make use of them ONLY when actually needed, and get cleaned up properly.  There should NEVER
  * be any 'use after free' or 'memory leak' problems in the toolkit or in the X11 Workbench.

  * Preventing 'use after free' can be a simple discipline of assigning any pointer to NULL right after
  * calling WBFree(), even if there is no code that might use the pointer (for now, at least).  Code
  * that might be added later by others may attempt to use this pointer, assuming it is valid.  Assigning
  * it to NULL is therefore pre-emptive in this case, forcing a crash to occur instead of pointer re-use,
  * which is FAR more preferable, as it would likely be caught early on.
  *
  * All functions must be declared in the form of 'a prototype', as per ANSI standards.  Functions
  * without any arguments must have '(void)' rather than '()'.  All function return types are to be
  * declared (no assumptions), and inline functions MUST be declared 'static', especially in
  * header files.\n
  *
  * Declaring no-parameter functions with a prototype or using '(void)' for the parameter list, will
  * work around those casees where a function is declared earlier in the code, without an actual
  * prototype, and you get a warning that it is "not a prototype".
  *
  * You should do a test-build of the code on multiple platforms, both debug and release, and eliminate
  * all compile warnings.  In some cases a warning will be generated on a 32-bit system but not on
  * a 64-bit system (or vice versa).  In other cases a warning may be generated by a compiler on
  * one operating system but not another.  Building on multiple platforms helps to address this.
  *
  * \b OBJECTS \b AND \b SHARED \b DATA
  *
  * C language code can be 'object oriented' too, if designed properly, by using object-oriented
  * principles in the design and use of structures as 'objects'.  Several structures are
  * already being abstracted to 'hide' members that are for internal use only, and others have
  * function 'vtable' structures associated with them.  If you create a persistent structure
  * that is to be shared or abstracted, you should have a 'Constructor' API function and a
  * corresponding 'Destroy' API function (as needed).\n
  *
  * For shared objects, particularly those that may be used simultaneously by different threads, you
  * should have thread-safe entry/exit code (as needed) and some form of reference counting, such as
  * 'AddRef/Release' functions, in which 'the final Release' will actually destroy the object.  This
  * is similar to the object reference count handling done by both CORBA and OLE 2.0\n
  *
  * \b CODE \b COMMENTS \b AND \b NAMING \b CONVENTIONS
  *
  * Code comments are always welcome.  Unless the comments are trivial, there is no such thing as
  * "too many comments", and even trivial ones might be welcome at times.  Single-line comments
  * are preferred except for '\#define', unless you need a commented area to 'stand out' more.\n
  *
  * API functions and structures must have minimal doxygen comments describing the functions,
  * parameters, and structure members.  They should also be members of functional groups.
  * No exceptions.  You should also test the resulting documentation to make sure it's properly
  * formatted and that all of the links work correctly.
  *
  * Code should be as self-documenting as possible.  Non-trivial variables should be declared
  * using descriptive names.  Hungarian notation can be helpful, but is not required.  Single-character
  * variable names are DIFFICULT TO CHANGE without manual effort and should be AVOIDED, ALWAYS!\n
  * Use of non-descriptive variables such as 'i1' or 'p3' is ok so long as its usage is intuitively
  * obvious within the code.  If any confusion might arise from a casual observer, use more descriptive
  * variable names.  Common sense should be the rule here.
  *
  * 'CamelHump' names should capitalize in a manner that helps understand where the word divisions
  * are.  Similarly, underscores can be used for 'all_lower_case' names for the same purpose.
  * Generally, API functions are 'CamelHump', utilities and trivial functions are 'all_lower_case',
  * '\#define's are ALL_CAPS, and enumerations are prefixed with the enumeration name.  API functions
  * should also begin with something that identifies the subsystem, such as 'WB' or 'FW' or 'Dlg'.  This
  * is NOT a 'hard' rule, but it DOES help minimize confusion and name collisions.\n
  * It is also typical to prefix '_' or '__' on alias names or internal-use functions.  Such names and
  * functions should not be publically used except as part of a typedef.  Example, a structure name
  * of '_my_struct_' typedef'd as MY_STRUCT.  Members of 'MY_STRUCT' (such as linked list pointers) are
  * likely to refer to the structure name itself, and not the typedef name, so both names are needed.
  *
  * 'Magic numbers' are a necessary evil sometimes.  Either document where the number came from,
  * or use a '\#define' with a descriptive name, or use BOTH.  A '\#define' placed in the code within a
  * function is acceptable as long as it's only used within that function.\n
  *
  * \b GOOD \b AND \b BAD \b CODE \b EXAMPLES:
  *
  * \code

  // ----------
  // -- GOOD --
  // ----------

  #define MY_BUFFER_SIZE 256
  int main(int argc, char *argv[])
  {
    int i1;
    char buffer[MY_BUFFER_SIZE];

    // use of 'fgets' with specific buffer size
    // no danger of buffer overflow this way

    if(fgets(buffer, sizeof(buffer), stdin))
    {
      i1 = strlen(buffer);

      fprintf(stdout, "Hello World %d\n", i1);
      // using fprintf rather than printf, but specifying 'stdout'
      // If need be, it can be easily re-directed to a different file
      // it also clarifies that output will be to 'stdout'.

      return 0; // standard 'success' return value of zero
    }
    else // proper error/exception handling
    {
      fprintf(stderr, "fgets returned NULL\n");
      // error messages to 'stderr'

      return 1; // return an error code
    }
  }

  // ---------
  // -- BAD --
  // ---------

  main() {
    // ugly '{' on same line as function - this is supposed to be ANSI C, and NOT K&R nor PASCAL!
    // function parameters missing, should be (void) or properly declared, even if unused
    // missing return type on 'main' (int assumed, don't rely on it!)

    int a;           // single-character name, no indication of type from the name
    char b[256];     // single-character name, 'magic number' buffer size

    if (gets(b)) a = strlen(b);    // 'if' on same line as conditional code (can't set debug breakpoint!)
                                   // 'gets' has no buffer size checking, buffer overrun possible
                                   // no '{' '}' around the conditional code block (bad style)

    printf ("Hello, World %d\n", a); // use of 'printf' discouraged; 'fprintf' with 'stdout' or 'stderr'
                                     // is preferred.  Use stderr for messages unless it's "the actual output"

    // sloppy error handling ('a' may be un-initialized)

    // no return value specified
  }

  * \endcode
  *
**/

/** \page mainpage_tutorial API Tutorials and Quick-Start guides
  *
  * \par For basic sample code, you can start here:
  * \ref mainpage_4 \n
  * \ref events \n
  * \n
  *
  * \par For information on the menu handling framework:
  * \ref menu_resource \n
  * \ref menu \n
  * \n
  *
  * \par For information on dialog boxes:
  * \ref dialog_api\n
  * \ref dialog_resource \n
  * \n
  *
  * \par For process control, i.e. running external programs:
  * \ref process \n
  * \n
  *
  * \par For information on threads and synchronization
  * \ref threads \n
  * \n
  *
  *
  * (additional information and tutorials to be added at a later date)
  *
**/

/** \page mainpage_4 'Hello World' sample using the X11workbench Toolkit
  *
  * \code

  #include <stdio.h>
  #include <stdlib.h>

  #include "window_helper.h"
  #include "dialog_window.h"

  int main(int argc, char *argv0[], char *envp0[])
  {
  int iRval = 1;
  char **argv = argv0; // re-define as char ** so I can re-allocate it as needed
  char **envp = envp0;

    if(!WBParseStandardArguments(&argc, &argv, &envp))
    {
      if(WBInit(NULL))
      {
        DLGMessageBox(MessageBox_OK | MessageBox_Info, None,
                      "Hello World",
                      "Hello World using X11workbench Toolkit");

  // if your application creates a modeless dialog window or frame window, you will
  // need a message loop.  For the sample, it is disabled with an '#if 0' block
  #if 0
        //=====================
        //   MAIN EVENT LOOP
        //=====================

        while (!bQuitFlag)
        {
          if(!WBCheckGetEvent(pX11Display, &event))
          {
            // SLEEP if no event while in message loop (function returns without blocking)
            // otherwise I can do background tasks during this loop iteration.

            WBDelay(100); // 100 microseconds (0.1 milliseconds)

            continue; // skip the 'WBDispatch' since there was no event
          }

          WBDispatch(&event);
        }
  #endif // 0


        WBExit(); // this frees toolkit resources and closes windows, etc.

        // The application itself continues to run past this point
      }

      // Freeing up 'possibly allocated' memory for envp, argv

      if(envp && envp != envp0) // was envp re-allocated by the toolkit?
      {
        WBFree(envp); // use 'WBFree' to free memory allocated by the toolkit
      }

      if(argv && argv != argv0) // was argv re-allocated by the toolkit?
      {
        WBFree(argv);
      }
    }
    else
    {
      WBToolkitUsage(); // print usage information to stderr
    }

    return iRval;
  }

  * \endcode
  *
**/

/** \page menu_resource Menu Resources and Menu Callbacks
  * \details
  *
  * For menus to be processed automatically by a \ref WBFrameWindow "Frame Window", you need to
  * set up menu resources and callback function arrays.
  *
  * The menu identifiers are atoms that are specified using plain text identifiers, both
  * in the menu resource AND in the menu callback arrays.  These callback arrays are assigned
  * to both \ref WBFrameWindow "Frame Windows" and \ref WBChildFrame "Child Frames".
  *
  * When a \ref WBChildFrame "Child Frame" has a menu assigned, or a menu callback array, whenever it is active
  * its menu and/or callback array is used for automatic menu processing.  Otherwise, the menu
  * and/or callback array for the Frame Window will be used.
  *
  * The \ref WBFrameWindow "Frame Window" allows you to automatically specify a menu resource
  * and menu callback array when you create it, via the FWCreateFrameWindow() function, and
  * the FWSetMenuHandlers() function.  You first create the window, and then assign its menu
  * handlers whenever you need them.  You can also assign different handlers for different
  * application states, as necessary.
  *
  * A typical menu resource might look like the following example:
  * \code

  static char szAppMenu[]="1\n"
                          "_File\tpopup\t2\n"
                          "_Tools\tpopup\t5\n"
                          "\tseparator\n"
                          "_Help\tpopup\t3\n"
                          "\n"
                          "2\n"
                          "_New File\tIDM_FILE_NEW\tNew File\tCtrl+N\n"
                          "_Open File\tIDM_FILE_OPEN\tOpen File\tCtrl+O\n"
                          "\tseparator\n"
                          "E_xit\tIDM_FILE_EXIT\tClose Application\tAlt+F4\n"
                          "\n"
                          "3\n"
                          "_Contents\tIDM_HELP_CONTENTS\tHelp Contents\tAlt+F1\n"
                          "Conte_xt\tIDM_HELP_CONTEXT\tContext Help\tF1\n"
                          "\tseparator\n"
                          "_About X11workbench\tIDM_HELP_ABOUT\tAbout X11workbench\tAlt+F1\n"
                          "\n"
                          "5\n"
                          "_Options\tIDM_TOOLS_OPTIONS\tDisplay Options Editor\n"
                          "\n";


  * \endcode
  *
  * This example shows top level menus for 'File', 'Tools', and 'Help' with a separator between 'Tools'
  * and 'Help'.  The '_' indicates that the next char will be displayed with an underscore, AND that it
  * will act as a hotkey (top-level menus use Alt+char as the hotkey; popups can use other combinations).
  *
  * To make the menu work, you need that callback array.  For this menu, a simplified callback array
  * is shown here (it uses macros for initialization):
  *
  * \code

  FW_MENU_HANDLER_BEGIN(main_menu_handlers)
    FW_MENU_HANDLER_ENTRY("IDM_FILE_EXIT",FileExitHandler,NULL)
    FW_MENU_HANDLER_ENTRY("IDM_FILE_NEW",FileNewHandler,NULL)
    FW_MENU_HANDLER_ENTRY("IDM_FILE_OPEN",FileOpenHandler,NULL)
    FW_MENU_HANDLER_ENTRY("IDM_HELP_ABOUT",HelpAboutHandler,NULL)
    FW_MENU_HANDLER_ENTRY("IDM_HELP_CONTEXT",HelpContextHandler,HelpContextUIHandler)
    FW_MENU_HANDLER_ENTRY("IDM_HELP_CONTENTS",HelpContentsHandler,NULL)
  FW_MENU_HANDLER_END

  * \endcode
  *
  * The FW_MENU_HANDLER_BEGIN macro creates a variable 'main_menu_handlers' that is an array
  * containing the menu handler information.  Each entry following that has 3 parameters:
  * \li The string identifier, in quotes, as defined in the menu resource
  * \li The menu callack that is invoked when the menu item is selected.  Can be NULL if only a UI callback is needed.
  * \li The (optional) 'UI' menu callback that is invoked when the menu needs information on how to display itself.
  * if there is no UI callback, then specify NULL.
  *
  * A menu UI callback returns a negative value to 'disable', or zero to 'enable' a menu item.  Other
  * capabilities are reserved for future use.
  *
  * See Also:  \ref FW_MENU_HANDLER_ENTRY "FW_MENU_HANDLER_ENTRY"
  *
  * The menu resources themselves consist of a set of lines, with several tab-delimited parameters
  * on each line.  The types of menu entries are:
  * \li Menu Identifier:  a number followed by a linefeed '\\n'.  This identifies a specific menu within
  * the resource.  The top level menu should be identfied with a "1\\n".
  * \li Menu Item:  A string, followed by tabbed columns indicating the identifier, tooltip text,
  * and shortcut key, and ending with a linefeed.  Top level menu items will not have shortcut keys.
  * \li Popup Menu:  A string, followed by tabbed columns, the first being the word 'popup', followed by
  * a popup menu ID (a number), and a linefeed.
  * \li Separator:  Begins with a tab character, and is followed by the word 'separator' and a linefeed.
  * \li Dynamic:  (reserved) Begins with a tab character, followed by the word 'dynamic', a tab, and an
  * identifier that will be passed to a UI callback.  The UI callback will indicate which menu items will
  * be inserted at that position.  This functionality is reserved for future use.
  *
  * Popups are each identified by their own resource, which begins with a single number followed by
  * a linefeed, followed by additional menu resource information.  In the example, there are 4 popup
  * menus identified by the numbers '2' through '5'.  These can invoke other popup menus, as needed.
  *
  * Menu callback functions have prototypes similar to the following:
  * \code

  int MenuHandler(XClientMessageEvent *pEvent);

  * \endcode
  *
  * It will be invoked by passing in a Client Message event, where the Atom for 'pEvent->message_type' will
  * be \ref aMENU_COMMAND "'aMENU_COMMAND'", and pEvent->data.l[0] will contain the menu item's Atom.  This
  * way, it is possible to share the same callback function for multiple message identifiers, by checking
  * the contents of the XClientMessageEvent to determine how to process it.
  *
  * A menu UI callback function is declared similar to the following:
  * \code

  int MenuUIHandler(WBMenu *pMenu, WBMenuItem *pMenuItem);

  * \endcode
  *
  * The 'pMenu' and 'pMenuItem' pointers identify the menu and menu item associated
  * with the UI request.  The function will return '1' to enable, or -1 to disable the menu
  * item associated with the callback.  A value of '0' is currently undefined, and will result
  * in a behavior as if NO UI callback were defined.
  *
**/

/** \page dialog_resource Dialog Box Resources
  * \details
  *
  * To simplify the creation of one of the most COMMON types of windows, the Dialog Box,
  * the X11workbench Toolkit uses a TEXT RESOURCE format that can be subsequently passed
  * to a high-level function to create a dialog box, either modal or modeless.  The return
  * value from a modal dialog box will be based on the value passed to \ref WBEndModal().
  *
  * For more information on creating a dialog box, see \ref DLGCreateDialogWindow().
  *
  * The format of the dialog box resource begins with the 'BEGIN_DIALOG' keyword, and
  * ends with the 'END_DIALOG' keyword.  In between are the various dialog controls, in
  * their 'tab order', such that the first control in the list that is capable of receiving
  * the input focus will get the focus when the window is made visible.
  *
  * A typical dialog window resource might look as follows:\n
  * \code

  BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:"Sample Message Box Dialog Window"
    CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE
    CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE
    CONTROL:DefPushButton ID:IDOK TITLE:OK X:80 Y:28 WIDTH:40 HEIGHT:18 VISIBLE
  END_DIALOG

  * \endcode
  *
  *
  * The general form of a dialog resource keyword is as follows:
  *
  * KEYWORD[:type] [ID:value] [property[:value] [property[:value] [...]]]
  *
  * where KEYWORD is defined as BEGIN_DIALOG, END_DIALOG, or CONTROL
  *  and  'type' is valid ONLY for 'CONTROL'
  *  and  'ID' is valid ONLY for 'CONTROL' or sub-dialogs
  *  and  'property' represents one or more properties (which may or may not have values).
  *
  * The value of a property is always separated from the property by a : with no white space.
  * If the value contains white space, it must be quoted (as in the above sample).  A doubled
  * quote mark will translate into a single quote if embedded within identical quote marks, such as
  * \code

  "This is a ""quote"" mark"

  * \endcode
  * translating into
  * \code

  This is a "quote" mark

  * \endcode
  *
  * Properties that use reserved keywords will NORMALLY have their values stored directly into the
  * corresponding area(s) within the dialog box's defining structures.  Additional properties
  * (including custom properties) that are specified for a control will be stored in a 'property list'
  * for that control using atoms to identify the property, and with the specified 'value' (as text).\n
  * For more information, see \ref WBDialogPropList() __WB_DIALOG_PROPLIST__ __WB_DIALOG_PROP__ \n
  *
  * In some cases, properties may be mutually exclusive, and by definition the last specified property
  * will be the one that takes precedence.  The same is true for duplicate entries.\n
  *
  * DIALOG CONTROL PRE-DEFINED TYPES
  *
  * The following pre-defined dialog control types are recognized:
  *
  * Static controls.  These can act as 'hot key' anchors for selecting the next
  * control in the tab order when there is 'underline' text AND the user presses
  * a hot-key consisting of CTRL + 'the underlined character'.  By definition the
  * input focus can NOT be assigned to a static control.
  * \li Frame:  A static 'frame' or bounding box, optionally with a caption
  * \li Text:  A static text control that can display 'underline' text
  * \li Icon:  An icon image (includes a transparency pixmap)
  * \li Image:  A regular pixmap image without transparency
  *
  * Edit controls.  Allows editing of text.  Can have focus.  Can be scrollable.  No caption.
  * \li Edit:  A single or multi-line text edit control.
  *
  * Button controls.  Mouse and keystroke activated (using hotkeys corresponding to underlined
  * characters).  Can have focus.  Buttons are activated by 'space bar' when they have the input focus
  * (pushbuttons are also activated by &lt;ENTER&gt; when the button has input focus).  Default
  * buttons are automatically 'activated' when the user presses &lt;ENTER&gt;, unless the control 'owns'
  * the '&lt;ENTER&gt;' key press event (such as with an 'edit' control, or a pushbutton with the input focus).
  * Nearly all button controls can be activated via a hot key using CTRL + 'the underlined text' in the caption.
  * \li PushButton:  Rectangular push button with text.
  * \li DefPushButton:  'Default' rectangular pushbutton.  Allows &lt;ENTER&gt; to activate it (under most circumstances)
  * \li CancelButton:  'Cancel' rectangular pushbutton.  Allows &lt;ESC&gt; to activate it (under nearly all circumstances)
  * \li RadioButton:  Round 'one of many' selection button.
  * \li FirstRadioButton:  Defines start of new 'group' of radio buttons.
  * \li CheckButton: 'Check Box' button (2-state)
  * \li TriStateButton: 'Tri State' check button (3 state), typically on/off/gray
  *
  * Scrolling controls.  User-selectable value between two limits, using rotating or sliding effect.
  * \li HScroll:  Horizontal scroll bar
  * \li VScroll:  Vertical scroll bar
  * \li Slider:  Horizontal or Vertical 'slider' (based on dimensions)
  * \li Knob:  Rotating control (270 degrees or 360 degree continuous)
  *
  * List controls.  List, drop-down list, edit with dropdown list, and tree controls.
  * \li List:  Classic listbox, optionally sortable, optionally multi-select
  * \li Combo: Classic drop-down list or edit with dropdown list
  * \li Tree: Tree control, as listbox with 'openable' hierarchy
  * \li ComboTree:  Like drop-down list but with hierarchical tree
  *
  * File/Path selection
  * \li FileList: Specialized List using filenames.  Directories specified first, displayed in bold text
  * \li FileCombo: Specialized drop-down or editable combo box, similar to above
  * \li PathTree: Specialized Tree using path names, open directory to list/refresh contents
  *
  * Sub-dialogs and Tab (container) control
  * \li Tab: Container for sub-dialogs, one per tab.
  *
  * See Also: \ref dlgctrl_atom
  *
  * RESERVED: adding the ability to register custom control types
  *
  *
  * PRE-DEFINED PROPERTIES
  *
  * Certain pre-defined properties have special meaning.  The following is a brief description
  * of what the semantics are.
  *
  * ID: The identifier of a control or sub-dialog.  A value is required.  The value may be one of the
  * pre-defined atoms, a custom (registered) atom with an associated integer ID value, or a hard-coded integer value.
  * Control messages to and from this control (or sub-dialog) will always use the ID value as an integer, regardless,
  * and so the pre-defined and registered atoms must have a unique integer associated with them.
  *
  * X,Y,WIDTH,HEIGHT:  These properties specify the size and position of a control (or dialog box)
  * using 'dialog units', which are roughly equivalent to the default font size.  The semantics are
  * actually similar to those used by other operating systems in an attempt to make dialog boxes
  * appear roughly the same (with respect to font size) at different screen resolutions.
  *
  * FONT:  The desired font face name and/or size.  When specified for a dialog box, it alters the
  * base dialog units accordingly, and applies for all controls that do not specify a font.  Otherwise,
  * it only applies to a single control.
  *
  * TITLE:  The 'title' string associated with a dialog box or control.  The title for a control is normally
  * stored as the 'CAPTION' property value.  The value is required and must be a string, though quotes are only
  * required when embedded white space is present.
  *
  * VISIBLE:  This property has no value, and its presence carries with it an implied value of TRUE for 'visibility'.
  *
  * VALIGN_TEXT_*, HALIGN_TEXT_*:  These properties define the text alignment for certain controls.
  *
  *
  * DIALOG RESOURCE SUMMARY\n
  *
  * RESERVED:  symbol name registration for dialog controls\n
  *
  * The current list of pre-defined symbols is as follows:\n
  * \li IDOK
  * \li IDCANCEL
  * \li IDYES
  * \li IDNO
  * \li IDABORT
  * \li IDRETRY
  * \li IDIGNORE
  * \li IDSTATIC
  * \li IDNONE
  *
  * The current list of recognized keywords is as follows:\n
  * \li BEGIN_DIALOG - identifies the start of a dialog definition
  * \li END_DIALOG - identifies the end of a dialog definition
  * \li FONT - identifies the font for the specified object (dialog or control)
  * \li CONTROL - specifies a control entry within a dialog definition
  * \li ID - specifies the ID of a control entry
  * \li X - specifies the X position of the upper left corner in dialog units
  * \li Y - specifies the Y position of the upper left corner in dialog units
  * \li WIDTH - specifies the width of the object (dialog or control) in dialog units
  * \li HEIGHT - specifies the height of the object (dialog or conrol) in dialog units
  * \li VISIBLE - indicates that the object is initially visible
  * \li TITLE - specifies the title (or caption) of the object
  * \li HALIGN_TEXT_LEFT - align text left in title/caption (default)
  * \li HALIGN_TEXT_RIGHT - align text right in title/caption
  * \li HALIGN_TEXT_CENTER - align text horizontally centered in title/caption
  * \li VALIGN_TEXT_TOP - top align text in title/caption
  * \li VALIGN_TEXT_BOTTOM - bottom align text in title/caption
  * \li VALIGN_TEXT_CENTER - vertically center text in title/caption (default)
  *
  * Other text keywords and identifiers are reserved.\n
  *
  * Internally defined controls - see also dialog_controls.h
  *
  * \code

  #define FRAME_CONTROL_STR            "Frame"
  #define TEXT_CONTROL_STR             "Text"
  #define ICON_CONTROL_STR             "Icon"
  #define IMAGE_CONTROL_STR            "Image"
  #define EDIT_CONTROL_STR             "Edit"
  #define PUSHBUTTON_CONTROL_STR       "PushButton"
  #define DEFPUSHBUTTON_CONTROL_STR    "DefPushButton"
  #define CANCELBUTTON_CONTROL_STR     "CancelButton"
  #define RADIOBUTTON_CONTROL_STR      "RadioButton"
  #define FIRSTRADIOBUTTON_CONTROL_STR "FirstRadioButton"
  #define CHECKBUTTON_CONTROL_STR      "CheckButton"
  #define TRISTATEBUTTON_CONTROL_STR   "TriStateButton"
  #define HSCROLL_CONTROL_STR          "HScroll"
  #define VSCROLL_CONTROL_STR          "VScroll"
  #define SLIDER_CONTROL_STR           "Slider"
  #define KNOB_CONTROL_STR             "Knob"
  #define LIST_CONTROL_STR             "List"
  #define COMBO_CONTROL_STR            "Combo"
  #define TREE_CONTROL_STR             "Tree"
  #define COMBOTREE_CONTROL_STR        "ComboTree"
  #define FILE_LIST_CONTROL_STR        "FileList"
  #define FILE_COMBO_CONTROL_STR       "FileCombo"
  #define PATH_TREE_CONTROL_STR        "PathTree"
  #define TAB_CONTROL_STR              "Tab"

  * \endcode
  *
**/


//-------------------------------------------------------------------------------------------------
// doxygen top-level group (module) definitions go here to preserve correct order.  no exceptions!
//-------------------------------------------------------------------------------------------------


/** \defgroup startup Application Startup and Shutdown
  * Functions and variables associated with application startup and shutdown
  *
  * Required functions for API startup and shutdown, resource pre-allocation, and final cleanup,
  * as well as useful utilities for argument parsing, and querying options.
**/

/** \defgroup core Core API
  *
  * The 'Core' API for the X11workbench Toolkit identifies those functions that implement the
  * most essential functions, such as the creation and destruction of windows, and the main event
  * loop,  All programs using the API must correctly initialize and make use of these functions
  * in lieu of calling their X11 counterparts.
  *
  * Typically, your application will need a basic event handling loop, such as:
  *
  * \code

        //=====================
        //   MAIN EVENT LOOP
        //=====================

        while (!bQuitFlag)
        {
          if(!WBCheckGetEvent(pX11Display, &event))
          {
            // SLEEP if no event while in message loop (function returns without blocking)
            // otherwise I can do background tasks during this loop iteration.

            WBDelay(100); // 100 microseconds (0.1 milliseconds)

            continue; // skip the 'WBDispatch' since there was no event
          }

          WBDispatch(&event);
        }

  * \endcode
  *
  * The call to WBDispatch will process the retrieved events by passing them to the
  * appropriate registered callback functions.
  *
  * The 'WBDelay()' call is a way of ensuring that your application does not 'spin' with 100%
  * CPU utilization while waiting for an event.  This can help with battery life, and so on.
  *
  * If you have no background processing to perform, you can use WBNextEvent() instead of
  * WBCheckGetEvent(), and avoid the need of the surrounding 'if' block.
  *
  * \sa \ref mainpage_4, \ref events
  *
**/

/** \defgroup platform Platform Independence
  *
  * Some functions either need special help on certain platforms, or are missing entirely.  In
  * other cases, the manner in which a function is implemented is very specific for a particular
  * platform.  Additionally, common definitions change from one platform to another.  The functions,
  * data types, and definitions in this group deal with these specific problems.\n
**/

/** \defgroup conf_help Configuration 'helper' functions
  * Functions and variables associated with application configuration
  *
  * Optional functions for configuration management.  Used internally by \ref startup and \ref core.
**/

/** \defgroup text Text Utilities (generic)
  * \brief Generic Utility functions for copying and manipulating text
  *
  * Utility functions for copying and manipulating text, such as string copying and concatenation.
  * These function standardize common string operations and allocate new buffers with 'WBAlloc()'
  * as needed.  This can greatly simplify working with string-based data.
  *
  * These generic string functions are compatible with Multi-Byte character sets, with the assumption
  * that a standard UTF-8 or multi-byte character consists of 1 or more non-zero bytes, and that the
  * end of a multi-byte or UTF-8 string is marked with a zero byte.
  *
  * For working specifically with Multi-Byte Character Sets (MBCS), see \ref text_object_multibyte.
  *
**/

/** \defgroup sub_alloc Memory sub-allocator for high performance dynamic memory management
  * \brief Generic utility functions for allocating and manipulated memory buffers.
  *
  * \details The purpose of the high performance sub-allocator is to minimize memory fragmentation and related performance
  * issues caused by 'malloc' and the related 'new' operator in C++.  In some implementations, they may simply be an alias
  * for the 'malloc' functions.  In other implementations they can manage sub allocation via the OS.  In still others, they
  * can implement a complex but efficient memory sub-allocation scheme using virtual memory.  Abstraction is the key, along
  * with performance.  The 'edit text' utilities are designed for hyper-efficient editing of extremely large text files.\n
  * Since I have seen 'malloc a boatload of tiny memory fragments' cause PERFORMANCE PROBLEMS in the past, I want to avoid that.
**/

/** \defgroup error X11 Error Handling API
  *
  * X11 has its own error notification mechanism that normally terminates the application.
  * Since many errors are actually 'expected' (particularly with respect to using the clipboard)
  * it is necessary to process these without program interruption.  Normal error handling
  * consists of a notification message sent to stderr, and error information being stored
  * in a set of global variables.  Prior to using this information, it is FIRST necessary to
  * clear the error state, and then check for an error after the operation has completed.\n
  *
  * \code

  WBSupressErrorOutput(); // expect errors, no need for diagnostics
  WBErrorClear();

  while(1)
  {
    // perform some operation that does not
    // normally indicate if an error took place
    // or needs to be checked for retry

    if(!WBErrorCheck())
    {
      break;
    }
    else
    {
      WB_ERROR_INFO *pErr = WBGetLastError();

      // report error, limit number of retries, etc.

      if(!WBErrorCheckRetry())
      {
        // do some kind of cleanup since I failed
        // and could not retry the operation

        break;
      }
    }
  }

  WBRestoreErrorOutput(); // restore error message output

  * \endcode
  *
**/

/** \defgroup file_help File Buffer and I/O 'helper' functions
  * Utility functions and structures associated with file I/O, buffering, file info, and directory searching
  *
  * These functions are designed specifically to provide a cross-platform capable method of dealing
  * with some specific I/O and file-related tasks, such as directory searches, file information,
  * buffered and non-buffered I/O, and canonical paths.
**/

/** \defgroup process Process Control Functions
  *
  * This group consists of a set of functions that allow you to synchronously or asynchronously
  * run processes, optionally re-directing input and output to or from a file or memory buffer.
**/

/** \defgroup threads Threads and Synchronization
  *
  * These functions and data types help to abstract the various thread and synchronization
  * functions that are necessary to properly implement threads.
**/

/** \defgroup frame Frame Window API
  *
  * The 'Frame Window' API for the X11workbench Toolkit identifies those functions that implement
  * 'Frame Windows'.  A Frame Window is a top-level window that is registered with the window manager
  * and typically has a title bar, sizeable border, menu, and icon.  It can contain other windows and
  * manage menu events.\n
  * A special case of a frame window is a dialog frame window.  See \ref DLGCreateDialogWindow()
**/

/** \defgroup child_frame Child frame Window API
  * \ingroup frame
  *
  * The 'Child Frame' API for the X11workbench Toolkit identifies those functions that implement
  * 'Child Frame' windows.  A Child Frame window is a child window that is registered with the containing
  * frame window and typically displays a tab on the frame window for easy access.  It also has its
  * own menu and menu handlers.  Typically another window type will 'derive' from this.\n
  *
  * \sa \ref edit_window
**/

/** \defgroup edit_window Edit Window APIs and Structures
  * \ingroup frame
  *
  * Edit windows are 'Child Frame' windows, owned by a frame window, in which
  * text is edited and menu callbacks are processed.\n
  * The edited text is typically associated with a file name.  An Edit Window
  * uses the \ref TEXT_OBJECT object (structure) to manage its state.
  *
  * \sa \ref text_object
**/

/** \defgroup dialog Dialog Boxes
  *
  * Dialog Box frame and intercommunication structures and API functions, required implementations
  * and standards necessary to implement a high level dialog box interface with standard and
  * customizable controls.
**/

/** \defgroup pixmap Pixmap utility functions
  *
  * Utility functions for loading and managing pixmaps, icons, cursors, and so forth.  These are
  * primarily utilities and wrappers that include platform-dependent implementations as well as
  * more generic functionality.
**/

/** \defgroup font Font Utilities
  * GC Utility/API functions for WB_FONT mid-level font selection and modification
  *
  * These are the definitions for font helper functions and structures, designed
  * to SPECIFICALY work with 'Xft' freetype fonts and rendering, but also support
  * legacy (X11) fonts and font sets.  For maximum compatibility, they have been
  * abstracted using the (new) WB_FONT/WB_FONTC objects, particularly for legacy
  * implementations that do not have the Xft library installed, and for those fonts
  * that are native X11 fonts or font sets.
**/

/** \defgroup font_legacy Legacy Font Utilities
  * \ingroup font
  * GC Utility functions for legacy (X11) font selection and modification
  *
  * These are the LEGACY definitions for font helper functions and structures, designed
  * to SPECIFICALY work with 'X11 Core' fonts and rendering.
  * Fonts under X11 (core) are generally difficult to deal with.  These utility
  * functions allow you to more easily select a font based on an existing
  * font or a general description of a font, with 'fuzzy' matching.\n
  * Additionally there is support for creating 'Font Sets' for use with Xmb, Xwc, and Xutf8
  * versions of 'Core' text rendering APIs.
**/

/** \defgroup font_struct Font Structures
  * \ingroup font
  * X11 Workbench Toolkit font-related structures
**/

/** \defgroup draw_text Text Drawing Utilities
  * GC Utility functions for drawing text
  *
  * GC Utility functions for drawing text, as well as determing ideal fonts and borders using
  * a variety of text alignments and tab methods.  The text drawing utilities are designed
  * to SPECIFICALY work with 'X11 Core' fonts and rendering.  Compatibility and
  * support for 'Xft' fonts and rendering is currently 'reserved for future implementation'.
  * Current support includes use of the 'Xmb' versions of the API for multi-byte character
  * strings, though actual 'core' font support for UTF-8 characters seems to be a bit limited.
**/

/** \defgroup window_dressing 'Window Dressing' Graphics Drawing Utilities
  * GC Utility functions for drawing 'Window Dressing', i.e. various standard windows components
  *
  * GC Utility functions for drawing various standard window components, collectively known here
  * as 'Window Dressing'.  This includes scroll bars, 3D effects, rectangles, tabs, buttons, and
  * other 'standard' components of modern GUI interfaces.
**/

/** \defgroup text_object Text Editing Utilities and Objects
  * \brief Generic utility functions and objects for editing text
  *
  * \details Text editing utilities and objects encapsulate the basic functionality
  * of editing text, such as text selection (character, line, or box), as well
  * as inserting, overwriting, deleting, replacing, and rendering edited text.
  * The utilities are 'line based' and intended to display text within a window
  * of character-based dimensions with a specified X,Y scroll position and a
  * fixed-width font.
  *
  * \sa \ref edit_window
**/

/** \defgroup printer Printer utility functions
  *
  * Utility functions for sending prepared output to a printer, querying printer capabilities,
  * and listing available printers.
**/

// this one is last

/** \defgroup debug Debug Helper
  * Functions, macros, and variables associated with debugging
  *
  * Debug functions are only present in a debug build, and you can assign the 'debug level' for
  * message generation.  Message output goes to stderr by default.  Code that is built for release
  * will not execute anything inside of '()' for debug macros, so that your final code will be
  * better optimized.
**/



// Groups that belong to 'core' (in their correct order)

/** \ingroup core
  * \defgroup wcore Window 'Core'
  *
  * These functions and definitions comprise the CORE WINDOW HANDLING functionality
  * for the X11workbench Toolkit API.  This includes information and initialization
  * functions, but not event nor class-specific functionality.
**/

/** \ingroup wcore
  * \defgroup wcore_internal Internal-only Window 'Core' features
  *
  * These functions and definitions comprise internal-only 'CORE WINDOW HANDLING'
  * features.  You should not make use of these.
**/

/** \ingroup core
  * \defgroup events Event Handling
  *
  * Event handling in X11 involves an event handler loop and methods by which
  * the various events can be dispatched to window callback functions, or to the
  * application's event handler. The X11workbench Toolkit API has provisinos for
  * event prioritization, asynchronous processing, and the generation of 'internal
  * events' (see \ref aWB_CHAR, \ref aWB_POINTER, \ref aWB_TIMER).
**/

/** \ingroup core
  * \defgroup expose Exposure and Mapping/Visibility
  *
  * Proper handling of Expose events is a performance-critical component
  * of graphical interfaces.  To simplify the handling and processing of
  * Expose events there are a set of APIs and internal states that assist
  * you in determining when to re-draw a window, and what portion of the
  * window needs to be re-drawn.
  *
  * A typical Expose event handler might look like this:\n
  * \code
  // parameters to function are XExposeEvent *pEvent, Window wID

  void MyExposeHandler(Window wID, XExposeEvent *pEvent)
  {
    Display *pDisplay = WBGetWindowDisplay(wID);
    GC gc;
    WB_GEOM geomPaint;

    gc = WBBeginPaint(wID, pEvent, &geomPaint);
    if(!gc)
    {
      return;
    }

    // here is where you modify the GC, change foreground/background colors, drawing modes, etc.
    // and perform necessary erasing within the geometry specified by geomPaint.
    // ideally your code will NOT attempt to draw anything outside of geomPaint.

    XSetForeground(pDisplay, gc, WBGetWindowFGColor(wID)); // example
    XSetBackground(pDisplay, gc, WBGetWindowBGColor(wID)); // example

    XClearArea(pDisplay, wID, geomPaint.x, geomPaint.y, geomPaint.width, geomPaint.height, 0);

    // perform any drawing here

    WBEndPaint(wID, gc);
  }

  * \endcode
*/

/** \ingroup core
  * \defgroup graphics Graphics Abstraction Layer
  *
  * These functions provide a graphics-related 'Abstraction Layer' API for performance
  * enhancement and cross-platform implementation of the toolkit.  Rather than calling
  * X11 library functions directly, you should use these equivalent API functions
  * whenever possible.
**/

/** \ingroup core
  * \defgroup timer Timer Functions
  *
  * The X11workbench Toolkit API has support for one-shot and periodic timer
  * events that are generated via XClientEvent using \ref aWB_TIMER.\n
  * These timer events are NOT hyper-accurate, although the timer event time
  * is expressed in microseconds (for math efficiency and convenience).  The
  * message loop will check for 'crossing an event time' and generate events
  * whenever a limit has been crossed.  This means that event processing time
  * can easily affect timer accuracy.  Additionally, if a timer's period is
  * less than the processing time of an event, a timer may be 'missed' as a
  * a result.  For this reason you should use a worker thread for timing that
  * requires precise accuracy.
*/

/** \ingroup core
  * \defgroup clipboard Clipboard and Selections
  *
  * Clipboard and generic 'Selection' helper functions.  Use these
  * to copy data to/from the clipboard or other 'selection'.  They
  * will process the requests asynchronously in a thread, returning
  * results in a convenient format.  This avoids the unnecessary
  * complexity of processing inner message loops and allows for
  * completion callback functions and messages.
**/

/** \ingroup core
  * \defgroup defaults Default Parameters and Definitions
  *
  * Functions and variables associated with default parameters, and default definitions
**/

/** \ingroup core
  * \defgroup core_struct 'Core' Structures
  *
  * Structures that help to implement 'Core' functionality
**/

/** \ingroup events
  * \defgroup events_atoms ClientMessage Atoms
  *
  * Atoms used for XClientMessageEvent notifications\n
  * Includes details on the various message parameters
**/

/** \ingroup events
  * \defgroup events_types Data Types and Definitions
  *
  * Various data types and definitions used for XClientMessageEvent notifications\n
  *
**/

/** \ingroup core
  * \defgroup wmatom Window Manager and Clipboard-related Atoms
  *
  * Pre-defined Atoms for the Window Manager and Clipboard processing
**/



// members of events group (part of 'core')

/** \ingroup events
  * \defgroup keyboard Keyboard Event Handling
  *
  * The X11workbench Toolkit API provides for mid-level keyboard event handling via
  * WB_CHAR ClientMessage notification events.\n
  * See \ref aWB_CHAR for more info.
**/

/** \ingroup events
  * \defgroup pointer Mouse Pointer Event Handling
  *
  * The X11workbench Toolkit API provides for mid-level pointer event handling via
  * WB_POINTER ClientMessage notification events.\n
  * See \ref aWB_POINTER for more info.
**/


