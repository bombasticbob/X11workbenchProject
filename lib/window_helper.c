/////////////////////////////////////////////////////////////////////////////////////////////
//            _             _                     _            _                           //
// __      __(_) _ __    __| |  ___ __      __   | |__    ___ | | _ __    ___  _ __  ___   //
// \ \ /\ / /| || '_ \  / _` | / _ \\ \ /\ / /   | '_ \  / _ \| || '_ \  / _ \| '__|/ __|  //
//  \ V  V / | || | | || (_| || (_) |\ V  V /    | | | ||  __/| || |_) ||  __/| | _| (__   //
//   \_/\_/  |_||_| |_| \__,_| \___/  \_/\_/_____|_| |_| \___||_|| .__/  \___||_|(_)\___|  //
//                                         |_____|               |_|                       //
//                                                                                         //
//                       basic window creation and message handling                        //
//                                                                                         //
/////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2019 by Bob Frazier (aka 'Big Bad Bombastic Bob')

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.
               Any claims to alleged functionality or features should be
               considered 'preliminary', and might not function as advertised.

  MIT-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  MIT-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/


/** \file window_helper.c
  * \brief 'window helper' main implementation file for the X11 Work Bench Toolkit API
  *
  * X11 Work Bench Toolkit Toolkit API
  * This file implements the main 'Window Helpers' including
  *   API initialization
  *   the main 'Event loop'
  *   window callback procedures
  *   upper level font management
  *   Expose and GC management
  *   Window context/state management
  *   X11 API 'wrapper' functions
*/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <signal.h>
#include <time.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/time.h> // for 'gettimeofday'

// TODO:  determine if pthread is available, optionally use for timers
#include <pthread.h> /* currently required */


#include <X11/cursorfont.h>
#ifndef XK_Delete /* moslty for interix */
#define XK_MISCELLANY /* mostly for interix */
#include <X11/keysymdef.h> // some platforms don't automatically include this with X headers
#endif // XK_Delete

#define _WINDOW_HELPER_C_ /*this causes some header definitions to change slightly */

#include "window_helper.h"
#include "pixmap_helper.h"
#include "conf_help.h"


#define MIN_EVENT_LOOP_SLEEP_PERIOD 100    /* 0.1 millisec */
#define MAX_EVENT_LOOP_SLEEP_PERIOD 50000 /* 50 msecs - better for Linux within a VM - worst was 3.6% during idle */
//#define MAX_EVENT_LOOP_SLEEP_PERIOD 100000 /* 0.1 sec - way too long, actually */

const char *sz_xcall_func = NULL;
int i_xcall_line = 0;


//#define USE_WINDOW_XIMAGE /* comment this out to disable using an XImage to perform graphiic operations on a window */


// **************************************************************************
//                       ALGORITHMS AND OTHER RELATED NOTES
// the hash algorithm is simple.  First, apply 'WINDOW_ENTRY_HASH' to the
// window ID.  Then use it as an index into the array of '_WINDOW_ENTRY_'
// structures.  If the entry it points to does NOT match the window ID I'm
// interested in, increment the index 'mod ARRAY SIZE' until I either find
// the matching window ID, wrap around, or find a zero window ID.  Wrapping
// around is basically prevented by ensuring that the array is at least twice
// the size of the maximum allowed window count. And, for the above reasons,
// the size of the array must be a power of 2 so that the hash works properly.

// NOTE:  window assignments tend to be consecutive so I must scramble them
//        up or risk inefficiency in the hash algorithm.  This can be
//        improved later to minimize the impact of this behavior.
//
// NOTE 2:  Window ID and other XID values APPEAR to depend on the definition
//          of 'RESOURCE_AND_CLIENT_COUNT' and the max # of clients
//          This basically makes the lower 29 bits of an XID consist of
//          the client ID (5 to 9 bits) and the resource ID (remaining bits)
//          with leading bits 31,30,29 all zeros.
//          It may be possible to create "fake" windows with the high bit set
// **************************************************************************


/**********************************************************************/
/*                                                                    */
/*       externally visible global variables (general use)            */
/*                                                                    */
/**********************************************************************/

//XFontStruct *pDefaultFont = NULL;  // default font
//XFontSet fontsetDefault = None;    // default font set, derived from default font
WB_FONT pDefaultFont = NULL;
Display *pDefaultDisplay = NULL;

int iStartupMinMax = 0; // main window open min/max/normal flag


/**********************************************************************/
/*                                                                    */
/*             global atoms, initialized via 'WBInit'                 */
/*        (atoms remain valid until all connections go away)          */
/*                                                                    */
/**********************************************************************/
/** \ingroup events_atoms menu
  * \hideinitializer
  * \brief commands sent by menus via ClientMessage
  *
  * MENU_COMMAND message format (relative to XEvent.xclient)\n
  * \n
  * type == ClientMessage\n
  * message_type == aMENU_COMMAND\n
  * format == 32 (always)\n
  * data.l[0] Menu command message ID (aka 'action')\n
  * data.l[1] secure hash for WBMenu object pointer - see  WBCreatePointerHash()\n
  * data.l[2] Window ID of the menu bar\n
  * \n
  * Whenever this message is received, you should NOT call WBDestroyPointerHash() for the WBMenu object
  * pointer.  This will be done automatically by the message framework.
  *
**/
Atom aMENU_COMMAND=None;

/** \ingroup events_atoms menu
  * \hideinitializer
  * \brief UI notifications sent by menus to owning Frame windows via ClientMessage using 'WBWindowDispatch'
  *
  * MENU_COMMAND message format (relative to XEvent.xclient)\n
  * \n
  * type == ClientMessage\n
  * message_type == aMENU_UI_COMMAND\n
  * format == 32 (always)\n
  * data.l[0] Menu command message ID (aka 'action')\n
  * data.l[1] secure hash for WBMenu object pointer - see  WBCreatePointerHash()\n
  * data.l[2] secure hash for WBMenuItem object pointer - see  WBCreatePointerHash()\n
  * data.l[3] the value '0' (reserved)\n
  * data.l[4] the value '0' (reserved)\n
  * \n
  * A Frame Window returns '0' to indicate that the menu should be displayed normally (same as 'not handled')\n
  * Other return values alter the display of the menu.
  *
  *  For a popup menu:
  *    -1 :  disables the menu
  *     1 :  enables the menu (default behavior if no UI handler present, but menu handler IS present)
  *     0 :  menu item NOT handled (menu item will be greyed)
  *
  *  For a dynamic menu: (preliminary) - popup menu items only (not found in top-level menus)
  *    -1 : disabled the menu
  *     0 : 'not handled' or 'error' (no dynamic menu will be added or displayed)
  *    \>0 : a 'secure internal pointer hash' representing an actual pointer value (preliminary, RESERVED)
  *         this pointer will be to a WBAlloc'd block of memory describing the menu items (as text).  It will
  *         be necessary for the caller to interpret this text to create the dynamic memory items.
  *         PRELIMINARY:  the text will be 'menu text\\tAtom Name' - no hotkeys, no tooltip text.  The menu
  *                       text can include underscores which will only work when the popup is available
  *
  * Whenever this message is received, you should NOT call WBDestroyPointerHash() for the WBMenu object
  * pointer, nor for the WBMenuItem object pointer.  This will be done automatically by the message framework.
  *
**/
Atom aMENU_UI_COMMAND=None;

/** \ingroup events_atoms
  * \hideinitializer
  * \brief notification of window re-size via ClientMessage
  *
  * RESIZE_NOTIFY message format (relative to XEvent.xclient)\n
  * \n
  * type == ClientMessage\n
  * message_type == aRESIZE_NOTIFY\n
  * format == 32 (always)\n
  * data.l[0] new 'left' client rectangle coordinate\n
  * data.l[1] new 'top' client rectangle coordinate\n
  * data.l[2] new 'right' client rectangle coordinate\n
  * data.l[3] new 'bottom' client rectangle coordinate\n
  * \n
  * The return value is ignored.  It is typically sent via a direct call to the message callback function.
  * Since it is merely a notification message, it does not need to be handled.  The specified coordinates
  * are in 'client' coordinates relative to the upper left corner of the client area, which is always (0,0).\n
**/
Atom aRESIZE_NOTIFY=None;

/** \ingroup events_atoms
  * \hideinitializer
  * \brief notify parent that child is being destroyed
  *
  * RESERVED - not yet implemented
  * TODO document DESTROY_NOTIFY format here
**/
Atom aDESTROY_NOTIFY=None;

/** \ingroup events_atoms dialog_events
  * \hideinitializer
  * \brief dialog control and child window notification messages
  *
  * These events are posted to the owning window (or dialog box frame) for controls
  * that are members of the dialog box or window.  These provide a powerful asynchronous
  * method by which you can handle user input and other information directly from the
  * control windows.
  *
  * CONTROL_NOTIFY message format (relative to XEvent.xclient)\n
  * \n
  * type == ClientMessage\n
  * message_type == aCONTROL_NOTIFY\n
  * format == 32 (always)\n
  * data.l[0] contains the dialog control ID (or -1 if N/A)\n
  * data.l[1] is the notify code\n
  * data.l[2] is window ID\n
  * \n
  * Other data elements are specific to the type notify code being used.\n
  * For more information, see:  \ref dlgctrl_notify
**/
Atom aCONTROL_NOTIFY=None;

/** \ingroup events_atoms window_dressing
  * \hideinitializer
 Scroll notifications via ClientMessage
  *
  * SCROLL_NOTIFY message format (relative to XEvent.xclient)\n
  * \n
  * type == ClientMessage\n
  * message_type == aSCROLL_NOTIFY\n
  * format == 32 (always)\n
  * data.l[0] Identifies the bar (WB_SCROLL_VERTICAL, WB_SCROLL_HORIZONTAL, or WB_SCROLL_DEFAULT)\n
  * data.l[1] Indicates the notification type, one of the following:\n
  * \li WB_SCROLL_KNOB    'knob track' - knob position will be in data.l[2]
  * \li WB_SCROLL_FORWARD  move down, or move right
  * \li WB_SCROLL_BACKWARD move up, or move left
  * \li WB_SCROLL_PAGEFWD  page down or page right
  * \li WB_SCROLL_PAGEBACK page up or page left
  * \li WB_SCROLL_FIRST    scroll to first entry, i.e. home or top
  * \li WB_SCROLL_LAST     scroll to last entry, i.e. bottom or end
  * \li WB_SCROLL_DBLCLICK double-click detection (no selection info in data.l[2])
  * \li WB_SCROLL_ABSOLUTE absolute scroll, to the absolute position in data.l[2]
  * \li WB_SCROLL_RELATIVE relative scroll, relative +/- position in data.l[2]
  * \li WB_SCROLL_NA       generic 'NA' or 'UNDEFINED' value
  *
  * data.l[2] Optional parameter, typically the absolute or relative scroll position
  * \n
*/
Atom aSCROLL_NOTIFY = None; // specific notification for scrollbars

/** \ingroup events_atoms
  * \hideinitializer
  * \brief query if it's ok to close (and optionally destroy yourself if ok) a window
  *
  * QUERY_CLOSE message format (relative to XEvent.xclient)\n
  * \n
  * type == ClientMessage\n
  * message_type == aQUERY_CLOSE\n
  * format == 32 (always)\n
  * data.l[0] contains a non-zero value if the window should destroy its private data NOW; 0 otherwise\n
  * \n
  * Window callbacks should check for this and return '0' when it's ok to destroy the window, a positive
  * value if it's NOT ok, or a negative value on error.
  *
  * Whenever data.l[0] contains a non-zero value, and it's ok to close the window, the window event handler
  * should destroy all of its private data, zero out data element '0' for the window data (if it pointed
  * to the private data), and call WBUnregisterWindowCallback() for itself.  The window will be destroyed
  * by the sender as soon as the callback returns.
  *
  * If the callback returns a non-zero value, it should not destroy any of its own private data.  The
  * sender will assume that it's not ok to close the window and will try to leave everything 'as-is'.
  *
  * Generally, you should return 0 from your event handler if it is ok to close the window,
  * 1 if NOT ok to close, and '-1' on error.
  *
**/
Atom aQUERY_CLOSE=None;

/** \ingroup events_atoms
  * \hideinitializer
  * \brief notify window that it should re-calculate things like scrollbars and viewports
  *
  * RECALC_LAYOUT message format (relative to XEvent.xclient)\n
  * \n
  * type == ClientMessage\n
  * message_type == aRECALC_LAYOUT\n
  * format == 32 (always)\n
  * \n
  * A window that has a viewport and scrollbars, using a text object or other construct that
  * supports this ClientMessage atom, should check for this message and recalculate viewports and
  * scrollbar positions whenever it is received.  If scroll positions have changed, you should invalidate
  * the entire window rectangle so that it can be re-painted.  However, you should not paint the window
  * synchronously.  You should rely on asynchronous processing of Expose events.
  *
  * In some cases, default handling of 'recalc layout' functionality may cause aRESIZE_NOTIFY client
  * message events to be dispatched.  Care should be taken to NOT cause an infinite loop or
  * infinite recursion due to the handling of these events.
  *
  * \sa aRESIZE_NOTIFY
**/
Atom aRECALC_LAYOUT=None;


/** \ingroup events_atoms dialog_events
  * \hideinitializer
  * \brief dialog focus messages
  *
  * DLG_FOCUS message format (relative to XEvent.xclient)\n
  * \n
  * type == ClientMessage\n
  * message_type == aDLG_FOCUS\n
  * format == 32 (always)\n
  * data.l[0] is a tri-state value as follows
  * \li less than zero for 'previous window'
  * \li greater than zero for 'next window'
  * \li equal to zero for 'set to this window'
  *
  * \b for \b data.l[0] \b == \b 0
  * \li data.l[1] is the control id to set focus to
  * \li data.l[2] is non-zero if the control focus was assigned via a hot-key, else zero.
  *
  *
  * by convention, all remaining entries in 'data.l' should be zero
**/
Atom aDLG_FOCUS=None;

/** \ingroup events_atoms
  * \hideinitializer
  * \brief dialog focus messages
  *
  * SET_FOCUS message format (relative to XEvent.xclient)\n
  * \n
  * type == ClientMessage\n
  * message_type == aSET_FOCUS\n
  * format == 32 (always)\n
  * data.l[0] is the window ID to set focus to (None for default)
  * \n
  * This message is typically sent to the application (.window = None)
  *
  * By posting a SET_FOCUS message to the application, you can ASYNCHRONOUSLY
  * fix focus-related problems, such as the window manager trying to set focus
  * to the application window while a modal dialog is visible.\n
  * When sent to a frame window, you are requesting that it set the focus to
  * the appropriate window, similar to \ref aDLG_FOCUS "aDLG_FOCUS"\n
  * Assigning 'data.l[0]' to 'None' tells a frame window to set focus to the default.
  * When the event is sent to the application, a value of 'None' is meaningless.
**/
Atom aSET_FOCUS=None;

/** \ingroup events_atoms keyboard
  * \hideinitializer
  * \brief keystroke/character notifications generated by API
  *
  * Mid-level keystroke handling generates WB_CHAR notifications via ClientMessage
  * passed to the appropriate window in addition to normal key up/down events.
  *
  * WB_CHAR notification message format (relative to XEvent.xclient)\n
  * \n
  * type == ClientMessage\n
  * message_type == aWB_CHAR\n
  * format == 32 (always)\n
  * data.l[0] is return from WBKeyEventProcessKey\n
  * data.l[1] is *piAltCtrlShift from WBKeyEventProcessKey\n
  * data.l[2] is # of characters decoded into data.l[3..4]\n
  * data.l[3..4] (as char[]) is decode buffer (at least 8 chars long, possibly 16 for 64-bit)\n
  * \n
  * see also:   WBKeyEventProcessKey()
**/
Atom aWB_CHAR=None;          ///< character notifications (generated by API; avoids key up/down handling)

/** \ingroup events_atoms timer
  * \hideinitializer
  * \brief timer notifications generated by API
  *
  * Mid-level timer handling generates WB_TIMER notifications via ClientMessage
  * passed to the appropriate window, either periodic or 'one-shot'\n
  * See \ref CreateTimer() for more information.
  *
  * WB_TIMER message format (relative to XEvent.xclient)\n
  * \n
  * type == ClientMessage\n
  * message_type == aWB_TIMER\n
  * format == 32 (always)\n
  * data.l[0] is the unique identifier associated with the timer
  * \n
  * see also:  CreateTimer(), DeleteTimer()
**/
Atom aWB_TIMER=None;         ///< timer notifications (generated by API)

/** \ingroup events_atoms pointer
  * \hideinitializer
  * \brief pointer click/double-click/drag notifications generated by API
  *
  * Mid-level pointer click/double-click/drag handling generates WB_POINTER notifications
  * (i.e. mouse motion) via ClientMessage passed to the appropriate window in addition to
  * the normal pointer notification events via the normal event system.
  *
  * WB_POINTER notification message format (relative to XEvent.xclient)\n
  * \n
  * type == ClientMessage\n
  * message_type == aWB_POINTER\n
  * format == 32 (always)\n
  * data.l[0] is one of the notification codes\n
  * \li \ref WB_POINTER_UNSPECIFIED
  * \li \ref WB_POINTER_CLICK
  * \li \ref WB_POINTER_DBLCLICK
  * \li \ref WB_POINTER_DRAG
  * \li \ref WB_POINTER_DROP
  * \li \ref WB_POINTER_MOVE
  * \li \ref WB_POINTER_CANCEL
  * \li \ref WB_POINTER_SCROLLUP
  * \li \ref WB_POINTER_SCROLLDOWN
  *
  * data.l[1] is a bitmap of the mouse button state (bit set when pressed)\n
  * \li WB_POINTER_BUTTON1 - bit 0 - left button
  * \li WB_POINTER_BUTTON2 - bit 1 - right button
  * \li WB_POINTER_BUTTON3 - bit 2 - center button
  * \li WB_POINTER_BUTTON4 - bit 3 - mouse wheel up
  * \li WB_POINTER_BUTTON5 - bit 4 - mouse wheel down
  *
  * data.l[2] is 'WB_KEYEVENT_xxx' mask for CTRL+ALT+SHIFT\n
  * \li WB_KEYEVENT_ALT
  * \li WB_KEYEVENT_CTRL
  * \li WB_KEYEVENT_SHIFT
  *
  * data.l[3] is translated X coordinate\n
  * data.l[4] is translated Y coordinate\n
  * \n
**/
Atom aWB_POINTER=None;       ///< 'pointer' notifications (generated by API)

// things used by window managers
/** \ingroup wmatom
  * \hideinitializer
  * \brief WM supported protocols
  *
  * Used by Window Manager to indicate supported protocols\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aWM_PROTOCOLS=None;     // WM supported protocols (see 'freedesktop.org' WM docs)

/** \ingroup wmatom
  * \hideinitializer
  * \brief Delete Window notification event
  *
  * Used by Window Manager to instruct a window to close, typically activated
  * by clicking on the 'x' button (or similar) in the window's title bar.
  * More information at freedesktop.org WM documentation
**/
Atom aWM_DELETE_WINDOW=None; // WM command to delete a window (a click on the 'x')

/** \ingroup wmatom
  * \hideinitializer
  * \brief 'Take Focus' - TODO document this properly
  *
  * TODO document this properly
  *
  * part of the WM_PROTOCOLS spec, ICCCM, associated with the focus bit in WM_HINTS\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aWM_TAKE_FOCUS=None;


/** \ingroup wmatom
  * \hideinitializer
  * \brief Atoms for fonts - Average Character Width
  *
  * Average Character Width (font property)
**/
Atom aAVERAGE_WIDTH=None;


/** \ingroup wmatom
  * \hideinitializer
  * \brief CLIPBOARD Atom for the clipboard
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aCLIPBOARD=None;        // Atom for 'CLIPBOARD'
/** \ingroup wmatom
  * \hideinitializer
  * \brief PRIMARY Atom for the clipboard - uses XA_PRIMARY
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aPRIMARY=XA_PRIMARY;    // Atom for 'PRIMARY' XA_PRIMARY
/** \ingroup wmatom
  * \hideinitializer
  * \brief SECONDARY Atom for the clipboard - uses XA_SECONDARY
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aSECONDARY=XA_SECONDARY;// Atom for 'SECONDARY' XA_SECONDARY
/** \ingroup wmatom
  * \hideinitializer
  * \brief MANAGER Atom for the clipboard
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aMANAGER=None;          // Atom for 'MANAGER'
/** \ingroup wmatom
  * \hideinitializer
  * \brief TARGET Atom for the clipboard
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aTARGET=None;           // Atom for 'TARGET'
/** \ingroup wmatom
  * \hideinitializer
  * \brief INCR Atom for the clipboard
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aINCR=None;             // Atom for 'INCR' (incremental transfers)
/** \ingroup wmatom
  * \hideinitializer
  * \brief WINDOW Atom for the clipboard - uses XA_WINDOW
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aWINDOW=XA_WINDOW;      // Atom for 'WINDOW'
/** \ingroup wmatom
  * \hideinitializer
  * \brief BITMAP Atom for the clipboard - uses XA_BITMAP
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aBITMAP=XA_BITMAP;      // Atom for 'BITMAP'
/** \ingroup wmatom
  * \hideinitializer
  * \brief DRAWABLE Atom for the clipboard - uses XA_DRAWABLE
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aDRAWABLE=XA_DRAWABLE;  // Atom for 'DRAWABLE'
/** \ingroup wmatom
  * \hideinitializer
  * \brief COLORMAP Atom for the clipboard - uses XA_COLORMAP
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aCOLORMAP=XA_COLORMAP;  // Atom for 'COLORMAP'
/** \ingroup wmatom
  * \hideinitializer
  * \brief PIXEL Atom for the clipboard
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aPIXEL=None;            // Atom for 'PIXEL'
/** \ingroup wmatom
  * \hideinitializer
  * \brief PIXMAP Atom for the clipboard - uses XA_PIXMAP
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aPIXMAP=XA_PIXMAP;      // Atom for 'PIXMAP'
/** \ingroup wmatom
  * \hideinitializer
  * \brief TEXT Atom for the clipboard
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aTEXT=None;             // Atom for 'TEXT'
/** \ingroup wmatom
  * \hideinitializer
  * \brief STRING Atom for the clipboard - uses XA_STRING
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aSTRING=XA_STRING;      // Atom for 'STRING'
/** \ingroup wmatom
  * \hideinitializer
  * \brief UTF8_STRING Atom for the clipboard
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aUTF8_STRING=None;      // Atom for 'UTF8_STRING'
/** \ingroup wmatom
  * \hideinitializer
  * \brief C_STRING Atom for the clipboard
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aC_STRING=None;         // Atom for 'C_STRING'
/** \ingroup wmatom
  * \hideinitializer
  * \brief COMPOUND_TEXT Atom for the clipboard
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aCOMPOUND_TEXT=None;    // Atom for 'COMPOUND_TEXT'
/** \ingroup wmatom
  * \hideinitializer
  * \brief TARGETS Atom for the clipboard
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aTARGETS=None;          // Atom for 'TARGETS'
/** \ingroup wmatom
  * \hideinitializer
  * \brief MULTIPLE Atom for the clipboard
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aMULTIPLE=None;         // Atom for 'MULTIPLE'
/** \ingroup wmatom
  * \hideinitializer
  * \brief TIMESTAMP Atom for the clipboard
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aTIMESTAMP=None;        // Atom for 'TIMESTAMP'
/** \ingroup wmatom
  * \hideinitializer
  * \brief NULL Atom for the clipboard
  *
  * Used by Clipboard owners and clients to communicate.\n
  * More information at freedesktop.org WM documentation\n
**/
Atom aNULL=None;             // Atom for 'NULL'


/**********************************************************************/
/*                                                                    */
/*    module-specific globals and structures for window processing    */
/*                                                                    */
/**********************************************************************/

// TODO:  do I implement this data type as a 'super type' of WBWindow ?
//typedef unsigned long long WBWindow;
//
//#define WBWINDOW_MASK 0xffffffff /* portion of WBWindow that is an actual Window ID */
//#define WBWINDOW_FLAGS_NORMAL 0x0
//#define WBWINDOW_FLAGS_PSEUDO 0x100000000LL /* tag WBWindow as a 'pseudo' window ID */

#ifdef _XSERVER64
#error _XSERVER64 defined
#endif



/** \struct s_internal_window_entry
  * \ingroup wcore_internal
  * \copydoc _WINDOW_ENTRY_
**/
/** \typedef _WINDOW_ENTRY_
  * \ingroup wcore_internal
  * \brief Core (internal) structure for window management, one per window
  *
  * Each '_WINDOW_ENTRY_' structure is mapped 1:1 to a window ID, and is allocated
  * whenever a callback function is assigned to a window.  When the window is
  * destroyed, the callback function can be assigned to NULL to detach the structure.
  * To avoid problems, the structure is not immediately deleted, but will remain for
  * an indefinite time period, with flags marking the window as 'deleted'.  This way
  * any delayed events being sent to the window can still be handled without throwing
  * an exception inside the X library.
  *
  * Management of this structure's members is handled by the API, and as such
  * their values should neither be directly modified nor relied upon outside
  * of the API's implementation files.  However, it's being documented here so
  * that you can understand the code if you need to debug or troubleshoot something.
  *
  * \code

  typedef struct s_internal_window_entry       // the structure that identifies the window and what to do with it
  {
    Window wID;                                // window to which the structure is mapped
    const char *szClassName;                   // window 'class name', mostly for debug and tracing, points to NULL or persistent name string
    Display *pDisplay;                         // display associated with this window
    WB_UINT64 iFlags;                          // 'iFlags' specified when window was created (for reference)
    XImage *pImage;                            // locally cached XImage for the window
    Window wParent;                            // cached window parent ID
    WBGC hGC;                                  // default graphics context
    unsigned long clrFG;                       // default foreground color (also assigned to GC)
    unsigned long clrBG;                       // default background color (also assigned to GC)
    WB_FONT pFont;                             // default font for window
    XWMHints *pWMHints;                        // XWMHints structure (cached)
    Pixmap pxIcon;                             // icon pixmap (may be None)
    Pixmap pxMask;                             // icon mask pixmap (may be None)
    int (* pCallback)(Window wIDEvent, XEvent *pEvent); // Pointer to the window's event callback function
    WB_GEOM geomAbsolute;                      // absolute window geometry (from notification)
    Region rgnClip;                            // complex clip (aka 'invalid') region (0 implies 'none')
    Region rgnPaint;                           // rectangular paint region (0 implies 'none')
    Window wIDMenu;                            // window ID for attached menu window
    int (* pMenuCallback)(Window wIDEvent, XEvent *pEvent); // Pointer to the window's MENU callback function - may be NULL, valid only for windows with menus
    Cursor curRecent;                          // most recent cursor resource (must be freed via XFreeCursor)
    int idCursor;                              // last cursor ID used by 'WBSetCursor()'
    int idDefaultCursor;                       // default cursor
    int iWaitCursorCount;                      // current 'count' for wait cursor
    int width;                                 // cached width value from latest 'Expose' event
    int height;                                // cached height value from latest 'Expose' event (TODO:  ConfigureNotify?)
    int border;                                // cached border value from latest 'Expose' event (TODO:  ConfigureNotify?)
    int iModalFlag;                            // current modal state (0 for modeless)  (see WBShowModal)
    int iModalReturn;                          // return value for a modal window (see WBShowModal)
    int iWindowState;                          // indicates if window mapped
    enum WMPropertiesWindowType eWindowType;   // a combination of WMPropertiesWindowType values (default None)
    enum WMPropertiesWMProtocols eWMProtocols; // a combination of WMPropertiesWMProtocols values, indicating supported protocols (default None)
    struct timeval tvLastActivity;             // time of last activity (TODO:  find a better way than 'gettimeofday')
    void *aWindowData[WINDOW_DATA_SIZE];       // 4 void pointers, to be uased as needed for 'window data'
  } _WINDOW_ENTRY_;

  * \endcode
  *
**/
typedef struct s_internal_window_entry       // the structure that identifies the window and what to do with it
{
  Window wID;                                ///< window to which the structure is mapped
  const char *szClassName;                   ///< window 'class name', mostly for debug and tracing, points to NULL or persistent name string
  Display *pDisplay;                         ///< display associated with this window
  WB_UINT64 iFlags;                          ///< 'iFlags' specified when window was created (for reference)
  XImage *pImage;                            ///< locally cached XImage for the window
  Window wParent;                            ///< cached window parent ID
  WBGC hGC;                                  ///< default graphics context
  unsigned long clrFG;                       ///< default foreground color (also assigned to GC)
  unsigned long clrBG;                       ///< default background color (also assigned to GC)
  WB_FONT pFont;                             ///< default font for window, NULL to use pDefaultFont
  XWMHints *pWMHints;                        ///< XWMHints structure (cached)
  Pixmap pxIcon;                             ///< icon pixmap (may be None)
  Pixmap pxMask;                             ///< icon mask pixmap (may be None)
  /** \brief Pointer to the window's event callback function
    *
    * The callback function defines the behavior of the window.  Each event that is dispatched
    * for the matching Window ID will be passed once to the callback function.  The callback
    * function must return an appropriate non-zero value if it processes the message.
    *
    * This will never be NULL unless the window entry is being destroyed.
  **/
  int (* pCallback)(Window wIDEvent, XEvent *pEvent);
  WB_GEOM geomAbsolute;                      ///< absolute window geometry (from notification)
  Region rgnClip;                            ///< complex clip (aka 'invalid') region (0 implies 'none')
  Region rgnPaint;                           ///< rectangular paint region (0 implies 'none')
  Window wIDMenu;                            ///< window ID for attached menu window
  /** \brief Pointer to the window's MENU callback function - may be NULL, valid only for windows with menus */
  int (* pMenuCallback)(Window wIDEvent, XEvent *pEvent);
  Cursor curRecent;                          ///< most recent cursor resource (must be freed via XFreeCursor)
  int idCursor;                              ///< last cursor ID used by 'WBSetCursor()'
  int idDefaultCursor;                       ///< default cursor
  int iWaitCursorCount;                      ///< current 'count' for wait cursor
  int width;                                 ///< cached width value from latest 'Expose' event
  int height;                                ///< cached height value from latest 'Expose' event (TODO:  ConfigureNotify?)
  int border;                                ///< cached border value from latest 'Expose' event (TODO:  ConfigureNotify?)
  int iModalFlag;                            ///< current modal state (0 for modeless)  (see WBShowModal)
  int iModalReturn;                          ///< return value for a modal window (see WBShowModal)
  int iWindowState;                          ///< indicates if window mapped
  enum WMPropertiesWindowType eWindowType;   ///< a combination of WMPropertiesWindowType values (default None)
  enum WMPropertiesWMProtocols eWMProtocols; ///< a combination of WMPropertiesWMProtocols values, indicating supported protocols (default None)
  struct timeval tvLastActivity;             ///< time of last activity (TODO:  find a better way than 'gettimeofday')
  void *aWindowData[WINDOW_DATA_SIZE];       ///< 4 void pointers, to be uased as needed for 'window data'
} _WINDOW_ENTRY_;

#define WINDOW_ENTRY_ARRAY_SIZE 2048 /* must be a power of 2 and twice the max expected # of windows */
#define WINDOW_ENTRY_ARRAY_MAX 2047  /* must be the above value minus 1 */
#define WINDOW_ENTRY_HASH(X) (((((unsigned long)X & 0xf00) + \
                                (((unsigned long)X >> 3) & 0x1f) + \
                                (((unsigned long)X << 5) & 0xe0)) ^ \
                               ((unsigned long)X >> 12)) & WINDOW_ENTRY_ARRAY_MAX)

#define WINDOW_ENTRY_UNUSED ((Window)-1)

#define WB_WINDOW_DELETE    -3       /* entry to be deleted during cleanup phase */
#define WB_WINDOW_DESTROYED -2       /* window has been destroyed, entry remains */
#define WB_WINDOW_DESTROYING -1      /* not destroyed yet - prevent recursion */
#define WB_WINDOW_UNMAPPED  0        /* window created, but not yet mapped */
#define WB_WINDOW_MAPPED    1        /* window mapped */
#define WB_WINDOW_SET_FOCUS_ON_MAP 2 /* focus is to be set when the window is mapped */
#define WB_WINDOW_DELETE_TIMEOUT 5   /* seconds to wait before deleting hash entry (was 30, now 5) */

#define WB_CHECK_SET_FOCUS_ON_MAP(X) ((X).iWindowState == WB_WINDOW_SET_FOCUS_ON_MAP)
#define WB_IS_WINDOW_UNMAPPED(X) ((X).iWindowState == WB_WINDOW_UNMAPPED || (X).iWindowState == WB_WINDOW_SET_FOCUS_ON_MAP)
#define WB_IS_WINDOW_MAPPED(X) ((X).iWindowState == WB_WINDOW_MAPPED)
#define WB_IS_WINDOW_BEING_DESTROYED(X) ((X).iWindowState == WB_WINDOW_DESTROYING)
#define WB_IS_WINDOW_DESTROYED(X) ((X).iWindowState == WB_WINDOW_DESTROYED || (X).iWindowState == WB_WINDOW_DELETE)
#define WB_TO_DELETE_WINDOW_ENTRY(X) ((X).iWindowState == WB_WINDOW_DELETE)


//------------------------------------------------------------------------------------------------------
// NOT globally visible variables that define the application, default display params, hash table, etc.
//------------------------------------------------------------------------------------------------------

static _WINDOW_ENTRY_ sWBHashEntries[WINDOW_ENTRY_ARRAY_SIZE]={{0,0}};
static volatile int nWBHashEntries = 0;
static Window wWBFakeWindow = 0;  // fake window keeps me from losing connection when I close all windows
static Window wIDApplication = None; // application window ID

// ignoring X errors - sometimes errors are expected (!?)
int bIgnoreXErrors = 0;
static WB_ERROR_INFO xErrorInfo = {NULL, NULL, 0, 0, 0, 0, 0, None};

// the default display - if I manage more than one, I may need these to be display-specific
Time tmDefaultDisplay = 0; // most recent time value for default display (from events)
WB_UINT64 qwDefaultDisplayTick = 0LL; // the tick count for the last 'default display time'

int bStandardColormap = 0; // flag that says 'cmapDefault' is initialized
XStandardColormap cmapDefault; // a copy of teh XStandardColormap for the Colormap for the default display



/**********************************************************************/
/*                                                                    */
/*  module-specific globals and structures related to event queuing   */
/*                                                                    */
/**********************************************************************/

#define EVENT_ARRAY_SIZE 0x2000 /* this many events maximum */
#define EVENT_ARRAY_MASK 0x1fff /* 'and' this for modular math */

/** \struct s_EVENT_ENTRY
  * \ingroup wcore_internal
  * \copydoc EVENT_ENTRY
**/
/** \typedef EVENT_ENTRY
  * \ingroup wcore_internal
  * \brief Core (internal) structure for storing and dispatching events
  *
**/
typedef struct s_EVENT_ENTRY
{
  Display *pDisplay; ///< the Display pointer for the event
  int iNext;         ///< index for 'next' in a linked list
  Window wID;        ///< the window for which the event is queued
  XEvent xEvt;       ///< the event I'm queueing

  /** \brief alignment padding to make the struct exactly 256 bytes in length
    *
    * Make the structure 256 bytes in length in order to support variable length data payloads (in addition to the event stuff)
    *
    * TODO:  this may not be necessary
  **/
  char padding[256 - sizeof(Display *) - sizeof(Window) - sizeof(int) - sizeof(XEvent)];

} EVENT_ENTRY;

static EVENT_ENTRY axWBEvt[EVENT_ARRAY_SIZE];

static int iWBQueuedEvent = -1, iWBQueueLast = -1, iWBPaintEvent = -1, iWBPaintLast = -1, iWBFreeEvent = -1;
static int iInitEventFlag = 0;

//static WBAppEvent pAppEventCallback = NULL;
static int (* pAppEventCallback)(XEvent *pEvent) = NULL;


#define TIMER_ARRAY_SIZE  512

/** \struct s_TIMER_ENTRY
  * \ingroup wcore_internal
  * \copydoc TIMER_ENTRY
**/
/** \typedef TIMER_ENTRY
  * \ingroup wcore_internal
  * \brief Core (internal) structure for managing timers
**/
typedef struct s_TIMER_ENTRY
{
  struct s_TIMER_ENTRY *pNext;  ///< linked lists for performance
  WB_UINT64 lTimeIndex;          ///< time index for which this timer next expires
  unsigned long lTimeInterval;   ///< interval (or zero for one-shot timer)

  Display *pDisplay;             ///< display associated with timer
  Window wID;                    ///< window to receive timer event
  long lID;                      ///< timer identifier
} TIMER_ENTRY;

static TIMER_ENTRY axWBTimer[TIMER_ARRAY_SIZE];
static TIMER_ENTRY *pTimerEntryActive = NULL, *pTimerEntryFree = NULL;
  // pointers for two linked lists.  entries must be in either 'active' or 'free' list.

/** \struct s_DELAYED_EVENT_ENTRY
  * \ingroup wcore_internal
  * \copydoc DELAYED_EVENT_ENTRY
**/
/** \typedef DELAYED_EVENT_ENTRY
  * \ingroup wcore_internal
  * \brief Core (internal) structure for managing delayed events
**/
typedef struct s_DELAYED_EVENT_ENTRY
{
  struct s_DELAYED_EVENT_ENTRY *pNext;  ///< linked lists for performance
  WB_UINT64 lTimeIndex;                  ///< time index for which this timer next expires

  XEvent event;                          ///< copy of delayed event
} DELAYED_EVENT_ENTRY;

static DELAYED_EVENT_ENTRY axWBDelayedEvent[TIMER_ARRAY_SIZE]; // same size as timers
static DELAYED_EVENT_ENTRY *pDelayedEventEntryActive = NULL, *pDelayedEventEntryFree = NULL;
  // pointers for two linked lists.  entries must be in either 'active' or 'free' list.


/**********************************************************************/
/*                                                                    */
/*                     local function prototypes                      */
/*                                                                    */
/**********************************************************************/

#ifdef NO_DEBUG
static __inline__ _WINDOW_ENTRY_ *WBGetWindowEntry(Window wID);
#else
#define WBGetWindowEntry(X) Debug_WBGetWindowEntry(X, __FUNCTION__, __LINE__)
static __inline__ _WINDOW_ENTRY_ *Debug_WBGetWindowEntry(Window wID, const char *szFunction, int nLine);
#endif // NO_DEBUG

static void __WBInitEvent();
static int __WBAddEvent(Display *pDisp, Window wID, XEvent *pEvent);
static void __WBDelWindowPaintEvents(Display *pDisp, Window wID);
static void __WBDelWindowEvents(Display *pDisp, Window wID);
static int __WBInsertPriorityEvent(Display *pDisp, Window wID, XEvent *pEvent);
static int __WBNextPaintEvent(Display *pDisp, XEvent *pEvent, Window wID);
static int __WBNextDisplayEvent(Display *pDisp, XEvent *pEvent);
static void WBInternalProcessExposeEvent(XExposeEvent *pEvent);
static int __internal_alloc_WMHints(_WINDOW_ENTRY_ *pEntry);
static Window __internal_GetParent(Display *pDisplay, Window wID, Window *pwRoot);
static const char * __internal_event_type_string(int iEventType);
static int __InternalCheckGetEvent(Display *pDisplay, XEvent *pEvent, Window wIDModal);
static void DeletAllTimersForWindow(Display *pDisplay, Window wID);

void __InternalDestroyWindow(Display *pDisp, Window wID, _WINDOW_ENTRY_ *pEntry);


/********************************************************************************/
/*                                                                              */
/*  WBInit, WBInitDisplay, WBExit - global initialization/termination functions */
/*                                                                              */
/********************************************************************************/

static int disable_imagecache = 0;
static int (*pOldDisplayIOErrorHandler)(Display *) = NULL;
static int WBXIOErrorHandler(Display *pDisp);
static int WBXErrorHandler(Display *pDisplay, XErrorEvent *pError);
static int hBogus[3];  // 'bogus' handles 0-2

static WB_GEOM geomStartup
#ifdef WB_C99_INITIALIZERS
  = {.x=0,.y=0,.width=0,.height=0,.border=0}; // C99 syntax; MS does not support this even in 2010 compiler
  // NOTE:  older 'element:value' syntax is supported by GCC only; use '.element=value' (C99) instead
#else // WB_C99_INITIALIZERS
  = {0,0,0,0,0}; // C89 syntax (universally supported)
#error this compiler does not support C99 structure initializers.  Some code will not (yet) compile.
#endif // WB_C99_INITIALIZERS
static char szStartupDisplayName[512]=":0.0";  // NOTE:  new values must be UTF-8
static char szDefaultDisplayName[512]= "";  // copy the "default" display name from WBInit() here

// libXft aka Freetype -
#ifdef X11WORKBENCH_TOOLKIT_HAVE_XFT
extern FT_Library __ftlib; /* located in font_helper.c */
#endif // X11WORKBENCH_TOOLKIT_HAVE_XFT



// helpers called by WBParseStandardArguments()

void __internal_startup_display(const char *szVal)
{
  strlcpy(szStartupDisplayName, szVal, sizeof(szStartupDisplayName));

  szStartupDisplayName[sizeof(szStartupDisplayName) - 1] = 0;
}


void __internal_startup_minimize(void)
{
  iStartupMinMax = -1;
}


void __internal_startup_maximize(void)
{
  iStartupMinMax = 1;
}


void __internal_startup_geometry(const char *szVal)
{
  sscanf(szVal, "%dx%d+%d+%d",
         &geomStartup.width, &geomStartup.height, &geomStartup.x, &geomStartup.y);
}


void __internal_disable_imagecache(void)
{
  disable_imagecache = 1;
}



// MAIN WINDOW INITIALIZATION FUNCTION - call this after WBParseStandardArguments() to be
// fully compliant with X11 command line standards.

Display *WBInit(const char *szDisplayName) // NOTE:  this is 'single instance' only...
{
int i1;
Display *pRval;

#ifndef WIN32
  signal(SIGCHLD, SIG_IGN); // make sure that 'SIGCHLD' signals are *IGNORED* - this is important
#endif // WIN32


  WBPlatformOnInit(); // initialize a few important 'platform helper' things

  bQuitFlag = FALSE; // in case I re-init an app.  note the variable is in 'platform_helper.c'

  // ********************************************************************************
  //                      HACK ALERT - HACK ALERT - HACK ALERT
  //
  // before I begin, allocate 3 handles.  Any handles <= '2' will be KEPT OPEN
  // to avoid problems with the X display using things like stderr for I/O
  // (that is in case stdin, stdout, and stderr weren't allocated or were freed)
  // This assumes that these 3 aren't already open, but for a windowing application
  // with no stdin/stdout/stderr, this is a distinct possibility
  //
  // It is caused by a limitation of the X11 libraries, and is probably a bug.

  for(i1=0; i1 < 3; i1++)
  {
    hBogus[i1] = open("/dev/null", O_RDWR);
  }

  // NOTE:  I can choose to clean this up later but for now it shouldn't do
  //        any harm to leave any file handles <= 2 open in 'hBogus'

  for(i1=2; i1 >= 0; i1--)
  {
    if(hBogus[i1] > 2)
    {
      close(hBogus[i1]);
      hBogus[i1] = -1;
    }
  }

  //                      HACK ALERT - HACK ALERT - HACK ALERT
  // ********************************************************************************

  // NEXT, determine what the display name should be and open it

  if(!szDisplayName)
  {
    szDisplayName = GetStartupDisplayName();
    if(!szDisplayName || !*szDisplayName)
    {
      szDisplayName = ":0.0"; // make sure it's SOMETHING
    }
  }

  if((pRval = XOpenDisplay(szDisplayName)) == NULL)
  {
    WB_ERROR_PRINT("%s - can't open display %s\n", __FUNCTION__, szDisplayName);

    return NULL;
  }

  // make sure that the 'DISPLAY' environment variable will match
  // what I have just opened; that way any X11 applications that I run
  // will continue to use THIS display.  Neat, huh?
  setenv("DISPLAY", szDisplayName, 1); // assign DISPLAY to whatever is in 'szDisplayName'

  // make a copy of the display name for use later on, like for the clipboard initialization
  strlcpy(szDefaultDisplayName, szDisplayName, sizeof(szDefaultDisplayName));


  // new I/O error handler - 'quit flag' will be set on error but app will
  // not terminate until the quit flag is 'noticed'

  pOldDisplayIOErrorHandler = XSetIOErrorHandler(WBXIOErrorHandler);

  if(WBInitDisplay(pRval)) // open and initialize display and basic windowing stuff (including clipboard)
  {
    WBExit(); // in case there are resources to free, plus it does XCloseDisplay(pRval);

    WB_ERROR_PRINT("%s - Unable to initialize X11 WorkBench Toolkit\n", __FUNCTION__);

    return NULL;
  }

//  XFlush(pRval);
  XSync(pRval, 0); // make sure that the display is "in sync"

#if 0 // see if I still need this by removing it
  WBDelay(100000); // wait 0.1 seconds for everything to stabilize (shorter times not good enough)
  // sometimes the window manager will get caught in a race condition and
  // forward along keystrokes that belong to the OLD application, such
  // as the last <RETURN> keystroke release, which could cause a dialog box
  // to mis-behave or a window to insert an unnecessary keystroke.  Giving
  // the window manager a chance to NOT be involved in a race condition should
  // prevent this from happening, or at least minimize the chances.
#endif // 0

  // now that I've initialized the display I can initialize things
  // that depend up on it, beginning with the font stuff

  __internal_font_helper_init(); // initialize font helper

  // TODO:  other things

  return pRval;
}

static int WBXIOErrorHandler(Display *pDisp)
{
  WB_DEBUG_PRINT(DebugLevel_ERROR | DebugSubSystem_Application,
                 "I/O error occurred, setting 'bQuitFlag'\n");

  bQuitFlag = TRUE;  // set QUIT flag on ALL I/O errors.  This is the safest way to shut things down.

//  if(pOldDisplayIOErrorHandler)
//    return(pOldDisplayIOErrorHandler(pDisp));

  return 0;  // for now will do this
}


int WBInitDisplay(Display *pDisplay)
{
unsigned long long ullTick;

  ullTick = WBGetTimeIndex();

  pDefaultDisplay = pDisplay;

  // create a 'fake' window that will keep me from losing connection when I terminate the app
  wWBFakeWindow = XCreateSimpleWindow(pDisplay, DefaultRootWindow(pDisplay), -1, -1, 1, 1, 0, 0, 0);

  // assign a global X11 error handler that will continue execution after printing an appropriate
  // debug message (as needed), in lieu of basically KILLING THE APPLICATION due to some trivial B.S. "error"

//  BEGIN_XCALL_DEBUG_WRAPPER
  XSetErrorHandler(WBXErrorHandler);
//  END_XCALL_DEBUG_WRAPPER

  // begin clipboard initialization with a background thread

  if(__StartInitClipboardSystem(pDisplay, szDefaultDisplayName)) // initialize clipboard system
  {
    WB_ERROR_PRINT("%s - unable to initialize clipboard system\n", __FUNCTION__);

    return 2;
  }

  /*
   * Load the font to use.  See Sections 10.2 & 6.5.1 of the X11 docs
   */

  pDefaultFont = WBLoadFont(pDisplay, WB_DEFAULT_FONT, WB_DEFAULT_FONT_SIZE, 0);

  if(!pDefaultFont)
  {
    pDefaultFont = WBLoadFont(pDisplay, "*", WB_DEFAULT_FONT_SIZE,
                              WBFontFlag_PITCH_FIXED | WBFontFlag_STYLE_SANS);

    if(!pDefaultFont)
    {
      pDefaultFont = WBLoadFont(pDisplay, "*", WB_DEFAULT_FONT_SIZE, 0);

      if(!pDefaultFont)
      {
        WB_ERROR_PRINT("%s - NO DEFAULT FONT, returning 0\n", __FUNCTION__);
        return 0;
      }
    }
  }

//  fontsetDefault = WBFontSetFromFont(pDisplay, pDefaultFont);

  //------
  // ATOMS
  //------

  // NOTE:  the documentation for 'XInternAtom' does _NOT_ include a provision to
  //        free up unused atoms.  There's no obvious way to get rid of the ones that
  //        are not being used any more.  The docs say the following:
  //        "It will become undefined only when the last connection to the X server closes."
  //        (As such, I should minimize introducing NEW atoms, even though it's kinda necessary)
  //
  // To compensate, MANY of the atoms that I create will use WBGetAtom() rather than XInternAtom()
  // and are considered to be 'WorkBench internal' only - so don't use outside of the toolkit

  // ClientMessage events (in general) for various notifications
  aMENU_COMMAND     = WBGetAtom(pDisplay, "MENU_COMMAND");    //XInternAtom(pDisplay, "MENU_COMMAND", False);
  aMENU_UI_COMMAND  = WBGetAtom(pDisplay, "MENU_UI_COMMAND"); //XInternAtom(pDisplay, "MENU_UI_COMMAND", False);
  aRESIZE_NOTIFY    = WBGetAtom(pDisplay, "RESIZE_NOTIFY");   //XInternAtom(pDisplay, "RESIZE_NOTIFY", False);
  aCONTROL_NOTIFY   = WBGetAtom(pDisplay, "CONTROL_NOTIFY");  //XInternAtom(pDisplay, "CONTROL_NOTIFY", False);
  aSCROLL_NOTIFY    = WBGetAtom(pDisplay, "SCROLL_NOTIFY");   //XInternAtom(pDisplay, "SCROLL_NOTIFY", False);
  aQUERY_CLOSE      = WBGetAtom(pDisplay, "QUERY_CLOSE");     //XInternAtom(pDisplay, "QUERY_CLOSE", False);
  aRECALC_LAYOUT    = WBGetAtom(pDisplay, "RECALC_LAYOUT");   //XInternAtom(pDisplay, "QUERY_CLOSE", False);
  aDESTROY_NOTIFY   = WBGetAtom(pDisplay, "DESTROY_NOTIFY");  //XInternAtom(pDisplay, "DESTROY_NOTIFY", False);
  aDLG_FOCUS        = WBGetAtom(pDisplay, "DLG_FOCUS");       //XInternAtom(pDisplay, "DLG_FOCUS", False);
  aSET_FOCUS        = WBGetAtom(pDisplay, "SET_FOCUS");       //XInternAtom(pDisplay, "SET_FOCUS", False);

  // no doubt the above list will grow as new types of ClientMessage events are added

  // internally-generated 'TIMER' event notification
  aWB_TIMER         = WBGetAtom(pDisplay, "WB_TIMER");        //XInternAtom(pDisplay, "WB_TIMER", False);

  // additional 'window manager' ClientMessage events that are generated internally by the toolkit
  // as a result of 'message translation' (basically user input 'RAW' to something more usable)
  aWB_CHAR          = WBGetAtom(pDisplay, "WB_CHAR");         //XInternAtom(pDisplay, "WB_CHAR", False);
  aWB_POINTER       = WBGetAtom(pDisplay, "WB_POINTER");      //XInternAtom(pDisplay, "WB_POINTER", False);


  // these next atoms REQUIRE the use of 'XInternAtom' since they have 'global' scope for the entire X11 system

  // window manager messages (see open desktop specification for window managers)
  // these should already be on the server since the WM would create them
  aWM_PROTOCOLS     = XInternAtom(pDisplay, "WM_PROTOCOLS", False);
  aWM_DELETE_WINDOW = XInternAtom(pDisplay, "WM_DELETE_WINDOW", False);
  aWM_TAKE_FOCUS    = XInternAtom(pDisplay, "WM_TAKE_FOCUS", False);

  // atoms used for fonts (font properties, basically)
  aAVERAGE_WIDTH    = XInternAtom(pDisplay, "AVERAGE_WIDTH", False);

  // atoms for the clipboard (these are all standards, should be on the server already)
  aCLIPBOARD        = XInternAtom(pDisplay, "CLIPBOARD", False);
  aMANAGER          = XInternAtom(pDisplay, "MANAGER", False);
  aTARGET           = XInternAtom(pDisplay, "TARGET", False);
  aINCR             = XInternAtom(pDisplay, "INCR", False);
  aPIXEL            = XInternAtom(pDisplay, "PIXEL", False);
  aTEXT             = XInternAtom(pDisplay, "TEXT", False);
#ifdef X_HAVE_UTF8_STRING /* this indicates the extension is present - rarely would it NOT be */
  aUTF8_STRING      = XInternAtom(pDisplay, "UTF8_STRING", False);
#endif // X_HAVE_UTF8_STRING
  aC_STRING         = XInternAtom(pDisplay, "C_STRING", False);
  aCOMPOUND_TEXT    = XInternAtom(pDisplay, "COMPOUND_TEXT", False);
  aTARGETS          = XInternAtom(pDisplay, "TARGETS", False);
  aMULTIPLE         = XInternAtom(pDisplay, "MULTIPLE", False);
  aTIMESTAMP        = XInternAtom(pDisplay, "TIMESTAMP", False);

// other atoms that are pre-defined - left as comments for future reference, as needed
//
//  aPRIMARY          = XA_PRIMARY;   //XInternAtom(pDisplay, "PRIMARY", False);
//  aSECONDARY        = XA_SECONDARY; //XInternAtom(pDisplay, "SECONDARY", False);
//  aWINDOW           = XA_WINDOW;    //XInternAtom(pDisplay, "WINDOW", False);
//  aBITMAP           = XA_BITMAP;    //XInternAtom(pDisplay, "BITMAP", False);
//  aDRAWABLE         = XA_DRAWABLE;  //XInternAtom(pDisplay, "DRAWABLE", False);
//  aCOLORMAP         = XA_COLORMAP;  //XInternAtom(pDisplay, "COLORMAP", False);
//  aPIXMAP           = XA_PIXMAP;    //XInternAtom(pDisplay, "PIXMAP", False);
//  aSTRING           = XA_STRING;    //XInternAtom(pDisplay, "STRING", False);

  // and, of course, the string 'NULL' which should be globally defined
  aNULL             = XInternAtom(pDisplay, "NULL", False);

  // make sure my atoms work.  Mostly, they're pre-defined or 'WorkBench internal'
  // atoms,  so no reason why they should not

  if(aMENU_COMMAND     == None ||
     aMENU_UI_COMMAND  == None ||
     aRESIZE_NOTIFY    == None ||
     aCONTROL_NOTIFY   == None ||
     aSCROLL_NOTIFY    == None ||
     aQUERY_CLOSE      == None ||
     aDESTROY_NOTIFY   == None ||
     aDLG_FOCUS        == None ||
     aSET_FOCUS        == None ||
     aWM_PROTOCOLS     == None ||
     aWM_DELETE_WINDOW == None ||
     aWM_TAKE_FOCUS    == None ||
     aAVERAGE_WIDTH    == None ||
     aWB_CHAR          == None ||
     aWB_TIMER         == None ||
     aWB_POINTER       == None ||
     aCLIPBOARD        == None ||
     aMANAGER          == None ||
     aTARGET           == None ||
     aINCR             == None ||
     aPIXEL            == None ||
     aTEXT             == None ||
#ifdef X_HAVE_UTF8_STRING /* this indicates the extension is present */
     aUTF8_STRING      == None || // TODO:  should this one be optional?
#endif // X_HAVE_UTF8_STRING
     aC_STRING         == None ||
     aCOMPOUND_TEXT    == None ||
     aTARGETS          == None ||
     aMULTIPLE         == None ||
     aTIMESTAMP        == None ||
//     aPRIMARY          == None ||
//     aSECONDARY        == None ||
//     aWINDOW           == None ||
//     aBITMAP           == None ||
//     aDRAWABLE         == None ||
//     aCOLORMAP         == None ||
//     aPIXMAP           == None ||
//     aSTRING           == None ||
     aNULL             == None )
  {
    return 1;
  }


  // now there's a minimum time delay that I need so that any characters
  // that have been posted to a console window are processed by that console
  // window and not by me.  If I grab the focus too early, it could interpret the
  // return for the previous command as an input to the program.
  //
  // This needs to be longer for a debug build than for a release one, due to debug output
  // on stderr (mostly).  At least that's how it seems to me.
  //
  // So, I need to delay for about 0.1 seconds at a minimum for debug builds, and 0.05 seconds
  // for a release build.

#ifdef NO_DEBUG
#define MIN_STARTUP_DELAY 50000LL
#else
#define MIN_STARTUP_DELAY 100000LL /* was 250000LL */
#endif // NO_DEBUG

  ullTick = WBGetTimeIndex() - ullTick;
  if(ullTick < MIN_STARTUP_DELAY)
  {
    // TODO:  eat all keyboard and mouse input events...

    usleep(MIN_STARTUP_DELAY - ullTick);
  }


  // FINALLY, initialize settings and finish the clipboard system

  if(__FinishInitClipboardSystem(pDisplay, szDefaultDisplayName)) // initialize clipboard system
  {
    WB_ERROR_PRINT("%s - unable to initialize clipboard system\n", __FUNCTION__);

    return 2;
  }

  CHSettingsRefresh(pDisplay); // must init first part of the clipboard system *FIRST* before I call this

  return 0;  // success
}


WB_FONTC WBGetDefaultFont(void)
{
  if(!pDefaultFont)
  {
    WB_ERROR_PRINT("%s - pDefaultFont is NULL\n", __FUNCTION__);
  }

  return (WB_FONTC)pDefaultFont;
}

//XFontStruct *WBGetDefaultFont(void)
//{
//  extern XFontStruct *pDefaultFont;  // default font
//
//  if(!pDefaultFont)
//  {
//    WB_ERROR_PRINT("%s - pDefaultFont is NULL\n", __FUNCTION__);
//  }
//
//  return(pDefaultFont);
//}

//XFontSet WBGetDefaultFontSet(Display *pDisplay)
//{
//extern XFontSet fontsetDefault; // TODO:  per-display font sets?
//
//  if(!pDisplay || pDisplay == pDefaultDisplay)
//  {
//    if(fontsetDefault == None)
//    {
//      WB_ERROR_PRINT("%s - fontsetDefault is None\n", __FUNCTION__);
//    }
//
//    return fontsetDefault;
//  }
//
//  WB_ERROR_PRINT("TODO:  %s - support use of non-default Display (returning 'None')\n", __FUNCTION__);
//
//  return None; // for now...
//}

Window WBGetHiddenHelperWindow(void)
{
  if(wWBFakeWindow == None)
  {
    WB_ERROR_PRINT("%s - wWBFakeWindow is 'None'\n", __FUNCTION__);
  }

  return wWBFakeWindow;
}

void __InternalDestroyWindow(Display *pDisp, Window wID, _WINDOW_ENTRY_ *pEntry)
{
  Window wIDTemp;
  Atom aNCW;
  XClientMessageEvent xMsg;
  Status st;
  XImage *pTempImage;
  int i1;


//  WB_ERROR_PRINT("TEMPORARY - %s - Destroying window %u (%08xH), %d hash entries\n",
//                 __FUNCTION__, (unsigned int)wID, (unsigned int)wID, nWBHashEntries);

  // first, I want to destroy any child windows that have window entries, FIRST.  Do that now.

  for(i1=0; i1 < WINDOW_ENTRY_ARRAY_SIZE; i1++)
  {
    if(WB_LIKELY(sWBHashEntries[i1].wID == WINDOW_ENTRY_UNUSED) ||
       WB_LIKELY(sWBHashEntries[i1].wID == None))
    {
      continue;  // ignore 'None' and 'UNUSED'
    }

    if(sWBHashEntries[i1].wID == wID)
    {
//      WB_ERROR_PRINT("TEMPORARY - %s - Destroy child windows, found 'me' %u (%08xH)\n",
//                     __FUNCTION__, (unsigned int)wID, (unsigned int)wID);
      continue;  // ignore "me"
    }

    if(sWBHashEntries[i1].wParent == wID)
    {
      if(WB_IS_WINDOW_BEING_DESTROYED(sWBHashEntries[i1]))
      {
//        WB_ERROR_PRINT("TEMPORARY - %s - child window already being destroyed %u (%08xH)\n",
//                       __FUNCTION__, (unsigned int)sWBHashEntries[i1].wID, (unsigned int)sWBHashEntries[i1].wID);
      }
      else if(WB_IS_WINDOW_DESTROYED(sWBHashEntries[i1])) // not already destroyed (or being deleted)
      {
//        WB_ERROR_PRINT("TEMPORARY - %s - child window already destroyed %u (%08xH)\n",
//                       __FUNCTION__, (unsigned int)sWBHashEntries[i1].wID, (unsigned int)sWBHashEntries[i1].wID);
      }
      else if(WB_TO_DELETE_WINDOW_ENTRY(sWBHashEntries[i1]))
      {
//        WB_ERROR_PRINT("TEMPORARY - %s - child window entry to be deleted %u (%08xH)\n",
//                       __FUNCTION__, (unsigned int)sWBHashEntries[i1].wID, (unsigned int)sWBHashEntries[i1].wID);
      }
      else
      {
//        WB_ERROR_PRINT("TEMPORARY - %s - Destroying child window %u (%08xH)\n",
//                       __FUNCTION__, (unsigned int)sWBHashEntries[i1].wID, (unsigned int)sWBHashEntries[i1].wID);

        __InternalDestroyWindow(pDisp, sWBHashEntries[i1].wID, &(sWBHashEntries[i1]));
      }
    }
  }


  if(!pEntry || !(pEntry->eWMProtocols & WMPropertiesWMProtocols_DeleteWindow))
  {
destroy_without_wm:

    if(pEntry)
    {
      pEntry->iWindowState = WB_WINDOW_DESTROYED; // so that there is no recursion problem
      // this way the window has already been marked 'destroyed' before actually calling
      // the function to destroy it.  Doing it this way tells everything else down the
      // pike that I shouldn't be querying info or trying to destroy it TWICE.
    }

//    WB_ERROR_PRINT("TEMPORARY:  %s - call to XDestroyWindow for %u (%08xH)\n", __FUNCTION__, (int)wID, (int)wID);

    BEGIN_XCALL_DEBUG_WRAPPER
    XDestroyWindow(pDisp, wID); // do this anyway (since it's still mapped and not destroyed)
    END_XCALL_DEBUG_WRAPPER

    BEGIN_XCALL_DEBUG_WRAPPER
//    XFlush(pDefaultDisplay);
    XSync(pDefaultDisplay, FALSE);  // try sync'ing to avoid certain problems
    END_XCALL_DEBUG_WRAPPER

    // TODO:  if pEntry is not NULL, do I wait for it to REALLY get destroyed?

    if(pEntry)
    {
      pTempImage = pEntry->pImage;
      pEntry->pImage = NULL;

      if(pTempImage)
      {
        BEGIN_XCALL_DEBUG_WRAPPER
        XDestroyImage(pTempImage); // buh-bye!
        END_XCALL_DEBUG_WRAPPER
      }
    }

    return;
  }

  if(!pDisp)
  {
    pDisp = pDefaultDisplay;
  }

  wIDTemp = DefaultRootWindow(pDisp);

  if(wIDTemp == None)
  {
    WB_ERROR_PRINT("ERROR - %s - default root window = 'None'\n", __FUNCTION__);
    goto destroy_without_wm;
  }

  aNCW = XInternAtom(pDisp, "_NET_CLOSE_WINDOW", False); /* global scope, must use XInternAtom */

  if(aNCW == None)
  {
    WB_ERROR_PRINT("ERROR - %s - atom for _NET_CLOSE_WINDOW = 'None'\n", __FUNCTION__);
    goto destroy_without_wm;
  }

  memset(&xMsg, 0, sizeof(xMsg));

  xMsg.type = ClientMessage;
  xMsg.serial = 0;
  xMsg.send_event = 1;
  xMsg.display = pDisp;
  xMsg.window = wID;
  xMsg.message_type = aNCW; // TODO:  different atom for different display?
  xMsg.format = 32;
  xMsg.data.l[0] = CurrentTime; //WBGetLastEventTime();
  xMsg.data.l[1] = 1; // normal application

  pEntry->iWindowState = WB_WINDOW_DESTROYING; // so that there is no recursion problem

  BEGIN_XCALL_DEBUG_WRAPPER
  st = XSendEvent(pDisp, wIDTemp, False, NoEventMask, (XEvent *)&xMsg);
  END_XCALL_DEBUG_WRAPPER

  BEGIN_XCALL_DEBUG_WRAPPER
  XSync(pDefaultDisplay, FALSE);  // try sync'ing to avoid certain errors
  END_XCALL_DEBUG_WRAPPER

//  WB_ERROR_PRINT("<<TEMPORARY: %s - message sent to %d to close %d (%s)\n", __FUNCTION__, (int)wIDTemp, (int)wID, pEntry->szClassName);

#if 0 /* this section never works */
  // waiting for the entry to be marked "destroyed"

  if(st)
  {
    WB_UINT64 tmNow = WBGetTimeIndex();

    WB_ERROR_PRINT("INFO:  %s - 'DESTROY WINDOW' message sent OK to WM\n", __FUNCTION__);

    st = 0;
    while(pEntry && (WBGetTimeIndex() - tmNow) < 50000) // wait up to 0.05 seconds
    {
      XEvent evt;

      WBDelay(MIN_EVENT_LOOP_SLEEP_PERIOD); // wait 0.1 msec

      // look for (and dispatch) destroy notify messages for my window
      if(XCheckTypedEvent(pDisp, DestroyNotify, &evt))
      {
        WBDispatch(&evt); // process destroy notifications
      }

      if(WB_IS_WINDOW_DESTROYED(*pEntry))
      {
        st = 1;

        WB_ERROR_PRINT("INFO:  %s - 'DESTROY WINDOW' message acknowledged by WM\n", __FUNCTION__);

        break;
      }
    }
  }

  if(!st)
#endif // 0

  {

//    WB_DEBUG_PRINT(DebugLevel_WARN | DebugSubSystem_Window,
//                   "WARNING - %s - did not destroy window via WM, calling XDestroyWindow for %d (%s)\n",
//                   __FUNCTION__, (int)wID, pEntry->szClassName);

    pEntry->iWindowState = WB_WINDOW_DESTROYED; // so that there is no recursion problem or attempts to use the window

//    WB_ERROR_PRINT("TEMPORARY:  %s - call to XDestroyWindow for %u (%08xH)\n", __FUNCTION__, (int)wID, (int)wID);

    BEGIN_XCALL_DEBUG_WRAPPER
    XDestroyWindow(pDisp, wID); // do this anyway (since it's still mapped and not destroyed)
    END_XCALL_DEBUG_WRAPPER

    BEGIN_XCALL_DEBUG_WRAPPER
    XSync(pDefaultDisplay, FALSE);  // try sync'ing to avoid certain problems
    END_XCALL_DEBUG_WRAPPER

    // if there's a cached XImage for this window, destroy it

    pTempImage = pEntry->pImage;
    pEntry->pImage = NULL;

    if(pTempImage)
    {
      BEGIN_XCALL_DEBUG_WRAPPER
      XDestroyImage(pTempImage); // buh-bye!
      END_XCALL_DEBUG_WRAPPER
    }
  }
}

void WBExit()
{
int i1;
//Window wIDRoot, wIDTemp;

  bQuitFlag = TRUE;  // in case this makes something happen

  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Init,
                 "TRACE:  WBExit\n");

  if(!pDefaultDisplay)
  {
    WB_ERROR_PRINT("ERROR: %s - default display contains NULL\n", __FUNCTION__);

    WBExitClipboardSystem(NULL); // just in case
    return;
  }

  WBExitClipboardSystem(pDefaultDisplay); // do this now

  XFlush(pDefaultDisplay);

  // for each remaining window in my list, destroy it
  for(i1=WINDOW_ENTRY_ARRAY_MAX - 1; i1 >= 0; i1--)
  {
    Display *pDisp = sWBHashEntries[i1].pDisplay;
    Window wID = sWBHashEntries[i1].wID;

    if(!wID || wID == WINDOW_ENTRY_UNUSED)
    {
      continue;
    }

    if(!pDisp)
    {
      pDisp = pDefaultDisplay;
    }

    if(WB_IS_WINDOW_MAPPED(sWBHashEntries[i1]))
    {
      WB_ERROR_PRINT("INFO: %s destroying window %d\n", __FUNCTION__, (int)wID);

      // send a 'destroy' request to the window manager

      __InternalDestroyWindow(pDisp, wID, &(sWBHashEntries[i1]));
    }

    WBUnregisterWindowCallback(wID);

    XFlush(pDisp);
  }

// TODO:  cache font sets within the font helper, and manage all of them there.
//  Font_OnExit(pDefaultDisplay); // call this _BEFORE_ I close the display

//  if(fontsetDefault != None)
//  {
//    XFreeFontSet(pDefaultDisplay, fontsetDefault);
//    fontsetDefault = None;
//  }

  if(pDefaultFont)
  {
//    XFreeFont(pDefaultDisplay, pDefaultFont);
    WBFreeFont(pDefaultDisplay, pDefaultFont);
    pDefaultFont = NULL;
  }

  if(wWBFakeWindow != None) // NOTE:  WM doesn't know about this
  {
    WB_ERROR_PRINT("INFO: %s destroying 'fake' window %d\n", __FUNCTION__, (int)wWBFakeWindow);

    BEGIN_XCALL_DEBUG_WRAPPER
    XDestroyWindow(pDefaultDisplay, wWBFakeWindow);
    END_XCALL_DEBUG_WRAPPER
  }

  BEGIN_XCALL_DEBUG_WRAPPER
  XSync(pDefaultDisplay, FALSE);  // try sync'ing first to avoid certain errors
  XCloseDisplay(pDefaultDisplay); // display is to be destroyed now
  END_XCALL_DEBUG_WRAPPER

  wWBFakeWindow = None;
  pDefaultDisplay = NULL;

  __internal_font_helper_exit(); // font helper
  PXM_OnExit();                  // pixmap_helper
  CHOnExit();                    // config_helper
  WBPlatformOnExit();            // platform_helper

  if(pOldDisplayIOErrorHandler)
  {
    XSetIOErrorHandler(pOldDisplayIOErrorHandler);
    pOldDisplayIOErrorHandler = NULL;
  }
}

const char *GetStartupDisplayName(void)
{
  return szStartupDisplayName;
}

void GetStartupGeometry(WB_GEOM *pGeom)
{
  if(pGeom)
  {
    memcpy(pGeom, &geomStartup, sizeof(WB_GEOM));
  }
}

int GetStartupMinMax(void)
{
  return iStartupMinMax;
}


Display *WBThreadInitDisplay(void)
{
Display *pDisplay;

  if(!szDefaultDisplayName[0]) // no display has been opened yet
  {
    return NULL;
  }

  pDisplay = XOpenDisplay(szDefaultDisplayName); // open a copy of the display


  // TODO:  other initialization


  if(pDisplay)
  {
    BEGIN_XCALL_DEBUG_WRAPPER
//    XFlush(pDisplay);
    XSync(pDisplay, FALSE);  // sync everything now
    END_XCALL_DEBUG_WRAPPER
  }

  return pDisplay;
}

void WBThreadFreeDisplay(Display *pThreadDisplay)
{
  if(pThreadDisplay)
  {
    BEGIN_XCALL_DEBUG_WRAPPER
//    XFlush(pThreadDisplay);
    XSync(pThreadDisplay, FALSE);  // try sync'ing first to avoid certain errors
    XCloseDisplay(pThreadDisplay); // display is to be destroyed now
    END_XCALL_DEBUG_WRAPPER
  }
}

void WBInitWindowAttributes(XSetWindowAttributes *pXSWA, unsigned long lBorderPixel,
                            unsigned long lBackgroundPixel, Colormap clrMap, int iBitGravity)
{
  memset(pXSWA, 0, sizeof(*pXSWA));

  pXSWA->border_pixel = lBorderPixel;
  pXSWA->background_pixel = lBackgroundPixel;
  pXSWA->colormap = clrMap;
  pXSWA->bit_gravity = iBitGravity;
}

void WBInitSizeHints(XSizeHints *pSH, Display *pDisplay, int iMinHeight, int iMinWidth)
{
  WB_GEOM geomStartup;

  if(!pDisplay)
  {
    pDisplay = WBGetDefaultDisplay();
  }

#define WBInitSizeHints__max(X,Y) ((X) > (Y) ? (X) : (Y))

  memset(pSH, 0, sizeof(*pSH));

  pSH->flags = (PPosition | PSize);

  GetStartupGeometry(&geomStartup); // based on user-specified or stored parameters

  // making this SIMPLE AS POSSIBLE, default to 2/3 of the screen (vertically and horizontally) and
  // center the window.  If the screen is 16x9, reduce the width estimate to 4/3 the height

  if(!geomStartup.width || !geomStartup.height) // width or height zero --> default
  {
    int iDisplayHeight = DisplayHeight(pDisplay, DefaultScreen(pDisplay));
    int iDisplayWidth = DisplayWidth(pDisplay, DefaultScreen(pDisplay));
    int iActualDisplayWidth = iDisplayWidth;

    if(iDisplayWidth > iDisplayHeight * 4 / 3) // for 16x9 screens, we want a reasonable estimate
    {
      iDisplayWidth = iDisplayHeight * 4 / 3;
    }

    // base window dimensions on 2/3 of the size of the display or min height/width

    pSH->width = WBInitSizeHints__max(iMinWidth, iDisplayWidth * 2 / 3);
    pSH->height = WBInitSizeHints__max(iMinHeight, iDisplayHeight * 2  / 3);

    // vertically and horizontally center the window

    pSH->x = (iActualDisplayWidth - pSH->width) / 2; // use the actual display width this time
    pSH->y = (iDisplayHeight - pSH->height) / 2;
  }
  else
  {
    // user-specified dimensions take precedence

    pSH->x = geomStartup.x;
    pSH->y = geomStartup.y;

    pSH->width = geomStartup.width;
    pSH->height = geomStartup.height;
  }

#undef WBInitSizeHints__max

}



int WBShowModal(Window wID, int bMenuSplashFlag)
{
int iRval = -1;
int iSleepPeriod;
WB_GEOM geom;
_WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);


  if(!pEntry)
    return -1;

  pEntry->iModalFlag = 1;
  pEntry->iModalReturn = -1;

  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Window,
                 "Show Modal %d (%08xH) bMenuSplashFlag=%d\n", (int)wID, (int)wID, bMenuSplashFlag);

  // make sure I'm "transient for" the parent window [always] except for menus
  if(bMenuSplashFlag <= 0) // not for menus but splash ok
  {
    Atom a1, a2;
//    Window wParent;

    a1 = XInternAtom(pEntry->pDisplay, "_NET_WM_STATE", False); /* global scope, must use XInternAtom */
    a2 = XInternAtom(pEntry->pDisplay, "_NET_WM_STATE_MODAL", False); /* global scope, must use XInternAtom */
    XChangeProperty(pEntry->pDisplay, wID, a1, XA_ATOM, 32, PropModePrepend, (unsigned char *)&a2, 1);
      // note:  Keeping existing properties, and adding my own

//    // setting 'WM_TRANSIENT_FOR' allows me to use the parent window while the dialog is open - I do NOT want that!
//    a1 = XInternAtom(pEntry->pDisplay, "WM_TRANSIENT_FOR", False); /* global scope, must use XInternAtom */
//    wParent = WBGetParentWindow(wID);  NOTE this is not the way to do it, fix elsewhere eh?
//    XChangeProperty(pEntry->pDisplay, wID, a1, XA_WINDOW, 32, PropModeReplace, (unsigned char *)&wParent, 1);
  }

  XMapRaised(pEntry->pDisplay, wID);

  if(!bMenuSplashFlag) // dialog boxes ONLY
  {
    WBSetInputFocus(wID); // NOTE:  menu popups _MUST_ be declared with 'focus bit' 0, and handled differently
  }

  if(bMenuSplashFlag > 0)
  {
//    WB_ERROR_PRINT("TEMPORARY:  %s - grabbing mouse and keyboard\n", __FUNCTION__);

    // ----------------------------
    // mouse and keyboard grab time
    // ----------------------------

    WBGetWindowGeom2(wID, &geom);  // geometry relative to root window

    BEGIN_XCALL_DEBUG_WRAPPER
    XGrabPointer(pEntry->pDisplay,wID, 1,
                 ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | PointerMotionMask
                  | EnterWindowMask | LeaveWindowMask,
                 GrabModeAsync, // pointer mode
                 GrabModeAsync, // keyboard mode
                 None, None, CurrentTime);
    XGrabKeyboard(pEntry->pDisplay, wID, 1,
                  GrabModeAsync, // pointer mode
                  GrabModeAsync, // keyboard mode
                  CurrentTime);
    END_XCALL_DEBUG_WRAPPER
  }
//  else
//  {
//    WB_ERROR_PRINT("TEMPORARY:  showing modal for NON-menu\n");
//  }


//  WB_ERROR_PRINT("TEMPORARY:  %s - begin modal event processing\n", __FUNCTION__);

  iSleepPeriod = MIN_EVENT_LOOP_SLEEP_PERIOD; // initial value, in microseconds

  while(!bQuitFlag)
  {
    XEvent event;

    // do a mini event loop but only for this window.  The event handler should
    // be smart enough to handle a condition where I attempt to change focus

    // for future implementation - see XmTrackingEvent for hints on how to implement this properly

    // TODO:  modal filtering for window and children of this window

    pEntry = WBGetWindowEntry(wID);  // re-assign 'pEntry'

    if(!pEntry)
    {
      break;
    }

    if(!WBIsValid(pEntry->pDisplay, wID) ||
       !pEntry->iModalFlag)
    {
      break;
    }

    if(!__InternalCheckGetEvent(pEntry->pDisplay, &event, wID))
    {
      WBDelay(iSleepPeriod);  // 100 microsecs (0.1 milliseconds) initially, grows over time
      if(iSleepPeriod < MAX_EVENT_LOOP_SLEEP_PERIOD) // up to 'MAX_EVENT_LOOP_SLEEP_PERIOD' microseconds
      {
        iSleepPeriod += (iSleepPeriod >> 1); // increase by 50%
      }
      else
      {
        iSleepPeriod = MAX_EVENT_LOOP_SLEEP_PERIOD; // the maximum
      }

      continue;
    }

    iSleepPeriod = MIN_EVENT_LOOP_SLEEP_PERIOD; // reset to the initial value

    // check for application events - these will continue to happen
    // even during a modal loop.

    if(event.xany.window == None)
    {
      // TODO:  if messages aren't consistent with 'xany', filter them here.

      WBAppDispatch(&event);
      continue;
    }

//#ifndef NO_DEBUG
//    WBDebugDumpEvent(&event); // TEMPORARY
//#endif // NO_DEBUG

    // For menus, check for mousie events outside of my window.  If this happens
    // I want to cancel the modal loop and re-play the event.

    if(bMenuSplashFlag > 0) // menus only
    {
      if((event.type == ButtonPress || event.type == ButtonRelease) &&
         !WBPointInGeom(event.xbutton.x_root, event.xbutton.y_root, geom))
      {
        WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_Mouse | DebugSubSystem_Menu,
                       "WBShowModal - (menu) mouse button press outside of grab window\n");

        BEGIN_XCALL_DEBUG_WRAPPER
        XUngrabPointer(pEntry->pDisplay, CurrentTime);
        XUngrabKeyboard(pEntry->pDisplay, CurrentTime);
        XAllowEvents(pEntry->pDisplay, ReplayPointer, CurrentTime/*event.xbutton.time*/);  // re-play the mousie event

        XPutBackEvent(pEntry->pDisplay, &event);  // TODO:  correct window ID?
        END_XCALL_DEBUG_WRAPPER

        WBDestroyWindow(wID);
        return -1;  // "canceled"
      }
    }
    else if(bMenuSplashFlag < 0) // splash screens
    {
    }
    else if(event.xany.window != wID && event.type == FocusIn) // dialog boxes getting focus
    {
      // in this case it is EXTREMELY important to determine if the main
      // window is getting an 'enter focus' notification, since I will need
      // to re-assign focus to 'wID' ASAP.  Examples are when the user clicks
      // on the main window while a dialog box is visible, or if the user attempts
      // to change focus to the main window via alt+tab or clicking on an icon in
      // the task bar.  Therefore, if 'event.xany.window' isn't a child of 'wID'
      // I shall call 'SetFocus' on 'wID' and eat the message.
      // For this to work, top level windows must allow 'EnterNotify' messages.

      if(!WBIsChildWindow(wID, event.xany.window))
      {
        Display *pDisplay = pEntry->pDisplay ? pEntry->pDisplay : pDefaultDisplay;

//        fprintf(stderr, "** TEMPORARY:  window %08xH 'FocusIn' in modal loop for %08xH\n",
//                (unsigned int)event.xany.window, (unsigned int)wID);

        WBPostDelayedSetFocusAppEvent(pDisplay, wID, event.xany.window, 100); // 100 msec delay
          // activate, set focus, raise, and map 'wID' (with 'event.xany.window' possibly having HAD focus)
          // and the 100 msec delay is to ensure that NO race conditions happen with the window manager

        continue;  // old message eaten
      }
    }


    // see if this event is intended for the modal window or one of its children
    // and if so, I want to dispatch it

    if(event.xany.window == wID ||
       event.type == Expose ||                                              // always handle expose events
       event.type == GraphicsExpose ||
//       event.type == NoExpose ||
       event.type == DestroyNotify ||                                       // always allow destroy notifications
       event.type == SelectionRequest ||
       event.type == SelectionClear ||
       event.type == SelectionNotify ||
       (bMenuSplashFlag > 0 &&                                              // check for ANY KB+mouse events when NOT a splash window
        (event.type == KeyPress || event.type == KeyRelease ||
         event.type == ButtonPress || event.type == ButtonRelease ||
         event.type == MotionNotify || event.type == EnterNotify ||
         event.type == LeaveNotify)) ||
       (bMenuSplashFlag >= 0 && WBIsChildWindow(wID, event.xany.window)) || // check for 'is a child of modal' when NOT a splash window
       WB_UNLIKELY(event.type == ClientMessage &&
                   (event.xclient.message_type == aWM_PROTOCOLS || // all of these get through
                    event.xclient.message_type == aWB_TIMER)))     // all timers get through
    {
      if(event.xany.window != wID && bMenuSplashFlag > 0 && // menu only because I'm capturing keyboard and mouse
         (event.type == KeyPress || event.type == KeyRelease || event.type == MotionNotify))
      {
        if(event.type == MotionNotify)
        {
          int iX, iY;
          // mouse coordinates have been adjusted for the window for which
          // it was intended.  these must be 'altered'
          WBXlatCoordPoint(event.xmotion.window, event.xmotion.x, event.xmotion.y,
                           wID, &iX, &iY);
          event.xmotion.x = iX;
          event.xmotion.y = iY;
          event.xmotion.window = wID;  // assign THIS window's ID for such messages
        }
        else
        {
//          Window wParent = WBGetParentWindow(wID);
          if(!WBIsChildWindow(wID, event.xany.window))
          {
            event.xany.window = wID;  // assign THIS window's ID for such messages
          }
        }
      }

#ifndef NO_DEBUG
      if(event.xany.window != wID &&
         WB_LIKELY(event.type != ClientMessage ||
                   (event.xclient.message_type != aWB_TIMER && event.xclient.message_type != aWM_PROTOCOLS)))

      {
        WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_Event | DebugSubSystem_Window,
                       "%s - event %s for window %d (%08xH) in modal loop\n",
                       __FUNCTION__,
                       WBEventName(event.type),
                       (int)event.xany.window, (int)event.xany.window);
      }

      if(event.type == KeyPress || event.type == KeyRelease)
      {
        WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_Keyboard | DebugSubSystem_Event | DebugSubSystem_Window,
                       "%s - TEMPORARY - processing key press/release within modal loop: %d (%08xH), %d (%08xH)\n",
                       __FUNCTION__, (int)event.xany.window, (int)event.xany.window, (int)wID, (int)wID);
      }

#endif // NO_DEBUG

      WBWindowDispatch(event.xany.window, &event);
    }
#ifndef NO_DEBUG
    else
    {
      // say something for debug purposes about messages that weren't processed

//      WB_DEBUG_PRINT(DebugLevel_ERROR,
//                     "** TEMPORARY:  IGNORING %s in modal loop: %d (%08xH), %d (%08xH)\n",
//                     __internal_event_type_string(event.type),
//                     (int)event.xany.window, (int)event.xany.window, (int)wID, (int)wID);

      if(event.type == KeyPress || event.type == KeyRelease)
      {
        WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_Keyboard | DebugSubSystem_Event | DebugSubSystem_Window,
                       "%s - key press/release in modal loop: %d (%08xH), %d (%08xH)\n",
                       __FUNCTION__, (int)event.xany.window, (int)event.xany.window, (int)wID, (int)wID);
      }
    }
#endif // NO_DEBUG

    // other stuff gets ignored

  }

  if(!pEntry)
  {
    return -1;
  }

  if(bMenuSplashFlag > 0) // menus only
  {
    BEGIN_XCALL_DEBUG_WRAPPER
    XUngrabPointer(pEntry->pDisplay, CurrentTime);
    XUngrabKeyboard(pEntry->pDisplay, CurrentTime);
    END_XCALL_DEBUG_WRAPPER
  }

  iRval = pEntry->iModalReturn;

  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Window,
                 "Exit from modal loop, window %d (%08xH) - returning %d (%08xH)\n",
                 (int)wID, (int)wID, iRval, iRval);

  // destroy the window now that I'm out of the loop

//  WB_ERROR_PRINT("** TEMPORARY - %s - destroying window %d\n", __FUNCTION__,(int)wID);

  WBDestroyWindow(wID);

  return iRval;
}

void WBEndModal(Window wID, int iRval)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(!pEntry)
    return;

  pEntry->iModalFlag = 0;
  pEntry->iModalReturn = iRval;

  WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_Window,
                 "WBEndModal - Window %d (%08xH), returning %d (%08xH)\n",
                 (int)wID, (int)wID, iRval, iRval);
}

void WBSetInputFocus(Window wID)  // set input focus to specific window (revert window is previous focus window)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
  Window wIDCurrent;
  int iRevert;
  Display *pDisp = pEntry ? pEntry->pDisplay : pDefaultDisplay;

  BEGIN_XCALL_DEBUG_WRAPPER
  XGetInputFocus(pDisp, &wIDCurrent, &iRevert);
  END_XCALL_DEBUG_WRAPPER

  if(wID != wIDCurrent) // don't have focus
  {
    _WINDOW_ENTRY_ *pPrev = WBGetWindowEntry(wIDCurrent);
    if(pPrev)
    {
      if(WB_CHECK_SET_FOCUS_ON_MAP(*pPrev))
      {
        WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Window,
                       "%s:%d - %d (%08xH) disabling focus change on map\n",
                       __FUNCTION__, __LINE__, (int)wIDCurrent, (int)wIDCurrent);

        pPrev->iWindowState = WB_WINDOW_UNMAPPED;  // remove 'set focus' state
      }
    }

    // see if expose event has been done on this yet...
    if(WB_LIKELY(pEntry) && //WB_UNLIKELY(!pEntry->width && !pEntry->height && !pEntry->border))
       WB_UNLIKELY(WB_IS_WINDOW_UNMAPPED(*pEntry)))
    {
      WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Window,
                     "%s:%d - %d (%08xH) not yet visible, enabling focus change on map\n",
                     __FUNCTION__, __LINE__, (int)wID, (int)wID);

      pEntry->iWindowState = WB_WINDOW_SET_FOCUS_ON_MAP;
    }
    else
    {
      WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Window,
                     "%s:%d - %d (%08xH) calling XSetInputFocus\n",
                     __FUNCTION__, __LINE__, (int)wID, (int)wID);

//      WB_ERROR_PRINT("TEMPORARY - %s calling XSetInputFocus on wID=%u (%08xH)\n", __FUNCTION__, (int)wID, (uint32_t)wID);

      BEGIN_XCALL_DEBUG_WRAPPER
      XSetInputFocus(pDisp, wID, RevertToParent, CurrentTime);
      END_XCALL_DEBUG_WRAPPER
    }
  }
}

// construction and destruction

void WBDestroyWindow(Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
  Display *pDisplay = pEntry ? pEntry->pDisplay : pDefaultDisplay;
  XEvent event;

  if(pEntry && WB_IS_WINDOW_DESTROYED(*pEntry)) // recursive or extra call
  {
    WB_WARN_PRINT("%s - Recursive call, Window %d (%08xH)\n",
                  __FUNCTION__, (int)wID, (int)wID);

    __WBDelWindowPaintEvents(pDisplay, wID); // make sure expose events go away

    return;
  }

  if(pEntry && WB_IS_WINDOW_BEING_DESTROYED(*pEntry)) // recursive call in need of XDestroyWindow
  {
    pEntry->iWindowState = WB_WINDOW_DESTROYED;  // initially, do this (in case of extra recursion)

    WB_ERROR_PRINT("INFO: %s recursively destroying window %d\n", __FUNCTION__, (int)wID);

    BEGIN_XCALL_DEBUG_WRAPPER
    XDestroyWindow(pDisplay, wID); // handler should clean up the rest
                                   // NOTE:  this _CAN_ recurse in some cases
//    XFlush(pDisplay);
    XSync(pDisplay, False);        // wait for server to actually do it - specific to debug output, really
    END_XCALL_DEBUG_WRAPPER

    __WBDelWindowPaintEvents(pDisplay, wID); // make sure expose events go away

    return;
  }

  WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_Window,
                 "%s - Window %d (%08xH) class %s\n",
                 __FUNCTION__, (int)wID, (int)wID, pEntry ? (pEntry->szClassName ? pEntry->szClassName : "NULL") : "*Unk*");

  // get all events for this window and remove them

  BEGIN_XCALL_DEBUG_WRAPPER
  XSync(pDisplay, FALSE);  // force a sync first
  END_XCALL_DEBUG_WRAPPER

  while(XCheckWindowEvent(pDisplay, wID, EVENT_ALL_MASK, &event))
  {
//      WBDelay(1000);  // force sleep during loop?
  }

  if(!pEntry)
  {
    WB_WARN_PRINT("WARNING:  WBDestroyWindow for wID not in list - window already destroyed?\n");

    XSync(pDisplay, 0);

    __WBDelWindowEvents(pDefaultDisplay, wID);

    WB_ERROR_PRINT("INFO: %s destroying UN-REGISTERED window %d\n", __FUNCTION__, (int)wID);

//    BEGIN_XCALL_DEBUG_WRAPPER
//    XDestroyWindow(pDefaultDisplay, wID);
//    END_XCALL_DEBUG_WRAPPER
      __InternalDestroyWindow(pDisplay, wID, NULL);
  }
  else
  {
    // TODO:  should I send a notification first?

    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Window,
                   "WBDestroyWindow - wID %d (%08xH)\n",
                   (int)wID, (int)wID);

    // I'll want to process some additional events at this point, JUST for the
    // window and its children

    BEGIN_XCALL_DEBUG_WRAPPER
    XSync(pDisplay, 0);
    END_XCALL_DEBUG_WRAPPER

// NOTE:  I used to dispatch remaining events, but this might dispatch EXPOSE and I don't want that
//    while(XCheckWindowEvent(pDisplay, wID, EVENT_ALL_MASK, &event))
//    {
//      WBWindowDispatch(wID, &event);
//    }

    WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Window,
                   "WBDestroyWindow - wID %d (%08xH), display flushed\n",
                   (int)wID, (int)wID);

    if(WB_IS_WINDOW_MAPPED(*pEntry))
    {
      WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Window,
                     "WBDestroyWindow - wID %d (%08xH), calling XDestroyWindow\n",
                     (int)wID, (int)wID);

      __InternalDestroyWindow(pDisplay, wID, pEntry); // may mark it 'DESTROYING' so recursion won't happen (see above)

//      if(!WB_IS_WINDOW_DESTROYED(*pEntry))
//      {
//        pEntry->iWindowState = WB_WINDOW_DESTROYED;  // initially, do this (in case of recursion)
//
//        WB_ERROR_PRINT("** WARNING: %s destroying window %d (marked it 'destroyed') "/*X errors ignored*/"\n", __FUNCTION__, (int)wID);
//
////        WBSupressErrorOutput();
//        BEGIN_XCALL_DEBUG_WRAPPER
//        XDestroyWindow(pDisplay, wID); // handler should clean up the rest
//                                       // NOTE:  this _CAN_ recurse in some cases
////        XFlush(pDisplay);
//        XSync(pDisplay, False);
//        END_XCALL_DEBUG_WRAPPER
////        WBAllowErrorOutput();
//      }
    }
    else if(!WB_IS_WINDOW_BEING_DESTROYED(*pEntry) && !WB_IS_WINDOW_DESTROYED(*pEntry))
    {
      WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Window,
                     "WBDestroyWindow - wID %d (%08xH), destroying 'unmapped' window\n",
                     (int)wID, (int)wID);

      __InternalDestroyWindow(pDisplay, wID, pEntry); // may mark it 'DESTROYING' so recursion won't happen (see above)
    }
    // NOTE:  the above 'if' may preclude this next one from EVAR happening
    else if(!WB_TO_DELETE_WINDOW_ENTRY(*pEntry)) // has not called 'WBUnregisterWindowCallback'
    {
      WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Window,
                     "WBDestroyWindow - wID %d (%08xH), Marking 'unmapped' window 'destroyed'\n",
                     (int)wID, (int)wID);

      pEntry->iWindowState = WB_WINDOW_DESTROYED;  // initially, do this
    }

    __WBDelWindowEvents(pDisplay, wID);

    if(!WB_TO_DELETE_WINDOW_ENTRY(*pEntry)) // in case 'Destroy' notification didn't make this happen
    {
      WB_DEBUG_PRINT(DebugLevel_WARN | DebugSubSystem_Window,
                     "WARNING - %s - last ditch attempt, unregistering window callback for window %d\n", __FUNCTION__, (int)wID);
      WBUnregisterWindowCallback(wID);
    }
  }
}


// application callback registration

void WBRegisterAppCallback(WBAppEvent pCallback)
{
  pAppEventCallback = pCallback;
}

void WBUnregisterAppCallback()
{
  pAppEventCallback = NULL;
}


/**********************************************************************/
/*                                                                    */
/*                  window entry array processing                     */
/*                                                                    */
/**********************************************************************/


static __inline__ void InternalRestoreWindowDefaults(int iIndex)
{
  sWBHashEntries[iIndex].szClassName = NULL; // no class name, initially
  sWBHashEntries[iIndex].wParent = 0;  // mark it as "unassigned"
  sWBHashEntries[iIndex].idCursor = WB_DEFAULT_CURSOR;
  sWBHashEntries[iIndex].idDefaultCursor = WB_DEFAULT_CURSOR;
  sWBHashEntries[iIndex].iWaitCursorCount = 0;
  sWBHashEntries[iIndex].curRecent = None;
  bzero(&(sWBHashEntries[iIndex].geomAbsolute), sizeof(sWBHashEntries[iIndex].geomAbsolute));
  sWBHashEntries[iIndex].rgnClip = 0;
  sWBHashEntries[iIndex].rgnPaint = 0;

  sWBHashEntries[iIndex].iModalFlag = 0;
  sWBHashEntries[iIndex].iModalReturn = -1;

  sWBHashEntries[iIndex].width = sWBHashEntries[iIndex].height
    = sWBHashEntries[iIndex].border = 0; // make sure these are zero as well (indicates 'not yet visible')


  // this is primarily for when I unregister the callback (I must also unregister the menu)
  sWBHashEntries[iIndex].wIDMenu = 0;
  sWBHashEntries[iIndex].pMenuCallback = 0;
  sWBHashEntries[iIndex].iWindowState = WB_WINDOW_UNMAPPED;

  sWBHashEntries[iIndex].eWindowType = WMPropertiesWindowType_Normal;  // TODO: notify window manager?
  sWBHashEntries[iIndex].eWMProtocols = WMPropertiesWMProtocols_None;  // TODO: notify window manager?

  // zero out the window data (TODO: zero out everything?)
  bzero(sWBHashEntries[iIndex].aWindowData, sizeof(sWBHashEntries[iIndex].aWindowData));
}

//static /*__inline*/ WBWindow WBWindowFromWindow(Window wID)
//{
//  return (WBWindow)((unsigned long long)wID | WBWINDOW_FLAGS_NORMAL);
//}

//static /*__inline*/ Window WBWindowToWindow(WBWindow wID)
//{
//  return (Window)(wID & WBWINDOW_MASK);
//}


// WBGetWindowEntry - the debug version indicates what the caller's line number and function are

#ifdef NO_DEBUG
static /*__inline__*/ _WINDOW_ENTRY_ *WBGetWindowEntry(Window wID)
#else
#define WBGetWindowEntry(X) Debug_WBGetWindowEntry(X, __FUNCTION__, __LINE__)
static /*__inline__*/ _WINDOW_ENTRY_ *Debug_WBGetWindowEntry(Window wID, const char *szFunction, int nLine)
#endif // NO_DEBUG
{
  int i1, iStart;

  if(!nWBHashEntries)
  {
#ifndef NO_DEBUG
    WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Window,
                   "%s:%d - Window hash table empty, %d (%08xH) not found\n",
                   szFunction, nLine, (int)wID, (int)wID);
#endif // NO_DEBUG
    return(NULL);
  }

  i1 = iStart = WINDOW_ENTRY_HASH(wID);

  while(sWBHashEntries[i1].wID)  // this must be assigned to zero for this to work properly
  {
    if(sWBHashEntries[i1].wID == wID)
    {
      gettimeofday(&(sWBHashEntries[i1].tvLastActivity), NULL);
      return(sWBHashEntries + i1);
    }

    i1++;
    i1 &= WINDOW_ENTRY_ARRAY_MAX;

    if(i1 == iStart)
      break;
  }

#ifndef NO_DEBUG
    WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Window,
                   "%s:%d - Window ID %d (%08xH) not found\n",
                   szFunction, nLine, (int)wID, (int)wID);
#endif // NO_DEBUG

  return(NULL);
}

// window callback registration - this also adds a window entry if one does
// not already exist for the specified window ID.  This function assumes
// that the window's display is the default display.

static _WINDOW_ENTRY_ *__AddOrLocateEntry(Window wID)
{
register int i1, i2, iStart;
_WINDOW_ENTRY_ *pRval = NULL;


  i2 = -1;  // 'unused' entry marker
  i1 = WINDOW_ENTRY_HASH(wID);

  if(!nWBHashEntries)
  {
    WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Window,
                   "__AddOrLocateEntry - zero out window hash/array since it's empty\n");
    bzero(sWBHashEntries, sizeof(sWBHashEntries));
  }
  else
  {
    // keep track of the one I start with as 'iStart'

    iStart = i1;

    while(sWBHashEntries[i1].wID)  // the array must be pre-assigned to zero for this to work properly
    {
      if(sWBHashEntries[i1].wID == wID)
      {
        pRval = sWBHashEntries + i1;
        break;
      }

      if(sWBHashEntries[i1].wID == WINDOW_ENTRY_UNUSED)
      {
        i2 = i1;  // keep track of the 1st unused entry in the chain
      }

      i1++;
      i1 &= WINDOW_ENTRY_ARRAY_MAX;

      if(i1 == iStart)
      {
        i1 = -1;  // error flag (hash table full)
        break;
      }
    }
  }

  // if pRval is NULL, I need to add the entry
  // in that case, either i2 or i1 points to it.
  // if both i1 and i2 are negative, it's an error
  // The number of active entries is limited to 3/4
  // of the hash table size for speed and efficiency.

  if(!pRval)
  {
    if(i1 < 0 && i2 < 0)
      return NULL;

    // --------------------------
    // HASH TABLE SIZE LIMITATION
    // --------------------------

    // if 4 times the # of entries is larger than 3 times the # of hash entries,
    // then the hash is 3/4 full and grossly inefficient.  This is my limit.

    if((nWBHashEntries * 4) > (3 * sizeof(sWBHashEntries)/sizeof(sWBHashEntries[0]))) // an efficient algorithm
      return NULL;  // enforce hash table twice maximum

    nWBHashEntries++;  // keep track

    if(i2 >= 0)
      i1 = i2;

    pRval = sWBHashEntries + i1;
    pRval->wID = wID;  // mark it "mine"
    pRval->pDisplay = pDefaultDisplay;  // for now - TODO get the real display
    pRval->pImage = NULL;               // pre-assign the cached image to NULL

    InternalRestoreWindowDefaults(i1);

    WBRestoreDefaultCursor(wID);  // assign the default cursor for a new entry
  }

  if(pRval)
  {
    gettimeofday(&(pRval->tvLastActivity), NULL);
  }

  return pRval;
}

static void __WindowEntryRestoreDefaultResources(int iIndex)
{
  Display *pDisp = pDefaultDisplay;

  if(sWBHashEntries[iIndex].pDisplay)
  {
    pDisp = sWBHashEntries[iIndex].pDisplay;
  }

  BEGIN_XCALL_DEBUG_WRAPPER
//  if(sWBHashEntries[iIndex].fontSet != None && sWBHashEntries[iIndex].fontSet != fontsetDefault)  // must delete it
//  {
//    XFreeFontSet(pDisp, sWBHashEntries[iIndex].fontSet);
//    sWBHashEntries[iIndex].fontSet = None;
//  }
//  if(sWBHashEntries[iIndex].pFontStruct && sWBHashEntries[iIndex].pFontStruct != pDefaultFont)  // must delete it
//  {
//    XFreeFont(pDisp, sWBHashEntries[iIndex].pFontStruct);
//    sWBHashEntries[iIndex].pFontStruct = NULL;
//  }
  if(sWBHashEntries[iIndex].pFont && sWBHashEntries[iIndex].pFont != pDefaultFont)  // must delete it
  {
    WBFreeFont(pDisp, sWBHashEntries[iIndex].pFont);
    sWBHashEntries[iIndex].pFont = NULL;
  }
  if(sWBHashEntries[iIndex].pxIcon)
  {
    XFreePixmap(pDisp, sWBHashEntries[iIndex].pxIcon);
    sWBHashEntries[iIndex].pxIcon = 0;
  }
  if(sWBHashEntries[iIndex].pxMask)
  {
    XFreePixmap(pDisp, sWBHashEntries[iIndex].pxMask);
    sWBHashEntries[iIndex].pxMask = 0;
  }
  if(sWBHashEntries[iIndex].pWMHints)
  {
    XFree(sWBHashEntries[iIndex].pWMHints);
    sWBHashEntries[iIndex].pWMHints = NULL;
  }
  if(sWBHashEntries[iIndex].curRecent != None)
  {
    XFreeCursor(pDisp, sWBHashEntries[iIndex].curRecent);
    sWBHashEntries[iIndex].curRecent = None;
  }
  if(sWBHashEntries[iIndex].rgnClip != 0)
  {
    XDestroyRegion(sWBHashEntries[iIndex].rgnClip);
    sWBHashEntries[iIndex].rgnClip = 0;
  }
  if(sWBHashEntries[iIndex].rgnPaint != 0)
  {
    WB_WARN_PRINT("WARNING:  paint region non-zero in __WindowEntryRestoreDefaultResources\n");
    XDestroyRegion(sWBHashEntries[iIndex].rgnPaint);
    sWBHashEntries[iIndex].rgnPaint = 0;
  }
  if(sWBHashEntries[iIndex].pImage != NULL)
  {
    XDestroyImage(sWBHashEntries[iIndex].pImage);
    sWBHashEntries[iIndex].pImage = NULL;
  }
  END_XCALL_DEBUG_WRAPPER

}

static void __WindowEntryDestructor(int iIndex)
{
int iPrev, iNext;

  __WindowEntryRestoreDefaultResources(iIndex);  // make sure no resources are allocated

  sWBHashEntries[iIndex].pCallback = 0;
  sWBHashEntries[iIndex].pDisplay = NULL;  // must happen AFTER restoring default resources

  // restore these and additional default values
  InternalRestoreWindowDefaults(iIndex);

  //////////////////////////////////////////////////////////////////////////////////////////////
  //   _   _           _       _____     _     _         ____ _                               //
  //  | | | | __ _ ___| |__   |_   _|_ _| |__ | | ___   / ___| | ___  __ _ _ __  _   _ _ __   //
  //  | |_| |/ _` / __| '_ \    | |/ _` | '_ \| |/ _ \ | |   | |/ _ \/ _` | '_ \| | | | '_ \  //
  //  |  _  | (_| \__ \ | | |   | | (_| | |_) | |  __/ | |___| |  __/ (_| | | | | |_| | |_) | //
  //  |_| |_|\__,_|___/_| |_|   |_|\__,_|_.__/|_|\___|  \____|_|\___|\__,_|_| |_|\__,_| .__/  //
  //                                                                                  |_|     //
  //////////////////////////////////////////////////////////////////////////////////////////////

  // NOW, I have to 'zero out' or mark the entry 'unused'.  To do this I
  // have to define what an unused window ID is ('WINDOW_ENTRY_UNUSED').
  // (this MUST happen or the hash table won't work)
  // there are a couple of cases where deleting an entry might break a 'chain'
  // As a result I need to ensure that I make use of 'unused' markers and only
  // remove them when the final entry in the chain is followed by a 'NULL'.
  //
  // Preceding entries that aren't 'NULL' indicate I am part of a 'chain' and
  // so I can't mark it 'NULL' if this entry isn't the last entry in the 'chain'
  // or the 'chain' breaks.  Therefore it will be marked 'unused'.

  iPrev = (iIndex - 1) & WINDOW_ENTRY_ARRAY_MAX;
  iNext = (iIndex + 1) & WINDOW_ENTRY_ARRAY_MAX;

  if(!sWBHashEntries[iNext].wID) // next isn't NULL so I'm the end of the chain
  {
    sWBHashEntries[iIndex].wID = 0;  // it's safe to do this now

    for(iIndex=iPrev; iIndex != iNext && sWBHashEntries[iIndex].wID == WINDOW_ENTRY_UNUSED;
        iIndex = (iIndex - 1) & WINDOW_ENTRY_ARRAY_MAX) // roundie roundie
    {
      sWBHashEntries[iIndex].wID = 0;  // zero out back up the chain until I hit something that's not 'unused'
    }
  }
  else
  {
    if(!sWBHashEntries[iPrev].wID)  // previous is NULL
    {
      // I'm not a chain.  I can mark this zero
      sWBHashEntries[iIndex].wID = 0;  // just zero it out (the normal case)
    }
    else
    {
      sWBHashEntries[iIndex].wID = WINDOW_ENTRY_UNUSED;  // mark this as "unused" but not the end of a chain
    }
  }

  nWBHashEntries--;
}

static void __PeriodicWindowEntryCleanup(void)
{
int i1;
struct timeval tvNow;
static struct timeval tvLastTime = {0,0};

  gettimeofday(&tvNow, NULL);

  if(tvNow.tv_sec == tvLastTime.tv_sec)
  {
    return;  // so I don't do this too often - only once per second
  }

  tvLastTime.tv_sec = tvNow.tv_sec;

  tvNow.tv_sec -= WB_WINDOW_DELETE_TIMEOUT;

  // for each remaining window in my list, destroy it
  // TODO:  a more intelligent way to do this.  Currently it loops 2048 times
  //        and this is NOT efficient.  however, at 1Ghz, 2048 loops should easily
  //        be less than 1 msec (maybe 10 to 20 cycles per loop on average).
  for(i1=WINDOW_ENTRY_ARRAY_MAX - 1; i1 >= 0; i1--)
  {
    Window wID = sWBHashEntries[i1].wID;

    if(!wID || wID == WINDOW_ENTRY_UNUSED)
    {
      continue;
    }

    if(sWBHashEntries[i1].iWindowState == WB_WINDOW_DELETE &&
       sWBHashEntries[i1].tvLastActivity.tv_sec < tvNow.tv_sec) // aged enough?
    {
      WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Window,
                     "%s - destroying entry %d for window %u (%08xH)\n",
                     __FUNCTION__, i1,
                     (int)sWBHashEntries[i1].wID, (int)sWBHashEntries[i1].wID);


//      WB_ERROR_PRINT("TEMPORARY:  %s - delete window entry %d for window %u (%08xH)\n",
//                     __FUNCTION__, i1,
//                     (int)sWBHashEntries[i1].wID, (int)sWBHashEntries[i1].wID);

//      __WindowEntryRestoreDefaultResources(i1);  // make sure no resources are allocated - actually next function does this already
      __WindowEntryDestructor(i1); // finalizes destruction and marks it 'unused'
    }
  }
}

Window WBCreateWindow(Display *pDisplay, Window wIDParent,
                      WBWinEvent pProc, const char *szClass,
                      int iX, int iY, int iWidth, int iHeight, int iBorder, int iIO,
                      WB_UINT64 iFlags, XSetWindowAttributes *pXSWA)
{
Window idRval;
_WINDOW_ENTRY_ *pEntry;
WB_GEOM geom;
unsigned long valuemask;
XSetWindowAttributes xswa;


  if(!pDisplay)
  {
    pDisplay = WBGetDefaultDisplay();

    if(!pDisplay) // in case the library wasn't initialized
    {
      return None;
    }
  }

// POOBAH
#ifdef HAS_WB_UINT64_BUILTIN
  valuemask = (unsigned long)(iFlags & 0xffffffffL);
#else // HAS_WB_UINT64_BUILTIN
  valuemask = iFlags.dw2; // assume low endian (for now)
#endif // HAS_WB_UINT64_BUILTIN

  if(!valuemask)
  {
    valuemask = CWBorderPixel | CWBackPixel | CWColormap | CWBitGravity;  // for now...
    if(!pXSWA)
    {
      pXSWA = &xswa;

      WBInitWindowAttributes(&xswa,
                             BlackPixel(pDisplay, DefaultScreen(pDisplay)),
                             WhitePixel(pDisplay, DefaultScreen(pDisplay)),
                             DefaultColormap(pDisplay, DefaultScreen(pDisplay)),
                             CenterGravity);
    }
  }

  idRval = XCreateWindow(pDisplay,
                         wIDParent != None ? wIDParent : DefaultRootWindow(pDisplay),
                         iX, iY, iWidth, iHeight, iBorder,
                         DefaultDepth(pDisplay, DefaultScreen(pDisplay)),
                         iIO,
                         DefaultVisual(pDisplay, DefaultScreen(pDisplay)),
                         valuemask,
                         pXSWA);

  if(idRval != None)
  {
    WBRegisterWindowCallback(idRval, pProc); // this must happen first (it creates the internal structures)
    WBSetWindowClassName(idRval, szClass);

    if(wIDParent != None)
    {
      WBSetParentWindow(idRval, wIDParent);  // assign the cached copy of the window's parent
    }

    pEntry = WBGetWindowEntry(idRval);

    if(!pEntry)
    {
      WB_ERROR_PRINT("ERROR:  %s - unable to get window entry (window still created)\n", __FUNCTION__);
    }
    else
    {
      pEntry->iFlags = iFlags;     // cache it
      pEntry->pDisplay = pDisplay; // make sure

      if(!pEntry->pWMHints) // normally THIS WILL BE THE CASE
      {
        // if no window hints were configured, set some up

        if(!__internal_alloc_WMHints(pEntry))
        {
          BEGIN_XCALL_DEBUG_WRAPPER
          XSetWMHints(pDisplay, idRval, pEntry->pWMHints);
          END_XCALL_DEBUG_WRAPPER
        }
      }

      geom.x = 0; // client area always begins at 0,0
      geom.y = 0;
      geom.width = iWidth;
      geom.height = iHeight;
      geom.border = iBorder;

      WBInvalidateGeom(idRval, &geom, 0); // invalidate but don't paint yet
    }
  }

  return idRval;
}

void WBSetWMProperties(Window wID, const char *szTitle, XSizeHints *pNormalHints,
                       XWMHints *pWMHints, XClassHint *pClassHints)
{
_WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
Display *pDisplay = pEntry ? pEntry->pDisplay : pDefaultDisplay;
XTextProperty xTextProp;
//  XSetStandardProperties(pDisplay, pNew->wbFW.wID, szTitle, szTitle, None,
//                         NULL, 0, NULL); // argv, argc, &xsh);
//      // this has been superseded by XSetWMProperties() and should not be used any more

//       typedef struct {
//            unsigned char *value;/* property data */
//            Atom encoding;      /* type of property */
//            int format;         /* 8, 16, or 32 */
//            unsigned long nitems;/* number of items in value */
//       } XTextProperty;

  if(szTitle)
  {
    xTextProp.value = (void *)szTitle;
    xTextProp.encoding = XA_STRING;
    xTextProp.format = 8; // 8-bit bytes in this one
    xTextProp.nitems = strlen(szTitle);
  }

  if(pWMHints)
  {
    if(!pEntry->pWMHints)
    {
      // if no window hints were configured, set some up

      if(__internal_alloc_WMHints(pEntry))
      {
        // TODO:  error??
      }
    }

    if(pEntry->pWMHints)
    {
      // combine the hints!

      if(pWMHints->flags & InputHint)
      {
        pEntry->pWMHints->input = pWMHints->input;
        pEntry->pWMHints->flags |= InputHint;
      }

      if(pWMHints->flags & StateHint)
      {
        pEntry->pWMHints->initial_state = pWMHints->initial_state;
        pEntry->pWMHints->flags |= StateHint;
      }

      if(pWMHints->flags & IconPixmapHint)
      {
        BEGIN_XCALL_DEBUG_WRAPPER
        if(pEntry->pxIcon != None)
        {
          XFreePixmap(pDisplay, pEntry->pxIcon);
//          pEntry->pxIcon = None;
        }
        END_XCALL_DEBUG_WRAPPER

        pEntry->pxIcon = pWMHints->icon_pixmap;
        pEntry->pWMHints->icon_pixmap = pWMHints->icon_pixmap;
        pEntry->pWMHints->flags |= IconPixmapHint;
      }
      else if(pEntry->pxIcon != None &&
              (!(pEntry->pWMHints->flags & IconPixmapHint) || pEntry->pWMHints->icon_pixmap == None))
      {
        pEntry->pWMHints->icon_pixmap = pEntry->pxIcon;
        pEntry->pWMHints->flags |= IconPixmapHint;
      }

      if(pWMHints->flags & IconMaskHint)
      {
        BEGIN_XCALL_DEBUG_WRAPPER
        if(pEntry->pxMask != None) // this is where I keep track of it
        {
          XFreePixmap(pDisplay, pEntry->pxMask);
//          pEntry->pxMask = None;
        }
        END_XCALL_DEBUG_WRAPPER

        pEntry->pxMask = pWMHints->icon_mask;
        pEntry->pWMHints->icon_mask = pWMHints->icon_mask;
        pEntry->pWMHints->flags |= IconMaskHint;
      }
      else if(pEntry->pxMask != None &&
              (!(pEntry->pWMHints->flags & IconMaskHint) || pEntry->pWMHints->icon_mask == None))
      {
        pEntry->pWMHints->icon_mask = pEntry->pxMask;
        pEntry->pWMHints->flags |= IconMaskHint;
      }

      if(pWMHints->flags & IconWindowHint)
      {
        pEntry->pWMHints->icon_window = pWMHints->icon_window;
        pEntry->pWMHints->flags |= IconWindowHint;
      }

      if(pWMHints->flags & IconPositionHint)
      {
        pEntry->pWMHints->icon_x = pWMHints->icon_x;
        pEntry->pWMHints->icon_y = pWMHints->icon_y;
        pEntry->pWMHints->flags |= IconPositionHint;
      }

      if(pWMHints->flags & WindowGroupHint)
      {
        pEntry->pWMHints->window_group = pWMHints->window_group;
        pEntry->pWMHints->flags |= WindowGroupHint;
      }
    }
  }

  BEGIN_XCALL_DEBUG_WRAPPER
  if(szTitle)
  {
    XSetWMProperties(pDisplay, wID, &xTextProp, &xTextProp, NULL, 0,
                     pNormalHints,
                     pEntry->pWMHints ? pEntry->pWMHints : pWMHints,
                     pClassHints);
  }
  else
  {
    XSetWMProperties(pDisplay, wID, NULL, NULL, NULL, 0,
                     pNormalHints,
                     pEntry->pWMHints ? pEntry->pWMHints : pWMHints,
                     pClassHints);
  }
  END_XCALL_DEBUG_WRAPPER

  if(pWMHints)
  {
    if(pEntry->pWMHints)
    {
      XFree(pEntry->pWMHints);
    }

    BEGIN_XCALL_DEBUG_WRAPPER
    pEntry->pWMHints = XGetWMHints(pDisplay, wID);
    END_XCALL_DEBUG_WRAPPER
  }

//  void XSetWMProperties(Display *display, Window w,
//              XTextProperty *window_name, XTextProperty *icon_name,
//              char **argv, int argc,
//              XSizeHints *normal_hints, XWMHints *wm_hints,
//              XClassHint *class_hints);
}

void WBSetWindowTitle(Window wID, const char *szTitle)
{
_WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
Display *pDisplay = pEntry ? pEntry->pDisplay : pDefaultDisplay;
Atom a1, a2;


  a1 = XInternAtom(pDisplay, "WM_NAME", False); /* global scope, must use XInternAtom */
  a2 = XInternAtom(pDisplay, "WM_ICON_NAME", False); /* global scope, must use XInternAtom */

  if(a1 != None)
  {
    BEGIN_XCALL_DEBUG_WRAPPER
    XChangeProperty(pDisplay, wID, a1, XA_STRING, 8, PropModeReplace, (unsigned char *)szTitle, strlen(szTitle));
    END_XCALL_DEBUG_WRAPPER
  }

  if(a2 != None)
  {
    BEGIN_XCALL_DEBUG_WRAPPER
    XChangeProperty(pDisplay, wID, a2, XA_STRING, 8, PropModeReplace, (unsigned char *)szTitle, strlen(szTitle));
    END_XCALL_DEBUG_WRAPPER
  }
}

void WBRegisterWindowCallback(Window wID, WBWinEvent pCallback)
{
_WINDOW_ENTRY_ *pEntry = __AddOrLocateEntry(wID);

  if(pEntry)
  {
    int bNewEntry = 0;

    if(!pEntry->pCallback)
    {
      bNewEntry = 1;
    }

    pEntry->pCallback = pCallback;

    if(bNewEntry)
    {
      WBRestoreDefaultCursor(wID);  // assign the default cursor if this is a new entry
    }
  }
}

void WBUnregisterWindowCallback(Window wID)
{
  int i1, /*iPrev, iNext,*/ iStart;

  if(wID == wIDApplication)
  {
    wIDApplication = None; // application window being unregistered
  }

  if(!nWBHashEntries)
  {
    WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Window,
                   "%s - nWBHashEntries == NULL\n", __FUNCTION__);
    return;
  }

  i1 = iStart = WINDOW_ENTRY_HASH(wID);

  while(sWBHashEntries[i1].wID)  // the array must be pre-assigned to zero for this to work properly
  {
    if(sWBHashEntries[i1].wID == wID)
      break;

    i1++;
    i1 &= WINDOW_ENTRY_ARRAY_MAX;

    if(i1 == iStart)
    {
      i1 = -1;  // as a flag that I didn't find it
      break;
    }
  }

  // free resources, mark the 'last activity' time, and
  // mark this entry as "to be destroyed"

  // NOTE:  used to NOT actually change the callback address (TODO:  change name of function?)
  //        but in this case I'm going to NULL it.  I don't want window callbacks being called

  if(i1 >= 0 && sWBHashEntries[i1].wID == wID)  // guarantees I have the right one
  {
    // look through all of the timers and unregister any that involve this window
    // this is to avoid certain problems where windows aren't being notified properly

    DeletAllTimersForWindow(sWBHashEntries[i1].pDisplay, wID);

    if(sWBHashEntries[i1].iWindowState != WB_WINDOW_DELETE)
    {
      WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_Window,
                     "Entry %d for window %d (%08xH) marked as 'to be destroyed'\n",
                     i1, (int)wID, (int)wID);

//      __WindowEntryDestructor(i1);
      __WindowEntryRestoreDefaultResources(i1);  // make sure no resources are allocated

      gettimeofday(&(sWBHashEntries[i1].tvLastActivity), NULL);

      sWBHashEntries[i1].iWindowState = WB_WINDOW_DELETE;
    }

    sWBHashEntries[i1].pCallback = NULL; // no more callback function.  'DestroyNotify' may still happen.
    // for 'DestroyNotify' events following this, WBDispatch will deal with that.
  }

}

// this one is ONLY called before mapping the window
void WBSetWMPropertiesWindowType(Window wID, enum WMPropertiesWindowType wmProp)
{

  // TODO:  implement this
  // see _NET_WM_WINDOW_TYPE and _NET_WM_STATE atom documentation, wm-spec-latest.html

}

// this one is called AFTER mapping the window.  The 'root' window
// will have to be notified of the changes being made.
void WBChangeWMPropertiesWindowType(Window wID, enum WMPropertiesWindowType wmProp, enum WMPropertiesWindowType wmChangeMask)
{

  // TODO:  implement this
  // see _NET_WM_WINDOW_TYPE and _NET_WM_STATE atom documentation, wm-spec-latest.html

}

enum WMPropertiesWindowType WBGetWMPropertiesWindowType(Window wID)
{
_WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);


  if(!pEntry)
  {
    return WMPropertiesWindowType_Normal;
  }

  return pEntry->eWindowType;
}

// this is a MUCH nicer way of handling variable length lists of WM_PROTOCOL atoms, as far as
// the code's appearance goes.  A bit of extra work, but you don't do this very often
void WBSetWMProtocols(Window wID, Atom aProperty, ...)
{
va_list va, va2;
Atom *pTemp, aArg;
int i1, nItems;
Display *pDisplay;
Atom aTemp[32]; // temp storage, in case I need "something"
_WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);


  pTemp = aTemp;

  pDisplay = WBGetWindowDisplay(wID);

  if(!pDisplay)
  {
    WB_ERROR_PRINT("ERROR - %s - no Display pointer\n", __FUNCTION__);
    return;
  }

  if(aProperty == None)
  {
    WB_ERROR_PRINT("TEMPORARY:  %s - removing WM PROTOCOLS atom list\n", __FUNCTION__);

    BEGIN_XCALL_DEBUG_WRAPPER
    XSetWMProtocols(pDisplay, wID, pTemp, 0);
    END_XCALL_DEBUG_WRAPPER

    return;
  }

  va_start(va, aProperty);

  // copy the va_list so I can count items and possibly allocate memory
  va_copy(va2, va);
  nItems = 1; // always at least one if the first isn't "None"

  while(1)
  {
    aArg = va_arg(va2, Atom);

    if(aArg == None)
    {
      break;
    }

    nItems++;
  }

  va_end(va2); // cleanup

  // using the # of items I count here, determine if my array size is sufficient
  // and WBAlloc() a bigger one if needed.  or not.

  if(nItems >= sizeof(aTemp)/sizeof(aTemp[0]))
  {
    pTemp = (Atom *)WBAlloc((nItems + 1) * sizeof(Atom));

    if(!pTemp)
    {
      WB_ERROR_PRINT("ERROR - %s - not enough memory for atom list, errno=%d (%xH)\n", __FUNCTION__, errno, errno);
      return;
    }
  }

  pTemp[0] = aProperty;

  for(i1=1; i1 < nItems; i1++)
  {
    aArg = va_arg(va, Atom);

    // TODO:  debug, check value?

    pTemp[i1] = aArg;
  }

  pTemp[nItems] = None;  // end with 'none'

  va_end(va); // cleanup

  // next, scan the list for properties that require special flags

  if(pEntry) // only if I have a window entry
  {
    pEntry->eWMProtocols &= ~WMPropertiesWMProtocols_Mask;

    for(i1=0; i1 < nItems; i1++)
    {
      if(pTemp[i1] == aWM_DELETE_WINDOW) // this window supports WM_DELETE
      {
        pEntry->eWMProtocols |= WMPropertiesWMProtocols_DeleteWindow;
      }

      // TODO, others
    }
  }

  // NOW, do the deed. and assign the atoms to WM_PROTOCOLS

  BEGIN_XCALL_DEBUG_WRAPPER
  XSetWMProtocols(pDisplay, wID, pTemp, nItems);
  END_XCALL_DEBUG_WRAPPER


  if(pTemp != aTemp) // if I allocated the buffer
  {
    WBFree(pTemp);
  }

}


Window WBLocateWindow(WBLocateWindowCallback callback, void *pData)
{
int i1, i2;

  if(!callback)
  {
    return (Window)0;
  }

  for(i1=0; i1 <= WINDOW_ENTRY_ARRAY_MAX; i1++)
  {
    Window wID = sWBHashEntries[i1].wID;
    if(wID && wID != WINDOW_ENTRY_UNUSED)
    {
      i2 = callback(wID, pData);
      if(i2 > 0)
      {
        return wID;
      }
      else if(i2 < 0)
      {
        return 0;
      }
    }
  }

  return 0;
}


// locate and return the application window.  there can be only one.

Window WBGetApplicationWindow(void)
{
  return wIDApplication;
}

void WBSetApplicationWindow(Window wID)
{
_WINDOW_ENTRY_ *pEntry;

  if(wID == None)
  {
    wIDApplication = None;
  }
  else
  {
    pEntry = WBGetWindowEntry(wID);

    if(!pEntry)
    {
      wIDApplication = None;
    }
    else
    {
      wIDApplication = wID;
    }
  }
}


/**********************************************************************/
/*                                                                    */
/*        periodic timer and delayed event helper functions           */
/*                                                                    */
/**********************************************************************/

//#define TIMER_ARRAY_SIZE  512
//
//static struct s_TIMER_ENTRY
//{
//  struct s_TIMER_ENTRY *pNext; // linked lists for performance
//  unsigned long long lTimeIndex; // time index for which this timer next expires
//  unsigned long lTimeInterval;   // interval (or zero for one-shot timer)
//
//  Display *pDisplay;             // display associated with timer
//  Window wID;                    // window to receive timer event
//  long lID;                      // timer identifier
//} TIMER_ENTRY;
//
//static TIMER_ENTRY axWBTimer[TIMER_ARRAY_SIZE];
//static TIMER_ENTRY *pTimerEntryActive = NULL, *pTimerEntryFree = NULL;
//  // pointers for two linked lists.  entries must be in either 'active' or 'free' list.

int CreateTimer(Display *pDisplay, Window wID, unsigned long lInterval, long lID, int iPeriodic)
{
int i1;
TIMER_ENTRY *pCur;
// if timer linked lists aren't set up yet, do that now


  if(!pTimerEntryActive && !pTimerEntryFree) // initial state
  {
    bzero(axWBTimer, sizeof(axWBTimer));

    for(i1=1; i1 < TIMER_ARRAY_SIZE; i1++)
    {
      axWBTimer[i1 - 1].pNext = axWBTimer + i1; // build linked list
    }

    pTimerEntryFree = axWBTimer;
  }

  // search for match, return -2 if found
  pCur = pTimerEntryActive;
  while(pCur)
  {
    if(pCur->pDisplay == pDisplay &&
       pCur->wID == wID &&
       pCur->lID == lID)
    {
      return -2;
    }

    pCur = pCur->pNext;
  }

  if(!pTimerEntryFree)
  {
    return -1; // no memory
  }

  pCur = pTimerEntryFree;
  pTimerEntryFree = pTimerEntryFree->pNext;
//  pCur->pNext = NULL;  // TODO in case I have to add locking later

  pCur->pDisplay = pDisplay;
  pCur->wID = wID;
  pCur->lID = lID;

  pCur->lTimeIndex = WBGetTimeIndex() + lInterval;
  if(iPeriodic)
  {
    pCur->lTimeInterval = lInterval;
  }
  else
  {
    pCur->lTimeInterval = 0;
  }

  pCur->pNext = pTimerEntryActive; // goes at the beginning of the list (it's easier)
  pTimerEntryActive = pCur;

  return 0;
}

static void __DeleteTimer(TIMER_ENTRY *pPrev, TIMER_ENTRY *pEntry)
{
  pEntry->lTimeIndex = pEntry->lTimeInterval = 0;
  pEntry->pDisplay = NULL;
  pEntry->wID = 0;
  pEntry->lID = 0;

  if(!pPrev) // assume head of linked list
  {
    if(pTimerEntryActive != pEntry) // sanity checks
    {
      // a leak is better than a crash
      WB_ERROR_PRINT("%s - (1) unable to properly delete timer due to pointer inconsistency %p %p %p\n",
                     __FUNCTION__, pTimerEntryActive, pEntry, pEntry->pNext);
    }
    else
    {
      pTimerEntryActive = pEntry->pNext;
      pEntry->pNext = pTimerEntryFree;
      pTimerEntryFree = pEntry;
    }
  }
  else if(pPrev->pNext == pEntry) // more sanity checks
  {
    pPrev->pNext = pEntry->pNext;
    pEntry->pNext = pTimerEntryFree;
    pTimerEntryFree = pEntry;
  }
  else
  {
      WB_ERROR_PRINT("%s - (2) unable to properly delete timer due to pointer inconsistency %p %p %p %p\n",
                     __FUNCTION__, pPrev, pPrev->pNext, pEntry, pEntry->pNext);
  }
}

void DeleteTimer(Display *pDisplay, Window wID, long lID)
{
TIMER_ENTRY *pCur, *pPrev;

  pCur = pTimerEntryActive;
  pPrev = NULL;

  while(pCur)
  {
    if(pCur->pDisplay == pDisplay &&
       pCur->wID == wID &&
       pCur->lID == lID)
    {
      __DeleteTimer(pPrev, pCur);
      return;
    }

    pPrev = pCur;
    pCur = pCur->pNext;
  }
}

static void DeletAllTimersForWindow(Display *pDisplay, Window wID)
{
TIMER_ENTRY *pCur, *pPrev, *pNext;

  pCur = pTimerEntryActive;
  pPrev = NULL;

  while(pCur)
  {
    if(pCur->pDisplay == pDisplay &&
       pCur->wID == wID)
    {
      pNext = pCur->pNext;

      __DeleteTimer(pPrev, pCur);

      pCur = pNext; // must do it THIS way if I remove the entry in between
                    // note:  'pPrev' doesn't change, but 'pNext' does (pPrev->pNext should equal pCur now)
    }
    else
    {
      pPrev = pCur;
      pCur = pCur->pNext;
    }
  }
}

static int __CheckTimers(Display *pDisplay, XEvent *pEvent)
{
TIMER_ENTRY *pCur, *pPrev;
WB_UINT64 lTime = WBGetTimeIndex();

// Find the _NEXT_ registered timer for which the current time 'crosses'

  pCur = pTimerEntryActive;
  pPrev = NULL;

  while(pCur)
  {
    if(pCur->pDisplay == pDisplay &&
       lTime >= pCur->lTimeIndex) // time index has crossed "the threshold" for the timer
    {
      if(!pEvent)
      {
        return 1; // only indicate that I found a timer that's active (don't process it)
      }

      if(pCur->lTimeInterval)
      {
        pCur->lTimeIndex += pCur->lTimeInterval;

        if(lTime >= pCur->lTimeIndex) // to prevent 'spinning'
        {
          pCur->lTimeIndex = lTime + pCur->lTimeInterval;
        }
      }
      else
      {
        __DeleteTimer(pPrev, pCur);
      }

      // now fill out the event structure pointed to by 'pEvent'
      bzero(pEvent, sizeof(*pEvent));

      pEvent->xclient.type = ClientMessage;
      pEvent->xclient.serial = 0;
      pEvent->xclient.send_event = 0;
      pEvent->xclient.display = pDisplay;
      pEvent->xclient.window = pCur->wID;
      pEvent->xclient.message_type = aWB_TIMER;
      pEvent->xclient.format=32;  // 32-bit integers
      pEvent->xclient.data.l[0] = pCur->lID;

      return 1; // found/processed a timer
    }

    pPrev = pCur;
    pCur = pCur->pNext;
  }

  return 0;  // no timer found/processed
}

static void __CreateDelayedEvent(XEvent *pEvent, unsigned int uiInterval)
{
int i1;
DELAYED_EVENT_ENTRY *pCur;
// if timer linked lists aren't set up yet, do that now


  if(!pDelayedEventEntryActive && !pDelayedEventEntryFree) // initial state
  {
    bzero(axWBDelayedEvent, sizeof(axWBDelayedEvent));

    for(i1=1; i1 < TIMER_ARRAY_SIZE; i1++)
    {
      axWBDelayedEvent[i1 - 1].pNext = axWBDelayedEvent + i1; // build linked list
    }

    pDelayedEventEntryFree = axWBDelayedEvent;
  }

  // search for match, return -2 if found
  pCur = pDelayedEventEntryFree;
  pDelayedEventEntryFree = pDelayedEventEntryFree->pNext;
//  pCur->pNext = NULL;  // TODO in case I have to add locking later

  memcpy(&(pCur->event), pEvent, sizeof(pCur->event));

  pCur->lTimeIndex = WBGetTimeIndex() + uiInterval;

  pCur->pNext = pDelayedEventEntryActive; // goes at the beginning of the list (it's easier)
  pDelayedEventEntryActive = pCur;
}

static void __DeleteDelayedEvent(DELAYED_EVENT_ENTRY *pPrev, DELAYED_EVENT_ENTRY *pEntry)
{
  pEntry->lTimeIndex = 0;
  bzero(&(pEntry->event), sizeof(pEntry->event));

  if(!pPrev) // assume head of linked list
  {
    if(pDelayedEventEntryActive != pEntry) // sanity checks
    {
      // a leak is better than a crash
      WB_ERROR_PRINT("%s - (1) unable to properly delete delayed event due to pointer inconsistency %p %p %p\n",
                     __FUNCTION__, pTimerEntryActive, pEntry, pEntry->pNext);
    }
    else
    {
      pDelayedEventEntryActive = pEntry->pNext;
      pEntry->pNext = pDelayedEventEntryFree;
      pDelayedEventEntryFree = pEntry;
    }
  }
  else if(pPrev->pNext == pEntry) // more sanity checks
  {
    pPrev->pNext = pEntry->pNext;
    pEntry->pNext = pDelayedEventEntryFree;
    pDelayedEventEntryFree = pEntry;
  }
  else
  {
    WB_ERROR_PRINT("%s - (2) unable to properly delete delayed event due to pointer inconsistency %p %p %p %p\n",
                   __FUNCTION__, pPrev, pPrev->pNext, pEntry, pEntry->pNext);
  }
}

static int __attribute__((noinline)) __CheckDelayedEvents(Display *pDisplay, XEvent *pEvent)
{
DELAYED_EVENT_ENTRY *pCur, *pPrev;
WB_UINT64 lTime = WBGetTimeIndex();

  // Find the _NEXT_ registered delayed event for which the current time 'crosses'

  pCur = pDelayedEventEntryActive;
  pPrev = NULL;

  while(pCur)
  {
    if((pCur->event.xany.display == pDisplay || pCur->event.xany.window == None) &&
       lTime >= pCur->lTimeIndex)
    {
      // fill out the event structure pointed to by 'pEvent'

      if(pCur->event.xany.window != None)
      {
        _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(pCur->event.xany.window);

        if(!pEntry || WB_IS_WINDOW_DESTROYED(*pEntry))
        {
          __DeleteDelayedEvent(pPrev, pCur);
          return 0; // none processed [code is easier this way]
        }
      }

      if(pEvent) // if NULL, I'm only looking to see if there IS one
      {
        memcpy(pEvent, &(pCur->event), sizeof(*pEvent));

        __DeleteDelayedEvent(pPrev, pCur);
      }

      return 1; // processed
    }

    pPrev = pCur;
    pCur = pCur->pNext;
  }

  return 0;  // no timer processed
}



/**********************************************************************/
/*                                                                    */
/*                  message loop helper functions                     */
/*                                                                    */
/**********************************************************************/

static Bool __WBCheckIfEventPredicate(Display *pDisplay, XEvent *pEvent, XPointer arg)
{
  if(pEvent && pEvent->type != Expose)
  {
    return TRUE;
  }
  else
  {
    return FALSE;
  }
}

static Bool __WBCheckIfEventPredicate0(Display *pDisplay, XEvent *pEvent, XPointer arg)
{
  if(pEvent &&
     (pEvent->type == SelectionNotify ||
      pEvent->type == SelectionClear ||
      pEvent->type == SelectionRequest))
  {
    return TRUE;
  }
  else
  {
    return FALSE;
  }
}

// WBCheckGetEvent - get next (prioritized) event, do translations

static int iMouseState = 0;           // artificial mouse state (global) for dbl-click and drag
static int iMouseModShiftCtrl = 0;    // Mod/Shift/Ctrl state for last mouse state
static int iMouseDragButtonState = 0; // mouse button bit-flags for last mouse state and auto-drag-cancel
static WB_UINT64 tmMouse;             // timeval for most recent processed mouse event
static Window wMouseCapture = None;
static int iMouseX = 0, iMouseY = 0;  // RAW x,y position from mouse message


enum
{
  MouseState_NONE = 0,
  MouseState_LCLICK = 1,
  MouseState_WAS_LCLICK,
  MouseState_LDRAG,      // 'drag' states imply mouse captured
  MouseState_RCLICK,
  MouseState_WAS_RCLICK,
  MouseState_RDRAG,
  MouseState_CCLICK,
  MouseState_WAS_CCLICK,
  MouseState_CDRAG
};

Time WBGetLastEventTime(void)
{
WB_UINT64 qwTick = WBGetTimeIndex();

  return tmDefaultDisplay + (qwTick - qwDefaultDisplayTick) / 1000;
}

int WBCheckGetEvent(Display *pDisplay, XEvent *pEvent)
{
  return __InternalCheckGetEvent(pDisplay, pEvent, None);  // no modal window implies "do certain things differently"
}

void WBWaitForEvent(Display *pDisplay)
{
int iTemp, iSleepPeriod;

  // First, see if I have any priority or other queued events

  iTemp = iWBQueuedEvent;

  // check internal queues first, if there's something there
  // these queues won't change without calling WBCheckGetEvent()

  iSleepPeriod = MIN_EVENT_LOOP_SLEEP_PERIOD; // the initial value

  while(WB_LIKELY(iTemp >= 0))
  {
    if(WB_LIKELY(axWBEvt[iTemp].pDisplay == pDisplay))
    {
      return; // found one
    }

    iTemp = axWBEvt[iTemp].iNext;
  }

  iTemp = iWBPaintEvent;

  while(iTemp >= 0)
  {
    if(WB_LIKELY(axWBEvt[iTemp].pDisplay == pDisplay))
    {
      return; // found one
    }

    iTemp = axWBEvt[iTemp].iNext;
  }

  while(!bQuitFlag) // forever, unless I quit
  {
    // check timers and internal event queues

    if(__CheckTimers(pDisplay, NULL))  // a timer is ready to create an event?
    {
      return;
    }

    if(__CheckDelayedEvents(pDisplay, NULL)) // delayed events
    {
      return;
    }

    if(XEventsQueued(pDisplay, QueuedAfterFlush)) // this appears to be the most efficient method to use
    {
      return; // I have events waiting!
    }

    // perform a variable delay, up to MAX_EVENT_LOOP_SLEEP_PERIOD, before checking again, so I don't 'spin'
    // we start with the min period, so we'll more effectively capture 'bunches' of events, which would be
    // typical for UI actions - this makes it appear 'snappier'.  But when no events happen, the sleep period
    // will increase until it hits 'MAX_EVENT_LOOP_SLEEP_PERIOD', which should be tweeked accordingly to get
    // minimum CPU usage while "idling" (and yet still respond to important things).

    WBDelay(iSleepPeriod);  // 100 microsecs (0.1 milliseconds) initially, grows over time

    if(iSleepPeriod < MAX_EVENT_LOOP_SLEEP_PERIOD) // up to 'MAX_EVENT_LOOP_SLEEP_PERIOD' microseconds
    {
      iSleepPeriod += (iSleepPeriod >> 2); // increase by 25%
    }
    else
    {
      iSleepPeriod = MAX_EVENT_LOOP_SLEEP_PERIOD; // the maximum
    }
  }
}

// "internal" version that allows me to do things different for modal loops
// it prioritizes events based on what type they are, to make UI response 'snappier'

int __InternalCheckGetEvent(Display *pDisplay, XEvent *pEvent, Window wIDModal)
{
int iRval = 0, iQueued;
int iFirstTime = 1;
//static unsigned long long ullLastTime = 0;

  do
  {
    BEGIN_XCALL_DEBUG_WRAPPER
    if(iFirstTime)
    {
      iQueued = XEventsQueued(pDisplay, QueuedAfterFlush); // QueuedAfterFlush on the first pass

      iFirstTime = 0; // assign it here so I only do this code section once
    }
    else
    {
      iQueued = XEventsQueued(pDisplay, QueuedAlready); // see if events are queued already (first, no flushing)
    }

    END_XCALL_DEBUG_WRAPPER

    // check for selection events first...

    BEGIN_XCALL_DEBUG_WRAPPER
    iRval = iQueued && // SelectionNotify, SelectionClear, SelectionRequest
            XCheckIfEvent(pDisplay, pEvent, __WBCheckIfEventPredicate0, NULL);
    END_XCALL_DEBUG_WRAPPER

    if(!iRval)
    {
      if(WB_UNLIKELY(0 != (iRval = __CheckDelayedEvents(pDisplay, pEvent)))) // delayed events first
      {
        break;
      }

      if(WB_UNLIKELY(0 != (iRval = __CheckTimers(pDisplay, pEvent))))  // then timers
      {
        break;
      }

      // then check for actual events in the X11 event queue

      BEGIN_XCALL_DEBUG_WRAPPER
      iRval = iQueued /*XEventsQueued(pDisplay, QueuedAlready)*/ &&
              (XCheckIfEvent(pDisplay, pEvent, __WBCheckIfEventPredicate, NULL) ||
               XCheckMaskEvent(pDisplay, ExposureMask, pEvent));
      END_XCALL_DEBUG_WRAPPER
    }

    if(iRval)
    {
      if(pDisplay == pDefaultDisplay) // for default display, grab the timestamp
      {
        Time tmEvent = 0;

        // for certain events I want to get the time of the event
        // and so I'll record that here

        switch(pEvent->type) // for the ones that have timestamps, I check for them
        {
          case KeyPress:
          case KeyRelease:
            tmEvent =((XKeyEvent *)pEvent)->time;
            break;
          case ButtonPress:
          case ButtonRelease:
            tmEvent =((XButtonEvent *)pEvent)->time;
            break;
          case MotionNotify:
            tmEvent =((XMotionEvent *)pEvent)->time;
            break;
          case EnterNotify:
          case LeaveNotify:
            tmEvent =((XCrossingEvent *)pEvent)->time;
            break;
          case PropertyNotify:
            tmEvent =((XPropertyEvent *)pEvent)->time;
            break;
          case SelectionRequest:
            tmEvent =((XSelectionRequestEvent *)pEvent)->time;
            break;
          case SelectionClear:
            tmEvent =((XSelectionClearEvent *)pEvent)->time;
            break;
          case SelectionNotify:
            tmEvent =((XSelectionEvent *)pEvent)->time;
            break;
        }

        if(tmEvent > tmDefaultDisplay)
        {
          tmDefaultDisplay = tmEvent;  // with the assumption that the millis here NEVER wrap around
          qwDefaultDisplayTick = WBGetTimeIndex(); // snap this too so I can adjust it
        }
      }

      if(pEvent->type == Expose)  // expose events get special handling
      {
        // EXPOSE EVENTS - some special handling

        WBProcessExposeEvent((XExposeEvent *)pEvent); // this consolidates incoming Expose events

        // after processing the expose event, use XSync to immediately sync back up
        // in case there are more events NOT received yet.  Only for EXPOSE though.

        BEGIN_XCALL_DEBUG_WRAPPER
        XFlush(pDisplay);      // send the events to the server (asynchronously)
//        XSync(pDisplay, 0);  // this way, I am waiting for the window painting to actually happen
        END_XCALL_DEBUG_WRAPPER

        iRval = 0;
        continue; // added - this might have been a bug...?
      }
      else if(pEvent->type == NoExpose) // pretend I never got this
      {
        iRval = 0;
        continue;  // act like it wasn't even there - try again
      }

      // TODO:  other events that might be part of the above list of events to grab first

      break;
    }
    else // no display events
    {
      // use XEventsQueued to see if I have events.  Use 'QueueAfterFlush' which appears to be the
      // most efficient way of doing this.

      if(XEventsQueued(pDisplay, QueuedAfterFlush) > 0)  // flushes and attempts to read more events into queue
      {
        continue;  // more events were read in, so loop back to the beginning
      }

      // regular 'next event' processing

      iRval = WBNextEvent(pDisplay, pEvent);  // get 'internal' queued events

      break;  // regardless if an event is found I break out now
    }

    // this conveniently re-tries when I get an Expose event (to try and consolidate them)


  } while(1);

  if(iRval)
  {
    if(pEvent->type == ConfigureNotify)
    {
      WB_GEOM gm;
      Window wIDTemp;
      // NOTE:  this could be done in WBWindowDispatch but the chance that
      //        it might be missed demands it be handled at a lower level

      _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(pEvent->xconfigure.window);

      if(pEntry) // notification needs to update internal 'absolute geometry' data
      {
        // NOTE:  window will get at least one of these when it becomes visible
        //        until then the values are initialized as zeros

        if(pEntry->geomAbsolute.width == 0 && // first time through, trust the message
           pEntry->geomAbsolute.height == 0)
        {
          pEntry->geomAbsolute.x = pEvent->xconfigure.x;
          pEntry->geomAbsolute.y = pEvent->xconfigure.y;
          pEntry->geomAbsolute.width = pEvent->xconfigure.width;
          pEntry->geomAbsolute.height = pEvent->xconfigure.height;
          pEntry->geomAbsolute.border = pEvent->xconfigure.border_width;

          // first time through, create clip region that's empty, and record the window's width/height info
          if(!pEntry->rgnClip)
          {
            // NOTE:  I must do it THIS way because the window isn't mapped yet.

            pEntry->width = pEvent->xconfigure.width;
            pEntry->height = pEvent->xconfigure.height;
            pEntry->border = pEvent->xconfigure.border_width;

            pEntry->rgnClip = XCreateRegion();
          }

          if(pEntry->rgnClip)
          {
            XRectangle xrct;

            xrct.x = 0;//(short)pEntry->x;
            xrct.y = 0;//(short)pEntry->y;
            xrct.width = (unsigned short)pEntry->width;
            xrct.height = (unsigned short)pEntry->height;

            XUnionRectWithRegion(&xrct, pEntry->rgnClip, pEntry->rgnClip); // clip region includes this, now
          }
        }
        else if(WB_IS_WINDOW_MAPPED(*pEntry)) // get values from parent window(s) and adjust absolute coords
        {                                     // NOTE:  this won't work if this OR the PARENT windows aren't mapped
          wIDTemp = pEvent->xconfigure.window;
          pEntry->geomAbsolute.x = pEntry->geomAbsolute.y = 0;

          while(wIDTemp)
          {
            WBGetWindowGeom(wIDTemp, &gm);
            pEntry->geomAbsolute.x += gm.x;
            pEntry->geomAbsolute.y += gm.y;

            if(wIDTemp == pEvent->xconfigure.window)
            {
              pEntry->geomAbsolute.width = gm.width;
              pEntry->geomAbsolute.height = gm.height;
              pEntry->geomAbsolute.border = gm.border;
            }

            wIDTemp = WBGetParentWindow(wIDTemp);
          }
        }
        else
        {
          WB_ERROR_PRINT("TEMPORARY:  %s - subsequent ConfigureNotify and window is not yet mapped\n", __FUNCTION__);
        }

        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Window,
                       "%s - update internal geometry %d (%08xH) %d, %d, %d, %d\n",
                       __FUNCTION__,
                       (int)pEvent->xconfigure.window, (int)pEvent->xconfigure.window,
                       pEntry->geomAbsolute.x, pEntry->geomAbsolute.y,
                       pEntry->geomAbsolute.width, pEntry->geomAbsolute.height);
      }
    }

    // MOUSE translations (double-click, drag help)
    // to use these, the client shouldn't handle the system mouse events
    // Additionally, behavior DIFFERS SIGNIFICANTLY when inside a modal loop

    if(pEvent->type == ButtonPress ||
       pEvent->type == ButtonRelease ||
       pEvent->type == MotionNotify)
    {
      int iButton1 = (((XButtonEvent *)pEvent)->state & Button1Mask)
                   || ((XButtonEvent *)pEvent)->button == Button1;
      int iButton2 = (((XButtonEvent *)pEvent)->state & Button2Mask)
                   || ((XButtonEvent *)pEvent)->button == Button2;
      int iButton3 = (((XButtonEvent *)pEvent)->state & Button3Mask)
                   || ((XButtonEvent *)pEvent)->button == Button3;
      int iButton4 = (((XButtonEvent *)pEvent)->state & Button4Mask)
                   || ((XButtonEvent *)pEvent)->button == Button4;
      int iButton5 = (((XButtonEvent *)pEvent)->state & Button5Mask)
                   || ((XButtonEvent *)pEvent)->button == Button5;

      int iDragButtonState = (iButton1 ? 1 : 0)  // mostly for dragging, but used in other places, too
                            | (iButton2 ? 2 : 0)
                            | (iButton3 ? 4 : 0);

      int iModShiftCtrl = ((XButtonEvent *)pEvent)->state & (ShiftMask | LockMask | ControlMask | Mod1Mask
                                                             | Mod2Mask | Mod3Mask | Mod4Mask | Mod5Mask);
      int iX, iY;

      if(pEvent->type == ButtonPress &&
         (iMouseState == MouseState_NONE ||
          iMouseState == MouseState_WAS_LCLICK))
      {
        Window wIDCurrent = None;
        int iRevert = 0;
        Window wID0 = ((XButtonEvent *)pEvent)->window;

        // NOTE:  if window does _NOT_ have input focus, make sure it gets the focus
        //        and re-display it's container in front of other windows (as needed)


        BEGIN_XCALL_DEBUG_WRAPPER
        XGetInputFocus(pDisplay, &wIDCurrent, &iRevert);
        END_XCALL_DEBUG_WRAPPER

//        WB_ERROR_PRINT("TEMPORARY:  mouse click %d, old window %d (%08xH), new window %d (%08xH)\n",
//                       iMouseState, (int)wIDCurrent, (int)wIDCurrent, (int)wID0, (int)wID0);

        if(wIDCurrent != wID0 &&
           ( wIDModal == None ||               // ok if NOT in modal state
             WBIsChildWindow(wIDModal, wID0))) // window I'm switching focus to is child of modal loop owner
        {
//          WBSetInputFocus(((XButtonEvent *)pEvent)->window);
          // TODO:  replicate part of 'set focus' code as private function to avoid duplication?


          _WINDOW_ENTRY_ *pPrev = WBGetWindowEntry(wIDCurrent);
          _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID0);

//          WB_ERROR_PRINT("TEMPORARY:  mouse click %d, old window %d (%08xH), new window %d (%08xH)\n",
//                         iMouseState, (int)wIDCurrent, (int)wIDCurrent, (int)wID0, (int)wID0);

          if(pPrev)
          {
            if(WB_CHECK_SET_FOCUS_ON_MAP(*pPrev))
            {
              WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Window,
                             "%s:%d - %d (%08xH) disabling focus change on map\n",
                             __FUNCTION__, __LINE__, (int)wIDCurrent, (int)wIDCurrent);

              pPrev->iWindowState = WB_WINDOW_UNMAPPED;  // remove 'set focus' state
            }
          }

          // see if expose event has been done on this yet...
          if(WB_LIKELY(pEntry) && //WB_UNLIKELY(!pEntry->width && !pEntry->height && !pEntry->border))
             WB_UNLIKELY(WB_IS_WINDOW_UNMAPPED(*pEntry)))
          {
            WB_DEBUG_PRINT(DebugLevel_WARN | DebugSubSystem_Window,
                           "%s:%d - %d (%08xH) not yet visible, enabling focus change on map\n",
                           __FUNCTION__, __LINE__, (int)wID0, (int)wID0);

            pEntry->iWindowState = WB_WINDOW_SET_FOCUS_ON_MAP;
          }
          else
          {
            WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Window,
                           "%s:%d - %d (%08xH) calling XSetInputFocus\n",
                           __FUNCTION__, __LINE__, (int)wID0, (int)wID0);

//            WB_ERROR_PRINT("TEMPORARY - %s calling XSetInputFocus on wID=%u (%08xH)\n", __FUNCTION__, (int)wID0, (uint32_t)wID0);

            BEGIN_XCALL_DEBUG_WRAPPER
            XSetInputFocus(pDisplay, wID0, RevertToParent, CurrentTime);
            END_XCALL_DEBUG_WRAPPER
          }

          iMouseState = MouseState_NONE; // if window focus changes, I don't want double clicking or dragging to happen
        }

        // TODO:  bring top level window forward if not topmost already
      }


      // based on current state
      switch(iMouseState)
      {
        case MouseState_WAS_LCLICK:

          if(pEvent->type == ButtonPress)
          {
            int iDblClickThresh = CHGetDoubleClickDistance(pDisplay);
            WB_UINT64 tmTemp = WBGetTimeIndex(); // snapshot the current time (microseconds)

            if(abs(iMouseX - ((XButtonEvent *)pEvent)->x) >= iDblClickThresh || // too far
               abs(iMouseY - ((XButtonEvent *)pEvent)->y) >= iDblClickThresh || // too far
               (tmTemp - tmMouse) > 1000 * CHGetDoubleClickTime(pDisplay))      // too slow
            {
              iMouseState = MouseState_NONE;

              // flow through to next section
            }
            else if(!iButton1 || iButton2 || iButton3)
            {
              iMouseState = MouseState_NONE;

              // flow through to next section
            }
            else
            {
              // post a double-click notification

              XClientMessageEvent evt = {
                                          .type=ClientMessage,
                                          .serial=0,
                                          .send_event=0,
                                          .display=pDisplay,
                                          .window=((XButtonEvent *)pEvent)->window,
                                          .message_type=aWB_POINTER,
                                          .format=32
                                        };

              evt.data.l[0] = WB_POINTER_DBLCLICK;
              evt.data.l[1] = iDragButtonState;
              evt.data.l[2] = (iModShiftCtrl & ShiftMask ? WB_KEYEVENT_SHIFT : 0)
                            | (iModShiftCtrl & ControlMask ? WB_KEYEVENT_CTRL : 0)
                            | (iModShiftCtrl & Mod1Mask ? WB_KEYEVENT_ALT : 0);

              WBXlatCoordPoint(((XButtonEvent *)pEvent)->window, ((XButtonEvent *)pEvent)->x, ((XButtonEvent *)pEvent)->y,
                               ((XButtonEvent *)pEvent)->window, &iX, &iY);

              evt.data.l[3] = iX;
              evt.data.l[4] = iY;

              WBPostPriorityEvent(((XButtonEvent *)pEvent)->window, (XEvent *)&evt);

              break;
            }
          }
          else if(pEvent->type == ButtonRelease)
          {
            iMouseState = MouseState_NONE;

            break;
          }
          else
          {
            // TODO:  mouse motion is OK, but what about anything else?

            break;
          }

          // at this poitn the state has been re-assigned

        case MouseState_NONE: // base condition - no current activity
          if(pEvent->type == ButtonPress)
          {
            // for now, post a 'CLICK' notification every time

            XClientMessageEvent evt = {
                                        .type=ClientMessage,
                                        .serial=0,
                                        .send_event=0,
                                        .display=pDisplay,
                                        .window=((XButtonEvent *)pEvent)->window,
                                        .message_type=aWB_POINTER,
                                        .format=32
                                      };

            evt.data.l[0] = WB_POINTER_CLICK;
            evt.data.l[1] = iDragButtonState
                          | (iButton4 ? 8 : 0)
                          | (iButton5 ? 16 : 0);
            evt.data.l[2] = (iModShiftCtrl & ShiftMask ? WB_KEYEVENT_SHIFT : 0)
                          | (iModShiftCtrl & ControlMask ? WB_KEYEVENT_CTRL : 0)
                          | (iModShiftCtrl & Mod1Mask ? WB_KEYEVENT_ALT : 0);

            WBXlatCoordPoint(((XButtonEvent *)pEvent)->window, ((XButtonEvent *)pEvent)->x, ((XButtonEvent *)pEvent)->y,
                             ((XButtonEvent *)pEvent)->window, &iX, &iY);

            evt.data.l[3] = iX;
            evt.data.l[4] = iY;

            WBPostPriorityEvent(((XButtonEvent *)pEvent)->window, (XEvent *)&evt);

//            WB_ERROR_PRINT("TEMPORARY:  mouse click at %d %d for %d (%08xH)  %d %d %d\n",
//                           iX, iY, (int)((XButtonEvent *)pEvent)->window, (int)((XButtonEvent *)pEvent)->window,
//                           iButton1, iButton2, iButton3);

            if(iButton1 && !iButton2 && !iButton3 && !iButton4 && !iButton5)
            {
              // left button - for now this is all I test for
              iMouseState = MouseState_LCLICK;
              iMouseModShiftCtrl = iModShiftCtrl;

              tmMouse = WBGetTimeIndex(); // snapshot the time (microseconds)

              iMouseX = ((XButtonEvent *)pEvent)->x;
              iMouseY = ((XButtonEvent *)pEvent)->y;
            }
            else if(iButton4 || iButton5)
            {
              // notify window of mouse wheel scrolling.  iButton4 is "scroll up", iButton5 is "scroll down"

              XClientMessageEvent evt = {
                                          .type=ClientMessage,
                                          .serial=0,
                                          .send_event=0,
                                          .display=pDisplay,
                                          .window=pEvent->xany.window,
                                          .message_type=aWB_POINTER,
                                          .format=32
                                        };

              if(iButton4)
              {
                evt.data.l[0] = WB_POINTER_SCROLLUP;
              }
              else
              {
                evt.data.l[0] = WB_POINTER_SCROLLDOWN;
              }

              evt.data.l[1] = iDragButtonState
                            | (iButton4 ? 8 : 0)
                            | (iButton5 ? 16 : 0);
              evt.data.l[2] = (iModShiftCtrl & ShiftMask ? WB_KEYEVENT_SHIFT : 0)
                            | (iModShiftCtrl & ControlMask ? WB_KEYEVENT_CTRL : 0)
                            | (iModShiftCtrl & Mod1Mask ? WB_KEYEVENT_ALT : 0);

              WBXlatCoordPoint(((XButtonEvent *)pEvent)->window, iMouseX, iMouseY,
                               ((XButtonEvent *)pEvent)->window, &iX, &iY);

              evt.data.l[3] = iX; // TODO:  should this be UN-TRANSLATED or SCREEN coordinates?
              evt.data.l[4] = iY; //        should I indicate WHICH WINDOW this should be for?

              WBWindowDispatch(evt.window, (XEvent *)&evt);
            }
          }
          else if(pEvent->type == ButtonRelease)
          {
//            if(iButton1 || iButton2 || iButton3 || iButton4 || iButton5)
//            {
//              WB_ERROR_PRINT("TEMPORARY:  %s button release, button state %d %d %d %d %d\n",
//                             __FUNCTION__, iButton1, iButton2, iButton3, iButton4, iButton5);
//            }
          }
          else // if(pEvent->type == MotionNotify)
          {
//            if(iButton1 || iButton2 || iButton3 || iButton4 || iButton5)
//            {
//              WB_ERROR_PRINT("TEMPORARY:  %s motion notify, button state %d %d %d %d %d\n",
//                             __FUNCTION__, iButton1, iButton2, iButton3, iButton4, iButton5);
//            }
          }

          break;

        case MouseState_LCLICK:

          if(pEvent->type == ButtonPress)
          {
            if(!iButton1 || iButton2 || iButton3)
            {
              // TODO:  MCLICK and RCLICK?
              iMouseState = MouseState_NONE;
            }
            else
            {
              // TODO:  is this a double-click?
            }
          }
          else if(pEvent->type == ButtonRelease)
          {
            iMouseState = MouseState_WAS_LCLICK;
          }
          else if(iMouseModShiftCtrl != iModShiftCtrl) // modifier state change
          {
            iMouseState = MouseState_NONE;
          }
          else
          {
            int iTemp, iDragThresh = CHGetDragThreshold(pDisplay);

            // DRAG DETECT (reserved)

            if(abs(iMouseX - ((XButtonEvent *)pEvent)->x) >= iDragThresh ||
               abs(iMouseY - ((XButtonEvent *)pEvent)->y) >= iDragThresh)
            {
              // check for entering drag state - window proc needs to respond correctly

              XClientMessageEvent evt = {
                                          .type=ClientMessage,
                                          .serial=0,
                                          .send_event=0,
                                          .display=pDisplay,
                                          .window=pEvent->xany.window,
                                          .message_type=aWB_POINTER,
                                          .format=32
                                        };

              evt.data.l[0] = WB_POINTER_DRAG;
              evt.data.l[1] = iDragButtonState
                            | (iButton4 ? 8 : 0)
                            | (iButton5 ? 16 : 0);
              evt.data.l[2] = (iModShiftCtrl & ShiftMask ? WB_KEYEVENT_SHIFT : 0)
                            | (iModShiftCtrl & ControlMask ? WB_KEYEVENT_CTRL : 0)
                            | (iModShiftCtrl & Mod1Mask ? WB_KEYEVENT_ALT : 0);

              iMouseDragButtonState = iDragButtonState;

              WBXlatCoordPoint(((XButtonEvent *)pEvent)->window, iMouseX, iMouseY,
                               ((XButtonEvent *)pEvent)->window, &iX, &iY);

              // NOTE:  sending ORIGINAL 'click' mouse coordinates since the drag moves the mouse
              evt.data.l[3] = iX; // TODO:  should this be UN-TRANSLATED or SCREEN coordinates?
              evt.data.l[4] = iY; //        should I indicate WHICH WINDOW this should be for?

              WBXlatCoordPoint(((XButtonEvent *)pEvent)->window, ((XButtonEvent *)pEvent)->x, ((XButtonEvent *)pEvent)->y,
                               ((XButtonEvent *)pEvent)->window, &iX, &iY);

              iTemp = WBWindowDispatch(evt.window, (XEvent *)&evt);
              if(iTemp == (int)evt.window) // must return window ID
              {
                iMouseState = MouseState_LDRAG;

                if(wMouseCapture == None)
                {
                  XGrabPointer(pDisplay, ((XButtonEvent *)pEvent)->window, 1,
                               ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | PointerMotionMask
                                | EnterWindowMask | LeaveWindowMask,
                               GrabModeAsync, // pointer mode
                               GrabModeAsync, // keyboard mode
                               None, None, CurrentTime);

                  wMouseCapture = ((XButtonEvent *)pEvent)->window;

                  // post a motion event to update pointer position
                  evt.data.l[0] = WB_POINTER_MOVE;
                  evt.data.l[3] = iX;
                  evt.data.l[4] = iY;

                  WBPostPriorityEvent(((XButtonEvent *)pEvent)->window, (XEvent *)&evt);

                  iMouseX = ((XButtonEvent *)pEvent)->x; // keep track of starting drag position
                  iMouseY = ((XButtonEvent *)pEvent)->y;

//                  WB_ERROR_PRINT("TEMPORARY:  %s:%d mouse drag begins: %d  %d,%d\n",
//                                 __FUNCTION__, __LINE__,
//                                 iButton1, iMouseX, iMouseY);
                }
//                else
//                {
//                  WB_ERROR_PRINT("TEMPORARY:  %s:%d mouse drag, but already captured: %d  %d,%d\n",
//                                 __FUNCTION__, __LINE__,
//                                 iButton1, iMouseX, iMouseY);
//                }
              }
              else
              {
//                WB_ERROR_PRINT("TEMPORARY:  %s:%d mouse drag NOT enabled.  %08xH %08xH\n",
//                               __FUNCTION__, __LINE__, iTemp, (int)evt.window);

                iMouseState = MouseState_NONE;  // TODO:  check for drag support first
              }
            }
          }

          break;

        case MouseState_LDRAG:
        case MouseState_RDRAG:
        case MouseState_CDRAG:

          if(pEvent->type == ButtonPress ||                // someone pressed a different mouse button
             iMouseDragButtonState != iDragButtonState ||  // button state has changed
             iMouseModShiftCtrl != iModShiftCtrl)          // modifier state change
          {
//            WB_ERROR_PRINT("TEMPORARY:  %s:%d mouse was dragging, now canceled\n", __FUNCTION__, __LINE__);

            WBMouseCancel(pDisplay, ((XButtonEvent *)pEvent)->window); // always call this
          }
          else if(pEvent->type == MotionNotify) // mods and buttons NOT changed
          {
            // modifiers still match (see above) so no need for cancelation here

            if(iButton1 && // for now rely on other code to cancel this if another button is pressed
               (iMouseX != ((XButtonEvent *)pEvent)->x ||
                iMouseY != ((XButtonEvent *)pEvent)->y))
            {
              XClientMessageEvent evt = {
                                          .type=ClientMessage,
                                          .serial=0,
                                          .send_event=0,
                                          .display=pDisplay,
                                          .window=((XButtonEvent *)pEvent)->window,
                                          .message_type=aWB_POINTER,
                                          .format=32
                                        };

//              WB_ERROR_PRINT("TEMPORARY:  %s:%d mouse drag motion\n", __FUNCTION__, __LINE__);

              evt.data.l[0] = WB_POINTER_MOVE;
              evt.data.l[1] = iDragButtonState
                            | (iButton4 ? 8 : 0)
                            | (iButton5 ? 16 : 0);
              evt.data.l[2] = (iModShiftCtrl & ShiftMask ? WB_KEYEVENT_SHIFT : 0)
                            | (iModShiftCtrl & ControlMask ? WB_KEYEVENT_CTRL : 0)
                            | (iModShiftCtrl & Mod1Mask ? WB_KEYEVENT_ALT : 0);

              WBXlatCoordPoint(((XButtonEvent *)pEvent)->window, ((XButtonEvent *)pEvent)->x, ((XButtonEvent *)pEvent)->y,
                               ((XButtonEvent *)pEvent)->window, &iX, &iY);

              evt.data.l[3] = iX; // TODO:  should this be UN-TRANSLATED or SCREEN coordinates?
              evt.data.l[4] = iY; //        should I indicate WHICH WINDOW this should be for?

              iMouseX = ((XButtonEvent *)pEvent)->x; // keep track of current drag position
              iMouseY = ((XButtonEvent *)pEvent)->y;

              WBPostPriorityEvent(((XButtonEvent *)pEvent)->window, (XEvent *)&evt);
            }
//            else
//            {
//              WB_ERROR_PRINT("TEMPORARY:  %s:%d mouse drag motion NOT handled: %d  %d,%d (%d,%d) \n",
//                             __FUNCTION__, __LINE__,
//                             iButton1, iMouseX, iMouseY, ((XButtonEvent *)pEvent)->x, ((XButtonEvent *)pEvent)->y);
//            }
          }
          else if(pEvent->type == ButtonRelease) // TODO:  check mouse button and key mask match
          {
            // handle drop event

            XClientMessageEvent evt = {
                                        .type=ClientMessage,
                                        .serial=0,
                                        .send_event=0,
                                        .display=pDisplay,
                                        .window=((XButtonEvent *)pEvent)->window,
                                        .message_type=aWB_POINTER,
                                        .format=32
                                      };

            evt.data.l[0] = WB_POINTER_DROP;
            evt.data.l[1] = iDragButtonState;
            evt.data.l[2] = (iModShiftCtrl & ShiftMask ? WB_KEYEVENT_SHIFT : 0)
                          | (iModShiftCtrl & ControlMask ? WB_KEYEVENT_CTRL : 0)
                          | (iModShiftCtrl & Mod1Mask ? WB_KEYEVENT_ALT : 0);

            WBXlatCoordPoint(((XButtonEvent *)pEvent)->window, ((XButtonEvent *)pEvent)->x, ((XButtonEvent *)pEvent)->y,
                             ((XButtonEvent *)pEvent)->window, &iX, &iY);

            evt.data.l[3] = iX; // TODO:  should this be UN-TRANSLATED or SCREEN coordinates?
            evt.data.l[4] = iY; //        should I indicate WHICH WINDOW this should be for?

            WBPostPriorityEvent(((XButtonEvent *)pEvent)->window, (XEvent *)&evt);

            if(wMouseCapture != None)
            {
              // end the mouse capture
              XUngrabPointer(pDisplay, CurrentTime);
              wMouseCapture = None;
            }

            iMouseState = MouseState_NONE; // complete
          }

          break;
      }
    }
    else if(iMouseState != MouseState_NONE &&
            (pEvent->type == KeyPress ||
             pEvent->type == KeyRelease))
    {
      int iModShiftCtrl = ((XKeyEvent *)pEvent)->state & (ShiftMask | LockMask | ControlMask | Mod1Mask
                                                          | Mod2Mask | Mod3Mask | Mod4Mask | Mod5Mask);

      int iKey = XLookupKeysym((XKeyEvent *)pEvent, 0);  // always use '0' index for these
                 //WBKeyEventProcessKey((XKeyEvent *)pEvent, NULL, NULL, NULL)

      // mouse state cancelation due to pressing or releasing a key AFTERWARDS
      // for now limit this to escape, space, enter, and one of the modifier keys

      if(iModShiftCtrl != iMouseModShiftCtrl ||
         (pEvent->type == KeyPress &&
          (iKey == XK_Escape || iKey == XK_Return || iKey == XK_KP_Enter)))
      {
        // cancel any mouse states due to pressing a key

        WBMouseCancel(pDisplay, ((XButtonEvent *)pEvent)->window);
      }
    }
  }

  return iRval;
}


/**********************************************************************/
/*                                                                    */
/*                  message dispatching functions                     */
/*         (see also 'WBInternalProcessExposeEvent', below)           */
/*                                                                    */
/**********************************************************************/

int WBAppDispatch(XEvent *pEvent)
{
Atom aTemp;
XEvent evtTemp;

  // internal-only messages [not hooked]

  if(pEvent->xany.type == ClientMessage
     && pEvent->xclient.message_type == aSET_FOCUS) // async assign focus (top level window only)
  {
    XWindowChanges xwc;
    Window wID = (Window)pEvent->xclient.data.l[0];
    Window wIDFrom = (Window)pEvent->xclient.data.l[1]; // window inadvertently getting focus
    Window wIDRoot = None;
    _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
    Display *pDisplay;

    if(pEntry && pEntry->pDisplay && pEvent->xany.display &&
       pEvent->xany.display != pEntry->pDisplay)
    {
      pEntry = NULL;  // anticipate multiple displays with matching window ID's in this case...
      WB_ERROR_PRINT("ERROR - %s - display pointer mismatch\n", __FUNCTION__);
    }

    if(pEntry)
    {
      if(pEntry->pDisplay)
      {
        pDisplay = pEntry->pDisplay;
      }
      else
      {
        pDisplay = pDefaultDisplay;
      }
    }
    else if(pEvent->xany.display) // TODO:  verify it's not different from that for pEntry
    {
      pDisplay = pEvent->xany.display;
    }
    else
    {
      pDisplay = pDefaultDisplay;
    }

//    fprintf(stderr, "** TEMPORARY - %s setting focus to %08xH\n", __FUNCTION__, (unsigned int)wID);
    // NOTE:  if this is not a top level window, results may be unexpected

    // tell the WM to mark the desired window as "the active window"
    aTemp = XInternAtom (pEvent->xany.display ? pEvent->xany.display : pDefaultDisplay,
                         "_NET_ACTIVE_WINDOW", False); /* global scope, must use XInternAtom */

    bzero(&evtTemp, sizeof(evtTemp));

    evtTemp.xany.type = ClientMessage;
    evtTemp.xany.send_event = True; // will send it, not post
    evtTemp.xany.display = pEvent->xany.display ? pEvent->xany.display : pDefaultDisplay;
    evtTemp.xany.window = wID; // in this case, the window to make active
    evtTemp.xany.serial = 0;

    __internal_GetParent(evtTemp.xany.display, wID, &wIDRoot); // send to 'wRoot'

    // client message params
    evtTemp.xclient.message_type = aTemp;
    evtTemp.xclient.format = 32;
    evtTemp.xclient.data.l[0] = 0; // "use old method" (should be suitable)
    evtTemp.xclient.data.l[1] = 0; // timestamp (zero for now)
    evtTemp.xclient.data.l[2] = wIDFrom; // window that was incorrectly set 'active'

    BEGIN_XCALL_DEBUG_WRAPPER
    XSendEvent(pDisplay, wIDRoot, False,
               SubstructureRedirectMask | SubstructureNotifyMask,
               &evtTemp);
    END_XCALL_DEBUG_WRAPPER

    WBSetInputFocus(wID); // set input focus to this window (after doing the above)
    // window managers that ignore _NET_ACTIVE_WINDOW should work OK with JUST
    // a call to XSetInputFocus.  fluxbox works when you use XSetInputFocus

    bzero(&xwc, sizeof(xwc));
    xwc.stack_mode = Above;

    // bring window forward
    BEGIN_XCALL_DEBUG_WRAPPER

    XConfigureWindow(pDisplay, wID, CWStackMode, &xwc);
    XMapWindow(pDisplay, wID);

    END_XCALL_DEBUG_WRAPPER

    return 1; // handled
  }

  if(!pAppEventCallback || !pAppEventCallback(pEvent))
  {
    return WBAppDefault(pEvent);
  }

  return 0;
}

void WBDispatch(XEvent *pEvent)
{
  // determine the window ID for the message, if applicable

//  if(pEvent->type == KeymapEvent)
//  {
//  }
  if(pEvent->xany.window == None)  // the application
  {
    WBAppDispatch(pEvent);
  }
  else
  {
    WBWindowDispatch(pEvent->xany.window, pEvent);
  }

  __PeriodicWindowEntryCleanup(); // TODO:  find a more intelligent way to make this work
}


int WBWindowDispatch(Window wID, XEvent *pEvent)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
  int iRval = 0, iSetFocus = 0;

  if(pEvent->type == ClientMessage)
  {
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Window,
                   "%s - client message, pEntry==%pH\n", __FUNCTION__, pEntry);
  }

  if(pEntry)
  {
    // detect resize, mouse, and keystrokes for menu

    if(pEntry->wIDMenu)
    {
      _WINDOW_ENTRY_ *pMenuEntry = WBGetWindowEntry(pEntry->wIDMenu);

      if(WB_UNLIKELY(!pMenuEntry))
      {
        WB_WARN_PRINT("%s - pMenuEntry is NULL, pEntry->wIDMenu = %d (%08xH)\n",
                      __FUNCTION__, (int)pEntry->wIDMenu, (int)pEntry->wIDMenu);
      }
      else if(WB_UNLIKELY(WB_IS_WINDOW_DESTROYED(*pMenuEntry)))
      {
        // DO NOT dispatch messages to destroyed menus

        WB_WARN_PRINT("%s:%d - %d (%08xH) NOT mapped\n",
                      __FUNCTION__, __LINE__, (int)wID, (int)wID);

        goto exit_point; // NOT handled (should I change this?)
      }
      else if(pMenuEntry->pMenuCallback &&
              (pEvent->type == ConfigureNotify ||   // resize, reposition
               pEvent->type == EnterNotify ||
               pEvent->type == LeaveNotify ||
               pEvent->type == KeyPress ||
               pEvent->type == KeyRelease ||
               pEvent->type == ButtonPress ||
               pEvent->type == ButtonRelease ||
               pEvent->type == MotionNotify ||
               pEvent->type == ClientMessage))
      {
        // TODO:  do I want to exclude 'Expose' and other event types ???
        //        [this is the only part that calls the client's callback function]

        iRval = pMenuEntry->pMenuCallback(pMenuEntry->wID, pEvent);

        if(iRval)
        {
          goto exit_point; // handled
        }
      }
    }

    if(pEvent->type == Expose)
    {
      WB_GEOM geom;

      if(WB_UNLIKELY(WB_IS_WINDOW_DESTROYED(*pEntry)))
      {
        // DO NOT dispatch messages to destroyed menus

        WB_WARN_PRINT("%s:%d - %d (%08xH) NOT mapped\n",
                      __FUNCTION__, __LINE__, (int)wID, (int)wID);

        goto exit_point; // NOT handled (should I change this?)
      }

      WBGetWindowGeom(wID, &geom);

      pEntry->width = geom.width;  // update geometry for 'pEntry'
      pEntry->height = geom.height;
      pEntry->border = geom.border;

      iSetFocus = WB_CHECK_SET_FOCUS_ON_MAP(*pEntry);
    }

    if(pEvent->type == ReparentNotify && wID == pEvent->xreparent.window)
    {
      WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_Window | DebugSubSystem_Event,
                     "%s - re-parent event, %d (%08xH), %d (%08xH)\n",
                     __FUNCTION__, (int)wID, (int)wID,
                     (int)pEvent->xreparent.parent, (int)pEvent->xreparent.parent);

      pEntry->wParent = pEvent->xreparent.parent;
    }

    if(pEntry->pCallback) // CAN be NULL, especially if there are stale events waiting to be sent
    {
      iRval = pEntry->pCallback(wID, pEvent);

      if(iSetFocus)
      {
        WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Window,
                       "%s:%d - %d (%08xH) mapped, setting focus\n",
                       __FUNCTION__, __LINE__, (int)wID, (int)wID);

//        WB_ERROR_PRINT("TEMPORARY - %s calling XSetInputFocus on wID=%u (%08xH)\n", __FUNCTION__, (int)wID, (uint32_t)wID);

        BEGIN_XCALL_DEBUG_WRAPPER
        XSetInputFocus(pEntry->pDisplay, wID, RevertToParent, CurrentTime);
        END_XCALL_DEBUG_WRAPPER
      }

      if(iRval) // if my callback 'handled' me properly
      {
        if(pEvent->type != DestroyNotify ||        // not a destroy notification
            pEvent->xdestroywindow.window != wID)  // destroyed window isn't me
        {
          if(pEvent->type == DestroyNotify)
          {
            WB_ERROR_PRINT("%s - UNEXPECTED - DestroyNotify for %d and message is for %d\n",
                           __FUNCTION__, (int)pEvent->xdestroywindow.window, (int)wID);
          }

          // return NOW - no further processing

          goto exit_point; // handled
        }

        // at this point, I had a DestroyNotify message for THIS window - flow through to next section
      }
    }
    else if(pEvent->type == DestroyNotify)
    {
      if(pEvent->xdestroywindow.window == wID)
      {
        // 'pEntry' is still valid, but SHOULD be marked 'to be destroyed'
        if(!WB_IS_WINDOW_DESTROYED(*pEntry)) // already destroyed?  no need to say anything
        {
          // I am being destroyed and I have no callback
          WB_ERROR_PRINT("INFO:  %s - DestroyNotify for wID %d (%s) and NO CALLBACK (this is sometimes expected)\n",
                         __FUNCTION__, (int)wID, pEntry->szClassName);
        }
      }
      else
      {
        WB_ERROR_PRINT("ERROR:  %s - (UNEXPECTED) DestroyNotify for %d and message is for %d (no callback)\n",
                       __FUNCTION__, (int)pEvent->xdestroywindow.window, (int)wID);
      }
    }
    else if(iSetFocus)  // still handle this, just in case
    {
      WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Window,
                      "%s:%d - %d (%08xH) mapped, setting focus\n",
                      __FUNCTION__, __LINE__, (int)wID, (int)wID);

//      WB_ERROR_PRINT("TEMPORARY - %s calling XSetInputFocus on wID=%u (%08xH)\n", __FUNCTION__, (int)wID, (uint32_t)wID);

      BEGIN_XCALL_DEBUG_WRAPPER
      XSetInputFocus(pEntry->pDisplay, wID, RevertToParent, CurrentTime);
      END_XCALL_DEBUG_WRAPPER
    }

    // handle any DestroyNotify events at this point.  A parent window may send these to child windows, even
    // after the window is actually destroyed and its callback NULL'd
    //
    // (NOTE:  if I had a callback, I still handle destroy notifications for ME at this point)

    if(pEvent->type == DestroyNotify &&
       pEvent->xdestroywindow.window == wID) // I am being destroyed
    {
      // window destroyed, already called callback (if there is one)

      _WINDOW_ENTRY_ *pEntry2 = WBGetWindowEntry(wID);

      WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_Window | DebugSubSystem_Event,
                     "%s - DestroyNotify for %d (%08xH)\n",
                     __FUNCTION__, (int)wID, (int)wID);

      if(pEntry2 && !iRval)  // must call 'Default'
      {
//        WB_ERROR_PRINT("TEMPORARY - doing default processing for DestroyNotify\n");
        WBDefault(wID, pEvent);
      }

      // if this window is the current 'application' window, set the 'quit' flag.
      if(wID == wIDApplication)
      {
        bQuitFlag = TRUE; // application window destroyed, application must exit
      }

      if(pEntry2 && pEntry2 == pEntry)
      {
        // window destruction means delete remaining events, then unregister the callback
        __WBDelWindowEvents(pEntry->pDisplay, wID);

        pEntry->iWindowState = WB_WINDOW_DESTROYED;  // to flag "I am destroying it now"
//        WB_ERROR_PRINT(">>TEMPORARY - %s - marking window %d (%s) destroyed and unregistering callback\n", __FUNCTION__, (int)wID, pEntry->szClassName);

        WBUnregisterWindowCallback(wID); // NOTE:  this assigns 'wIDApplication' to None if this was the application window

        goto exit_point; // handled
      }
      else
      {
        WB_ERROR_PRINT("WARNING - %s - pEntry == %p, pEntry2 == %p\n", __FUNCTION__, pEntry, pEntry2);
      }
    }
  }
  else
  {
    WB_DEBUG_PRINT(DebugLevel_WARN/*Medium*/ | DebugSubSystem_Window | DebugSubSystem_Event /*| DebugSubSystem_Selection*/,
                   "%s - Event %s for window %d (%08xH) not handled [no pEntry]\n",
                   __FUNCTION__, WBEventName(pEvent->type), (int)wID, (int)wID);
  }

  // NOTE:  I get here if the registered callback returns zero or isn't assigned
  //        and it's either NOT a 'DestroyNotify' or there's no window entry

  if(!iRval)
  {
    iRval = WBDefault(wID, pEvent);
  }
  else
  {
    WBDefault(wID, pEvent);  // do it anyway but don't use THAT return value
  }

exit_point:

  // TODO: any "always do this" stuff belongs here

  return iRval;
}

int WBAppDefault(XEvent *pEvent)
{
  return 0;  // not handled
}

int WBDefault(Window wID, XEvent *pEvent)
{
  int i1;
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
  Display *pDisplay = pEvent->xany.display ? pEvent->xany.display
                    : pEntry ? pEntry->pDisplay : pDefaultDisplay;


  if (pEvent->type == Expose && pEvent->xexpose.count == 0)
  {
    // for now, just erase the background using whatever background color is currently assigned
    if(pEntry && pEntry->hGC != NULL)
    {
      WBGC gc = WBBeginPaint(wID, &(pEvent->xexpose), NULL);
      if(gc != NULL)
      {
        WBClearWindow(wID, gc);
        WBEndPaint(wID, gc);
      }
    }
    else
    {
//      WB_ERROR_PRINT("TEMPORARY: %s - window has NO assigned GC, calling XClearWindow\n", __FUNCTION__);

      XClearWindow(pDisplay, wID);  // TODO:  rather than erase background, see if I need to
    }

    return 1; // handled
  }
  else if(pEvent->type == ConfigureNotify && pEvent->xconfigure.window == wID)
  {
    WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_Window | DebugSubSystem_Event,
                   "%s - window %08xH gets ConfigureNotify\n",
                   __FUNCTION__, (unsigned int)wID);

    // see if it's a move, or a re-size.  on re-size I have to re-paint and re-calculate
    // the various display thingies.  But if I'm just moving it, no need.

    if(pEvent->xconfigure.width != pEntry->width ||
       pEvent->xconfigure.height != pEntry->height ||
       pEvent->xconfigure.border_width != pEntry->border)
    {
      if(!WB_IS_WINDOW_MAPPED(*pEntry) ||   // if I'm not mapped, just change the numbers and create a region
         !pEntry->width || !pEntry->height) // same if width/height was zero (but is no longer)
      {
        XRectangle xrct;

        // NOTE:  I must do it THIS way because the window isn't mapped yet.

        pEntry->width = pEvent->xconfigure.width;
        pEntry->height = pEvent->xconfigure.height;
        pEntry->border = pEvent->xconfigure.border_width;

        if(pEntry->rgnClip != None)
        {
          XDestroyRegion(pEntry->rgnClip);
        }

        pEntry->rgnClip = XCreateRegion();

        if(pEntry->rgnClip &&
           pEntry->width && pEntry->height) // make sure non-zero
        {
          xrct.x = 0;//(short)pEntry->x;
          xrct.y = 0;//(short)pEntry->y;
          xrct.width = (unsigned short)pEntry->width;
          xrct.height = (unsigned short)pEntry->height;

          XUnionRectWithRegion(&xrct, pEntry->rgnClip, pEntry->rgnClip);
        }
      }
      else
      {
//        WB_ERROR_PRINT("TEMPORARY:  %s - ConfigureNotify invalidating geometry\n", __FUNCTION__);

        WBInvalidateGeom(wID, NULL, 1);  // for simplicity, just re-paint it - note, NOT saying "do it now"
      }
    }

    return 1; // handled
  }
  else if(pEvent->type == VisibilityNotify &&
          pEvent->xvisibility.window == wID &&
          pEvent->xvisibility.state != VisibilityFullyObscured)
  {
    // Focus and Z-order changes generate this.  If my window's state changes to at least partially 'unobscured',
    // then the response is to invalidate the entire window so it re-paints.

    // TODO:  see what was covering it up before, to limit the re-painting

    WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_Window | DebugSubSystem_Event,
                   "%s - window %08xH gets VisibilityNotify, state=%d\n",
                   __FUNCTION__, (unsigned int)pEvent->xvisibility.window, pEvent->xvisibility.state);

    WBInvalidateGeom(pEvent->xvisibility.window, NULL, 1); // TODO:  determine what changed

    return 1; // handled
  }
  else if(pEvent->type == MapRequest &&
          (pEvent->xmaprequest.parent == wID || pEvent->xmaprequest.window == wID))
  {
    // XMapWindow and related can generate this.  I want to see if it happens, ever.

    WB_ERROR_PRINT("TEMPORARY: %s - window %08xH gets MapRequest for %08xH\n",
                   __FUNCTION__, (unsigned int)pEvent->xmaprequest.parent, (unsigned int)pEvent->xmaprequest.window);
  }
  else if(pEvent->type == ClientMessage)
  {
//    fprintf(stderr, "TEMPORARY:  client message in WBDefault\n");
    if(pEvent->xclient.message_type == aWM_PROTOCOLS && pEvent->xclient.window == wID)
    {
      if(pEvent->xclient.data.l[0] == aWM_DELETE_WINDOW)
      {
        // If this is managed by the WM, I'll get this message in response to a request
        // to close the window.  This includes clicking the 'x' button in the title bar

        XClientMessageEvent evt;

        WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_Window | DebugSubSystem_Event,
                       "%s - WM_DELETE_WINDOW for %d (%08xH)\n",
                       __FUNCTION__, (int)wID, (int)wID);

        WB_ERROR_PRINT("TEMPORARY:  %s - WM_PROTOCOLS WM_DELETE_WINDOW, requests call to XDestroyWindow for %u (%08xH)\n", __FUNCTION__, (int)wID, (int)wID);

        // the default action is to FIRST query the window to see if it's ok to destroy it.  if it is,
        // the window should THEN safely destroy all of its child windows, etc. before returning, so that
        // I don't end up with a pile of X11 errors.

        bzero(&evt, sizeof(evt));
        evt.type = ClientMessage;
        evt.display = pDisplay;
        evt.window = wID;
        evt.message_type = aQUERY_CLOSE; // QUERY_CLOSE request
        evt.format = 32;
        evt.data.l[0] = 1; // tell it to destroy contents if ok to close

        i1 = WBWindowDispatch(evt.window, (XEvent *)&evt);

        if(i1 <= 0) // ok to close the window (or there was an error, so close anyway)
        {
          if(i1 < 0)
          {
            WB_ERROR_PRINT("ERROR:  %s - QUERY_CLOSE returns %d, destroying window %u (%08xH) anyway\n",
                           __FUNCTION__, i1, (int)wID, (int)wID);
          }
          else
          {
            WB_ERROR_PRINT("INFO:  %s - QUERY_CLOSE returns %d, ok to destroy window %u (%08xH)\n",
                           __FUNCTION__, i1, (int)wID, (int)wID);
          }

          if(wID == wIDApplication) // if it's the "application window", set the quit flag
          {
//            WB_ERROR_PRINT("TEMPORARY:  %s - setting 'quit' flag\n", __FUNCTION__);

            bQuitFlag = TRUE; // application window destroyed, application must exit
          }

          // window destruction means delete remaining events, then unregister the callback
          __WBDelWindowEvents(pEntry->pDisplay, wID);

          pEntry->iWindowState = WB_WINDOW_DESTROYED;  // to flag "I am destroying it now"

          WBUnregisterWindowCallback(wID); // make sure this happens - FYI it assigns matching wIDApplication to 'None'

//        WBDestroyWindow(wID); // destroy the window  (DO NOT CALL THIS, the application will stay running if it's the main frame)

          // default action is to destroy the window *NOW*
          BEGIN_XCALL_DEBUG_WRAPPER
          XDestroyWindow(pDisplay, wID);  // todo:  wrap this in ???
          END_XCALL_DEBUG_WRAPPER
        }

        return 1;  // "handled"
      }
    }
    else if(pEvent->xclient.message_type == aWB_TIMER && pEvent->xclient.window == wID)
    {
      WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Window | DebugSubSystem_Event,
                      "%s - un-handled WB_TIMER for %d (%08xH)\n",
                      __FUNCTION__, (int)wID, (int)wID);
    }
#ifndef NO_DEBUG    // uncomment this block to dump every event NOT handled
    else
    {
      WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Window | DebugSubSystem_Event,
                      "%s - un-handled ClientMessage for %d (%08xH)\n",
                      __FUNCTION__, (int)wID, (int)wID);

      WB_IF_DEBUG_LEVEL(DebugLevel_Light | DebugSubSystem_Window | DebugSubSystem_Event)
      {
        WBDebugDumpEvent(pEvent);
      }
    }
#endif // NO_DEBUG
  }
  else if(pEvent->type == KeyPress ||
          pEvent->type == KeyRelease)
  {
    WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Window | DebugSubSystem_Event | DebugSubSystem_Keyboard,
                   "%s - key press/release event for %d (%08xH) in default handler\n",
                   __FUNCTION__, (int)wID, (int)wID);

    if(pEvent->type == KeyPress /* || pEvent->type == KeyRelease */)
    {
      // generate a WB_CHAR event for unhandled 'keypress' events
      // this lets all windows have a chance at intercepting the
      // keypress event before a WB_CHAR is generated

      XClientMessageEvent evt;
      int cbData, iACS = 0;

      // post a high-priority message to myself to display the menu

      bzero(&evt, sizeof(evt));
      evt.type = ClientMessage;
      evt.display = pDisplay;
      evt.window = pEvent->xany.window;
      evt.message_type = aWB_CHAR; // WB_CHAR notification
      evt.format = 32;

      cbData = sizeof(evt.data) - 3 * sizeof(evt.data.l[0]);
      evt.data.l[0] = WBKeyEventProcessKey((XKeyEvent *)pEvent,
                                            (char *)&(evt.data.l[3]),
                                            &cbData, &iACS);

      evt.data.l[1] = iACS;
      evt.data.l[2] = cbData;

      // pressing or releasing shift, ctrl, alt, or 'meta' must not
      // generate an event.  Fortunately these are all within a range

      if(evt.data.l[0] < XK_Shift_L || evt.data.l[0] > XK_Hyper_R)
      {
        // NOTE:  l[0] is return value from WBKeyEventProcessKey
        //        l[1] is iACS return value
        //        l[2] is # of characters decoded into 'l[3]'
        //        l[3..] is character decode buffer

        if(iACS & WB_KEYEVENT_KEYSYM)
        {
          // temporary debug
          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Keyboard,
                         "%s - generating WB_CHAR for KEYSYM %ld (%lxH) iACS=%xH window %d (%08xH)\n",
                         __FUNCTION__, evt.data.l[0], evt.data.l[0], iACS,
                         (int)pEvent->xany.window, (int)pEvent->xany.window);
        }
        else
        {
          // temporary debug
          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Keyboard,
                         "%s - generating WB_CHAR \"%.*s\" iACS=%xH window %d (%08xH)\n",
                         __FUNCTION__, cbData, (char *)&(evt.data.l[3]), iACS,
                         (int)pEvent->xany.window, (int)pEvent->xany.window);
        }

        WBPostPriorityEvent(pEvent->xany.window, (XEvent *)&evt);
      }
    }

  }
  else if(pEvent->type == DestroyNotify &&
          pEvent->xdestroywindow.window == wID)
  {
    _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

    if(pEntry && pEntry->wIDMenu)
    {
      Window wIDMenu = pEntry->wIDMenu;
      pEntry->wIDMenu = 0;

      // Look for any other occurences of this menu attached to any other window
      // TODO: make this more efficient, eh?
      // TODO:  see if I even need this.  I've not been sharing WBMenu resources at all...

      for(i1=0; i1 <= WINDOW_ENTRY_ARRAY_MAX; i1++)
      {
        if(sWBHashEntries[i1].wIDMenu == wIDMenu)
          break;
      }

      // am I the last guy using the menu?
      if(i1 > WINDOW_ENTRY_ARRAY_MAX)
      {
        WBDestroyWindow(wIDMenu);
      }
    }
  }
  else if(pEvent->type == SelectionRequest)
  {
    // NOTE:  selection events are handled by the Clipboard worker thread.  However, I can still (possibly)
    //        get these things sent to me.  The *POLITE* thing to do is respond to them with an error sent
    //        back to the requestor.  And so, that's what I do.  And display it in on stderr in debug code...
#ifndef NO_DEBUG
    char *p1 = pEvent->xselectionrequest.selection != None ? WBGetAtomName(pDisplay, pEvent->xselectionrequest.selection) : NULL;
    char *p2 = pEvent->xselectionrequest.target != None ? WBGetAtomName(pDisplay, pEvent->xselectionrequest.target) : NULL;
    char *p3 = pEvent->xselectionrequest.property != None ? WBGetAtomName(pDisplay, pEvent->xselectionrequest.property) : NULL;

    WB_ERROR_PRINT("TEMPORARY - %s - SelectionRequest wID=%d(%08xH) class=%s owner=%d requestor=%d selection=%s target=%s property=%s\n",
                   __FUNCTION__,
                   (int)wID, (int)wID,
                   (const char *)(pEntry ? pEntry->szClassName : "UNK"),
                   (int)pEvent->xselectionrequest.owner,
                   (int)pEvent->xselectionrequest.requestor,
                   p1 ? p1 : "NULL",
                   p2 ? p2 : "NULL",
                   p3 ? p3 : "NULL");

    if(p1)
    {
      WBFree(p1);
    }
    if(p2)
    {
      WBFree(p2);
    }
    if(p3)
    {
      WBFree(p3);
    }
#endif // NO_DEBUG

    // the default rejects the request.  Send a 'SelectionNotify' to indicate the failure
    // failing to send the SelectionNotify can REALLY screw things up for the requestor

    if(pEvent->xselectionrequest.owner == wID) // only if I'm the selection owner
    {
      XSelectionEvent evtN;

      memset(&evtN, 0, sizeof(evtN));

      evtN.type = SelectionNotify;
      evtN.send_event = True; // 'cause I'm going to use 'XSendEvent' to reply immediately
      evtN.requestor = pEvent->xselectionrequest.requestor;
      evtN.selection = pEvent->xselectionrequest.selection;
      evtN.target = pEvent->xselectionrequest.target;
      evtN.property = None; // to indicate failure
      evtN.time = pEvent->xselectionrequest.time; // same time as request (for now)

      BEGIN_XCALL_DEBUG_WRAPPER
      XSendEvent(pDisplay, evtN.requestor, False, 0, (XEvent *)&evtN);
      END_XCALL_DEBUG_WRAPPER
    }
  }
  else if(pEvent->type == SelectionClear)
  {
#ifndef NO_DEBUG
    char *p1 = WBGetAtomName(pDisplay, pEvent->xselectionclear.selection);

    WB_ERROR_PRINT("TEMPORARY - %s - SelectionClear wID=%d(%08xH) class=%s window=%d selection=%s\n",
                   __FUNCTION__,
                   (int)wID, (int)wID,
                   (const char *)(pEntry ? pEntry->szClassName : "UNK"),
                   (int)pEvent->xselectionclear.window,
                   p1 ? p1 : "NULL");

    if(p1)
    {
      WBFree(p1);
    }
#endif // NO_DEBUG

    // the default rejects the request.  No need to send a 'SelectionNotify'
  }
  else if(pEvent->type == SelectionNotify)
  {
#ifndef NO_DEBUG
    char *p1 = pEvent->xselection.selection != None ? WBGetAtomName(pDisplay, pEvent->xselection.selection) : NULL;
    char *p2 = pEvent->xselection.target != None ? WBGetAtomName(pDisplay, pEvent->xselection.target) : NULL;
    char *p3 = pEvent->xselection.property != None ? WBGetAtomName(pDisplay, pEvent->xselection.property) : NULL;

    WB_ERROR_PRINT("TEMPORARY - %s - SelectionNotify wID=%d(%08xH) class=%s requestor=%d selection=%s target=%s property=%s\n",
                   __FUNCTION__,
                   (int)wID, (int)wID,
                   (const char *)(pEntry ? pEntry->szClassName : "UNK"),
                   (int)pEvent->xselection.requestor,
                   p1 ? p1 : "NULL",
                   p2 ? p2 : "NULL",
                   p3 ? p3 : "NULL");

    if(p1)
    {
      WBFree(p1);
    }
    if(p2)
    {
      WBFree(p2);
    }
    if(p3)
    {
      WBFree(p3);
    }
#endif // NO_DEBUG
  }
//#ifndef NO_DEBUG    // uncomment this block to dump every event NOT handled
//  else
//  {
//    WBDebugDumpEvent(pEvent);
//  }
//#endif // NO_DEBUG

  return 0;  // indicate 'not handled' for now
}


void WBProcessExposeEvent(XExposeEvent *pEvent)
{
XEvent xevt;

  // first, handle the expose event as-is
  WBInternalProcessExposeEvent(pEvent);

  // next, grab whatever expose events are still out there and combine them, too

//  XFlush(pEvent->display);
  XSync(pEvent->display, 0); // to grab whatever expose events might be out there

  while(!bQuitFlag && XCheckTypedWindowEvent(pEvent->display, pEvent->window, Expose, &xevt))
  {
    WBInternalProcessExposeEvent((XExposeEvent *)&xevt);
  }
}


void WBMouseCancel(Display *pDisplay, Window wID)
{
XClientMessageEvent evt;
int iX, iY;


  if((iMouseState != MouseState_LDRAG &&
      iMouseState != MouseState_RDRAG &&
      iMouseState != MouseState_CDRAG &&
      iMouseState != MouseState_WAS_LCLICK &&
      iMouseState != MouseState_WAS_RCLICK &&
      iMouseState != MouseState_WAS_CCLICK) // expected states to do a 'Mouse Cancel' for
     || wMouseCapture == None)
  {
    if(wMouseCapture != None)
    {
      WB_ERROR_PRINT("ERROR:  %s - incorrect mouse state:  %d (%08xH)\n", __FUNCTION__, iMouseState, iMouseState);

      XUngrabPointer(pDisplay ? pDisplay : WBGetDefaultDisplay(), CurrentTime);

      wMouseCapture = None; // not captured
    }
    else if(iMouseState == MouseState_NONE)
    {
      return; // just ignore it.  no harm, no foul.  mouse not captured, state is 'None'
    }
    else if(iMouseState != MouseState_WAS_LCLICK &&
            iMouseState != MouseState_WAS_RCLICK &&
            iMouseState != MouseState_WAS_CCLICK) // the "was" states are ok here.  'mouse cancel' will not be sent, however
    {
      // any other mouse state is unexpected here.  spit out a message

      WB_ERROR_PRINT("ERROR:  %s - mouse not captured.  mouse state:  %d (%08xH) \n", __FUNCTION__, iMouseState, iMouseState);
    }

    // TODO:  send notification for a 'WAS' state??

    iMouseState = MouseState_NONE; // by convention, do this (always) on mouse cancel

    return; // for now, just do this [no capture]
  }

  if(wID == None)
  {
    wID = wMouseCapture; // the window with the mouse capture (checked for 'None' previously)
  }

  if(!pDisplay)
  {
    pDisplay = WBGetWindowDisplay(wID);
    if(!pDisplay)
    {
      pDisplay = WBGetDefaultDisplay(); // desperately make it work
    }
  }

  bzero(&evt, sizeof(evt));
  evt.type=ClientMessage;
  evt.display=pDisplay;
  evt.window=wID;
  evt.message_type=aWB_POINTER;
  evt.format=32;
  evt.data.l[0] = WB_POINTER_CANCEL;

  evt.data.l[1] = iMouseDragButtonState;
  evt.data.l[2] = (iMouseModShiftCtrl & ShiftMask ? WB_KEYEVENT_SHIFT : 0)
                | (iMouseModShiftCtrl & ControlMask ? WB_KEYEVENT_CTRL : 0)
                | (iMouseModShiftCtrl & Mod1Mask ? WB_KEYEVENT_ALT : 0);

  WBXlatCoordPoint(wMouseCapture, iMouseX, iMouseY, wMouseCapture, &iX, &iY);

  evt.data.l[3] = iX;
  evt.data.l[4] = iY;

  WBPostPriorityEvent(wID, (XEvent *)&evt); // post the WB_POINTER 'WB_POINTER_CANCEL' event

  iMouseState = MouseState_NONE; // canceled

  XUngrabPointer(pDisplay, CurrentTime);

  wMouseCapture = None;
  iMouseModShiftCtrl = iMouseDragButtonState = 0;
}



int WBMapWindow(Display *pDisplay, Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
  int iRval, iSetFocus = 0;

  if(pEntry)
  {
    iSetFocus = WB_CHECK_SET_FOCUS_ON_MAP(*pEntry);

    pEntry->iWindowState = WB_WINDOW_MAPPED;

    if(!pEntry->pWMHints)
    {
      // if no window hints were configured, set some up

      if(!__internal_alloc_WMHints(pEntry))
      {
        BEGIN_XCALL_DEBUG_WRAPPER
        XSetWMHints(pEntry->pDisplay, wID, pEntry->pWMHints);
        END_XCALL_DEBUG_WRAPPER
      }
    }
  }

  BEGIN_XCALL_DEBUG_WRAPPER
  iRval = XMapWindow(pDisplay, wID);
  END_XCALL_DEBUG_WRAPPER

  if(iSetFocus)
  {
    WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Window,
                   "%s:%d - %d (%08xH) mapped, setting focus\n",
                   __FUNCTION__, __LINE__, (int)wID, (int)wID);

//    WB_ERROR_PRINT("TEMPORARY - %s calling XSetInputFocus on wID=%u (%08xH)\n", __FUNCTION__, (int)wID, (uint32_t)wID);

    BEGIN_XCALL_DEBUG_WRAPPER
    XSetInputFocus(pEntry->pDisplay, wID, RevertToParent, CurrentTime);
    END_XCALL_DEBUG_WRAPPER
  }

  return iRval;
}

int WBMapRaised(Display *pDisplay, Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  int iRval, iSetFocus = 0;

  if(pEntry)
  {
    iSetFocus = WB_CHECK_SET_FOCUS_ON_MAP(*pEntry);

    pEntry->iWindowState = WB_WINDOW_MAPPED;

    if(!pEntry->pWMHints)
    {
      // if no window hints were configured, set some up

      if(!__internal_alloc_WMHints(pEntry))
      {
        BEGIN_XCALL_DEBUG_WRAPPER
        XSetWMHints(pEntry->pDisplay, wID, pEntry->pWMHints);
        END_XCALL_DEBUG_WRAPPER
      }
    }
  }

  iRval = XMapRaised(pDisplay, wID);

  if(iSetFocus)
  {
    WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Window,
                   "%s:%d - %d (%08xH) mapped, setting focus\n",
                   __FUNCTION__, __LINE__, (int)wID, (int)wID);

//    WB_ERROR_PRINT("TEMPORARY - %s calling XSetInputFocus on wID=%u (%08xH)\n", __FUNCTION__, (int)wID, (uint32_t)wID);

    BEGIN_XCALL_DEBUG_WRAPPER
    XSetInputFocus(pEntry->pDisplay, wID, RevertToParent, CurrentTime);
    END_XCALL_DEBUG_WRAPPER
  }

  return iRval;
}

int WBUnmapWindow(Display *pDisplay, Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
  int iRval;

  if(pEntry)
  {
    if(WB_IS_WINDOW_UNMAPPED(*pEntry) || WB_IS_WINDOW_DESTROYED(*pEntry))
    {
      return 0;
    }

    pEntry->iWindowState = WB_WINDOW_UNMAPPED; // aka 'unmapped'
  }

  BEGIN_XCALL_DEBUG_WRAPPER
  iRval = XUnmapWindow(pDisplay, wID);
  END_XCALL_DEBUG_WRAPPER

  // TODO:  if window HAD focus, set it to the main app window?

  return iRval;
}


int WBIsMapped(Display *pDisplay, Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry && WB_IS_WINDOW_MAPPED(*pEntry) && !WB_IS_WINDOW_DESTROYED(*pEntry))
  {
    return 1;
  }

  // TODO:  handle windows NOT being tracked???

  return 0;
}

int WBIsValid(Display *pDisplay, Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry && !WB_IS_WINDOW_DESTROYED(*pEntry))
  {
//    fprintf(stderr, "TEMPORARY - returning 'valid' for window %d\n", wID);
    return 1;
  }

  // TODO:  handle windows NOT being tracked???

  return 0;
}



/**********************************************************************/
/*                                                                    */
/*                 basic window property functions                    */
/*                                                                    */
/**********************************************************************/

static int __internal_alloc_WMHints(_WINDOW_ENTRY_ *pEntry)
{
  if(pEntry)
  {
    if(pEntry->pWMHints)
    {
      return 0;
    }
    else
    {
      pEntry->pWMHints = XAllocWMHints();
      if(pEntry->pWMHints)
      {
        // set defaults
        pEntry->pWMHints->initial_state = NormalState;
        pEntry->pWMHints->input = True; // this means the WINDOW MANAGER should manage input focus (this is normal)
        pEntry->pWMHints->flags = InputHint | StateHint;

        return 0;
      }
    }
  }

  return -1;
}

Display * WBGetWindowDisplay(Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry)
  {
    return pEntry->pDisplay;
  }

  return pDefaultDisplay;
}

void WBSetWindowIcon(Window wID, int idIcon)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
  Display *pDisp = pEntry ? pEntry->pDisplay : pDefaultDisplay;

  if(pEntry)
  {
    if(__internal_alloc_WMHints(pEntry))
    {
      return;
    }

    BEGIN_XCALL_DEBUG_WRAPPER
    if(pEntry->pxIcon != None)
    {
      XFreePixmap(pDisp, pEntry->pxIcon);
      pEntry->pxIcon = None;
    }

    if(pEntry->pxMask != None)
    {
      XFreePixmap(pDisp, pEntry->pxMask);
      pEntry->pxMask = None;
    }
    END_XCALL_DEBUG_WRAPPER

    pEntry->pxIcon = PXM_GetIconPixmap(idIcon, NULL, &(pEntry->pxMask));

    pEntry->pWMHints->flags |= IconPixmapHint; // (InputHint|StateHint|IconPixmapHint);
    if(pEntry->pxMask)
      pEntry->pWMHints->flags |= IconMaskHint;
    else
      pEntry->pWMHints->flags &= ~IconMaskHint;

    pEntry->pWMHints->icon_pixmap = pEntry->pxIcon;
    pEntry->pWMHints->icon_mask = pEntry->pxMask;

    BEGIN_XCALL_DEBUG_WRAPPER
    XSetWMHints(pDisp, wID, pEntry->pWMHints);
    END_XCALL_DEBUG_WRAPPER
  }
}

//void WBSetWindowFontStruct(Window wID, XFontStruct *pFontStruct)
//{
//  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
//
//  if(pEntry)
//  {
//    if(pEntry->pFontStruct && pEntry->pFontStruct != pDefaultFont)  // must delete it
//    {
//      XFreeFont(pEntry->pDisplay, pEntry->pFontStruct);
//    }
//
//    if(pEntry->fontSet != None && pEntry->fontSet != fontsetDefault)
//    {
//      XFreeFontSet(pEntry->pDisplay, pEntry->fontSet);
//    }
//
//    pEntry->fontSet = None; // always, before I do the next part
//
//    pEntry->pFontStruct = pFontStruct;
//
//    if(pFontStruct)
//    {
//      pEntry->fontSet = WBFontSetFromFont(pEntry->pDisplay, pFontStruct);
//    }
//  }
//}

//void WBSetWindowFontSet(Window wID, XFontSet fontSet)
//{
//  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
//
//  if(pEntry)
//  {
//    if(pEntry->pFontStruct && pEntry->pFontStruct != pDefaultFont)  // must delete it
//    {
//      XFreeFont(pEntry->pDisplay, pEntry->pFontStruct);
//    }
//
//    if(pEntry->fontSet != None && pEntry->fontSet != fontsetDefault)
//    {
//      XFreeFontSet(pEntry->pDisplay, pEntry->fontSet);
//    }
//
//    pEntry->pFontStruct = NULL;
//
//    if(fontSet != None)
//    {
//      pEntry->fontSet = fontSet;
//      pEntry->pFontStruct = WBFontFromFontSet(pEntry->pDisplay, fontSet);
//    }
//  }
//}

void WBSetWindowFont(Window wID, WB_FONTC pFont)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry)
  {
    if(pEntry->pFont && pEntry->pFont != pDefaultFont)  // must delete it
    {
      WBFreeFont(pEntry->pDisplay, pEntry->pFont);
    }

//    if(pFont) TODO:  do I use NULL or make a copy of the default instead?
//    {
      pEntry->pFont = WBCopyFont(pEntry->pDisplay, pFont); // for now do it THIS way
//    }
//    else
//    {
//      pEntry->pFont = NULL;
//    }
  }
}

void WBCreateWindowDefaultGC(Window wID, unsigned long clrFG, unsigned long clrBG)
{
  XGCValues   gcv;            /* Struct for creating GC */

  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(!pEntry)
    return;

  if(pEntry->hGC)
  {
    WBFreeGC(pEntry->hGC);
    // I shall re-assign this below, no need to NULL it
  }

  // the GC's font will be used with regular 'XDrawText' and 'XDrawString' calls
  // The associated Font Set must be queried separately for calls to XmbXXX or Xutf8XXX functions

  memset(&gcv, 0, sizeof(gcv));

  gcv.foreground = clrFG;
  gcv.background = clrBG;

// This is what I did before, and it's left commented for future reference
//  if(!pEntry->pFontStruct)
//  {
//    gcv.font = pDefaultFont->fid;
//  }
//  else
//  {
//    gcv.font = pEntry->pFontStruct->fid;
//  }

#ifndef NO_DEBUG
#warning does the default GC _REALLY_ need to have a default X11 (legacy) font ID assigned in the XGCValues struct???
#endif // NO_DEBUG
  pEntry->hGC = WBCreateGC(pEntry->pDisplay, wID, (/*GCFont |*/ GCForeground | GCBackground), &gcv);

//// TEMPORARY - for debugging a specific problem
//  if(pEntry->hGC && (((CARD32)pEntry->hGC->values.clip_mask) & 0xe0000000))
//  {
//    WB_ERROR_PRINT("ERROR:  %s - hGC clip_mask is NOT VALID\n", __FUNCTION__);
//  }

  pEntry->clrFG = clrFG; // cache this info in 'pEntry' as well
  pEntry->clrBG = clrBG;
}

void WBSetWindowDefaultGC(Window wID, WBGC hGC)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry)
  {
    if(pEntry->hGC)
    {
      WBFreeGC(pEntry->hGC);
    }

    pEntry->hGC = hGC;

//// TEMPORARY - for debugging a specific problem
//    if(hGC && (((CARD32)hGC->values.clip_mask) & 0xe0000000))
//    {
//      WB_ERROR_PRINT("ERROR:  %s - hGC clip_mask is NOT VALID\n", __FUNCTION__);
//    }
  }
}

void WBSetWindowData(Window wID, int iIndex, void *pData)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry && iIndex >= 0 && iIndex <= WINDOW_DATA_SIZE)
  {
    pEntry->aWindowData[iIndex] = pData;
  }
}

WBGC WBGetWindowDefaultGC(Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry)
  {
    return(pEntry->hGC);
  }

  return(NULL);
}

WBGC WBGetWindowCopyGC(Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
  WBGC gcRval = 0;

  if(!pEntry)
  {
    return NULL;
  }

//  WB_WARN_PRINT("TEMPORARY:  %s - calling WBCopyGC()\n", __FUNCTION__);
  gcRval = WBCopyGC(pEntry->hGC);

  return(gcRval);
}

unsigned long WBGetWindowFGColor(Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry)
  {
    return(pEntry->clrFG);
  }

  return(0);
}

unsigned long WBGetWindowBGColor(Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry)
  {
    return(pEntry->clrBG);
  }

  return(0);
}

unsigned long WBGetGCFGColor(WBGC gc)
{
//XGCValues val;
//Status ret;
//
//
//  BEGIN_XCALL_DEBUG_WRAPPER
//  ret = XGetGCValues(pDisplay, gc, GCForeground, &val);
//  END_XCALL_DEBUG_WRAPPER
//
//  if(!ret)
//  {
//    // use pre-defined color for BLACK
//
//    return BlackPixel(pDisplay, DefaultScreen(pDisplay));
//  }
//
//  return val.foreground;

  if(gc != NULL)
  {
    return gc->values.foreground;
  }
  else
  {
    return BlackPixel(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));
  }
}

unsigned long WBGetGCBGColor(WBGC gc)
{
//XGCValues val;
//Status ret;
//
//
//  BEGIN_XCALL_DEBUG_WRAPPER
//  ret = XGetGCValues(pDisplay, gc, GCBackground, &val);
//  END_XCALL_DEBUG_WRAPPER
//
//  if(!ret)
//  {
//    // use pre-defined color for WHITE
//
//    return WhitePixel(pDisplay, DefaultScreen(pDisplay));
//  }
//
//  return val.background;


  if(gc != NULL)
  {
    return gc->values.background;
  }
  else
  {
    return WhitePixel(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));
  }
}


void WBDefaultStandardColormap(Display *pDisplay, XStandardColormap *pMap)
{
XStandardColormap *pMaps = NULL;
XStandardColormap cmap;
Colormap cmDefault;
unsigned long lTemp; //, lWhite = WhitePixel(pDisplay, DefaultScreen(pDisplay));
XColor clrRed, clrGreen, clrBlue;
int i1, nMaps = 0;


  if(!pMap)
  {
    return;
  }

  if(!pDisplay)
  {
    pDisplay = WBGetDefaultDisplay();
  }

  if(pDisplay == WBGetDefaultDisplay() &&
     bStandardColormap)
  {
    // use the cached structure.  faster.

    memcpy(pMap, &cmapDefault, sizeof(cmapDefault));

    return;
  }

  bzero(&cmap, sizeof(cmap));

  cmDefault = DefaultColormap(pDisplay, DefaultScreen(pDisplay));

  // TRY to use the APIs to get this information.  I mean, REALLY TRY.
  if(!XGetRGBColormaps(pDisplay, DefaultRootWindow(pDisplay), &pMaps, &nMaps, XA_RGB_DEFAULT_MAP) ||
     nMaps == 0)
  {
    if(pMaps)
    {
      XFree(pMaps);
    }

    pMaps = NULL;

    if(!XGetRGBColormaps(pDisplay, DefaultRootWindow(pDisplay), &pMaps, &nMaps, XA_RGB_BEST_MAP) ||
       nMaps == 0)
    {
      if(pMaps)
      {
        XFree(pMaps);
      }

      pMaps = NULL;
    }
  }

  if(pMaps) // meaning that the above 'thingy' actually worked (I never really see it work, though)
  {
    for(i1=0; i1 < nMaps; i1++)
    {
      if(pMaps[i1].colormap == cmDefault)
      {
        memcpy(&cmap, &(pMaps[i1]), sizeof(XStandardColormap));
        break;
      }
    }

    XFree(pMaps);

    cmap.killid = None; // make sure
    cmap.visualid = None;

    if(i1 < nMaps) // I broke out of the loop?  I found one?
    {
      if(pDisplay == WBGetDefaultDisplay())
      {
        memcpy(&cmapDefault, &cmap, sizeof(cmap));
      }

      memcpy(pMap, &cmap, sizeof(cmap));
      return;
    }
  }

//  WB_ERROR_PRINT("TEMPORARY:  %s no matching XStandardColormap found - creating\n", __FUNCTION__);

  // --------------------------------------------------------
  // DERIVE A COLOR MAP FROM RGB COLORS AND KNOWN INFORMATION
  // --------------------------------------------------------

  bzero(&clrRed, sizeof(clrRed));
  bzero(&clrGreen, sizeof(clrGreen));
  bzero(&clrBlue, sizeof(clrBlue));

  clrRed.red = 65535;
  clrGreen.green = 65535;
  clrBlue.blue = 65535;
  XAllocColor(pDisplay, cmDefault, &clrRed);
  XAllocColor(pDisplay, cmDefault, &clrGreen);
  XAllocColor(pDisplay, cmDefault, &clrBlue);

//  WB_ERROR_PRINT("TEMPORARY:  %s  red: %08lxH  green: %08lxH  blue: %08lxH\n", __FUNCTION__,
//                 clrRed.pixel, clrGreen.pixel, clrBlue.pixel);

  // black is my 'base' pixel.
  cmap.base_pixel = BlackPixel(pDisplay, DefaultScreen(pDisplay));

  // next, 'nuke out' how the pixel multipliers work, using the Red, Green, and Blue 'alloc'd colors
  if(clrRed.pixel >= clrGreen.pixel && clrRed.pixel >= clrBlue.pixel)
  {
    if(clrGreen.pixel >= clrBlue.pixel)
    {
      cmap.blue_max = clrBlue.pixel - cmap.base_pixel;
      cmap.blue_mult = 1;

      cmap.green_mult = 1;
      while(cmap.green_mult < cmap.blue_max)
      {
        cmap.green_mult <<= 1;
      }

      lTemp = (clrGreen.pixel - cmap.base_pixel);
      cmap.green_max = lTemp / cmap.green_mult;

      cmap.red_mult = cmap.green_mult;

      while(cmap.red_mult < lTemp)
      {
        cmap.red_mult <<= 1;
      }

      cmap.red_max = (clrRed.pixel - cmap.base_pixel)
                   / cmap.red_mult;
    }
    else
    {
      cmap.green_max = clrGreen.pixel - cmap.base_pixel;
      cmap.green_mult = 1;

      cmap.blue_mult = 1;

      while(cmap.blue_mult < cmap.green_max)
      {
        cmap.blue_mult <<= 1;
      }

      lTemp = (clrBlue.pixel - cmap.base_pixel);
      cmap.blue_max = lTemp / cmap.blue_mult;

      cmap.red_mult = cmap.blue_mult;

      while(cmap.red_mult < lTemp)
      {
        cmap.red_mult <<= 1;
      }

      cmap.red_max = (clrRed.pixel - cmap.base_pixel)
                   / cmap.red_mult;
    }
  }
  else if(clrGreen.pixel >= clrRed.pixel && clrGreen.pixel >= clrBlue.pixel)
  {
    if(clrRed.pixel >= clrBlue.pixel)
    {
      cmap.blue_max = clrBlue.pixel - cmap.base_pixel;
      cmap.blue_mult = 1;

      cmap.red_mult = 1;
      while(cmap.red_mult < cmap.blue_max)
      {
        cmap.red_mult <<= 1;
      }

      lTemp = (clrRed.pixel - cmap.base_pixel);
      cmap.red_max = lTemp / cmap.red_mult;

      cmap.green_mult = cmap.red_mult;

      while(cmap.green_mult < lTemp)
      {
        cmap.green_mult <<= 1;
      }

      cmap.green_max = (clrGreen.pixel - cmap.base_pixel)
                     / cmap.green_mult;
    }
    else
    {
      cmap.red_max = clrRed.pixel - cmap.base_pixel;
      cmap.red_mult = 1;

      cmap.blue_mult = 1;

      while(cmap.blue_mult < cmap.green_max)
      {
        cmap.blue_mult <<= 1;
      }

      lTemp = (clrBlue.pixel - cmap.base_pixel);
      cmap.blue_max = lTemp / cmap.blue_mult;

      cmap.green_mult = cmap.blue_mult;

      while(cmap.green_mult < lTemp)
      {
        cmap.green_mult <<= 1;
      }

      cmap.green_max = (clrGreen.pixel - cmap.base_pixel)
                     / cmap.green_mult;
    }
  }
  else
  {
    if(clrRed.pixel >= clrGreen.pixel)
    {
      cmap.green_max = clrGreen.pixel - cmap.base_pixel;
      cmap.green_mult = 1;

      cmap.red_mult = 1;
      while(cmap.red_mult < cmap.green_max)
      {
        cmap.red_mult <<= 1;
      }

      lTemp = (clrRed.pixel - cmap.base_pixel);
      cmap.red_max = lTemp / cmap.red_mult;

      cmap.blue_mult = cmap.red_mult;

      while(cmap.blue_mult < lTemp)
      {
        cmap.blue_mult <<= 1;
      }

      cmap.blue_max = (clrBlue.pixel - cmap.base_pixel)
                    / cmap.blue_mult;
    }
    else
    {
      cmap.red_max = clrRed.pixel - cmap.base_pixel;
      cmap.red_mult = 1;

      cmap.green_mult = 1;
      while(cmap.green_mult < cmap.red_max)
      {
        cmap.green_mult <<= 1;
      }

      lTemp = (clrGreen.pixel - cmap.base_pixel);
      cmap.green_max = lTemp / cmap.green_mult;


      cmap.blue_mult = cmap.green_mult;

      while(cmap.blue_mult < lTemp)
      {
        cmap.blue_mult <<= 1;
      }

      cmap.blue_max = (clrBlue.pixel - cmap.base_pixel)
                    / cmap.blue_mult;
    }
  }

  XFreeColors(pDisplay, cmDefault, &clrRed.pixel, 1, 0);
  XFreeColors(pDisplay, cmDefault, &clrGreen.pixel, 1, 0);
  XFreeColors(pDisplay, cmDefault, &clrBlue.pixel, 1, 0);

//  WB_ERROR_PRINT("TEMPORARY:  red: %u,%u   grn: %u,%u   blu: %u,%u\n",
//                 (unsigned int)cmap.red_max, (unsigned int)cmap.red_mult,
//                 (unsigned int)cmap.green_max, (unsigned int)cmap.green_mult,
//                 (unsigned int)cmap.blue_max, (unsigned int)cmap.blue_mult);

  if(pDisplay == WBGetDefaultDisplay())
  {
    memcpy(&cmapDefault, &cmap, sizeof(cmap));
  }

  memcpy(pMap, &cmap, sizeof(cmap));
}


WB_FONTC WBQueryWindowFont(Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry && pEntry->pFont)
  {
    return pEntry->pFont;
  }

  return NULL;
}

WB_FONT WBGetWindowFont(Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry && pEntry->pFont)
  {
    return WBCopyFont(pEntry->pDisplay, pEntry->pFont);
  }

  if(!pDefaultFont)
  {
    WB_ERROR_PRINT("%s - default font is NULL\n", __FUNCTION__);

    return NULL;
  }

  return WBCopyFont(pEntry->pDisplay, pDefaultFont);
}

//XFontSet WBGetWindowFontSet(Window wID)
//{
//  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
//
//  if(pEntry && pEntry->fontSet != None)
//  {
//    return(pEntry->fontSet);
//  }
//
//  if(fontsetDefault == None)
//  {
//    WB_ERROR_PRINT("%s - default font is NULL\n", __FUNCTION__);
//  }
//
//  return(fontsetDefault);  // use global font set
//}

void WBSetWindowClassName(Window wID, const char *szClassName)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry)
  {
    pEntry->szClassName = szClassName;
  }
}

const char *WBGetWindowClassName(Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry)
  {
    return(pEntry->szClassName);
  }

  return(NULL);
}

void *WBGetWindowData(Window wID, int iIndex)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry && iIndex >= 0 && iIndex <= WINDOW_DATA_SIZE)
  {
    return(pEntry->aWindowData[iIndex]);
  }

  return(NULL);
}

// use this to set the cursor without assigning the 'current cursor'
static void __InternalSetWindowCursor(Window wID, int idCursor)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
  Display *pDisplay = pEntry ? pEntry->pDisplay : pDefaultDisplay;
  Cursor curNew = idCursor != -1 ? XCreateFontCursor(pDisplay, idCursor) : None;
  XColor clrF, clrB;

  if(curNew == None && idCursor != -1)
  {
    WB_ERROR_PRINT("ERROR - %s - Cursor ID %d (%xH) returns 'None'\n", __FUNCTION__, idCursor, idCursor);
  }

  // this will work for *ANY* window (assuming default display for unmapped windows)
  // unfortunately it may cause a memory leak for windows that aren't mapped
  if(curNew != None)
    XDefineCursor(pDisplay, wID, curNew);
  else
    XUndefineCursor(pDisplay, wID);

  // and this will manage resources for internally 'known' windows

  if(pEntry)
  {
    if(pEntry->curRecent != None)
      XFreeCursor(pDisplay, pEntry->curRecent);

    pEntry->curRecent = curNew;

#if 1
    if(curNew != None)
    {
      // TODO:  use the default FG and BG colors of the window and
      // change the cursor colors accordingly.  This should force
      // the cursor to change immediately

      // for now it's always white background, black foreground

      bzero(&clrF, sizeof(clrF));
      bzero(&clrB, sizeof(clrB));
      clrB.pixel = /*pEntry->clrFG*/ WhitePixel(pDisplay, DefaultScreen(pDisplay));
      clrF.pixel = /*pEntry->clrBG*/ BlackPixel(pDisplay, DefaultScreen(pDisplay));
      XQueryColor(pDisplay, DefaultColormap(pDisplay, DefaultScreen(pDisplay)), &clrF);
      XQueryColor(pDisplay, DefaultColormap(pDisplay, DefaultScreen(pDisplay)), &clrB);

      XRecolorCursor(pDisplay, curNew, &clrB, &clrF); // this will 'flash' it, kinda
      XRecolorCursor(pDisplay, curNew, &clrF, &clrB); // show NOW
    }
#endif // 0
  }
}

void WBSetWindowDefaultCursor(Window wID, int idStandardCursor)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry)
  {
    pEntry->idDefaultCursor = idStandardCursor;

    if(!pEntry->iWaitCursorCount)               // if we're not currently displaying a wait cursor
      WBSetWindowCursor(wID, idStandardCursor); // change the cursor immediately to this one
  }
}

int WBGetWindowDefaultCursor(Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry)
    return pEntry->idDefaultCursor;

  return WB_DEFAULT_CURSOR;  // the standard default cursor
}

void WBBeginWaitCursor(Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
  Window wIDRoot = 0, wIDParent = 0;
  Window *pwIDChildren = NULL;
  unsigned int u1, nChildren = 0;

  if(pEntry)
  {
    if(!(pEntry->iWaitCursorCount++))
    {
      __InternalSetWindowCursor(wID, WB_WAIT_CURSOR); // change the cursor immediately to the 'watch' cursor

      // also do the same for all of the child windows

      if(XQueryTree(pEntry->pDisplay, wID, &wIDRoot, &wIDParent, &pwIDChildren, &nChildren))
      {
        if(pwIDChildren)
        {
          for(u1=nChildren; u1; u1--) // go backwards
          {
            Window wKid = pwIDChildren[u1 - 1];
            _WINDOW_ENTRY_ *pE = WBGetWindowEntry(wKid);

            if(pE)
            {
              __InternalSetWindowCursor(wKid, WB_WAIT_CURSOR); // all must use the wait cursor now
            }
          }

          XFree(pwIDChildren);
        }
      }
    }
  }
  else
  {
    __InternalSetWindowCursor(wID, WB_WAIT_CURSOR); // change the cursor immediately to the 'watch' cursor
  }
}

void WBEndWaitCursor(Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
  Window wIDRoot = 0, wIDParent = 0;
  Window *pwIDChildren = NULL;
  unsigned int u1, nChildren = 0;


  if(pEntry)
  {
    if(pEntry->iWaitCursorCount <= 1)
    {
      pEntry->iWaitCursorCount = 0;
//      WBRestoreDefaultCursor(wID);
      __InternalSetWindowCursor(wID, pEntry->idCursor);

      // walk child windows, restore THEIR cursors also

      if(XQueryTree(pEntry->pDisplay, wID, &wIDRoot, &wIDParent, &pwIDChildren, &nChildren))
      {
        if(pwIDChildren)
        {
          for(u1=nChildren; u1; u1--) // go backwards
          {
            Window wKid = pwIDChildren[u1 - 1];
            _WINDOW_ENTRY_ *pE = WBGetWindowEntry(wKid);

            if(pE)
            {
              __InternalSetWindowCursor(wKid, pE->idCursor); // restore to what it was
            }
          }

          XFree(pwIDChildren);
        }
      }
    }
    else
    {
      pEntry->iWaitCursorCount--;
    }
  }
  else
  {
    __InternalSetWindowCursor(wID, -1); // change the cursor immediately to the 'watch' cursor
  }
}

void WBSetWindowCursor(Window wID, int idCursor)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry)
  {
    pEntry->idCursor = idCursor;
  }

  __InternalSetWindowCursor(wID, idCursor);
}

void WBRestoreDefaultCursor(Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry)
  {
    pEntry->idCursor = pEntry->idDefaultCursor;
    __InternalSetWindowCursor(wID, pEntry->idDefaultCursor); // restore the cursor immediately
  }
}


// read-only window properties

void WBGetWindowGeom0(Window wID, WB_GEOM *pGeom)  // absolute window geometry (from latest notification)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pGeom)
  {
    if(wID == None) // root window
    {
      WBGetWindowGeom(wID, pGeom);
      return;
    }

    if(!pEntry || (!pEntry->geomAbsolute.width && !pEntry->geomAbsolute.height))
    {
      bzero(pGeom, sizeof(*pGeom));

      Window wIDTemp = wID;

      while(wIDTemp)
      {
        WB_GEOM gm;
        WBGetWindowGeom(wIDTemp, &gm);

        pGeom->x += gm.x;
        pGeom->y += gm.y;

        if(wIDTemp == wID)
        {
          pGeom->width = gm.width;
          pGeom->height = gm.height;
          pGeom->border = gm.border;

          WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Window,
                         "%s - geometry for window %d (%08xH) = %d,%d,%d,%d,%d\n",
                         __FUNCTION__, (int)wID, (int)wID,
                         gm.x, gm.y, gm.width, gm.height, gm.border);
        }
        else
        {
          WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Window,
                         "%s - geometry for parent window %d (%08xH) = %d,%d,%d,%d,%d\n",
                         __FUNCTION__, (int)wIDTemp, (int)wIDTemp,
                         gm.x, gm.y, gm.width, gm.height, gm.border);
        }

        wIDTemp = WBGetParentWindow(wIDTemp);
      }
    }
    else
    {
      memcpy(pGeom, &(pEntry->geomAbsolute), sizeof(*pGeom));
    }
  }
}

void WBGetWindowGeom(Window wID, WB_GEOM *pGeom)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
  Display *pDisp = pEntry ? pEntry->pDisplay : pDefaultDisplay;
  Window winRoot = None;
  unsigned int uiDepth = 0;

  if(!pGeom)
  {
    return;
  }

  bzero(pGeom, sizeof(*pGeom));

  if(wID == None) // I want the root window's geometry, i.e. the screen size
  {
    Window winTemp;

    winRoot = DefaultRootWindow(pDisp);
    if(winRoot == None) // an error
    {
      return; // just leave it zero'd
    }

    BEGIN_XCALL_DEBUG_WRAPPER
    XSync(pDisp, 0);
    XGetGeometry(pDisp, winRoot, &winTemp,
                 &(pGeom->x), &(pGeom->y),
                 &(pGeom->width), &(pGeom->height),
                 &(pGeom->border), &uiDepth);
    END_XCALL_DEBUG_WRAPPER

    return;
  }

  if(WB_LIKELY(pEntry) &&
     WB_UNLIKELY(WB_IS_WINDOW_DESTROYED(*pEntry) || WB_IS_WINDOW_BEING_DESTROYED(*pEntry)))
  {
    WB_WARN_PRINT("%s:%d - %d (%08xH) NOT mapped\n",
                  __FUNCTION__, __LINE__, (int)wID, (int)wID);
    return;
  }

  if(!pEntry)
  {
    WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Window,
                   "%s:%d - pEntry is NULL, %d (%08xH) may NOT be mapped\n",
                   __FUNCTION__, __LINE__, (int)wID, (int)wID);
  }
  else if(!WB_IS_WINDOW_MAPPED(*pEntry) &&
          pEntry->geomAbsolute.width > 0 && pEntry->geomAbsolute.height > 0)
  {
    // if not mapped, return the best guess geometry

    pGeom->x = 0; // pEntry->geomAbsolute.x;
    pGeom->y = 0; // pEntry->geomAbsolute.y;
    pGeom->width = pEntry->geomAbsolute.width;
    pGeom->height = pEntry->geomAbsolute.height;
    pGeom->border = pEntry->geomAbsolute.border;

    WB_ERROR_PRINT("TEMPORARY:  %s - unmapped window geometry %d, %d, %d, %d\n",
                   __FUNCTION__, pGeom->x, pGeom->y, pGeom->width, pGeom->height);

    return;
  }
//  else if(!WB_IS_WINDOW_MAPPED(*pEntry))
//  {
//    WB_ERROR_PRINT("TEMPORARY:  %s - unmapped window, no 'absolute' GEOM available (pre 'X' calls)\n", __FUNCTION__);
//  }

  BEGIN_XCALL_DEBUG_WRAPPER
  XSync(pDisp, 0);
  XGetGeometry(pDisp, wID, &winRoot,
               &(pGeom->x), &(pGeom->y),
               &(pGeom->width), &(pGeom->height),
               &(pGeom->border), &uiDepth);
  END_XCALL_DEBUG_WRAPPER

//  if(pEntry && !WB_IS_WINDOW_MAPPED(*pEntry))
//  {
//    WB_ERROR_PRINT("TEMPORARY:  %s - unmapped window, no 'absolute' GEOM available (post 'X' calls)\n", __FUNCTION__);
//  }

//fprintf(stderr, "XGetGeometry: window %08xH  %d, %d, %d, %d\n",
//        wID, pGeom->x, pGeom->y, pGeom->width, pGeom->height);

#if 0 /* 1 */
  {
    XWindowAttributes xwa;      /* getting size of window, etc. */
    memset(&xwa, 0, sizeof(xwa));
    if(XGetWindowAttributes(pDisp, winRoot, &xwa))
    {
      WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Window,
                     "%s - window %08xH  %d, %d, %d, %d\n",
                     __FUNCTION__, winRoot, xwa.x, xwa.y, xwa.width, xwa.height);
//      pGeom->x = xwa.x;
//      pGeom->y = xwa.y;
//      pGeom->width = xwa.width;
//      pGeom->height = xwa.height;
//      pGeom->border = xwa.border_width;
    }
  }
#endif // 0,1
}

void WBGetWindowGeom2(Window wID, WB_GEOM *pGeom)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
  Display *pDisp = pEntry ? pEntry->pDisplay : pDefaultDisplay;
  Window winRoot = 0, wParent;
  unsigned int uiDepth = 0;
  WB_GEOM geom;

  bzero(pGeom, sizeof(*pGeom));

  if(wID == None) // root window
  {
    WBGetWindowGeom(wID, pGeom);
    return;
  }

  if(WB_LIKELY(pEntry) &&
     WB_UNLIKELY(WB_IS_WINDOW_DESTROYED(*pEntry) || WB_IS_WINDOW_BEING_DESTROYED(*pEntry)))
  {
    WB_WARN_PRINT("%s:%d - %d (%08xH) NOT mapped\n",
                  __FUNCTION__, __LINE__, (int)wID, (int)wID);
    return;
  }
  else if(!WB_IS_WINDOW_MAPPED(*pEntry) &&
          pEntry->geomAbsolute.width > 0 && pEntry->geomAbsolute.height > 0)
  {
    // if not mapped, return the best guess geometry

    pGeom->x = pEntry->geomAbsolute.x;
    pGeom->y = pEntry->geomAbsolute.y;
    pGeom->width = pEntry->geomAbsolute.width;
    pGeom->height = pEntry->geomAbsolute.height;
    pGeom->border = pEntry->geomAbsolute.border;

    WB_ERROR_PRINT("TEMPORARY:  %s - unmapped window geometry %d, %d, %d, %d\n",
                   __FUNCTION__, pGeom->x, pGeom->y, pGeom->width, pGeom->height);

    return;
  }
//  else if(!WB_IS_WINDOW_MAPPED(*pEntry))
//  {
//    WB_ERROR_PRINT("TEMPORARY:  %s - unmapped window, no 'absolute' GEOM available\n", __FUNCTION__);
//  }


  BEGIN_XCALL_DEBUG_WRAPPER
  XGetGeometry(pDisp, wID, &winRoot,
               &(pGeom->x), &(pGeom->y),
               &(pGeom->width), &(pGeom->height),
               &(pGeom->border), &uiDepth);
  END_XCALL_DEBUG_WRAPPER

  WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Window,
                 "%s - geometry for window %d (%08xH) = %d,%d,%d,%d,%d\n",
                 __FUNCTION__, (int)wID, (int)wID,
                 pGeom->x, pGeom->y, pGeom->width, pGeom->height, pGeom->border);

  wParent = WBGetParentWindow(wID);

  while(wParent > 0 && winRoot != wParent)
  {
    _WINDOW_ENTRY_ *pParentEntry = WBGetWindowEntry(wParent);

    if(WB_LIKELY(pParentEntry) &&
       WB_UNLIKELY(WB_IS_WINDOW_DESTROYED(*pParentEntry) || WB_IS_WINDOW_BEING_DESTROYED(*pParentEntry)))
    {
      WB_WARN_PRINT("%s:%d - %d (%08xH) NOT mapped\n",
                    __FUNCTION__, __LINE__, (int)wID, (int)wID);
      continue;
    }

    bzero(&geom, sizeof(geom));

    BEGIN_XCALL_DEBUG_WRAPPER
    XGetGeometry(pDisp, wParent, &winRoot,  // assumes parent windows have same display, which is reasonable
                 &geom.x, &geom.y,
                 &geom.width, &geom.height,
                 &geom.border, &uiDepth);
    END_XCALL_DEBUG_WRAPPER

    WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Window,
                   "%s - geometry for parent window %d (%08xH) = %d,%d,%d,%d,%d\n",
                   __FUNCTION__, (int)wParent, (int)wParent,
                   geom.x, geom.y, geom.width, geom.height, geom.border);

    pGeom->x += geom.x;
    pGeom->y += geom.y;

    wParent = WBGetParentWindow(wParent);
  }
}

void WBGetWindowRect(Window wID, WB_RECT *pRect)
{
  WB_GEOM geom;

  if(!pRect)
    return;

  WBGetWindowGeom(wID, &geom);

  pRect->left = geom.x; // + geom.border;
  pRect->top = geom.y; // + geom.border;                      // TODO:  verify
  pRect->right = pRect->left + geom.width + 2 * geom.border;
  pRect->bottom = pRect->top + geom.height + 2 * geom.border;  // TODO:  verify
}

void WBGetClientRect(Window wID, WB_RECT *pRect)
{
  WB_GEOM geom;

  if(!pRect)
    return;

  WBGetWindowGeom(wID, &geom);

  // NOTE:  GEOM 'border' isn't correct unless I'm trying to calculate
  //        the size of the border surrounding a window.  the client rect
  //        will always have 0,0 as its upper left corner

  pRect->left = 0;// geom.border; // 0
  pRect->top = 0; // geom.border; // 0
  pRect->right = geom.width;
  pRect->bottom = geom.height;
}

void WBXlatCoordPoint(Window wIDSrc, int iXSrc, int iYSrc, Window wIDDest, int *piXDest, int *piYDest)
{
WB_GEOM gOrig, gXlat;

  if(wIDSrc == wIDDest)
  {
    if(piXDest)
      *piXDest = iXSrc;
    if(piYDest)
      *piYDest = iYSrc;
    return;
  }

  if(wIDSrc != 0) // not "root window"
    WBGetWindowGeom0(wIDSrc, &gOrig);
  else
    bzero(&gOrig, sizeof(gOrig));

  if(wIDDest != 0)
    WBGetWindowGeom0(wIDDest, &gXlat);
  else
    bzero(&gXlat, sizeof(gXlat));

//WB_WARN_PRINT("TEMPORARY:  xlat %d,%d via %d,%d %d,%d\n",
//              iXSrc, iYSrc, gOrig.x, gOrig.y, gXlat.x, gXlat.y);

  if(piXDest)
    *piXDest = iXSrc + gOrig.x // xlat relative to absolute position
             - gXlat.x;        // new relative position from absolute position

  if(piYDest)
    *piYDest = iYSrc + gOrig.y
             - gXlat.y;
}

void WBXlatCoordGeom(Window wIDSrc, const WB_GEOM *pGeomSrc, Window wIDDest, WB_GEOM *pGeomDest)
{
WB_GEOM gOrig, gXlat;

  if(!pGeomSrc || !pGeomDest)
    return;

  if(wIDSrc == wIDDest)
  {
    memcpy(pGeomDest, pGeomSrc, sizeof(*pGeomDest));
    return;
  }

  if(wIDSrc != 0) // not "root window"
    WBGetWindowGeom(wIDSrc, &gOrig);
  else
    bzero(&gOrig, sizeof(gOrig));

  if(wIDDest != 0)
    WBGetWindowGeom(wIDDest, &gXlat);
  else
    bzero(&gXlat, sizeof(gXlat));

  pGeomDest->x = pGeomSrc->x + gOrig.x - gXlat.x;
  pGeomDest->y = pGeomSrc->y + gOrig.y - gXlat.y;
  pGeomDest->width = pGeomSrc->width;
  pGeomDest->height = pGeomSrc->height;
  pGeomDest->border = pGeomSrc->border;
}

void WBXlatCoordRect(Window wIDSrc, const WB_RECT *pRectSrc, Window wIDDest, WB_RECT *pRectDest)
{
WB_GEOM geomSrc, geomDest;

  if(!pRectSrc || !pRectDest)
    return;

  if(wIDSrc == wIDDest)
  {
    memcpy(pRectDest, pRectSrc, sizeof(*pRectDest));
    return;
  }

  geomSrc.x = pRectSrc->left;
  geomSrc.y = pRectSrc->top;
  geomSrc.width = pRectSrc->right - geomSrc.x;
  geomSrc.height = pRectSrc->bottom - geomSrc.y;
  geomSrc.border = 0;

  WBXlatCoordGeom(wIDSrc, &geomSrc, wIDDest, &geomDest);

  pRectDest->left = geomDest.x;
  pRectDest->right = geomDest.y;
  pRectDest->right = geomDest.width + geomDest.x;
  pRectDest->bottom = geomDest.y + geomDest.height;
}

int WBPointInWindow(Window wIDRef, int iX, int iY, Window wIDQuery)
{
WB_RECT rctDest;

  if(wIDRef != wIDQuery)
    WBXlatCoordPoint(wIDRef, iX, iY, wIDQuery, &iX, &iY);

  WBGetWindowRect(wIDQuery, &rctDest);

  return(iX >= rctDest.left && iX < rctDest.right
         && iY >= rctDest.top && iY < rctDest.bottom);
}

// keyboard mappings

int WBKeyEventProcessKey(const XKeyEvent *pEvent, char *pBuf, int *pcbLen, int *piAltCtrlShift)
{
KeySym ks;
int cRval = 0, cbLen, cbLen0 = pcbLen ? *pcbLen : 1;
int iACSMask = ShiftMask | ControlMask | Mod1Mask /* | Mod2Mask | Mod3Mask | Mod4Mask | Mod5Mask */;
int bKeySym = 0;

  // extract as much information from this keystroke as possible.

  iACSMask &= ((XKeyEvent *)pEvent)->state;

  if(piAltCtrlShift)
  {
    *piAltCtrlShift = 0;
  }

  if(!pEvent)
  {
    return -1;
  }

  if(pBuf)
  {
    cbLen = XLookupString((XKeyEvent *)pEvent, pBuf, cbLen0, &ks, NULL);

    if((int)ks == XK_Delete || (int)ks == XK_KP_Delete)
    {
      cbLen = 0;  // force this for the delete key - sometimes it translates
    }

    // TODO:  force other keys to use keycodes?  maybe backspace, escape, ???

    if(cbLen <= 0)
    {
      *pBuf = 0;
      bKeySym = 1;
      cbLen = 0;  // just in case
      cRval = (int)ks; // return the keysym code
    }
    else
    {
      if(cbLen < cbLen0)
      {
        pBuf[cbLen] = 0;
      }

      cRval = *pBuf; // always (for now)
    }
    if(pcbLen)
    {
      *pcbLen = cbLen;
    }
  }
  else
  {
    int tbuf[8]; // note:  must be int aligned, that's why

    cbLen = XLookupString((XKeyEvent *)pEvent, (char *)tbuf, sizeof(tbuf) - 1, &ks, NULL);

    if(pcbLen)
    {
      *pcbLen = cbLen;  // calculates actual length this way
    }

    if(cbLen <= 0)
    {
      cRval = ks;  // use the scan code
      bKeySym = 1;
    }
    else if(cbLen == 1)
    {
      cRval = *((unsigned char *)tbuf);
    }
    else if(cbLen == 2)
    {
      cRval = *((unsigned short *)tbuf);
    }
    else if(cbLen == 4)
    {
      cRval = *((unsigned int *)tbuf);
    }
    else
    {
      cRval = *((unsigned char *)tbuf); // for now
    }
  }

  if(piAltCtrlShift)
  {
    *piAltCtrlShift = (bKeySym ? WB_KEYEVENT_KEYSYM : 0)
                    | ((iACSMask & Mod1Mask) ? WB_KEYEVENT_ALT : 0)
                    | ((iACSMask & ControlMask) ? WB_KEYEVENT_CTRL : 0)
                    | ((iACSMask & ShiftMask) ? WB_KEYEVENT_SHIFT : 0);
  }

  return cRval;
}



// parent-child relationships

static Window __internal_GetParent(Display *pDisplay, Window wID, Window *pwRoot)
{
Window wIDRoot = 0, wIDParent = 0;
Window *pwIDChildren = NULL;
unsigned int nChildren = 0;

  // TODO:  if parent is desktop, return 'None' ?

  if(XQueryTree(pDisplay, wID, &wIDRoot, &wIDParent, &pwIDChildren, &nChildren))
  {
    if(pwIDChildren)
      XFree(pwIDChildren);
  }

  if(pwRoot)
  {
    *pwRoot = wIDRoot;
  }

  return wIDParent;
}

Window WBGetParentWindow(Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
  Display *pDisplay = pEntry ? pEntry->pDisplay : pDefaultDisplay;
  Window wIDRoot = 0, wIDParent = 0;
  Window *pwIDChildren = NULL;
  unsigned int nChildren = 0;

  if(pEntry && pEntry->wParent > 0)
  {
    return pEntry->wParent;
  }

  if(XQueryTree(pDisplay, wID, &wIDRoot, &wIDParent, &pwIDChildren, &nChildren))
  {
    if(pwIDChildren)
      XFree(pwIDChildren);
  }

  if(wIDParent > 0 && pEntry)
  {
    pEntry->wParent = wIDParent;  // cache it
  }

  return wIDParent;
}

void WBSetParentWindow(Window wID, Window wIDParent)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry)
    pEntry->wParent = wIDParent;
}

int WBReparentWindow(Window wID, Window wIDParent, int iX, int iY)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
  Display *pDisplay = pDefaultDisplay;
  int iRval;

  if(pEntry)
  {
    pDisplay = pEntry->pDisplay;
  }

  iRval = XReparentWindow(pDisplay, wID, wIDParent, iX, iY);

  if(iRval < 0 && pEntry)  // TODO: verify if non-zero or negative is error
  {
    pEntry->wParent = wIDParent;
  }

  return iRval;
}

int WBIsChildWindow(Window wIDParent, Window wIDChild)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wIDParent);
  _WINDOW_ENTRY_ *pEntry2 = WBGetWindowEntry(wIDChild);
  Display *pDisplay = pDefaultDisplay;
  Window wIDRoot = 0, wIDP = 0;
  Window *pwIDChildren = NULL;
  int iRval = 0;
  unsigned int i1, nChildren = 0;


  if(wIDParent == wIDChild)
    return 0;

  if(pEntry2 && pEntry2->wParent > 0)
  {
    return  pEntry2->wParent == wIDParent ? 1 : 0;
  }

//  if(!pEntry2)
//  {
//    fprintf(stderr, "WARNING: wIDChild %d (%08xH) has no entry\n", wIDChild, wIDChild);
//
//    if(!WBIsChildWindow(DefaultRootWindow(pDisplay), wIDChild))
//      return 0;  // not a valid window - I don't want crashes, so I do this
//  }

  if(pEntry)
  {
    if(WB_IS_WINDOW_DESTROYED(*pEntry) || WB_IS_WINDOW_UNMAPPED(*pEntry))
      return 0;  // can't determine parent/child relationship

    // TODO: if the window has been unmapped, I may get an error
    //       so use some kind of flag to determine if the window was unmapped...

    pDisplay = pEntry->pDisplay;
  }
  else
  {
    // this window may be invalid, so check for that case
    if(!WBIsChildWindow(DefaultRootWindow(pDisplay), wIDParent))
      return 0;  // not a valid window - I don't want crashes, so I do this
  }

  if(XQueryTree(pDisplay, wIDParent, &wIDRoot, &wIDP, &pwIDChildren, &nChildren))
  {
    for(i1=0; pwIDChildren && i1 < nChildren; i1++)
    {
      if(pwIDChildren[i1] == wIDChild)
      {
        iRval = 1;
        break;
      }
    }

    // recurse children and get their children (etc.)
    for(i1=0; !iRval && pwIDChildren && i1 < nChildren; i1++)
    {
      iRval = WBIsChildWindow(pwIDChildren[i1], wIDChild);  // recurse to the bottom
    }

    if(pwIDChildren)
      XFree(pwIDChildren);

    return iRval;
  }

#if 0
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wIDChild);
  Display *pDisplay = pDefaultDisplay;
  Window wIDRoot = 0, wIDP = 0;
  Window *pwIDChildren = NULL;
  unsigned int i1, nChildren = 0;

  if(wIDParent == wIDChild)
    return 0;

  if(pEntry)
    pDisplay = pEntry->pDisplay;

  if(XQueryTree(pDisplay, wIDChild, &wIDRoot, &wIDP, &pwIDChildren, &nChildren))
  {
    if(pwIDChildren)
      XFree(pwIDChildren);

    if(wIDRoot == wIDParent ||  // check for parent = root
       wIDP == wIDParent)       // and a direct parent/child relationship
    {
      return 1;
    }
    else if(!wIDP || wIDP == wIDRoot)
    {
      return 0;
    }
    else
    {
      return WBIsChildWindow(wIDParent, wIDP);
    }
  }
#endif // 0
  return 0;
}


/**********************************************************************/
/*                                                                    */
/*                   basic menu helper functions                      */
/*                                                                    */
/**********************************************************************/

void WBRegisterMenuCallback(Window wID, WBWinEvent pMenuCallback)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry)
  {
    pEntry->pMenuCallback = pMenuCallback;
  }
  else
  {
    WB_WARN_PRINT("%s - NULL pEntry wID = %d (%08xH)\n", __FUNCTION__, (int)wID, (int)wID);
  }
}

void WBAddMenuWindow(Window wID, Window wIDMenu)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry)
  {
    // for now there is only one

    pEntry->wIDMenu = wIDMenu;
  }
  else
  {
    WB_WARN_PRINT("%s - NULL pEntry wID = %d (%08xH)\n", __FUNCTION__, (int)wID, (int)wID);
  }
}

Window WBGetMenuWindow(Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry)
  {
    return pEntry->wIDMenu;
  }
  else
  {
    WB_WARN_PRINT("%s - NULL pEntry wID = %d (%08xH)\n", __FUNCTION__, (int)wID, (int)wID);
  }

  return 0;
}

void WBRemoveMenuWindow(Window wID, Window wIDMenu)
{
  int i1;
  _WINDOW_ENTRY_ *pEntry = NULL;


  if(wID == -1)  // meaning ALL of them
  {
    for(i1=0; i1 <= WINDOW_ENTRY_ARRAY_MAX; i1++)
    {
      if(sWBHashEntries[i1].wIDMenu == wIDMenu)
      {
        sWBHashEntries[i1].wIDMenu = 0;
      }
    }

    return;
  }

  pEntry = WBGetWindowEntry(wID);
  if(pEntry)
  {
    if(pEntry->wIDMenu == wIDMenu)
    {
      pEntry->wIDMenu = 0;
    }
  }
  else
  {
    WB_WARN_PRINT("%s - NULL pEntry wID = %d (%08xH)\n", __FUNCTION__, (int)wID, (int)wID);
  }
}



/**********************************************************************/
/*                                                                    */
/*                expose event (aka 'paint') helpers                  */
/*                                                                    */
/**********************************************************************/

void WBUpdateWindow(Window wID)
{
  XRectangle xrct;
  XExposeEvent evt;
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  BEGIN_XCALL_DEBUG_WRAPPER
  XFlush(WBGetWindowDisplay(wID));

  if(pEntry)
  {
    if(pEntry->rgnClip == None ||
       XEmptyRegion(pEntry->rgnClip))
    {
#ifndef NO_DEBUG
      if(pEntry->rgnClip == None) // should not happen in this case
      {
        WB_ERROR_PRINT("ERROR:  %s - clipping region is 'None'\n", __FUNCTION__);
      }
      else
      {
        XClipBox(pEntry->rgnClip, &xrct);

        if(xrct.width != 0 && xrct.height != 0)
        {
          WB_ERROR_PRINT("ERROR:  %s - clipping region is 'empty', but bounds = %d, %d, %d, %d\n", __FUNCTION__,
                         xrct.x, xrct.y, xrct.width, xrct.height);

//          WBDebugDumpRegion(pEntry->rgnClip, 1);
        }
      }
#endif // NO_DEBUG
    }
    else
    {
      XClipBox(pEntry->rgnClip, &xrct);
      // generate an 'expose' event and post it

      bzero(&evt, sizeof(evt));
      evt.type = Expose;
      evt.display = pEntry->pDisplay;
      evt.window = wID;
      evt.x = xrct.x;
      evt.y = xrct.y;
      evt.width = xrct.width;
      evt.height = xrct.height;

      WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_Expose,
                     "%s.%d creating/handling Expose event, %d,%d,%d,%d\n",
                     __FUNCTION__, __LINE__, evt.x, evt.y, evt.width, evt.height);

      WBProcessExposeEvent(&evt); // better than posting it (this consolidates every Expose event for that window)
                                  // NOTE:  it also calls WBInvalidateGeom() internally but NOT 'WBUpdateWindow()'
                                  //        It also checks the message queue an combines *ALL* expose events that are waiting
    }

  }
  END_XCALL_DEBUG_WRAPPER
}

void WBUpdateWindowImmediately(Window wID)
{
  XRectangle xrct;
  XExposeEvent evt;
  XEvent evt0; // NOTE if it's too small I get a stack overflow so MUST be 'XEvent'
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

#define WB_IS_WINDOW_UNMAPPED(X) ((X).iWindowState == WB_WINDOW_UNMAPPED || (X).iWindowState == WB_WINDOW_SET_FOCUS_ON_MAP)
#define WB_IS_WINDOW_MAPPED(X) ((X).iWindowState == WB_WINDOW_MAPPED)
#define WB_IS_WINDOW_BEING_DESTROYED(X) ((X).iWindowState == WB_WINDOW_DESTROYING)
#define WB_IS_WINDOW_DESTROYED(X) ((X).iWindowState == WB_WINDOW_DESTROYED || (X).iWindowState == WB_WINDOW_DELETE)

  BEGIN_XCALL_DEBUG_WRAPPER
  XFlush(WBGetWindowDisplay(wID));
  END_XCALL_DEBUG_WRAPPER

  if(pEntry &&
     WB_IS_WINDOW_MAPPED(*pEntry) &&
     pEntry->rgnClip != None && !XEmptyRegion(pEntry->rgnClip))
  {
    BEGIN_XCALL_DEBUG_WRAPPER
    XClipBox(pEntry->rgnClip, &xrct);
    END_XCALL_DEBUG_WRAPPER

    // generate an 'expose' event and post it

    bzero(&evt, sizeof(evt));
    evt.type = Expose;
    evt.display = pEntry->pDisplay;
    evt.window = wID;
    evt.x = xrct.x;
    evt.y = xrct.y;
    evt.width = xrct.width;
    evt.height = xrct.height;

    WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_Expose,
                   "%s.%d creating/handling Expose event, %d,%d,%d,%d\n",
                   __FUNCTION__, __LINE__, evt.x, evt.y, evt.width, evt.height);

    WBInternalProcessExposeEvent(&evt); // better than posting it (this consolidates every Expose event for that window)
                                        // NOTE:  it also calls WBInvalidateGeom() internally but NOT 'WBUpdateWindow()'

    if(__WBNextPaintEvent(pEntry->pDisplay, &evt0, wID) >= 0) // grab the 'combined' paint event from the queue
    {
      WBWindowDispatch(wID, &evt0); // send "combined painting" message synchronously
    }
    else
    {
      WBWindowDispatch(wID, (XEvent *)&evt); // send message synchronously
    }
  }
}

void WBInvalidateGeom(Window wID, const WB_GEOM *pGeom, int bPaintNow)
{
  WB_GEOM geom;
  XRectangle xrct;
#ifndef NO_DEBUG
  XRectangle xrct2;
#endif // NO_DEBUG

  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  BEGIN_XCALL_DEBUG_WRAPPER
  XFlush(WBGetWindowDisplay(wID));

  if(pEntry)
  {
    if(!pGeom)
    {
      WBGetWindowGeom(wID, &geom);
      geom.x = geom.y = geom.border; // always use coordinates relative to window origin (0,0)
      pGeom = &geom;

      WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_Expose,
                     "%s.%d - NULL pGeom, %d,%d,%d,%d\n", __FUNCTION__, __LINE__,
                     pGeom->x, pGeom->y, pGeom->width, pGeom->height);
    }
    else
    {
      WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_Expose,
                     "%s.%d - %d,%d,%d,%d\n", __FUNCTION__, __LINE__,
                     pGeom->x, pGeom->y, pGeom->width, pGeom->height);
    }

    // NOTE:  XRectangle doesn't encompass the full range of x,y,width,height - limited to 16-bit values

    xrct.x = (short)pGeom->x;
    xrct.y = (short)pGeom->y;
    xrct.width = (unsigned short)pGeom->width;
    xrct.height = (unsigned short)pGeom->height;

    if(!pEntry->rgnClip)
    {
      pEntry->rgnClip = XCreateRegion();
    }

    if(pEntry->rgnClip)
    {
      XUnionRectWithRegion(&xrct, pEntry->rgnClip, pEntry->rgnClip);

      WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_Expose,
                     "%s.%d - resulting invalid rect: %d,%d,%d,%d\n", __FUNCTION__, __LINE__,
                     xrct.x, xrct.y, xrct.width, xrct.height);

      if(WBCheckDebugLevel(DebugLevel_Medium | DebugSubSystem_Expose))
      {
        XRectangle xrct;

        BEGIN_XCALL_DEBUG_WRAPPER
        XClipBox(pEntry->rgnClip, &xrct);
        END_XCALL_DEBUG_WRAPPER

        WB_ERROR_PRINT("%s.%d - Bounding rectangle of new invalid region: %d, %d, %d, %d\n",
                       __FUNCTION__, __LINE__, xrct.x, xrct.y, xrct.width, xrct.height);

//        WBDebugDumpRegion(pEntry->rgnClip, 1);
      }

      if(bPaintNow)
      {
        WBUpdateWindow(wID);
      }
    }
  }
  END_XCALL_DEBUG_WRAPPER
}

void WBInvalidateRegion(Window wID, Region rgn, int bPaintFlag)
{
//  WB_GEOM geom;

  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(rgn == None)
  {
    WBInvalidateGeom(wID, NULL, bPaintFlag);
    return;
  }

  BEGIN_XCALL_DEBUG_WRAPPER
  XFlush(WBGetWindowDisplay(wID));
  END_XCALL_DEBUG_WRAPPER

  if(pEntry)
  {
    if(!pEntry->rgnClip)
    {
      pEntry->rgnClip = XCreateRegion();
    }

    if(pEntry->rgnClip)
    {
      BEGIN_XCALL_DEBUG_WRAPPER
      XUnionRegion(rgn, pEntry->rgnClip, pEntry->rgnClip);
      END_XCALL_DEBUG_WRAPPER

      if(bPaintFlag)
      {
        WBUpdateWindow(wID);
      }

      if(WBCheckDebugLevel(DebugLevel_Medium | DebugSubSystem_Expose))
      {
        XRectangle xrct;

        BEGIN_XCALL_DEBUG_WRAPPER
        XClipBox(pEntry->rgnClip, &xrct);
        END_XCALL_DEBUG_WRAPPER

        // use WB_ERROR_PRINT since it avoids the test for debug level
        WB_ERROR_PRINT("%s.%d - Bounding rectangle of new invalid region: %d, %d, %d, %d\n",
                       __FUNCTION__, __LINE__, xrct.x, xrct.y, xrct.width, xrct.height);

//        WBDebugDumpRegion(pEntry->rgnClip, 1);
      }
    }
    else
    {
      WB_ERROR_PRINT("%s.%d - unable to create clipping region\n", __FUNCTION__, __LINE__);
    }
  }
}

void WBValidateGeom(Window wID, const WB_GEOM *pGeom)
{
//  WB_GEOM geom;
  Region rgnTemp;
  XRectangle xrct;
  _WINDOW_ENTRY_ *pEntry;

  pEntry = WBGetWindowEntry(wID);

  BEGIN_XCALL_DEBUG_WRAPPER
  XFlush(WBGetWindowDisplay(wID));
  END_XCALL_DEBUG_WRAPPER

  if(pEntry)
  {
    if(!pEntry->rgnClip)
    {
      pEntry->rgnClip = XCreateRegion(); // put an empty one there

      return;
    }

    if(!pGeom) // validate everything
    {
      if(pEntry->rgnClip)
      {
        BEGIN_XCALL_DEBUG_WRAPPER
        XDestroyRegion(pEntry->rgnClip);
        END_XCALL_DEBUG_WRAPPER
      }

      pEntry->rgnClip = XCreateRegion(); // put an empty one there

      return;
    }

    xrct.x = (short)pGeom->x;
    xrct.y = (short)pGeom->y;
    xrct.width = (unsigned short)pGeom->width;
    xrct.height = (unsigned short)pGeom->height;

    BEGIN_XCALL_DEBUG_WRAPPER
    rgnTemp = XCreateRegion();
    END_XCALL_DEBUG_WRAPPER

    if(!rgnTemp)
    {
      return; // oops (error)
    }

    BEGIN_XCALL_DEBUG_WRAPPER
    XUnionRectWithRegion(&xrct, rgnTemp, rgnTemp);
    XSubtractRegion(rgnTemp, pEntry->rgnClip, pEntry->rgnClip);

    XDestroyRegion(rgnTemp);

    if(XEmptyRegion(pEntry->rgnClip)) // if it's empty, destroy it
    {
      // now I leave the empty region alone
    }

    END_XCALL_DEBUG_WRAPPER
  }
}

void WBValidateRegion(Window wID, Region rgn)
{
  _WINDOW_ENTRY_ *pEntry;

  pEntry = WBGetWindowEntry(wID);

  BEGIN_XCALL_DEBUG_WRAPPER
  XFlush(WBGetWindowDisplay(wID));
  END_XCALL_DEBUG_WRAPPER

  if(pEntry)
  {
    if(!pEntry->rgnClip)
    {
      pEntry->rgnClip = XCreateRegion(); // put an empty one there

      return;
    }

    if(rgn == None) // validate everything
    {
      if(pEntry->rgnClip)
      {
        BEGIN_XCALL_DEBUG_WRAPPER
        XDestroyRegion(pEntry->rgnClip);
        END_XCALL_DEBUG_WRAPPER
      }

      pEntry->rgnClip = XCreateRegion(); // put an empty one there

      return;
    }

    BEGIN_XCALL_DEBUG_WRAPPER
    XSubtractRegion(rgn, pEntry->rgnClip, pEntry->rgnClip);
    if(XEmptyRegion(pEntry->rgnClip))
    {
      // now I leave the empty region alone
    }
    END_XCALL_DEBUG_WRAPPER
  }
}

Region WBGetInvalidRegion(Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  BEGIN_XCALL_DEBUG_WRAPPER
  XFlush(WBGetWindowDisplay(wID));
  END_XCALL_DEBUG_WRAPPER

  if(pEntry && pEntry->rgnClip)
  {
    int iRet;

    BEGIN_XCALL_DEBUG_WRAPPER
    iRet = XEmptyRegion(pEntry->rgnClip);
    END_XCALL_DEBUG_WRAPPER

    if(iRet)
    {
      return None;
    }
    else
    {
      Region rgnRval = XCreateRegion();

      if(rgnRval == None)
      {
        WB_ERROR_PRINT("ERROR:  %s - no region created\n", __FUNCTION__);
      }
      else
      {
        BEGIN_XCALL_DEBUG_WRAPPER
        XUnionRegion(pEntry->rgnClip, rgnRval, rgnRval);
        END_XCALL_DEBUG_WRAPPER
      }

      return rgnRval;
    }
  }

  return None;
}

Region WBGetPaintRegion(Window wID)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  BEGIN_XCALL_DEBUG_WRAPPER
  XFlush(WBGetWindowDisplay(wID));
  END_XCALL_DEBUG_WRAPPER

  if(pEntry && pEntry->rgnPaint)
  {
    Region rgnRval = XCreateRegion();

    if(rgnRval == None)
    {
      WB_ERROR_PRINT("ERROR:  %s - no region created\n", __FUNCTION__);
    }
    else
    {
      BEGIN_XCALL_DEBUG_WRAPPER
      XUnionRegion(pEntry->rgnPaint, rgnRval, rgnRval);
      END_XCALL_DEBUG_WRAPPER
    }

    return rgnRval;
  }

  return None;
}

Region WBCopyRegion(Region rgnSource)
{
Region rgnRval;

// * NOTE * this may have been a valid test at one time, but NOW it fails to work in Linux
//  if(((CARD32)(intptr_t)rgnSource) & 0xe0000000) // see man page for XGetGCValues and the implication of invalid XIDs
//  {
//    WB_ERROR_PRINT("ERROR:  %s - invalid source region %d (%08xH), no region created\n",
//                   __FUNCTION__, (int)(intptr_t)rgnSource, (int)(intptr_t)rgnSource);
//
//    return NULL;
//  }

  BEGIN_XCALL_DEBUG_WRAPPER
  rgnRval = XCreateRegion();
  END_XCALL_DEBUG_WRAPPER

  if(rgnRval == None)
  {
    WB_ERROR_PRINT("ERROR:  %s - unable to create region\n", __FUNCTION__);
  }
  else
  {
    BEGIN_XCALL_DEBUG_WRAPPER
    XUnionRegion(rgnSource, rgnRval, rgnRval);
    END_XCALL_DEBUG_WRAPPER
  }

  return rgnRval;
}

Region WBRectToRegion(const WB_RECT *pRect)
{
XRectangle xrct;
Region rgnRval;

  if(!pRect)
  {
    return None;
  }

  BEGIN_XCALL_DEBUG_WRAPPER
  rgnRval = XCreateRegion();
  END_XCALL_DEBUG_WRAPPER

  if(rgnRval == None)
  {
    WB_ERROR_PRINT("ERROR:  %s - no region created\n", __FUNCTION__);
  }
  else
  {
    xrct.x = (short)pRect->left;
    xrct.y = (short)pRect->top;
    xrct.width = (unsigned short)(pRect->right - pRect->left);
    xrct.height = (unsigned short)(pRect->bottom - pRect->top);

    BEGIN_XCALL_DEBUG_WRAPPER
    XUnionRectWithRegion(&xrct, rgnRval, rgnRval);
    END_XCALL_DEBUG_WRAPPER
  }

  return rgnRval;
}

Region WBGeomToRegion(const WB_GEOM *pGeom)
{
XRectangle xrct;
Region rgnRval;

  if(!pGeom)
  {
    return None;
  }

  BEGIN_XCALL_DEBUG_WRAPPER
  rgnRval = XCreateRegion();
  END_XCALL_DEBUG_WRAPPER

  if(rgnRval == None)
  {
    WB_ERROR_PRINT("ERROR:  %s - no region created\n", __FUNCTION__);
  }
  else
  {
    xrct.x = (short)pGeom->x;
    xrct.y = (short)pGeom->y;
    xrct.width = (unsigned short)pGeom->width;
    xrct.height = (unsigned short)pGeom->height;

    BEGIN_XCALL_DEBUG_WRAPPER
    XUnionRectWithRegion(&xrct, rgnRval, rgnRval);
    END_XCALL_DEBUG_WRAPPER
  }

  return rgnRval;
}

// paint helpers

WBGC WBBeginPaint(Window wID, XExposeEvent *pEvent, WB_GEOM *pgBounds)
{
_WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
WB_GEOM geomTemp;
WBGC gcRval;
int iRet;


  if(!pEvent || pEvent->type != Expose || !pEntry)
  {
    WB_DEBUG_PRINT(DebugLevel_WARN | DebugSubSystem_Expose,
                   "%s.%d - returning None (bad parameter)\n", __FUNCTION__, __LINE__);
    return None;
  }

  geomTemp.x      = pEvent->x;
  geomTemp.y      = pEvent->y;
  geomTemp.width  = pEvent->width;
  geomTemp.height = pEvent->height;

  BEGIN_XCALL_DEBUG_WRAPPER
  iRet = XEmptyRegion(pEntry->rgnClip);
  END_XCALL_DEBUG_WRAPPER

  if(iRet)
  {
    geomTemp.x = geomTemp.y = geomTemp.width = geomTemp.height = 0;
    gcRval = NULL; // nothing to paint

    WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_Expose,
                   "%s.%d - returning NULL (nothing to paint)\n", __FUNCTION__, __LINE__);
  }
  else
  {
    gcRval = WBBeginPaintGeom(wID, &geomTemp);

    if(gcRval && pgBounds)
    {
      pgBounds->x      = geomTemp.x;
      pgBounds->y      = geomTemp.y;
      pgBounds->width  = geomTemp.width;
      pgBounds->height = geomTemp.height;
    }
  }

  return gcRval;
}

WBGC WBBeginPaintGeom(Window wID, WB_GEOM *pgBounds) // WBGC will get the 'invalid' region assigned as clip region
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
  WBGC gcRval;
  Region rgnPaint;
  XRectangle xrct;
  int iRet;


  if(!pEntry || !pgBounds)
  {
    WB_ERROR_PRINT("%s.%d - invalid parameters\n", __FUNCTION__, __LINE__);

    return NULL;
  }

  BEGIN_XCALL_DEBUG_WRAPPER
  XSync(WBGetWindowDisplay(wID), 0);
  if(pEntry->rgnClip)
  {
    iRet = XEmptyRegion(pEntry->rgnClip);
  }
  END_XCALL_DEBUG_WRAPPER

  if(!pEntry->rgnClip || iRet) // clipping region is empty?
  {
    if(!pEntry->rgnClip)
    {
      WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Expose,
                     "%s.%d - no clip region  (returning NULL)\n", __FUNCTION__, __LINE__);
    }
    else // if(pBounds)
    {
      WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Expose,
                     "%s.%d - empty clip region - bounds = %d,%d,%d,%d  (returning NULL)\n",
                     __FUNCTION__, __LINE__, pgBounds->x, pgBounds->y, pgBounds->width, pgBounds->height);
    }

    // NOTE:  If I'm in the middle of painting, *AND* the region is empty, then additional 'Expose'
    //        handlers might call this function.  I need to gracefully allow the empty region

    if(!pEntry->rgnClip)
    {
      BEGIN_XCALL_DEBUG_WRAPPER
      pEntry->rgnClip = XCreateRegion(); // create an empty region
      END_XCALL_DEBUG_WRAPPER
    }

    return NULL; // don't return a WBGC - no need to paint
  }

  gcRval = WBCopyGC(pEntry->hGC);

  if(!gcRval)
  {
    WB_ERROR_PRINT("%s - * BUG * at line %d - unable to copy GC for window %d (%08xH)\n",
                   __FUNCTION__, __LINE__, (int)wID, (int)wID);

    // it's checked again, but I need to flow through to the next part
  }

  // using pEntry->rgnClip create a paint region
  // that intersects with the paint area

  if(pEntry->rgnPaint)
  {
    WB_WARN_PRINT("%s - * BUG * at line %d - non-zero paint region for window %d (%08xH)\n",
                  __FUNCTION__, __LINE__, (int)wID, (int)wID);

    BEGIN_XCALL_DEBUG_WRAPPER
    XDestroyRegion(pEntry->rgnPaint);
    END_XCALL_DEBUG_WRAPPER

    pEntry->rgnPaint = None;
  }

  if(gcRval)
  {
    BEGIN_XCALL_DEBUG_WRAPPER
    rgnPaint = XCreateRegion();
    END_XCALL_DEBUG_WRAPPER

    if(rgnPaint)
    {
      Region rgnTemp = XCreateRegion();

      if(!rgnTemp)
      {
        BEGIN_XCALL_DEBUG_WRAPPER
        XDestroyRegion(rgnPaint);
        END_XCALL_DEBUG_WRAPPER

        rgnPaint = None;

        WBFreeGC(gcRval);
        gcRval = NULL;

        WB_ERROR_PRINT("ERROR:  %s - could not create clip region\n", __FUNCTION__);
      }
      else
      {
        // combine specified region with clipping region.  result is new paint region
        xrct.x      = pgBounds->x;
        xrct.y      = pgBounds->y;
        xrct.width  = pgBounds->width;
        xrct.height = pgBounds->height;

        BEGIN_XCALL_DEBUG_WRAPPER
        XUnionRectWithRegion(&xrct, rgnTemp, rgnTemp);  // the paint rectangle as a region
        XUnionRegion(pEntry->rgnClip, rgnPaint, rgnPaint);  // a copy of the invalid region
        XIntersectRegion(rgnTemp, rgnPaint, rgnPaint);      // INTERSECT with xrct (usually from the Expose event)

        // so now the paint region includes the intersect of the xrct passed as 'pgBounds' with the invalid region
        // (if called by WBBeginPaint, 'pgBounds' will be the rectangular area from the Expose event)

        XDestroyRegion(rgnTemp);
        END_XCALL_DEBUG_WRAPPER
      }
    }

    if(rgnPaint) // using this as a flag, of sorts - could also use 'gcRval'
    {
      // by default we clip children so I must enumerate them now
      // for those that are visible, clip their rectangles out of
      // the paint region.

      // TDDO:  clip children


      BEGIN_XCALL_DEBUG_WRAPPER
      iRet = XEmptyRegion(rgnPaint);
      END_XCALL_DEBUG_WRAPPER

      if(iRet) // it's empty - return NULL
      {
        BEGIN_XCALL_DEBUG_WRAPPER
        XDestroyRegion(rgnPaint);
        END_XCALL_DEBUG_WRAPPER

        WBFreeGC(gcRval);

        WB_DEBUG_PRINT(DebugLevel_WARN | DebugSubSystem_Expose,
                       "%s.%d - empty paint region - returning NULL gcRval for window %d (%08xH)\n",
                       __FUNCTION__, __LINE__, (int)wID, (int)wID);

        return NULL;
      }

      pEntry->rgnPaint = rgnPaint;

      // gcRval is always NOT-NULL here

      // assign the clipping region to the GC

      WBSetClipOrigin(gcRval, 0, 0);
      WBSetRegion(gcRval, rgnPaint);
    }
  }

  if(gcRval != NULL /*&& pgBounds*/) // pgBounds is ALWAYS 'NOT NULL'
  {
    // get the 'bounds' from the expose event
    // and intersect them.  This should prevent me from re-painting several times

    BEGIN_XCALL_DEBUG_WRAPPER
    XClipBox(rgnPaint, &xrct);
    END_XCALL_DEBUG_WRAPPER

    pgBounds->x     = xrct.x;
    pgBounds->y     = xrct.y;
    pgBounds->width = xrct.width;
    pgBounds->height = xrct.height;
    pgBounds->border = 0;


    WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_Expose,
                   "%s.%d - bounds=%d,%d,%d,%d\n",
                   __FUNCTION__, __LINE__,
                   xrct.x, xrct.y, xrct.width, xrct.height);
  }

  if(gcRval == NULL)
  {
    WB_DEBUG_PRINT(DebugLevel_WARN | DebugSubSystem_Expose,
                   "%s.%d - returning NULL gcRval for window %d (%08xH)\n",
                   __FUNCTION__, __LINE__, (int)wID, (int)wID);
  }

  return gcRval;
}

void WBClearWindow(Window wID, WBGC gc)
{
unsigned long clrFG, clrBG;
_WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
Display *pDisplay;
XRectangle xrct;


  if(!pEntry || pEntry->rgnPaint == None)
  {
    WB_ERROR_PRINT("ERROR: %s - WBClearWindow with no paint region\n", __FUNCTION__);

    return; // for now don't do anything
  }

  pDisplay = pEntry->pDisplay; // cache it

  clrFG = WBGetGCFGColor(gc);
  clrBG = WBGetGCBGColor(gc);

  BEGIN_XCALL_DEBUG_WRAPPER
  XClipBox(pEntry->rgnPaint, &xrct);
  END_XCALL_DEBUG_WRAPPER

/////// DEBUG
//  if(xrct.x < 0 || xrct.y < 0 ||
//     xrct.width > pEntry->width ||
//     xrct.height > pEntry->height)
//  {
//    WB_ERROR_PRINT("TEMPORARY:  %s - rect exceeds window bounds (%d, %d, %d, %d)\n", __FUNCTION__,
//                   xrct.x, xrct.y, xrct.x + xrct.width, xrct.y + xrct.height);
//  }
//  else
//  {
//    WB_ERROR_PRINT("TEMPORARY:  %s - filling rect (%d, %d, %d, %d)\n", __FUNCTION__,
//                   xrct.x, xrct.y, xrct.x + xrct.width, xrct.y + xrct.height);
//  }
/////// DEBUG

//  BEGIN_XCALL_DEBUG_WRAPPER
//
//  // use XClearArea first (this should refresh what was there before if 'covered up')
//  XClearArea(pDisplay, wID, xrct.x, xrct.y, xrct.width, xrct.height, False);
//
//  END_XCALL_DEBUG_WRAPPER

  // now erase the background according to the clip rectangle

//  BEGIN_XCALL_DEBUG_WRAPPER
  WBSetForeground(gc, clrBG);

  if(xrct.width > 0 && xrct.height > 0)
  {
//    WB_ERROR_PRINT("TEMPORARY: %s - clearing window %08xH geom %d, %d, %d, %d\n",
//                   __FUNCTION__, (WB_UINT32)wID, xrct.x, xrct.y, xrct.width, xrct.height);

    WBFillRectangle(pDisplay, wID, gc, xrct.x, xrct.y, xrct.width, xrct.height);
  }

  WBSetForeground(gc, clrFG);
}

void WBEndPaint(Window wID, WBGC gc)
{
  // validate the paint region and remove it from the 'invalid' region

  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(pEntry->rgnClip != None)
  {
    if(pEntry->pImage)
    {
      // for now update with everything; later, just update the modified rgnPaint paint region?
      // (it would have to be an intersection between the paint region and the clipping region)

      WBUpdateWindowWithImage(pEntry->pDisplay, wID);
    }

    if(pEntry->rgnPaint != None)
    {
      BEGIN_XCALL_DEBUG_WRAPPER
      XSubtractRegion(pEntry->rgnClip, pEntry->rgnPaint, pEntry->rgnClip);
      END_XCALL_DEBUG_WRAPPER

// TODO:  should I leave the empty region anyway, or not?  leaving it might work better...
//
//      if(XEmptyRegion(pEntry->rgnClip))
//      {
//        XDestroyRegion(pEntry->rgnClip);
//        pEntry->rgnClip = None;
//      }

// some debugging code
//
//      {
//        XRectangle xrct;
//
//        BEGIN_XCALL_DEBUG_WRAPPER
//        XClipBox(pEntry->rgnPaint, &xrct);
//        END_XCALL_DEBUG_WRAPPER
//
//        WB_ERROR_PRINT("TEMPORARY: %s - new clip region, window %08xH geom %d, %d, %d, %d\n",
//                       __FUNCTION__, (WB_UINT32)wID, xrct.x, xrct.y, xrct.width, xrct.height);
//      }
    }
    else // destroy clip region if paint region is 'None'
    {
      WB_ERROR_PRINT("ERROR: %s - no paint region\n", __FUNCTION__);

//      XDestroyRegion(pEntry->rgnClip);
//      pEntry->rgnClip = None;
    }
  }
  else
  {
    WB_ERROR_PRINT("ERROR: %s - no clip region\n", __FUNCTION__);
  }

  if(pEntry->rgnPaint != None)
  {
    BEGIN_XCALL_DEBUG_WRAPPER
    XDestroyRegion(pEntry->rgnPaint);
    END_XCALL_DEBUG_WRAPPER

    pEntry->rgnPaint = None;
  }

  if(gc)
  {
    WBFreeGC(gc);
  }
}


/**********************************************************************/
/*                                                                    */
/*          Cached XImage handling for paint and graphics             */
/*                                                                    */
/**********************************************************************/

// POOBAH
XImage *WBGetWindowImage(Display *pDisplay, Window wID)
{
_WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(!pEntry || pEntry->iWindowState == WB_WINDOW_DESTROYED) // so that there is no attempt to use the window
  {
    return NULL;
  }

  if(pEntry->iFlags & WBCreateWindow_flagsNoImageCache)
  {
    return NULL; // always
  }

#ifdef USE_WINDOW_XIMAGE
  if(!disable_imagecache && !(pEntry->pImage)) // this allows me to do a 'soft disable' of the image cache
  {
    Window winRoot = None;
    int iX0=0, iY0=0;
    unsigned int iWidth0=0, iHeight0=0, iBorder;
    unsigned int uiDepth = 0;

    if(!pDisplay)
    {
      pDisplay = pEntry->pDisplay;
      if(!pDisplay)
      {
        pDisplay = WBGetDefaultDisplay();
      }
    }

    BEGIN_XCALL_DEBUG_WRAPPER
    XGetGeometry(pDisplay, wID, &winRoot, &iX0, &iY0, &iWidth0, &iHeight0, &iBorder, &uiDepth);

    // TODO:  if the window has never been painted, create a blank pixmap and fill with the background color
    //        It may also be possible (for a completely invalid window) to erase its pixmap and then create
    //        a 'blank' one of the appropriate size without grabbing the bits off of the X server

    pEntry->pImage = WBXGetImage(pDisplay, wID, 0, 0, iWidth0, iHeight0, 0xffffffff, ZPixmap);
    // NOTE:  this may fail if part of the window extends past the screen size.  In those cases, it may
    //        be necessary to 'fudge' it a bit.
    // TODO:  test for and handle this condition
    END_XCALL_DEBUG_WRAPPER

    // NOTE:  the XImage has width and height members indicating such. when window is re-sized, these can be
    //        compared, and if the new window size is larger than the pixmap (or just different) either a
    //        new pixmap can be derived from the old one, or it can simply be deleted and re-created when needed.
  }
#endif // USE_WINDOW_XIMAGE

  return pEntry->pImage;
}


int WBAssignWindowImage(Display *pDisplay, Window wID, XImage *pImage)
{
_WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);


  if(!pEntry || (pEntry->iFlags & WBCreateWindow_flagsNoImageCache))
  {
    return -1; // not using an image, can't assign one
  }


  return -1; // for now
}


int WBCopyIntoWindowImage(Display *pDisplay, Window wID, XImage *pSrcImage,
                          int xSrc, int ySrc, int width, int height,
                          int xOffs, int yOffs)
{
_WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);


  if(!pEntry || (pEntry->iFlags & WBCreateWindow_flagsNoImageCache))
  {
    return -1; // not using an image, can't assign one nor copy
    // TODO:  handle this situation using a Pixmap and copy to window instead??
  }


  return -1; // for now
}


void WBUpdateWindowWithImage(Display *pDisplay, Window wID)
{
_WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  // TODO:  see __internalDoAntiAlias in draw_text.c for similar operations

  if(!pEntry || pEntry->iWindowState == WB_WINDOW_DESTROYED) // so that there is no attempt to use the window
  {
    if(!pEntry)
    {
      WB_WARN_PRINT("WARNING:  %s - no 'window entry' for Window %d (%08xH)\n",
                    __FUNCTION__, (unsigned int)wID, (unsigned int)wID);
    }
    else
    {
      WB_DEBUG_PRINT(DebugLevel_Medium, "WARNING:  %s - NOT updating 'destroyed' Window %d (%08xH)\n",
                    __FUNCTION__, (unsigned int)wID, (unsigned int)wID);
    }

    return;
  }

  // use the current (default) graphics context.  if not valid, fail.
  // TODO:  make a copy and ONLY update the current 'invalid' region instead??
  //        this might actually speed things up a LOT

  if(pEntry->hGC == None) // no default GC - can't do this
  {
    WB_DEBUG_PRINT(DebugLevel_Light, "WARNING:  %s - no GC for Window %d (%08xH)\n",
                  __FUNCTION__, (unsigned int)wID, (unsigned int)wID);
    return;
  }

  if(!(pEntry->pImage))
  {
    WB_WARN_PRINT("WARNING:  %s - no XImage for %d (%08xH) - this should never happen\n",
                  __FUNCTION__, (unsigned int)wID, (unsigned int)wID);
  }
  else
  {
    Window winRoot = None;
    int iX0=0, iY0=0;
    unsigned int iWidth0=0, iHeight0=0, iBorder;
    unsigned int uiDepth = 0;

    if(!pDisplay)
    {
      pDisplay = pEntry->pDisplay;
      if(!pDisplay)
      {
        pDisplay = WBGetDefaultDisplay();
      }
    }

    BEGIN_XCALL_DEBUG_WRAPPER
    // TODO:  always use cached information from pEntry ???
    XGetGeometry(pDisplay, wID, &winRoot, &iX0, &iY0, &iWidth0, &iHeight0, &iBorder, &uiDepth);
    END_XCALL_DEBUG_WRAPPER

    // if the image size is too small, reduce width and height accordingly

    if(WB_UNLIKELY(pEntry->pImage->width < iWidth0))
    {
      iWidth0 = pEntry->pImage->width;
    }

    if(WB_UNLIKELY(pEntry->pImage->height < iHeight0))
    {
      iHeight0 = pEntry->pImage->height;
    }

    // TODO:  limit the update to the bounding rectangle of the invalid/clipping region.  This
    //        might be fastest.  But, when the invalid/clip region is empty, do it ALL.

    WBXPutImage(pDisplay, wID, pEntry->hGC, pEntry->pImage, 0, 0, iX0, iY0, iWidth0, iHeight0);
    // NOTE:  this process should be very fast by comparison to getting the image from the drawable (window)
  }
}



/**********************************************************************/
/*                                                                    */
/*                  internal event queue processing                   */
/*                                                                    */
/**********************************************************************/

static void __WBInitEvent()
{
  int i1;

  if(iInitEventFlag)
  {
    return; // already done
  }

  iInitEventFlag = 1;

  // initialize the 'free' event pool, and all of the other event queue entries

  iWBFreeEvent = 0;
  for(i1=1; i1 < EVENT_ARRAY_SIZE; i1++)
  {
    axWBEvt[i1 - 1].iNext = i1;
  }

  axWBEvt[EVENT_ARRAY_SIZE - 1].iNext = -1;  // end of chain
  iWBQueuedEvent = iWBQueueLast = -1;  // because the queue is empty
  iWBPaintEvent = iWBPaintLast = -1;  // same here
}


static int __WBAddEvent(Display *pDisp, Window wID, XEvent *pEvent)
{
  int iEvent = -1;
  // TODO:  synchronization objects?

  if(!iInitEventFlag)
  {
    __WBInitEvent();
  }

  if(iWBFreeEvent < 0) // none left
  {
    return -1;
  }

  if(pEvent->type == Expose)
  {
    WBProcessExposeEvent((XExposeEvent *)pEvent);
  }

  iEvent = iWBFreeEvent;
  iWBFreeEvent = axWBEvt[iWBFreeEvent].iNext; // new 'free' pointer
  axWBEvt[iEvent].iNext = -1;                 // mark the end of the 'iEvent's entry

  // add to iWBQueuedEvent linked list

  if(iWBQueuedEvent < 0)
  {
    iWBQueuedEvent = iEvent;
    iWBQueueLast = iEvent;
  }
  else
  {
    if(iWBQueueLast < 0)
    {
      // traverse the queue
      iWBQueueLast = iWBQueuedEvent;
      while(axWBEvt[iWBQueueLast].iNext != -1)
      {
        iWBQueueLast = axWBEvt[iWBQueueLast].iNext;
      }
    }

    axWBEvt[iWBQueueLast].iNext = iEvent;
    iWBQueueLast = iEvent;
  }

  axWBEvt[iEvent].pDisplay = pDisp;
  axWBEvt[iEvent].wID = wID;
  memcpy(&(axWBEvt[iEvent].xEvt), pEvent, sizeof(XEvent));

  return 0; // success
}

static void __WBDelWindowPaintEvents(Display *pDisp, Window wID)
{
  int iEvent, iPrev, iTemp;
  XEvent event;

  if(iWBPaintEvent < 0)
  {
    return;
  }

  iEvent = iWBPaintEvent;
  iPrev = -1;

  while(iEvent >= 0)
  {
    if(axWBEvt[iEvent].wID == wID &&
       axWBEvt[iEvent].pDisplay == pDisp)
    {
      if(iPrev < 0)
      {
        iWBPaintEvent = axWBEvt[iEvent].iNext;  // remove from head
        if(iWBPaintEvent < 0)
        {
          iWBPaintLast = -1;
        }
      }
      else
      {
        axWBEvt[iPrev].iNext = axWBEvt[iEvent].iNext;  // remove from chain
        if(axWBEvt[iPrev].iNext < 0)
        {
          iWBPaintLast = iPrev;
        }
      }

      iTemp = iEvent;

      // add 'iEvent' to the chain of free events
      iEvent = axWBEvt[iTemp].iNext;
      axWBEvt[iTemp].iNext = iWBFreeEvent;
      iWBFreeEvent = iTemp;
    }
    else
    {
      iPrev = iEvent;
      iEvent = axWBEvt[iEvent].iNext;
    }
  }

  XSync(pDisp, 0);

  // now the X events (remove them from the queue)
  while(XCheckWindowEvent(pDisp, wID, ExposureMask, &event))
    ;
}

static void __WBDelWindowEvents(Display *pDisp, Window wID)
{
  int iEvent, iPrev, iTemp;
  XEvent event;

//  if(iWBQueuedEvent < 0 && iWBPaintEvent < 0)
//  {
//    return;
//  }

  // traverse iWBQueuedEvent

  iEvent = iWBQueuedEvent;
  iPrev = -1;
  while(iEvent >= 0)
  {
    if(axWBEvt[iEvent].wID == wID &&
       axWBEvt[iEvent].pDisplay == pDisp)
    {
      if(iPrev < 0)
      {
        iWBQueuedEvent = axWBEvt[iEvent].iNext;  // remove from head
        if(iWBQueuedEvent < 0)
        {
          iWBQueueLast = -1;
        }
      }
      else
      {
        axWBEvt[iPrev].iNext = axWBEvt[iEvent].iNext;  // remove from chain
        if(axWBEvt[iPrev].iNext < 0)
        {
          iWBQueueLast = iPrev;
        }
      }

      iTemp = iEvent;

      // add 'iEvent' to the chain of free events
      iEvent = axWBEvt[iTemp].iNext;
      axWBEvt[iTemp].iNext = iWBFreeEvent;
      iWBFreeEvent = iTemp;
    }
    else
    {
      iPrev = iEvent;
      iEvent = axWBEvt[iEvent].iNext;
    }
  }

  // NOW traverse iWBPaintEvent

  iEvent = iWBPaintEvent;
  iPrev = -1;
  while(iEvent >= 0)
  {
    if(axWBEvt[iEvent].wID == wID &&
       axWBEvt[iEvent].pDisplay == pDisp)
    {
      if(iPrev < 0)
      {
        iWBPaintEvent = axWBEvt[iEvent].iNext;  // remove from head
        if(iWBPaintEvent < 0)
        {
          iWBPaintLast = -1;
        }
      }
      else
      {
        axWBEvt[iPrev].iNext = axWBEvt[iEvent].iNext;  // remove from chain
        if(axWBEvt[iPrev].iNext < 0)
        {
          iWBPaintLast = iPrev;
        }
      }

      iTemp = iEvent;

      // add 'iEvent' to the chain of free events
      iEvent = axWBEvt[iTemp].iNext;
      axWBEvt[iTemp].iNext = iWBFreeEvent;
      iWBFreeEvent = iTemp;
    }
    else
    {
      iPrev = iEvent;
      iEvent = axWBEvt[iEvent].iNext;
    }
  }

// do XSync and exit

  XSync(pDisp, 0);

  // now the X 'expose' events (remove them from the queue)
  while(XCheckWindowEvent(pDisp, wID, EVENT_ALL_MASK, &event))
    ;

//  XSync(pDisp);
//
//  // the X events again
//  while(XCheckWindowEvent(pDisp, wID, EVENT_ALL_MASK, &event))
//    ;
}

static int __WBInsertPriorityEvent(Display *pDisp, Window wID, XEvent *pEvent)
{
  int iEvent = -1;
  // TODO:  synchronization objects?

  if(!iInitEventFlag)
  {
    __WBInitEvent();
  }

  if(iWBFreeEvent < 0) // none left
  {
    return -1;
  }

// TODO:  do I do something different for Expose events?
//  if(pEvent->type == Expose)
//    WBProcessExposeEvent((XExposeEvent *)pEvent);

  iEvent = iWBFreeEvent;
  iWBFreeEvent = axWBEvt[iEvent].iNext;
  axWBEvt[iEvent].iNext = -1;  // the end

  // add to iWBQueuedEvent linked list

  if(iWBQueuedEvent < 0)
  {
    iWBQueuedEvent = iEvent;
    iWBQueueLast = iEvent;
  }
  else
  {
    int iTempEvent = iWBQueuedEvent;

    // insert at the beginning of the chain
    iWBQueuedEvent = iEvent;
    axWBEvt[iWBQueuedEvent].iNext = iTempEvent;
  }

  axWBEvt[iEvent].pDisplay = pDisp;
  axWBEvt[iEvent].wID = wID;
  memcpy(&(axWBEvt[iEvent].xEvt), pEvent, sizeof(XEvent));

  return 0;
}

static int __WBNextPaintEvent(Display *pDisp, XEvent *pEvent, Window wID)
{
  int iRval = iWBPaintEvent, iPrev = -1;

  while(iRval >= 0)
  {
    if(WB_LIKELY(axWBEvt[iRval].pDisplay == pDisp) &&
       (WB_LIKELY(wID == None) || axWBEvt[iRval].xEvt.xany.window == wID))
    {
      break;
    }

    iPrev = iRval;
    iRval = axWBEvt[iRval].iNext;
  }

  if(iRval >= 0)
  {
    WB_DEBUG_PRINT(DebugLevel_Verbose | DebugSubSystem_Window | DebugSubSystem_Event,
                 "%s - getting an EXPOSE event for %d (%08xH)\n",
                 __FUNCTION__,
                 (int)axWBEvt[iRval].xEvt.xany.window,
                 (int)axWBEvt[iRval].xEvt.xany.window);

    if(iRval == iWBPaintEvent)
    {
      iWBPaintEvent = axWBEvt[iRval].iNext;
    }
    else
    {
      if(iRval == iWBPaintLast)
      {
        iWBPaintLast = iPrev;
        axWBEvt[iPrev].iNext = -1;
      }
      else if(iPrev >= 0)
      {
        axWBEvt[iPrev].iNext = axWBEvt[iRval].iNext;
      }
    }

    if(iWBPaintEvent < 0)
    {
      iWBPaintLast = -1;
    }

    if(pEvent)
    {
      memcpy(pEvent, &(axWBEvt[iRval].xEvt), sizeof(XEvent));
    }

    axWBEvt[iRval].iNext = iWBFreeEvent;
    iWBFreeEvent = iRval;
  }

  return iRval;
}


static int __WBNextDisplayEvent(Display *pDisp, XEvent *pEvent)
{
  int iRval = iWBQueuedEvent, iPrev = -1;

  while(WB_LIKELY(iRval >= 0))
  {
    if(WB_LIKELY(axWBEvt[iRval].pDisplay == pDisp))
    {
      break;
    }

    iPrev = iRval;
    iRval = axWBEvt[iRval].iNext;
  }

  if(WB_LIKELY(iRval >= 0)) // I want the "I have an event" path to be faster
  {
    if(WB_LIKELY(iRval == iWBQueuedEvent)) // TODO:  is this "likely" ?
    {
      iWBQueuedEvent = axWBEvt[iRval].iNext;

      if(iWBQueuedEvent < 0)
      {
        iWBQueueLast = -1;
      }
    }
    else
    {
      if(iRval == iWBQueueLast)
      {
        iWBQueueLast = iPrev;
        axWBEvt[iPrev].iNext = -1;
      }
      else if(iPrev >= 0)
      {
        axWBEvt[iPrev].iNext = axWBEvt[iRval].iNext;
      }
    }

    WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Window | DebugSubSystem_Event,
                   "%s - getting %s event for %d (%08xH)\n",
                   __FUNCTION__,
                   WBEventName(axWBEvt[iRval].xEvt.type),
                   (int)axWBEvt[iRval].xEvt.xany.window,
                   (int)axWBEvt[iRval].xEvt.xany.window);

    if(WB_LIKELY(pEvent))
    {
      memcpy(pEvent, &(axWBEvt[iRval].xEvt), sizeof(XEvent));
    }

    axWBEvt[iRval].iNext = iWBFreeEvent;
    iWBFreeEvent = iRval;
  }

  // TODO:  is this really "unlikely" ?
  if(WB_UNLIKELY(iRval < 0))  // no event found in normal queue - try paint queue
  {
    // this function is separated out so I can call it directly - see WBUpdateWindowImmediately()

    iRval = __WBNextPaintEvent(pDisp, pEvent, None);
  }

  return iRval >= 0;
}

static void WBInternalProcessExposeEvent(XExposeEvent *pEvent)
{
int iEvent;
Window wID;
Display *pDisp;
WB_GEOM geom;


  if(!iInitEventFlag)
  {
    __WBInitEvent();
  }

  // expose events are combined whenever possible
  // so that I can choose to respond to them immediately, increment
  // the 'count' member to indicate that at least one more event is waiting
  // then, make sure I place an event in the 'paint' queue that encompasses
  // the entire invalid region.  Then I make sure that the 'invalid' region
  // of the window contains the rectangular area specified by the Expose
  // event so that the final paint message will paint everything properly.

  wID = pEvent->window;
  pDisp = pEvent->display;

  // STEP 1:  search the 'paint' queue for a matching window ID

  for(iEvent=iWBPaintEvent; iEvent >= 0; iEvent = axWBEvt[iEvent].iNext)
  {
    if(axWBEvt[iEvent].wID == wID && axWBEvt[iEvent].pDisplay == pDisp)
    {
      break;
    }
  }

  if(iEvent >= 0)  // found!
  {
    // expand the expose event's rectangle to include THIS one

    if(axWBEvt[iEvent].xEvt.xexpose.x > pEvent->x)
    {
      axWBEvt[iEvent].xEvt.xexpose.x = pEvent->x;
    }

    if(axWBEvt[iEvent].xEvt.xexpose.y > pEvent->y)
    {
      axWBEvt[iEvent].xEvt.xexpose.y = pEvent->y;
    }

    if(axWBEvt[iEvent].xEvt.xexpose.x + axWBEvt[iEvent].xEvt.xexpose.width < pEvent->x + pEvent->width)
    {
      axWBEvt[iEvent].xEvt.xexpose.width = pEvent->x + pEvent->width - axWBEvt[iEvent].xEvt.xexpose.x;
    }

    if(axWBEvt[iEvent].xEvt.xexpose.y + axWBEvt[iEvent].xEvt.xexpose.height < pEvent->y + pEvent->height)
    {
      axWBEvt[iEvent].xEvt.xexpose.height = pEvent->y + pEvent->height - axWBEvt[iEvent].xEvt.xexpose.y;
    }
  }
  else
  {
    // make a copy of the event and put it into the 'paint' queue
    // note that if I have no room, I'll simply have to reject it

    if(iWBFreeEvent < 0) // I check here because an existing event might be editable
    {
      WB_ERROR_PRINT("ERROR: %s - no more free 'event queue' entries\n", __FUNCTION__);
      return; // can't do anything else, really
    }
    else
    {
      iEvent = iWBFreeEvent;
      iWBFreeEvent = axWBEvt[iWBFreeEvent].iNext; // remove 'iEvent' from the head of the free chain

      axWBEvt[iEvent].iNext = -1;  // the end of the chain on my new "not free any more" event 'iEvent'

      // add to iWBPaintEvent linked list

      if(iWBPaintEvent < 0)
      {
        iWBPaintEvent = iEvent;
        iWBPaintLast = iEvent;
      }
      else
      {
        if(iWBPaintLast < 0)
        {
          // traverse the queue
          iWBPaintLast = iWBPaintEvent;
          while(axWBEvt[iWBPaintLast].iNext != -1)
          {
            iWBPaintLast = axWBEvt[iWBPaintLast].iNext;
          }
        }

        axWBEvt[iWBPaintLast].iNext = iEvent;
        iWBPaintLast = iEvent;
      }

      axWBEvt[iEvent].pDisplay = pDisp;
      axWBEvt[iEvent].wID = wID;
      memcpy(&(axWBEvt[iEvent].xEvt), pEvent, sizeof(XEvent));

      axWBEvt[iEvent].xEvt.xexpose.count = 0;  // always make this a zero
    }
  }

  // make sure I invalidate the region covered by the expose event

  geom.x = pEvent->x;
  geom.y = pEvent->y;
  geom.width = pEvent->width;
  geom.height = pEvent->height;
  geom.border = 0;

//  WB_ERROR_PRINT("TEMPORARY:  %s - %d,%d,%d,%d\n", __FUNCTION__, geom.x, geom.y, geom.width, geom.height);

  WBInvalidateGeom(wID, &geom, 0);

  pEvent->count++;  // increment so it indicates "more to come" before I pass it along

  // make sure window is no longer "unmapped'
  // TODO:  fix this so it's less of a hack??
  {
    _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);
    if(pEntry && WB_IS_WINDOW_UNMAPPED(*pEntry))
    {
      if(WB_CHECK_SET_FOCUS_ON_MAP(*pEntry))
      {
        WBSetInputFocus(wID); // hopefully will NOT cause trouble
        pEntry->iWindowState = WB_WINDOW_MAPPED;
      }
      else
      {
        pEntry->iWindowState = WB_WINDOW_MAPPED;
      }
    }
  }

}

// event queue functions

int WBNextEvent(Display *pDisplay, XEvent *pEvent)
{
  return __WBNextDisplayEvent(pDisplay, pEvent);
}

int WBPostEvent(Window wID, XEvent *pEvent)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

  if(!pEntry)
    return -1;

//  if(pEvent->type == ClientMessage)
//      fprintf(stderr, "TEMPORARY: client message in WBPostEvent\n");

  return __WBAddEvent(pEntry->pDisplay, wID, pEvent);
}

void WBPostDelayedEvent(XEvent *pEvent, unsigned int nDelay)
{
  __CreateDelayedEvent(pEvent, nDelay);
}

int WBPostPriorityEvent(Window wID, XEvent *pEvent)
{
  _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

//  if(pEvent->type == ClientMessage)
//      fprintf(stderr, "TEMPORARY: client message in WBPostPriorityEvent\n");

  if(!pEntry)
  {
//    fprintf(stderr, "TEMPORARY:  returning -1 from WBPostPriorityEvent because pEntry is NULL\n");
    return -1;
  }

  return __WBInsertPriorityEvent(pEntry->pDisplay, wID, pEvent);
}

int WBPostAppEvent(XEvent *pEvent)
{
  Display *pDisp = pDefaultDisplay;

//  pEvent->xany.window = 0;  // make sure
  if(pEvent->xany.display)
  {
    pDisp = pEvent->xany.display;
  }

  return __WBAddEvent(pDisp, 0, pEvent);
}

void WBPostDelayedSetFocusAppEvent(Display *pDisplay, Window wID, Window wIDFrom, unsigned int iDelay)
{
XClientMessageEvent evtClient;

  if(!pDisplay)
  {
    _WINDOW_ENTRY_ *pEntry = WBGetWindowEntry(wID);

    if(pEntry && pEntry->pDisplay)
    {
      pDisplay = pEntry->pDisplay;
    }
    else
    {
      pDisplay = pDefaultDisplay;
    }
  }

  memset(&evtClient, 0, sizeof(evtClient));

  evtClient.type = ClientMessage;
  evtClient.display = pDisplay;
  evtClient.window = None; // sent to application
  evtClient.message_type = aSET_FOCUS;
  evtClient.format = 32;
  evtClient.data.l[0] = wID;     // set focus here
  evtClient.data.l[1] = wIDFrom; // was focus THERE (but should not be NOW)

  if(iDelay > 0)
  {
    WBPostDelayedEvent((XEvent *)&evtClient, iDelay);
  }
  else
  {
    WBPostAppEvent((XEvent *)&evtClient);
  }
}



#define EVENT_NAME_ENTRY(X) { X, #X }

static struct
{
  int iID;
  const char *szName;
} aIDName[]=
{
  EVENT_NAME_ENTRY(KeyPress),
  EVENT_NAME_ENTRY(KeyRelease),
  EVENT_NAME_ENTRY(ButtonPress),
  EVENT_NAME_ENTRY(ButtonRelease),
  EVENT_NAME_ENTRY(MotionNotify),
  EVENT_NAME_ENTRY(EnterNotify),
  EVENT_NAME_ENTRY(LeaveNotify),
  EVENT_NAME_ENTRY(FocusIn),
  EVENT_NAME_ENTRY(FocusOut),
  EVENT_NAME_ENTRY(KeymapNotify),
  EVENT_NAME_ENTRY(Expose),
  EVENT_NAME_ENTRY(GraphicsExpose),
  EVENT_NAME_ENTRY(NoExpose),
  EVENT_NAME_ENTRY(VisibilityNotify),
  EVENT_NAME_ENTRY(CreateNotify),
  EVENT_NAME_ENTRY(DestroyNotify),
  EVENT_NAME_ENTRY(UnmapNotify),
  EVENT_NAME_ENTRY(MapNotify),
  EVENT_NAME_ENTRY(MapRequest),
  EVENT_NAME_ENTRY(ReparentNotify),
  EVENT_NAME_ENTRY(ConfigureNotify),
  EVENT_NAME_ENTRY(ConfigureRequest),
  EVENT_NAME_ENTRY(GravityNotify),
  EVENT_NAME_ENTRY(ResizeRequest),
  EVENT_NAME_ENTRY(CirculateNotify),
  EVENT_NAME_ENTRY(CirculateRequest),
  EVENT_NAME_ENTRY(PropertyNotify),
  EVENT_NAME_ENTRY(SelectionClear),
  EVENT_NAME_ENTRY(SelectionRequest),
  EVENT_NAME_ENTRY(SelectionNotify),
  EVENT_NAME_ENTRY(ColormapNotify),
  EVENT_NAME_ENTRY(ClientMessage),
  EVENT_NAME_ENTRY(MappingNotify),
  EVENT_NAME_ENTRY(LASTEvent),
  { 0, NULL }
};

const char * WBEventName(int iEventID)
{
    int i1;
    static char aTemp[32];

    for(i1=0; aIDName[i1].iID; i1++)
    {
        if(aIDName[i1].iID == iEventID)
        {
            return aIDName[i1].szName;
        }
    }

    sprintf(aTemp, "[Event %d]", iEventID);
    return aTemp;
}

#include <X11/Xproto.h>

#define X_PROTO_ENTRY(X) { X, #X },

struct
{
  int iProto;
  const char *szProto;
} aXProto[] =
{
  X_PROTO_ENTRY(X_CreateWindow)
  X_PROTO_ENTRY(X_ChangeWindowAttributes)
  X_PROTO_ENTRY(X_GetWindowAttributes)
  X_PROTO_ENTRY(X_DestroyWindow)
  X_PROTO_ENTRY(X_DestroySubwindows)
  X_PROTO_ENTRY(X_ChangeSaveSet)
  X_PROTO_ENTRY(X_ReparentWindow)
  X_PROTO_ENTRY(X_MapWindow)
  X_PROTO_ENTRY(X_MapSubwindows)
  X_PROTO_ENTRY(X_UnmapWindow)
  X_PROTO_ENTRY(X_UnmapSubwindows)
  X_PROTO_ENTRY(X_ConfigureWindow)
  X_PROTO_ENTRY(X_CirculateWindow)
  X_PROTO_ENTRY(X_GetGeometry)
  X_PROTO_ENTRY(X_QueryTree)
  X_PROTO_ENTRY(X_InternAtom)
  X_PROTO_ENTRY(X_GetAtomName)
  X_PROTO_ENTRY(X_ChangeProperty)
  X_PROTO_ENTRY(X_DeleteProperty)
  X_PROTO_ENTRY(X_GetProperty)
  X_PROTO_ENTRY(X_ListProperties)
  X_PROTO_ENTRY(X_SetSelectionOwner)
  X_PROTO_ENTRY(X_GetSelectionOwner)
  X_PROTO_ENTRY(X_ConvertSelection)
  X_PROTO_ENTRY(X_SendEvent)
  X_PROTO_ENTRY(X_GrabPointer)
  X_PROTO_ENTRY(X_UngrabPointer)
  X_PROTO_ENTRY(X_GrabButton)
  X_PROTO_ENTRY(X_UngrabButton)
  X_PROTO_ENTRY(X_ChangeActivePointerGrab)
  X_PROTO_ENTRY(X_GrabKeyboard)
  X_PROTO_ENTRY(X_UngrabKeyboard)
  X_PROTO_ENTRY(X_GrabKey)
  X_PROTO_ENTRY(X_UngrabKey)
  X_PROTO_ENTRY(X_AllowEvents)
  X_PROTO_ENTRY(X_GrabServer)
  X_PROTO_ENTRY(X_UngrabServer)
  X_PROTO_ENTRY(X_QueryPointer)
  X_PROTO_ENTRY(X_GetMotionEvents)
  X_PROTO_ENTRY(X_TranslateCoords)
  X_PROTO_ENTRY(X_WarpPointer)
  X_PROTO_ENTRY(X_SetInputFocus)
  X_PROTO_ENTRY(X_GetInputFocus)
  X_PROTO_ENTRY(X_QueryKeymap)
  X_PROTO_ENTRY(X_OpenFont)
  X_PROTO_ENTRY(X_CloseFont)
  X_PROTO_ENTRY(X_QueryFont)
  X_PROTO_ENTRY(X_QueryTextExtents)
  X_PROTO_ENTRY(X_ListFonts)
  X_PROTO_ENTRY(X_ListFontsWithInfo)
  X_PROTO_ENTRY(X_SetFontPath)
  X_PROTO_ENTRY(X_GetFontPath)
  X_PROTO_ENTRY(X_CreatePixmap)
  X_PROTO_ENTRY(X_FreePixmap)
  X_PROTO_ENTRY(X_CreateGC)
  X_PROTO_ENTRY(X_ChangeGC)
  X_PROTO_ENTRY(X_CopyGC)
  X_PROTO_ENTRY(X_SetDashes)
  X_PROTO_ENTRY(X_SetClipRectangles)
  X_PROTO_ENTRY(X_FreeGC)
  X_PROTO_ENTRY(X_ClearArea)
  X_PROTO_ENTRY(X_CopyArea)
  X_PROTO_ENTRY(X_CopyPlane)
  X_PROTO_ENTRY(X_PolyPoint)
  X_PROTO_ENTRY(X_PolyLine)
  X_PROTO_ENTRY(X_PolySegment)
  X_PROTO_ENTRY(X_PolyRectangle)
  X_PROTO_ENTRY(X_PolyArc)
  X_PROTO_ENTRY(X_FillPoly)
  X_PROTO_ENTRY(X_PolyFillRectangle)
  X_PROTO_ENTRY(X_PolyFillArc)
  X_PROTO_ENTRY(X_PutImage)
  X_PROTO_ENTRY(X_GetImage)
  X_PROTO_ENTRY(X_PolyText8)
  X_PROTO_ENTRY(X_PolyText16)
  X_PROTO_ENTRY(X_ImageText8)
  X_PROTO_ENTRY(X_ImageText16)
  X_PROTO_ENTRY(X_CreateColormap)
  X_PROTO_ENTRY(X_FreeColormap)
  X_PROTO_ENTRY(X_CopyColormapAndFree)
  X_PROTO_ENTRY(X_InstallColormap)
  X_PROTO_ENTRY(X_UninstallColormap)
  X_PROTO_ENTRY(X_ListInstalledColormaps)
  X_PROTO_ENTRY(X_AllocColor)
  X_PROTO_ENTRY(X_AllocNamedColor)
  X_PROTO_ENTRY(X_AllocColorCells)
  X_PROTO_ENTRY(X_AllocColorPlanes)
  X_PROTO_ENTRY(X_FreeColors)
  X_PROTO_ENTRY(X_StoreColors)
  X_PROTO_ENTRY(X_StoreNamedColor)
  X_PROTO_ENTRY(X_QueryColors)
  X_PROTO_ENTRY(X_LookupColor)
  X_PROTO_ENTRY(X_CreateCursor)
  X_PROTO_ENTRY(X_CreateGlyphCursor)
  X_PROTO_ENTRY(X_FreeCursor)
  X_PROTO_ENTRY(X_RecolorCursor)
  X_PROTO_ENTRY(X_QueryBestSize)
  X_PROTO_ENTRY(X_QueryExtension)
  X_PROTO_ENTRY(X_ListExtensions)
  X_PROTO_ENTRY(X_ChangeKeyboardMapping)
  X_PROTO_ENTRY(X_GetKeyboardMapping)
  X_PROTO_ENTRY(X_ChangeKeyboardControl)
  X_PROTO_ENTRY(X_GetKeyboardControl)
  X_PROTO_ENTRY(X_Bell)
  X_PROTO_ENTRY(X_ChangePointerControl)
  X_PROTO_ENTRY(X_GetPointerControl)
  X_PROTO_ENTRY(X_SetScreenSaver)
  X_PROTO_ENTRY(X_GetScreenSaver)
  X_PROTO_ENTRY(X_ChangeHosts)
  X_PROTO_ENTRY(X_ListHosts)
  X_PROTO_ENTRY(X_SetAccessControl)
  X_PROTO_ENTRY(X_SetCloseDownMode)
  X_PROTO_ENTRY(X_KillClient)
  X_PROTO_ENTRY(X_RotateProperties)
  X_PROTO_ENTRY(X_ForceScreenSaver)
  X_PROTO_ENTRY(X_SetPointerMapping)
  X_PROTO_ENTRY(X_GetPointerMapping)
  X_PROTO_ENTRY(X_SetModifierMapping)
  X_PROTO_ENTRY(X_GetModifierMapping)
  X_PROTO_ENTRY(X_NoOperation)
  {0, 0}
};


static const char * __internal_event_type_string(int iEventType)
{
  switch(iEventType)
  {
    case KeyPress:
      return "KeyPress";
    case KeyRelease:
      return "KeyRelease";
    case ButtonPress:
      return "ButtonPress";
    case ButtonRelease:
      return "ButtonRelease";
    case MotionNotify:
      return "MotionNotify";
    case EnterNotify:
      return "EnterNotify";
    case LeaveNotify:
      return "LeaveNotify";
    case FocusIn:
      return "FocusIn";
    case FocusOut:
      return "FocusOut";
    case KeymapNotify:
      return "KeymapNotify";
    case Expose:
      return "Expose";
    case GraphicsExpose:
      return "GraphicsExpose";
    case NoExpose:
      return "NoExpose";
    case VisibilityNotify:
      return "VisibilityNotify";
    case CreateNotify:
      return "CreateNotify";
    case DestroyNotify:
      return "DestroyNotify";
    case UnmapNotify:
      return "UnmapNotify";
    case MapNotify:
      return "MapNotify";
    case MapRequest:
      return "MapRequest";
    case ReparentNotify:
      return "ReparentNotify";
    case ConfigureNotify:
      return "ConfigureNotify";
    case ConfigureRequest:
      return "ConfigureRequest";
    case GravityNotify:
      return "GravityNotify";
    case ResizeRequest:
      return "ResizeRequest";
    case CirculateNotify:
      return "CirculateNotify";
    case CirculateRequest:
      return "CirculateRequest";
    case PropertyNotify:
      return "PropertyNotify";
    case SelectionClear:
      return "SelectionClear";
    case SelectionRequest:
      return "SelectionRequest";
    case SelectionNotify:
      return "SelectionNotify";
    case ColormapNotify:
      return "ColormapNotify";
    case ClientMessage:
      return "ClientMessage";
    case MappingNotify:
      return "MappingNotify";
#ifdef GenericEvent /* this wasn't present in earlier versions of X11 */
    case GenericEvent:
      return "GenericEvent";
#endif // GenericEvent
  }
  return "*Unknown Event";
}


void WBDebugDumpGC(Display *pDisplay, WBGC hGC)
{
XGCValues xgcv;

  if(!hGC)
  {
    WBDebugPrint("GC DUMP - NULL hGC\n");
    return;
  }

  bzero(&xgcv, sizeof(xgcv));
  memcpy(&xgcv, &(hGC->values), sizeof(xgcv));

  WBGetGCValues(hGC,
                GCFunction | GCPlaneMask | GCForeground | GCBackground | GCLineWidth | GCLineStyle | GCCapStyle
                | GCJoinStyle | GCFillStyle | GCFillRule | GCTile | GCStipple | GCTileStipXOrigin | GCTileStipYOrigin
                | GCFont | GCSubwindowMode | GCGraphicsExposures | GCClipXOrigin | GCClipYOrigin /*| GCClipMask*/
                | GCDashOffset /*| GCDashList*/ | GCArcMode,
                &xgcv);

  WBDebugPrint("WBGC DUMP - GC     = %ld (%08lxH)\n", (long)(hGC->gc), (long)(hGC->gc));
  WBDebugPrint("function           = %d (%08xH)\n", xgcv.function, xgcv.function);
  WBDebugPrint("plane_mask         = %ld (%016lxH)\n", xgcv.plane_mask, xgcv.plane_mask);
  WBDebugPrint("foreground         = %ld (%016lxH)\n", xgcv.foreground, xgcv.foreground);
  WBDebugPrint("background         = %ld (%016lxH)\n", xgcv.background, xgcv.background);
  WBDebugPrint("line_width         = %d (%08xH)\n", xgcv.line_width, xgcv.line_width);
  WBDebugPrint("line_style         = %d (%08xH)\n", xgcv.line_style, xgcv.line_style);
  WBDebugPrint("cap_style          = %d (%08xH)\n", xgcv.cap_style, xgcv.cap_style);
  WBDebugPrint("join_style         = %d (%08xH)\n", xgcv.join_style, xgcv.join_style);
  WBDebugPrint("fill_style         = %d (%08xH)\n", xgcv.fill_style, xgcv.fill_style);
  WBDebugPrint("fill_rule          = %d (%08xH)\n", xgcv.fill_rule, xgcv.fill_rule);
  WBDebugPrint("arc_mode           = %d (%08xH)\n", xgcv.arc_mode, xgcv.arc_mode);
  WBDebugPrint("tile               = %d (%08xH)\n", (int)xgcv.tile, (int)xgcv.tile);
  WBDebugPrint("stipple            = %d (%08xH)\n", (int)xgcv.stipple, (int)xgcv.stipple);
  WBDebugPrint("ts_x_origin        = %d (%08xH)\n", xgcv.ts_x_origin, xgcv.ts_x_origin);
  WBDebugPrint("ts_y_origin        = %d (%08xH)\n", xgcv.ts_y_origin, xgcv.ts_y_origin);
  WBDebugPrint("font               = %d (%08xH)\n", (int)xgcv.font, (int)xgcv.font);
  WBDebugPrint("subwindow_mode     = %d (%08xH)\n", xgcv.subwindow_mode, xgcv.subwindow_mode);
  WBDebugPrint("graphics_exposures = %d (%08xH)\n", xgcv.graphics_exposures, xgcv.graphics_exposures);
  WBDebugPrint("clip_x_origin      = %d (%08xH)\n", xgcv.clip_x_origin, xgcv.clip_x_origin);
  WBDebugPrint("clip_y_origin      = %d (%08xH)\n", xgcv.clip_y_origin, xgcv.clip_y_origin);
//  WBDebugPrint("clip_mask          = %d (%08xH)\n", (int)xgcv.clip_mask, (int)xgcv.clip_mask);
  WBDebugPrint("dash_offset        = %d (%08xH)\n", xgcv.dash_offset, xgcv.dash_offset);
//  WBDebugPrint("dashes             = %d (%08xH)\n", xgcv.dashes, xgcv.dashes);
}


void WBDebugDumpEvent(XEvent *pEvent)
{
char *p1;

  WBDebugPrint("EVENT %s\n", __internal_event_type_string(pEvent->xany.type));
  WBDebugPrint("    serial:      %ld\n", pEvent->xany.serial);
  WBDebugPrint("    send_event:  %c\n", pEvent->xany.send_event ? 'T' : 'F');
  WBDebugPrint("    display:     %p\n", pEvent->xany.display);
  WBDebugPrint("    Window:      %08xH\n", (unsigned int)pEvent->xany.window);

  switch(pEvent->xany.type)
  {
    case ClientMessage: /* these require WBGetAtomName since the atoms may not be 'global' */
      p1 = WBGetAtomName(pEvent->xany.display, pEvent->xclient.message_type);
      WBDebugPrint(" message_type:   %s\n", p1);
      WBFree(p1);

      WBDebugPrint("       format:   %d\n", pEvent->xclient.format);
      WBDebugPrint("    data[0].l:   %ld (%08lxH)\n", pEvent->xclient.data.l[0], pEvent->xclient.data.l[0]);
      WBDebugPrint("    data[1].l:   %ld (%08lxH)\n", pEvent->xclient.data.l[1], pEvent->xclient.data.l[1]);
      WBDebugPrint("    data[2].l:   %ld (%08lxH)\n", pEvent->xclient.data.l[2], pEvent->xclient.data.l[2]);
      WBDebugPrint("    data[3].l:   %ld (%08lxH)\n", pEvent->xclient.data.l[3], pEvent->xclient.data.l[3]);
      WBDebugPrint("    data[4].l:   %ld (%08lxH)\n", pEvent->xclient.data.l[4], pEvent->xclient.data.l[4]);

      WBDebugDump("** client event data dump **", &(pEvent->xclient.data), sizeof(pEvent->xclient.data));
      break;


    case SelectionNotify: /* note THESE always use 'XGetAtomName' */
      p1 = XGetAtomName(pEvent->xany.display, pEvent->xselection.selection);
      WBDebugPrint("    selection:   %s\n", p1);
      XFree(p1);

      p1 = XGetAtomName(pEvent->xany.display, pEvent->xselection.target);
      WBDebugPrint("    target:      %s\n", p1);
      XFree(p1);

      p1 = XGetAtomName(pEvent->xany.display, pEvent->xselection.property);
      WBDebugPrint("    property:    %s\n", p1);
      XFree(p1);

      WBDebugPrint("    time:        %ld\n", (unsigned long)pEvent->xselection.time);
      break;


    case SelectionRequest: /* note THESE always use 'XGetAtomName' */
      WBDebugPrint("    Requestor:   %08xH\n", (unsigned int)pEvent->xselectionrequest.requestor);

      p1 = XGetAtomName(pEvent->xany.display, pEvent->xselectionrequest.selection);
      WBDebugPrint("    selection:   %s\n", p1);
      XFree(p1);

      p1 = XGetAtomName(pEvent->xany.display, pEvent->xselectionrequest.target);
      WBDebugPrint("    target:      %s\n", p1);
      XFree(p1);

      p1 = XGetAtomName(pEvent->xany.display, pEvent->xselectionrequest.property);
      WBDebugPrint("    property:    %s\n", p1);
      XFree(p1);

      WBDebugPrint("    time:        %ld\n", (unsigned long)pEvent->xselectionrequest.time);
      break;

//    default:
      // nothing else
  }
}


void WBDebugDumpRegion(Region hRgn, int bRotate)
{
XRectangle xrct;
int iW, iH;

  XClipBox(hRgn, &xrct);

  WBDebugPrint("REGION %u (%08xH):  clip rect: %d, %d, %d, %d  bRotate=%d\n",
               (unsigned int)(WB_UINTPTR)hRgn,
               (unsigned int)(WB_UINTPTR)hRgn,
               xrct.x, xrct.y, xrct.width + xrct.x, xrct.height + xrct.y,
               bRotate);

  if(xrct.width == 0 || xrct.height == 0)
  {
    WBDebugPrint("      (Region is empty)\n");
    return;
  }

  if(bRotate)
  {
    iW = xrct.x;
    xrct.x = xrct.y;
    xrct.y = iW;

    iW = xrct.width;
    xrct.width = xrct.height;
    xrct.height = iW;
  }

  WBDebugPrint("      ");
  for(iW=xrct.x; iW < xrct.x + xrct.width; iW++)
  {
    WBDebugPrint("%d", (iW / 100) % 10);
  }

  WBDebugPrint("\n      ");

  for(iW=xrct.x; iW < xrct.x + xrct.width; iW++)
  {
    WBDebugPrint("%d", (iW / 10) % 10);
  }

  WBDebugPrint("\n      ");

  for(iW=xrct.x; iW < xrct.x + xrct.width; iW++)
  {
    WBDebugPrint("%d", iW % 10);
  }

  WBDebugPrint("\n      ");

  for(iW=xrct.x; iW < xrct.x + xrct.width; iW++)
  {
    WBDebugPrint("-");
  }

  WBDebugPrint("+\n");


  for(iH=xrct.y; iH < xrct.y + xrct.height; iH++)
  {
    WBDebugPrint("%5d|", iH);
    for(iW=xrct.x; iW < xrct.x + xrct.width; iW++)
    {
      if((!bRotate && XPointInRegion(hRgn, iW, iH)) ||
         (bRotate && XPointInRegion(hRgn, iH, iW)))
      {
        WBDebugPrint(".");
      }
      else
      {
        WBDebugPrint(" ");
      }
    }
    WBDebugPrint("|\r\n");
  }

  WBDebugPrint("      ");

  for(iW=xrct.x; iW < xrct.x + xrct.width; iW++)
  {
    WBDebugPrint("=");
  }

  WBDebugPrint("+\n");

}


// ****************************************************
//
//            E R R O R   H A N D L I N G
//
// ****************************************************

static int WBXErrorHandler(Display *pDisplay, XErrorEvent *pError)
{
char tbuf[512];
int i1;
_WINDOW_ENTRY_ *pEntry;


  // if the error results from an expected condition, just set the
  // appropriate error information in the exception buffer and return
  // For now this will be a manual check after a function call but
  // later I may enable structured exception handling or a signal
  // 'SIGUSR1' might work for this...

  // cacheing the latest error information
  xErrorInfo.pDisplay = pDisplay;
  xErrorInfo.serial = pError->serial;
  xErrorInfo.pFunc = sz_xcall_func;
  xErrorInfo.iLine = i_xcall_line;
  xErrorInfo.error_code = pError->error_code;
  xErrorInfo.request_code = pError->request_code;
  xErrorInfo.minor_code = pError->minor_code;
  xErrorInfo.resourceid = pError->resourceid;

  if(bIgnoreXErrors)
  {
    return 1;
  }


  WB_ERROR_PRINT("%s","************************************************************************\n");

  // NOTE:  pError->type is always zero - replies are always 1 - these are reserved values, see X11/X.h

  WB_ERROR_PRINT("window_helper.c:%d  %s\n    display %pH  serial %08lxH\n",
                 __LINE__, __FUNCTION__, pDisplay, pError->serial);
  if(sz_xcall_func)
  {
    WB_ERROR_PRINT("    called from %s line %d\n", sz_xcall_func, i_xcall_line);
  }
//  else
//  {
//    WB_ERROR_PRINT("called from unknown function\n");
//  }

  XGetErrorText(pDisplay, pError->error_code, tbuf, sizeof(tbuf));
  WB_ERROR_PRINT("    Error Code: %d  %s\n", pError->error_code, tbuf);

  for(i1=0; aXProto[i1].szProto; i1++)
  {
    if(aXProto[i1].iProto == pError->request_code)
    {
      WB_ERROR_PRINT("    Request Code:  %s\n", aXProto[i1].szProto);
      break;
    }
  }

  if(!aXProto[i1].szProto)
  {
    WB_ERROR_PRINT("    Request Code:  UNKNOWN (%d, %08xH)\n", pError->request_code, pError->request_code);
  }

  WB_ERROR_PRINT("    Minor Request Code:  %d (%08xH)\n", pError->minor_code, pError->minor_code);

  if(pError->error_code == BadWindow ||
     ((pError->error_code == BadMatch || pError->error_code == BadDrawable) &&
      (pError->request_code == X_SetInputFocus ||
       pError->request_code == X_GetGeometry)))
  {
    pEntry = WBGetWindowEntry((Window)pError->resourceid);

    if(pEntry)
    {
#ifndef NO_DEBUG

      const char *pState;

      switch(pEntry->iWindowState)
      {
        case WB_WINDOW_DELETE:
          pState = "WB_WINDOW_DELETE";
          break;
        case WB_WINDOW_DESTROYED:
          pState = "WB_WINDOW_DESTROYED";
          break;
        case WB_WINDOW_UNMAPPED:
          pState = "WB_WINDOW_UNMAPPED";
          break;
        case WB_WINDOW_MAPPED:
          pState = "WB_WINDOW_MAPPED";
          break;
        case WB_WINDOW_SET_FOCUS_ON_MAP:
          pState = "WB_WINDOW_SET_FOCUS_ON_MAP";
          break;
        default:
          pState = "UNKNOWN STATE";
      }

      WB_ERROR_PRINT("    X Resource ID:  %d (%08xH) state=%d %s\n",
                     (int)pError->resourceid, (int)pError->resourceid,
                     pEntry->iWindowState, pState);

      if(pEntry->szClassName)
      {
        WB_ERROR_PRINT("        Window 'class name': %s\n", pEntry->szClassName);
      }

#endif // NO_DEBUG

      while(pEntry && pEntry->wParent != None)
      {
        Window wID = pEntry->wParent;
        pEntry = WBGetWindowEntry(wID);

        if(!pEntry)
        {
          WB_ERROR_PRINT("        Parent window:  %d (%08xH) (no entry)\n",
                         (int)wID, (int)wID);
        }
        else
        {
#ifndef NO_DEBUG

          switch(pEntry->iWindowState)
          {
            case WB_WINDOW_DELETE:
              pState = "WB_WINDOW_DELETE";
              break;
            case WB_WINDOW_DESTROYED:
              pState = "WB_WINDOW_DESTROYED";
              break;
            case WB_WINDOW_UNMAPPED:
              pState = "WB_WINDOW_UNMAPPED";
              break;
            case WB_WINDOW_MAPPED:
              pState = "WB_WINDOW_MAPPED";
              break;
            case WB_WINDOW_SET_FOCUS_ON_MAP:
              pState = "WB_WINDOW_SET_FOCUS_ON_MAP";
              break;
            default:
              pState = "UNKNOWN STATE";
          }

          WB_ERROR_PRINT("        Parent window:  %d (%08xH) state=%d %s\n",
                         (int)wID, (int)wID,
                         pEntry->iWindowState, pState);

          if(pEntry->szClassName)
          {
            WB_ERROR_PRINT("        Parent Window 'class name': %s\n", pEntry->szClassName);
          }

#endif // NO_DEBUG
        }
      }
    }
    else
    {
      WB_ERROR_PRINT("    X Resource ID:  %d (%08xH) (no window entry)\n", (int)pError->resourceid, (int)pError->resourceid);
    }
  }
  else
  {
    WB_ERROR_PRINT("    X Resource ID:  %d (%08xH)\n", (int)pError->resourceid, (int)pError->resourceid);
  }

  WB_ERROR_PRINT("%s","************************************************************************\n");
  return 1;
}


void WBErrorClear(void)
{
  memset(&xErrorInfo, 0, sizeof(xErrorInfo));
}

int WBErrorCheck(void)
{
  return xErrorInfo.pDisplay != NULL;
}

int WBErrorCheckRetry(void)
{
  if(!xErrorInfo.pDisplay)
  {
    return 0;
  }

  // check for possibility of retry

  return xErrorInfo.error_code == BadAlloc; // for now this is the only retryable one
}

const WB_ERROR_INFO * WBGetLastError(void)
{
  return &xErrorInfo;
}



// certain C compilers might not handle inlines well.  So I define function bodies for them here

#if !defined(__DOXYGEN__) && !defined(__GNUC__) && !defined(_MSVC_VER)

Display * WBGetDefaultDisplay(void)
{
  return pDefaultDisplay;
}

void WBInvalidateRect(Window wID, const WB_RECT *pRCT, int bPaintFlag)
{
  WB_GEOM geom;

  if(!pRCT)
  {
    WBInvalidateGeom(wID, NULL, bPaintFlag);
    return;
  }

  geom.x      = pRCT->left;
  geom.y      = pRCT->top;
  geom.width  = pRCT->right - pRCT->left;
  geom.height = pRCT->bottom - pRCT->top;
  geom.border = 0;

  WBInvalidateGeom(wID, &geom, bPaintFlag);
}

void WBValidateRect(Window wID, WB_RECT *pRCT)
{
  WB_GEOM geom;

  if(!pRCT)
  {
    WBValidateGeom(wID, NULL);
    return;
  }

  geom.x      = pRCT->left;
  geom.y      = pRCT->top;
  geom.width  = pRCT->right - pRCT->left;
  geom.height = pRCT->bottom - pRCT->top;
  geom.border = 0;

  WBValidateGeom(wID, &geom);
}

void WBSupressErrorOutput(void)
{
extern int bIgnoreXErrors;

  // TODO:  serialize this with a mutex or other sync object?
  bIgnoreXErrors++;
}

void WBAllowErrorOutput(void)
{
extern int bIgnoreXErrors;

  // TODO:  serialize this with a mutex or other sync object?
  if(bIgnoreXErrors > 0)
  {
    bIgnoreXErrors--;
  }
  else
  {
    bIgnoreXErrors = 0;
  }
}

#endif // !defined(__DOXYGEN__) && !defined(__GNUC__) && !defined(_MSVC_VER)



