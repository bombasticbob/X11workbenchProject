/////////////////////////////////////////////////////////////////////////////////////////////
//          _                                     _            _                           //
//   _ __  (_)__  __ _ __ ___    __ _  _ __      | |__    ___ | | _ __    ___  _ __  ___   //
//  | '_ \ | |\ \/ /| '_ ` _ \  / _` || '_ \     | '_ \  / _ \| || '_ \  / _ \| '__|/ __|  //
//  | |_) || | >  < | | | | | || (_| || |_) |    | | | ||  __/| || |_) ||  __/| | _| (__   //
//  | .__/ |_|/_/\_\|_| |_| |_| \__,_|| .__/_____|_| |_| \___||_|| .__/  \___||_|(_)\___|  //
//  |_|                               |_|  |_____|               |_|                       //
//                                                                                         //
//             pixmap and icon helpers (ultimately providing universal support)            //
//                                                                                         //
/////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2019 by Bob Frazier (aka 'Big Bad Bombastic Bob')

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.
               Any claims to alleged functionality or features should be
               considered 'preliminary', and might not function as advertised.

  MIT-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  MIT-like license.  See COPYING and README files for more information.

  This file may have additional license requirements, due to the use of
  potentially derived code.  Please see the code comments in the appropriate
  source file section to identify that portion of the code that may be
  covered by additional requirements.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <math.h> // and now I'll need -lm

// application header file
#include "pixmap_helper.h" // this will include platform_helper.h and window_helper.h

// This next section has includes for the XShmXXX functions - must do this AFTER platform_helper.h has been included
#if !defined(WIN32) && defined(X11WORKBENCH_TOOLKIT_HAVE_XSHM_EXTENSION)
#include <sys/ipc.h>
#include <sys/shm.h>
#include <X11/extensions/XShm.h>
#endif // !defined(WIN32) && defined(X11WORKBENCH_TOOLKIT_HAVE_XSHM_EXTENSION)

#ifdef X11WORKBENCH_TOOLKIT_HAVE_XFT
#include <X11/Xft/Xft.h>
#endif // X11WORKBENCH_TOOLKIT_HAVE_XFT


// include pixmap data

#include "icon_ok.xpm"
#include "icon_stop.xpm"
#include "icon_warn.xpm"
#include "icon_what.xpm"
#include "icon_splat.xpm"

// other pixmaps (some not entirely work safe)
#include "icon_bang.xpm"
#include "icon_barney.xpm"
#include "icon_bear.xpm"
#include "icon_death.xpm"
#include "icon_finger.xpm"
#include "icon_skull.xpm"
#include "icon_triangle.xpm"
#include "icon_what_bold.xpm"
#include "icon_wtf.xpm"
#include "icon_thumbup.xpm"
#include "icon_thumbdown.xpm"



#ifdef NO_DEBUG
#define DEBUG_DUMP_XPM_ATTRIBUTES(X)
#define DEBUG_DUMP_COLORMAP(X)
#else
static void DebugDumpXpmAttributes(const char *szFunction, int nLine, XPM_ATTRIBUTES *pAttr);
#define DEBUG_DUMP_XPM_ATTRIBUTES(X) DebugDumpXpmAttributes(__FUNCTION__, __LINE__, X)
#define DEBUG_DUMP_COLORMAP(X) WBDebugDumpColormap("Called from " __FUNCTION__, X)
#endif // NO_DEBUG


#define _PI_ 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679 /* approximately */


#define MINIMUM_ATOM_RESOURCE_LIST_SIZE 256

typedef struct __INTERNAL_ATOM_RESOURCE_LIST__
{
  Atom aAtom;
  char **ppResource;
} INTERNAL_ATOM_RESOURCE_LIST;

static INTERNAL_ATOM_RESOURCE_LIST *pAtomResourceList = NULL;
static int nAtomResourceList = 0, nAtomResourceListMax = 0;

static char **ppRegAppLarge_Internal = NULL;
static char **ppRegAppSmall_Internal = NULL;

XStandardColormap PXM_StandardColormapFromColormap_rval; // storage for static var for PXM_StandardColormapFromColormap()


//--------------------
// STARTUP AND CLEANUP
//--------------------

void PXM_OnExit(void)
{
  if(pAtomResourceList)
  {
    WBFree(pAtomResourceList);
    pAtomResourceList = NULL;
  }

  nAtomResourceList = 0;
  nAtomResourceListMax = 0;

  ppRegAppLarge_Internal = NULL;
  ppRegAppSmall_Internal = NULL;
}


//---------------
// MATH UTILITIES
//---------------

unsigned char WB_isqrt(unsigned char iVal)
{
static const unsigned char aAnswers[256] =
{
  0,1,1,2,2,2,2,3,3,3,3,3,3,4,4,4,
  4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,6,
  6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,
  8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,
  9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,10,
  10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,
  11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
  11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,
  12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,
  13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
  13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,
  14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
  14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,
  15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
  15,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16
};


  return aAnswers[iVal & 0xff];
}

unsigned char WB_icos0(unsigned char iVal)
{
static const unsigned char aAnswers[256] =
{
255,255,255,255,255,255,255,255,255,255,255,254,254,254,254,254,
254,254,253,253,253,253,253,252,252,252,252,252,251,251,251,250,
250,250,249,249,249,248,248,248,247,247,247,246,246,245,245,244,
244,244,243,243,242,242,241,241,240,240,239,238,238,237,237,236,
236,235,234,234,233,232,232,231,231,230,229,228,228,227,226,226,
225,224,223,223,222,221,220,220,219,218,217,216,215,215,214,213,
212,211,210,209,208,208,207,206,205,204,203,202,201,200,199,198,
197,196,195,194,193,192,191,190,189,188,187,186,185,184,183,181,
180,179,178,177,176,175,174,172,171,170,169,168,167,165,164,163,
162,161,159,158,157,156,154,153,152,151,149,148,147,146,144,143,
142,140,139,138,136,135,134,132,131,130,128,127,126,124,123,122,
120,119,117,116,115,113,112,110,109,108,106,105,103,102,100,99,
98,96,95,93,92,90,89,87,86,84,83,81,80,79,77,76,
74,73,71,70,68,67,65,63,62,60,59,57,56,54,53,51,
50,48,47,45,44,42,41,39,37,36,34,33,31,30,28,27,
25,23,22,20,19,17,16,14,13,11,9,8,6,5,3,2
};


  return aAnswers[iVal & 0xff];
}

static const char aCosAnswers[0x400] = // 1024 of them for a complete circle
{
  127, 127, 127, 127, 127, 127, 127, 127,
  127, 127, 127, 127, 127, 127, 127, 126,
  126, 126, 126, 126, 126, 126, 126, 126,
  126, 126, 125, 125, 125, 125, 125, 125,
  125, 124, 124, 124, 124, 124, 124, 123,
  123, 123, 123, 123, 122, 122, 122, 122,
  122, 121, 121, 121, 121, 120, 120, 120,
  120, 119, 119, 119, 118, 118, 118, 118,
  117, 117, 117, 116, 116, 116, 115, 115,
  115, 114, 114, 114, 113, 113, 113, 112,
  112, 112, 111, 111, 111, 110, 110, 109,
  109, 109, 108, 108, 107, 107, 106, 106,
  106, 105, 105, 104, 104, 103, 103, 102,
  102, 102, 101, 101, 100, 100, 99, 99,
  98, 98, 97, 97, 96, 96, 95, 95,
  94, 94, 93, 93, 92, 91, 91, 90,
  90, 89, 89, 88, 88, 87, 86, 86,
  85, 85, 84, 84, 83, 82, 82, 81,
  81, 80, 79, 79, 78, 78, 77, 76,
  76, 75, 74, 74, 73, 72, 72, 71,
  71, 70, 69, 69, 68, 67, 67, 66,
  65, 65, 64, 63, 63, 62, 61, 61,
  60, 59, 58, 58, 57, 56, 56, 55,
  54, 54, 53, 52, 51, 51, 50, 49,
  49, 48, 47, 46, 46, 45, 44, 44,
  43, 42, 41, 41, 40, 39, 38, 38,
  37, 36, 35, 35, 34, 33, 32, 32,
  31, 30, 29, 29, 28, 27, 26, 26,
  25, 24, 23, 22, 22, 21, 20, 19,
  19, 18, 17, 16, 16, 15, 14, 13,
  12, 12, 11, 10, 9, 9, 8, 7,
  6, 5, 5, 4, 3, 2, 2, 1,
  0, -1, -2, -2, -3, -4, -5, -5,
  -6, -7, -8, -9, -9, -10, -11, -12,
  -12, -13, -14, -15, -16, -16, -17, -18,
  -19, -19, -20, -21, -22, -22, -23, -24,
  -25, -26, -26, -27, -28, -29, -29, -30,
  -31, -32, -32, -33, -34, -35, -35, -36,
  -37, -38, -38, -39, -40, -41, -41, -42,
  -43, -44, -44, -45, -46, -46, -47, -48,
  -49, -49, -50, -51, -51, -52, -53, -54,
  -54, -55, -56, -56, -57, -58, -58, -59,
  -60, -61, -61, -62, -63, -63, -64, -65,
  -65, -66, -67, -67, -68, -69, -69, -70,
  -71, -71, -72, -72, -73, -74, -74, -75,
  -76, -76, -77, -78, -78, -79, -79, -80,
  -81, -81, -82, -82, -83, -84, -84, -85,
  -85, -86, -86, -87, -88, -88, -89, -89,
  -90, -90, -91, -91, -92, -93, -93, -94,
  -94, -95, -95, -96, -96, -97, -97, -98,
  -98, -99, -99, -100, -100, -101, -101, -102,
  -102, -102, -103, -103, -104, -104, -105, -105,
  -106, -106, -106, -107, -107, -108, -108, -109,
  -109, -109, -110, -110, -111, -111, -111, -112,
  -112, -112, -113, -113, -113, -114, -114, -114,
  -115, -115, -115, -116, -116, -116, -117, -117,
  -117, -118, -118, -118, -118, -119, -119, -119,
  -120, -120, -120, -120, -121, -121, -121, -121,
  -122, -122, -122, -122, -122, -123, -123, -123,
  -123, -123, -124, -124, -124, -124, -124, -124,
  -125, -125, -125, -125, -125, -125, -125, -126,
  -126, -126, -126, -126, -126, -126, -126, -126,
  -126, -126, -127, -127, -127, -127, -127, -127,
  -127, -127, -127, -127, -127, -127, -127, -127,
  -127, -127, -127, -127, -127, -127, -127, -127,
  -127, -127, -127, -127, -127, -127, -127, -126,
  -126, -126, -126, -126, -126, -126, -126, -126,
  -126, -126, -125, -125, -125, -125, -125, -125,
  -125, -124, -124, -124, -124, -124, -124, -123,
  -123, -123, -123, -123, -122, -122, -122, -122,
  -122, -121, -121, -121, -121, -120, -120, -120,
  -120, -119, -119, -119, -118, -118, -118, -118,
  -117, -117, -117, -116, -116, -116, -115, -115,
  -115, -114, -114, -114, -113, -113, -113, -112,
  -112, -112, -111, -111, -111, -110, -110, -109,
  -109, -109, -108, -108, -107, -107, -106, -106,
  -106, -105, -105, -104, -104, -103, -103, -102,
  -102, -102, -101, -101, -100, -100, -99, -99,
  -98, -98, -97, -97, -96, -96, -95, -95,
  -94, -94, -93, -93, -92, -91, -91, -90,
  -90, -89, -89, -88, -88, -87, -86, -86,
  -85, -85, -84, -84, -83, -82, -82, -81,
  -81, -80, -79, -79, -78, -78, -77, -76,
  -76, -75, -74, -74, -73, -72, -72, -71,
  -71, -70, -69, -69, -68, -67, -67, -66,
  -65, -65, -64, -63, -63, -62, -61, -61,
  -60, -59, -58, -58, -57, -56, -56, -55,
  -54, -54, -53, -52, -51, -51, -50, -49,
  -49, -48, -47, -46, -46, -45, -44, -44,
  -43, -42, -41, -41, -40, -39, -38, -38,
  -37, -36, -35, -35, -34, -33, -32, -32,
  -31, -30, -29, -29, -28, -27, -26, -26,
  -25, -24, -23, -22, -22, -21, -20, -19,
  -19, -18, -17, -16, -16, -15, -14, -13,
  -12, -12, -11, -10, -9, -9, -8, -7,
  -6, -5, -5, -4, -3, -2, -2, -1,
  0, 1, 2, 2, 3, 4, 5, 5,
  6, 7, 8, 9, 9, 10, 11, 12,
  12, 13, 14, 15, 16, 16, 17, 18,
  19, 19, 20, 21, 22, 22, 23, 24,
  25, 26, 26, 27, 28, 29, 29, 30,
  31, 32, 32, 33, 34, 35, 35, 36,
  37, 38, 38, 39, 40, 41, 41, 42,
  43, 44, 44, 45, 46, 46, 47, 48,
  49, 49, 50, 51, 51, 52, 53, 54,
  54, 55, 56, 56, 57, 58, 58, 59,
  60, 61, 61, 62, 63, 63, 64, 65,
  65, 66, 67, 67, 68, 69, 69, 70,
  71, 71, 72, 72, 73, 74, 74, 75,
  76, 76, 77, 78, 78, 79, 79, 80,
  81, 81, 82, 82, 83, 84, 84, 85,
  85, 86, 86, 87, 88, 88, 89, 89,
  90, 90, 91, 91, 92, 93, 93, 94,
  94, 95, 95, 96, 96, 97, 97, 98,
  98, 99, 99, 100, 100, 101, 101, 102,
  102, 102, 103, 103, 104, 104, 105, 105,
  106, 106, 106, 107, 107, 108, 108, 109,
  109, 109, 110, 110, 111, 111, 111, 112,
  112, 112, 113, 113, 113, 114, 114, 114,
  115, 115, 115, 116, 116, 116, 117, 117,
  117, 118, 118, 118, 118, 119, 119, 119,
  120, 120, 120, 120, 121, 121, 121, 121,
  122, 122, 122, 122, 122, 123, 123, 123,
  123, 123, 124, 124, 124, 124, 124, 124,
  125, 125, 125, 125, 125, 125, 125, 126,
  126, 126, 126, 126, 126, 126, 126, 126,
  126, 126, 127, 127, 127, 127, 127, 127,
  127, 127, 127, 127, 127, 127, 127, 127 //,
//  127
};

char WB_icos(int iVal)
{
  return aCosAnswers[iVal & 0x3ff];
}

unsigned int WB_iatan(int iX, int iY)
{

  return 0; // for now...
}





//-------------------------
// RGB and YUV conversions
//-------------------------

static int clip255(int iIn)
{
  if(iIn < 0)
  {
    return 0;
  }
  else if(iIn > 255)
  {
    return 255;
  }

  return iIn;
}

void PXM_RGBToYUV(int iR, int iG, int iB, int *piY, int *piU, int *piV)
{
int iY, iU, iV;

  iR = clip255(iR);
  iG = clip255(iG);
  iB = clip255(iB);

  iY = clip255(((  66 * iR + 129 * iG +  25 * iB + 128) >> 8) + 16);
  iU = clip255((( -38 * iR -  74 * iG + 112 * iB + 128) >> 8) + 128);
  iV = clip255((( 112 * iR -  94 * iG -  18 * iB + 128) >> 8) + 128);

  if(piY)
  {
    *piY = iY;
  }

  if(piU)
  {
    *piU = iU;
  }

  if(piV)
  {
    *piV = iV;
  }
}

void PXM_YUVToRGB(int iY, int iU, int iV, int *piR, int *piG, int *piB)
{
int iR, iG, iB;
int iC = iY - 16;
int iD = iU - 128;
int iE = iV - 128;

  iR = clip255(( 298 * iC            + 409 * iE + 128) >> 8);
  iG = clip255(( 298 * iC - 100 * iD - 208 * iE + 128) >> 8);
  iB = clip255(( 298 * iC + 516 * iD            + 128) >> 8);

  if(piR)
  {
    *piR = iR;
  }

  if(piG)
  {
    *piG = iG;
  }

  if(piB)
  {
    *piB = iB;
  }
}

void PXM_HSVToRGB(int iH, int iS, int iV, int *piR, int *piG, int *piB)
{
// this algorithm is similar to what Microsoft uses in their MFC classes, and
// what wxWidgets uses in their classes.  As such, it's an "open" algorithm,
// as the licensing of these two code bases appears to be otherwise incompatible.
// The algorithm has been attributed to A. R. Smith .  It appears to be "a standard"
// (NOTE:  I shall research to make sure it's use here is not stomping on ownership)
int iR, iG, iB;

double dH, dS, dV, dFracH, dR, dG, dB;
int iQuadrant;
double dUnSat, dLinDn, dLinUp;


  if(!iS) // a simple optimization for B&W
  {
    iR = iG = iB = iV; // RGB is equal to the brightness when no color
  }
  else
  {
    dH = (6.0 / 256.0) * iH;    // convert 0-255 angle to 0-360 angle [for the algorithm] and divide by 60
    iQuadrant = (int)floor(dH);  // quadrant 0 through 5 for 0-360 angle
    dFracH = dH - iQuadrant;     // the fractional part of 'dH'

    dS = iS / 255.0; // convert 0-255 saturation to 0-1.0 value
    dV = iV / 255.0; // convert 0-255 'Volume' (brightness, luminocity) to 0-1.0 value

    dUnSat = dV * (1.0 - dS);                  // linear delta based on saturation value
    dLinDn = dV * (1.0 - dS * dFracH);         // NOTE:  an improved algorithm would use a cos/sin function
    dLinUp = dV * (1.0 - dS * (1.0 - dFracH)); // NOTE:  an improved algorithm would use a cos/sin function

    // switch/case is typically slower - using 'if' block instead
    if(iQuadrant < 3) // bottom half
    {
      if(iQuadrant == 0)
      {
        dR = dV;       // red is essentially 'saturated' for +/-60 degrees... (this seems wrong to me)
        dG = dLinUp;   // linear slope increasing
        dB = dUnSat;   // 'un-saturated' value (as dS increases, this goes down, based on dV)
      }
      else if(iQuadrant == 1)
      {
        dR = dLinDn;   // linear slope decreasing
        dG = dV;       // now green is 'saturated'
        dB = dUnSat;   // still 'un-saturated'
      }
      else // 2
      {
        dR = dUnSat;   // now red is 'un-saturated'
        dG = dV;       // green still 'saturated'
        dB = dLinUp;   // blue is 'on the rise' now
      }
    }
    else
    {
      if(iQuadrant == 3)
      {
        dR = dUnSat;  // red is 'un-saturated' still
        dG = dLinDn;  // green is on the way down
        dB = dV;      // now blue is 'saturated'
      }
      else if(iQuadrant == 4)
      {
        dR = dLinUp;  // red is 'on the rise' now
        dG = dUnSat;  // green is 'unsaturated'
        dB = dV;      // blue is 'saturated' again
      }
      else // 5
      {
        dR = dV;      // red is 'saturated' again
        dG = dUnSat;  // green is still 'unsaturated'
        dB = dLinDn;  // blue is 'on the way down'
      }
    }

    iR = clip255((int)floor(256 * dR)); // using 256 rather than 255 gives me some 'rounding up'
    iG = clip255((int)floor(256 * dG));
    iB = clip255((int)floor(256 * dB));
	}

  if(piR)
  {
    *piR = iR;
  }

  if(piG)
  {
    *piG = iG;
  }

  if(piB)
  {
    *piB = iB;
  }
}

void PXM_RGBToHSV(int iR, int iG, int iB, int *piH, int *piS, int *piV)
{
// this algorithm is similar to what Microsoft uses in their MFC classes, and
// what wxWidgets uses in their classes.  As such, it's an "open" algorithm,
// as the licensing of these two code bases appears to be otherwise incompatible.
// The algorithm has been attributed to A. R. Smith .  It appears to be "a standard"
// (NOTE:  I shall research to make sure it's use here is not stomping on ownership)

double dH, dS, dV, dDelta;
int iMinRGB, iMaxRGB;


  iMinRGB = (iR <= iG)
          ? (iR <= iB)
             ? iR : iB
          : (iG <= iB)
             ? iG : iB;

  iMaxRGB = (iR >= iG)
          ? (iR >= iB)
             ? iR : iB
          : (iG >= iB)
             ? iG : iB;

  if(piV)
  {
    *piV = iMaxRGB; // use the max RGB value as my 'volume' (aka brightness, luminocity)
  }

  dV = iMaxRGB / 255.0; // convert to value between 0 and 1 for rest of algorithm

	if(!iMaxRGB) // black
	{
	  if(piH)
	  {
	    *piH = 0; // the color red
	  }
	  if(piS)
	  {
	    *piS = 0; // zero saturation
	  }

		return; // I am done here.  'V' is already equal to the RGB values (which must be the same if I get here)
	}

  dS = 1.0 * (iMaxRGB - iMinRGB) // the delta
	   / (double)iMaxRGB;          // ratio of delta to max = saturation (a value from 0 to 1.0)

  if(piS) // store it
  {
    *piS = clip255((int)floor(256.0 * dS));  // using 256 rather than 255 gives me some 'rounding up'
  }

  // calculating 'H'

  if(!piH) // if not asking for H, bail out now
  {
    return;
  }

	if(iMaxRGB == iMinRGB)
	{
		dH = 0.0; // the color 'red'
	}
	else
	{
	  // NOTE:  this infers the quadrants based on which color is maximum

    dDelta = iMaxRGB - iMinRGB;

    if(iR == iMaxRGB) // maxed out red?
		{
		  // quadrants 5 and 0 (note quadrant 5 goes negative)
      dH = (iG - iB) / dDelta; // calculate diff between yellow and magenta as +/- 1.0
    }
    else if(iG == iMaxRGB) // maxed out green?
    {
      dH = 2.0 + (iB - iR) / dDelta; // calculate diff between cyan and yellow as +/- 1.0
    }
    else // if(iB == iMaxRGB) maxed out blue
    {
      dH = 4.0 + (iR - iG) / dDelta; // calculate diff between magenta and cyan as +/- 1.0
    }
	}

  // dH is a value from -1 to 5.  If it's less than zero, add 6 to it
  if(dH < 0.0)
  {
    dH += 6.0;
  }

  // now dH is a value from 0 to 6, corresponding to values of 0-256.

  if(dH >= 6.0)
  {
    dH = 0.0;  // so it converts correctly
  }

  *piH = clip255((int)floor((256.0 / 6.0) * dH));  // using 256 rather than 255 gives me some 'rounding up'
}


static unsigned short internal_get_rgb_from_pixel(long lPixel, int iMult, int iMax)
{
unsigned long lVal;


  if(WB_LIKELY(iMult == 65536)) // a typical value for 8-bit colors in the pixel
  {
    lVal = lPixel / 65536; // this should compile as a fast bit shift
  }
  else if(WB_LIKELY(iMult == 256)) // a typical value for 8-bit colors in the pixel
  {
    lVal = lPixel / 256; // this should compile as a fast bit shift
  }
  else if(WB_LIKELY(iMult == 1)) // a typical value for 8-bit colors in the pixel
  {
    lVal = lPixel;
  }
  else // other values are possible, deal with them here
  {
    lVal = lPixel / iMult; // an arbitrary multiplier - slower, but functional
  }

  if(WB_LIKELY(iMax == 65535 || iMax == 255))
  {
    lVal = lVal & iMax;

    if(WB_LIKELY(iMax == 255))
    {
      if(lVal == iMax) // so that white is always ffffH
      {
        lVal = 65535;
      }
      else
      {
        lVal *= 256; // to convert it to 0-65535 value
      }
    }
  }
  else // unlikely, but possible - slower code but functional
  {
    lVal %= (iMax + 1);

    if(lVal == iMax) // so that white is always ffffH
    {
      lVal = 65535;
    }
    else
    {
#ifdef HAS_WB_UINT64_BUILTIN
      lVal = (unsigned long)((WB_UINT64)65536    // do math as 'long long' to avoid overflows on 32-bit
                             * (WB_UINT64)lVal
                             / (WB_UINT64)(iMax + 1));
#else  // !HAS_WB_UINT64_BUILTIN
      // NOTE:  some values could cause math overflow (but are not likely)

      lVal = 65536L * lVal
           / (iMax + 1);
#endif // HAS_WB_UINT64_BUILTIN
    }
  }

  return (unsigned short)lVal;
}

void PXM_PixelToRGB(XStandardColormap *pMap, XColor *pColor)
{
unsigned long lColor;
XStandardColormap map;


  if(!pColor)
  {
    return;
  }

  if(!pMap)
  {
    WBDefaultStandardColormap(WBGetDefaultDisplay(), &map);
    pMap = &map;

//    DEBUG_DUMP_COLORMAP(pMap);
  }

  // 'nuking' this one out is a bit difficult.  I have to sort the values properly

  lColor = pColor->pixel - pMap->base_pixel;

  if(!pMap->red_mult && !pMap->green_mult && !pMap->blue_mult)
  {
    return;
  }

  pColor->flags = DoRed | DoGreen | DoBlue; // pre-assign this, re-assign as needed

  if(!pMap->green_mult && !pMap->blue_mult)
  {
    // monochrome

    pColor->red = internal_get_rgb_from_pixel(lColor, pMap->red_mult, pMap->red_max);
    pColor->green = pColor->blue = pColor->red; // make them the same (by convention for now)

    pColor->flags = DoRed; // usually indicates 'monochrome' - only use 'red'
  }
  else
  {
    pColor->red = internal_get_rgb_from_pixel(lColor, pMap->red_mult, pMap->red_max);
    pColor->green = internal_get_rgb_from_pixel(lColor, pMap->green_mult, pMap->green_max);
    pColor->blue = internal_get_rgb_from_pixel(lColor, pMap->blue_mult, pMap->blue_max);
  }
}

void PXM_RGBToPixel(XStandardColormap *pMap, XColor *pColor)
{
unsigned long lR, lG, lB;
XStandardColormap map;


  if(!pColor)
  {
    return;
  }

  if(!pMap)
  {
    WBDefaultStandardColormap(WBGetDefaultDisplay(), &map);
    pMap = &map;

//    DEBUG_DUMP_COLORMAP(pMap);
  }

  // this one is straightforward, right out of the docs for the XStandardColormap structure

  lR = lG = lB = 0; // pre-assign

  if(!pColor->flags) // assume all 3 primaries, assign accordingly
  {
    pColor->flags = DoRed | DoGreen | DoBlue;
  }

  if(pColor->flags & DoRed)
  {
    lR = ((unsigned long)(pColor->red) * (unsigned long)(pMap->red_max + 1))
       / (unsigned long)65536L;
  }

//  if(lR < 0)
//  {
//    lR = 0;
//  }
//  else
  if(lR > pMap->red_max)
  {
    lR = pMap->red_max;
  }

  if(pColor->flags & DoGreen)
  {
    lG = ((unsigned long)(pColor->green) * (unsigned long)(pMap->green_max + 1))
       / (unsigned long)65536L;
  }

//  if(lG < 0)
//  {
//    lG = 0;
//  }
//  else
  if(lG > pMap->green_max)
  {
    lG = pMap->green_max;
  }

  if(pColor->flags & DoBlue)
  {
    lB = (((unsigned long)pColor->blue) * (unsigned long)(pMap->blue_max + 1))
       / (unsigned long)65536L;
  }

//  if(lB < 0)
//  {
//    lB = 0;
//  }
//  else
  if(lB > pMap->blue_max)
  {
    lB = pMap->blue_max;
  }

  pColor->pixel = (pMap->base_pixel
                   + lR * pMap->red_mult
                   + lG * pMap->green_mult
                   + lB * pMap->blue_mult)
                & 0xffffffffL;

//  WB_ERROR_PRINT("TEMPORARY:  %s - pixel=%lX %d,%d,%d  %ld,%ld,%ld  %ld,%ld,%ld  %ld,%ld,%ld %ld\n",
//                 __FUNCTION__,
//                 pColor->pixel, pColor->red, pColor->green, pColor->blue,
//                 lR, lG, lB, pMap->red_mult, pMap->green_mult, pMap->blue_mult,
//                 pMap->red_max, pMap->green_max, pMap->blue_max, pMap->base_pixel);
}


void PXM_RegisterAppIcons(char *ppRegAppLarge[], char *ppRegAppSmall[])
{
  ppRegAppLarge_Internal = ppRegAppLarge;
  ppRegAppSmall_Internal = ppRegAppSmall;
}

static char **GetPreDefinedIconResource(int idIcon)
{
char **pData = NULL;

  switch(idIcon)
  {
    case ID_APPLICATION:
      if(ppRegAppSmall_Internal)
      {
        pData = ppRegAppSmall_Internal;
      }
      else
      {
        pData = icon_ok_xpm; // TODO:  make a 19x19 version
      }
      break;
    case ID_ICON_APP:
      if(ppRegAppLarge_Internal)
      {
        pData = ppRegAppLarge_Internal;
      }
      else
      {
        pData = icon_ok_xpm;
      }
      break;
    case ID_ICON_OK:
      pData = icon_ok_xpm;
      break;
    case ID_ICON_STOP:
      pData = icon_stop_xpm;
      break;
    case ID_ICON_WARN:
      pData = icon_warn_xpm;
      break;
    case ID_ICON_WHAT:
      pData = icon_what_xpm;
      break;
    case ID_ICON_SPLAT:
      pData = icon_splat_xpm;
      break;
    case ID_ICON_BANG:
      pData = icon_bang_xpm;
      break;
    case ID_ICON_TRIANGLE:
      pData = icon_triangle_xpm;
      break;
    case ID_ICON_WHAT_BOLD:
      pData = icon_what_bold_xpm;
      break;
    case ID_ICON_WTF:
      pData = icon_wtf_xpm;
      break;
    case ID_ICON_DEATH:
      pData = icon_death_xpm;
      break;
    case ID_ICON_FINGER:
      pData = icon_finger_xpm;
      break;
    case ID_ICON_SKULL:
      pData = icon_skull_xpm;
      break;
    case ID_ICON_THUMBUP:
      pData = icon_thumbup_xpm;
      break;
    case ID_ICON_THUMBDOWN:
      pData = icon_thumbdown_xpm;
      break;
    case ID_ICON_BEAR:
      pData = icon_bear_xpm;
      break;
    case ID_ICON_BARNEY:  // this is a joke.  really.
      pData = icon_barney_xpm;
      break;
  }

  return pData;
}

static void RegisterIconResource(Atom aIcon, char **ppResource)
{
int i1;

  if(!pAtomResourceList)
  {
    pAtomResourceList = (INTERNAL_ATOM_RESOURCE_LIST *)
                        WBAlloc(MINIMUM_ATOM_RESOURCE_LIST_SIZE * sizeof(*pAtomResourceList));

    if(!pAtomResourceList)
    {
      WB_ERROR_PRINT("%s - not enough memoory for atom resource list\n", __FUNCTION__);
      return;
    }

    nAtomResourceList = 0;
    nAtomResourceListMax = MINIMUM_ATOM_RESOURCE_LIST_SIZE;
  }

  for(i1=0; i1 < nAtomResourceList; i1++)
  {
    if(pAtomResourceList[i1].aAtom == aIcon) // already there?
    {
      WB_ERROR_PRINT("%s - matching atom already in the list (ignoring)\n", __FUNCTION__);
      return;  // fow now I just leave.  later I might allow editing
    }
  }

  if((nAtomResourceList + 1) >= nAtomResourceListMax)
  {
    int iNewSize = MINIMUM_ATOM_RESOURCE_LIST_SIZE / 2 + nAtomResourceListMax;

    void *pTemp = WBReAlloc(pAtomResourceList, iNewSize);
    if(!pTemp)
    {
      WB_ERROR_PRINT("%s - not enough memoory for atom resource list re-alloc\n", __FUNCTION__);
      return;
    }

    pAtomResourceList = (INTERNAL_ATOM_RESOURCE_LIST *)pTemp;
    nAtomResourceListMax += MINIMUM_ATOM_RESOURCE_LIST_SIZE / 2;
  }

  pAtomResourceList[nAtomResourceList].aAtom = aIcon;
  pAtomResourceList[nAtomResourceList].ppResource = ppResource;
  nAtomResourceList++;
}

static const char * const szPreDefinedIconResources[] =
{
  "ID_APPLICATION",
  "ID_ICON_OK",
  "ID_ICON_STOP",
  "ID_ICON_WARN",
  "ID_ICON_WHAT",
  "ID_ICON_QUESTION",
  "ID_ICON_SPLAT",
  "ID_ICON_ASTERISK",
  "ID_ICON_BANG",
  "ID_ICON_TRIANGLE",
  "ID_ICON_WHAT_BOLD",
  "ID_ICON_WTF",
  "ID_ICON_DEATH",
  "ID_ICON_FINGER",
  "ID_ICON_SKULL",
  "ID_ICON_THUMBUP",
  "ID_ICON_THUMBDOWN",
  "ID_ICON_BEAR",
  "ID_ICON_BARNEY",
  "ID_ICON_APP"
};

static char **GetRegisteredIconResource(Atom aIcon)
{
static int iHasBeenRegistered = 0;
int i1, i2;

  // if the pre-defined atoms have not yet been registered, do it NOW

  if(!iHasBeenRegistered)
  {
    for(i1=ID_ICON_FIRST, i2=0;
        i1 <= ID_ICON_LAST
         && i2 < sizeof(szPreDefinedIconResources)/sizeof(szPreDefinedIconResources[0]);
        i1++, i2++)
    {
      Atom aTemp = WBGetAtom(WBGetDefaultDisplay(), szPreDefinedIconResources[i2]);

      if(aTemp != None)
      {
        RegisterIconResource(aTemp, GetPreDefinedIconResource(i1));
      }
    }

    iHasBeenRegistered = 1;
  }

  for(i1=0; i1 < nAtomResourceList; i1++)
  {
    if(pAtomResourceList[i1].aAtom == aIcon) // already there?
    {
      return pAtomResourceList[i1].ppResource;
    }
  }

  return NULL;
}



Pixmap PXM_GetIconPixmap(int idIcon, XPM_ATTRIBUTES *pAttr, Pixmap *pMask)
{
char **pData;


  pData = GetPreDefinedIconResource(idIcon);

  if(!pData)
  {
    if(pAttr)
    {
      bzero(pAttr, sizeof(*pAttr));
    }

    if(pMask)
    {
      *pMask = None;
    }

    return None;
  }

  return PXM_LoadPixmap(pData, pAttr, pMask);
}


Pixmap PXM_GetIconPixmapFromAtom(Atom aIcon, XPM_ATTRIBUTES *pAttr, Pixmap *pMask /* = NULL*/)
{
char **pData;


  pData = GetRegisteredIconResource(aIcon);

  if(!pData)
  {
    if(pAttr)
    {
      bzero(pAttr, sizeof(*pAttr));
    }

    if(pMask)
    {
      *pMask = None;
    }

    return None;
  }

  return PXM_LoadPixmap(pData, pAttr, pMask);
}


Pixmap PXM_LoadPixmap(char *ppXPM[], XPM_ATTRIBUTES *pAttr, Pixmap *pMask /* = NULL*/)
{
Pixmap pixRval = None, pixRval2 = None;
XPM_ATTRIBUTES xattr;
//#ifndef NO_DEBUG
//WB_UINT64 ullTime = WBGetTimeIndex();
//#endif // NO_DEBUG


  if(!ppXPM)
  {
    if(pAttr)
    {
      bzero(pAttr, sizeof(*pAttr));
    }

    if(pMask)
    {
      *pMask = None;
    }

    return None;
  }

  bzero(&xattr, sizeof(xattr));

//  WB_ERROR_PRINT("TEMPORARY:  %s line %d  delta tick %lld\n", __FUNCTION__, __LINE__, (WBGetTimeIndex() - ullTime));

#ifdef X11WORKBENCH_TOOLKIT_HAVE_XPM
  BEGIN_XCALL_DEBUG_WRAPPER
#endif // X11WORKBENCH_TOOLKIT_HAVE_XPM
  XPM_CREATE_PIXMAP_FROM_DATA(WBGetDefaultDisplay(), WBGetHiddenHelperWindow(),
                              ppXPM, &pixRval, &pixRval2, &xattr);
#ifdef X11WORKBENCH_TOOLKIT_HAVE_XPM
  END_XCALL_DEBUG_WRAPPER
#endif // X11WORKBENCH_TOOLKIT_HAVE_XPM

//  WB_ERROR_PRINT("TEMPORARY:  %s line %d  delta tick %lld\n", __FUNCTION__, __LINE__, (WBGetTimeIndex() - ullTime));

  if(pAttr)
  {
    memcpy(pAttr, &xattr, sizeof(xattr));
  }
  else
  {
    WB_IF_DEBUG_LEVEL(DebugLevel_Light | DebugSubSystem_Pixmap)
    {
      DEBUG_DUMP_XPM_ATTRIBUTES(&xattr);
    }

    XPM_FREE_ATTRIBUTES(&xattr);
  }

  if(pMask)
  {
    *pMask = pixRval2;
  }
  else if(pixRval2 != None) // free pixRval2 if it was allocated (it's the 'mask')
  {
    BEGIN_XCALL_DEBUG_WRAPPER
    XFreePixmap(WBGetDefaultDisplay(), pixRval2);
    END_XCALL_DEBUG_WRAPPER
  }

  return(pixRval);
}

Pixmap PXM_ImageToPixmap(Display *pDisplay, Drawable dw, XImage *pImage,
                         unsigned long clrFGPixel, unsigned long clrBGPixel)
{
Pixmap pxRval;
WBGC gc;
XGCValues gcv;
int iW, iH;

  if(!pDisplay)
  {
    pDisplay = WBGetDefaultDisplay();
  }

  if(!pImage)
  {
    WB_ERROR_PRINT("%s - pImage is NULL\n", __FUNCTION__);
    return None;
  }

  iW = pImage->width;
  iH = pImage->height;

  if(!iW || !iH)
  {
    WB_ERROR_PRINT("%s - Image width/height not valid, iW=%d,iH=%d\n", __FUNCTION__, iW, iH);
    return None;
  }

  BEGIN_XCALL_DEBUG_WRAPPER
  pxRval = XCreatePixmap(pDisplay, dw, iW, iH, DefaultDepth(pDisplay, DefaultScreen(pDisplay)));
  END_XCALL_DEBUG_WRAPPER

  if(pxRval == None)
  {
    WB_ERROR_PRINT("%s - XCreatePixmap failed\n", __FUNCTION__);
    return None;
  }

  // I will need to create a GC.  Make it a simple one that only specifies FG and BG

  memset(&gcv, 0, sizeof(gcv));
  gcv.foreground = clrFGPixel;//BlackPixel(pDisplay, DefaultScreen(pDisplay));
  gcv.background = clrBGPixel;//WhitePixel(pDisplay, DefaultScreen(pDisplay));

  // NOTE:  for monochrome masks I'd likely use '1' for foreground, '0' for background

  BEGIN_XCALL_DEBUG_WRAPPER
  gc = WBCreateGC(pDisplay, dw, (GCForeground | GCBackground), &gcv);
  END_XCALL_DEBUG_WRAPPER

  if(gc == NULL)
  {
    WB_ERROR_PRINT("%s - WBCreateGC failed\n", __FUNCTION__);

    BEGIN_XCALL_DEBUG_WRAPPER
    XFreePixmap(pDisplay, pxRval);
    END_XCALL_DEBUG_WRAPPER
    return None;
  }
  else
  {
    BEGIN_XCALL_DEBUG_WRAPPER
    WBXPutImage(pDisplay, pxRval, gc, pImage, 0, 0, 0, 0, iW, iH); // and now I have a copy of it

    WBFreeGC(gc);
    END_XCALL_DEBUG_WRAPPER
  }

  return pxRval;
}


Pixmap PXM_ImageToPixmap0(Display *pDisplay, Drawable dw, XImage *pImage)
{
  if(!pDisplay)
  {
    pDisplay = WBGetDefaultDisplay();
  }

  return PXM_ImageToPixmap(pDisplay, dw, pImage,
                           BlackPixel(pDisplay, DefaultScreen(pDisplay)),
                           WhitePixel(pDisplay, DefaultScreen(pDisplay)));
}


XImage *PXM_PixmapToImage(Display *pDisplay, Pixmap pxImage)
{
XImage *pRval;
Window winRoot; // not used, still needed?
int iX=0, iY=0;
unsigned int iWidth=0, iHeight=0, iBorder;
unsigned int uiDepth = 0;


  if(!pDisplay)
  {
    pDisplay = WBGetDefaultDisplay();
  }

  // TODO:  special handling for pxImage == None ???

  if(pxImage == None)
  {
    return NULL;
  }

  BEGIN_XCALL_DEBUG_WRAPPER

  // use XGetGeometry to obtain the characteristics of the pixmap.  iX and iY SHOULD be zero...
  XGetGeometry(pDisplay, pxImage, &winRoot, &iX, &iY, &iWidth, &iHeight, &iBorder, &uiDepth);

  if(!iWidth || !iHeight)
  {
    pRval = NULL;
  }
  else
  {
    // TODO:  do I still need iX and iY?
    pRval = WBXGetImage(pDisplay, pxImage, 0, 0, iWidth, iHeight, -1L, ZPixmap);
  }

  END_XCALL_DEBUG_WRAPPER

  return pRval;
}

Pixmap PXM_CopyPixmap(Display *pDisplay, Drawable dw, Pixmap pxSource)
{
XGCValues gcv;
Window winRoot;
GC gc;
Pixmap pxRval;
int iRet, iX=0, iY=0;
unsigned int iWidth=0, iHeight=0, iBorder;
unsigned int uiDepth = 0;


  if(!pDisplay)
  {
    pDisplay = WBGetDefaultDisplay();
  }

  if((CARD32)pxSource & 0xe0000000)
  {
    WB_ERROR_PRINT("%s - invalid Pixmap - %d (%08xH)\n", __FUNCTION__, (int)pxSource, (int)pxSource);

    return None;
  }

  BEGIN_XCALL_DEBUG_WRAPPER
  // use XGetGeometry to obtain the characteristics of the pixmap.  iX and iY SHOULD be zero...
  iRet = XGetGeometry(pDisplay, pxSource, &winRoot, &iX, &iY, &iWidth, &iHeight, &iBorder, &uiDepth);
  END_XCALL_DEBUG_WRAPPER

  if(!iWidth || !iHeight)
  {
    WB_ERROR_PRINT("%s - XGetGeometry failed, pxSource=%d (%08xH), iRet=%d\n",
                   __FUNCTION__, (int)pxSource, (int)pxSource, iRet);
    pxRval = None;
  }
  else
  {
    BEGIN_XCALL_DEBUG_WRAPPER
    pxRval = XCreatePixmap(pDisplay, dw, iWidth, iHeight, uiDepth); // note depth of new pixmap matches old
    END_XCALL_DEBUG_WRAPPER

    if(pxRval == None)
    {
      WB_ERROR_PRINT("%s - XCreatePixmap failed\n", __FUNCTION__);
      return None;
    }

    // I will need to create a GC.  Make it a simple one that only specifies FG and BG

    memset(&gcv, 0, sizeof(gcv));
    gcv.foreground = BlackPixel(pDisplay, DefaultScreen(pDisplay));  // use these (for now)
    gcv.background = WhitePixel(pDisplay, DefaultScreen(pDisplay));

    // NOTE:  for monochrome masks I'd likely use '1' for foreground, '0' for background

    BEGIN_XCALL_DEBUG_WRAPPER
    gc = XCreateGC(pDisplay, dw, (GCForeground | GCBackground), &gcv);
    END_XCALL_DEBUG_WRAPPER

    if(gc == NULL)
    {
      WB_ERROR_PRINT("%s - WBCreateGC failed\n", __FUNCTION__);

      BEGIN_XCALL_DEBUG_WRAPPER
      XFreePixmap(pDisplay, pxRval);
      END_XCALL_DEBUG_WRAPPER
      pxRval = None;
    }
    else
    {
      BEGIN_XCALL_DEBUG_WRAPPER
      XCopyArea(pDisplay, pxSource, pxRval, gc, 0, 0, iWidth, iHeight, 0, 0);
      XFreeGC(pDisplay, gc);
      END_XCALL_DEBUG_WRAPPER
    }
  }

  return pxRval;
}

void WBSimpleAntiAliasPixmap(Display *pDisplay, const XStandardColormap *pMap, Pixmap pxImage, unsigned long lPixel, WB_GEOM *pGeom)
{
WB_GEOM geom;
XImage *pImage = NULL;
WBGC gc;
XGCValues gcv;
XStandardColormap map;


  if(!pDisplay)
  {
    pDisplay = WBGetDefaultDisplay();
  }

  if(pxImage == None)
  {
    return;
  }

  if(!pMap)
  {
    WBDefaultStandardColormap(pDisplay, &map);
    pMap = &map;
  }

  if(pGeom)
  {
    memcpy(&geom, pGeom, sizeof(geom));
  }
  else
  {
    Window winRoot; // unused, but I still need it

    int iX=0, iY=0;
    unsigned int iWidth=0, iHeight=0, iBorder;
    unsigned int uiDepth = 0;

    // use XGetGeometry to obtain the characteristics of the pixmap.  iX and iY SHOULD be zero...
    BEGIN_XCALL_DEBUG_WRAPPER
    XGetGeometry(pDisplay, pxImage, &winRoot, &iX, &iY, &iWidth, &iHeight, &iBorder, &uiDepth);
    END_XCALL_DEBUG_WRAPPER

    geom.x = 0;
    geom.y = 0;
    geom.width = iWidth;
    geom.height = iHeight;
  }

  if(!geom.width || !geom.height)
  {
    return;
  }

  // create an XImage, and perform the operation on that
  BEGIN_XCALL_DEBUG_WRAPPER
  pImage = WBXGetImage(pDisplay, pxImage, geom.x, geom.y, geom.width, geom.height, 0xffffffff, ZPixmap);
  // NOTE:  'ZPixmap' is WAY faster than XYPixmap, but takes up more RAM
  END_XCALL_DEBUG_WRAPPER

  if(!pImage)
  {
    WB_ERROR_PRINT("ERROR: %s - unable to create image via XGetImage()\n", __FUNCTION__);
    return;
  }

  WBSimpleAntiAliasImage(pMap, pImage, lPixel, &geom);

  memset(&gcv, 0, sizeof(gcv));
  gcv.foreground = lPixel;
  gcv.background = lPixel; // for now just do this

  BEGIN_XCALL_DEBUG_WRAPPER
  gc = WBCreateGC(pDisplay, pxImage, (GCForeground | GCBackground), &gcv);
  END_XCALL_DEBUG_WRAPPER

  if(gc == None)
  {
    WB_ERROR_PRINT("%s - XCreateGC failed\n", __FUNCTION__);
  }
  else
  {
    BEGIN_XCALL_DEBUG_WRAPPER
    WBXPutImage(pDisplay, pxImage, gc, pImage, 0, 0, geom.x, geom.y, geom.width, geom.height);

    WBFreeGC(gc);
    END_XCALL_DEBUG_WRAPPER
  }

  // I can destroy the image now
  BEGIN_XCALL_DEBUG_WRAPPER
  WBXDestroyImage(pImage);
  END_XCALL_DEBUG_WRAPPER
}

static unsigned long __internal_grey_the_pixel(XStandardColormap *pMap, unsigned long lPixel,
                                               int iR0, int iG0, int iB0) // note 16-bit RGB here
{
XColor clr;
int iR, iG, iB;

  clr.pixel = lPixel;
  PXM_PixelToRGB(pMap, &clr);
  RGB_FROM_XCOLOR(clr, iR, iG, iB); // 16-bit RGB values

  iR = (3 * iR + iR0 + 1) / 4; // create 'average' colors (this works the best, 3/4 original, 1/4 background)
  iG = (3 * iG + iG0 + 1) / 4;
  iB = (3 * iB + iB0 + 1) / 4;

  RGB_TO_XCOLOR(iR, iG, iB, clr);
  PXM_RGBToPixel(pMap, &clr);

  return clr.pixel;  // yeah that was a lot of stuff to do
}

void WBSimpleAntiAliasImage(const XStandardColormap *pMap, XImage *pImage, unsigned long lPixel, WB_GEOM *pGeom)
{
WB_GEOM geom;
XStandardColormap map;
int nX, nY, iR, iG, iB;
XColor clr;


  // TODO:  do I want to operate directly on the memory?  for now, use the 'XGetPixel' and 'XPutPixel' utilities

  if(!pImage)
  {
    return;
  }

  if(!pMap)
  {
    WBDefaultStandardColormap(WBGetDefaultDisplay(), &map);
  }
  else
  {
    memcpy(&map, pMap, sizeof(map));
  }

  if(pGeom)
  {
    memcpy(&geom, pGeom, sizeof(geom));
  }
  else
  {
    geom.x = 0;
    geom.y = 0;
    geom.width = pImage->width;
    geom.height = pImage->height;
  }

  clr.pixel = lPixel;
  PXM_PixelToRGB(&map, &clr);
  RGB_FROM_XCOLOR(clr, iR, iG, iB);

  for(nX = geom.x; nX < (geom.x + geom.width - 1); nX++)
  {
    for(nY = geom.y; nY < (geom.y + geom.height - 1); nY++)
    {
      // detect the 'inside pixel' or 'outside pixel' on a corner
      // the idea is to look for one of these and put 'greyed'
      // pixels in between
      //
      //  X.           Xo       .X           oX
      //  .X  becomes  oX  and  X.  becomes  Xo
      //
      //  where 'o' represents a color between . and X
      //

      unsigned long lPixel1 = XGetPixel(pImage, nX, nY);
      unsigned long lPixel2 = XGetPixel(pImage, nX + 1, nY);
      unsigned long lPixel3 = XGetPixel(pImage, nX, nY + 1);
      unsigned long lPixel4 = XGetPixel(pImage, nX + 1, nY + 1);

      if(lPixel1 == lPixel && lPixel4 == lPixel)
      {
        if(lPixel2 != lPixel) // grey it
        {
          lPixel2 = __internal_grey_the_pixel(&map, lPixel2, iR, iG, iB);
          if(lPixel2 != lPixel) // make sure it's not because if it is, it's a problem
          {
            BEGIN_XCALL_DEBUG_WRAPPER
            XPutPixel(pImage, nX + 1, nY, lPixel2);
            END_XCALL_DEBUG_WRAPPER
          }
        }

        if(lPixel3 != lPixel) // grey it
        {
          lPixel3 = __internal_grey_the_pixel(&map, lPixel3, iR, iG, iB);
          if(lPixel3 != lPixel) // make sure it's not because if it is, it's a problem
          {
            BEGIN_XCALL_DEBUG_WRAPPER
            XPutPixel(pImage, nX, nY + 1, lPixel3);
            END_XCALL_DEBUG_WRAPPER
          }
        }
      }

      if(lPixel2 == lPixel && lPixel3 == lPixel)
      {
        if(lPixel1 != lPixel) // grey it
        {
          lPixel1 = __internal_grey_the_pixel(&map, lPixel1, iR, iG, iB);
          if(lPixel1 != lPixel) // make sure it's not because if it is, it's a problem
          {
            BEGIN_XCALL_DEBUG_WRAPPER
            XPutPixel(pImage, nX, nY, lPixel1);
            END_XCALL_DEBUG_WRAPPER
          }
        }

        if(lPixel4 != lPixel) // grey it
        {
          lPixel4 = __internal_grey_the_pixel(&map, lPixel4, iR, iG, iB);
          if(lPixel4 != lPixel) // make sure it's not because if it is, it's a problem
          {
            BEGIN_XCALL_DEBUG_WRAPPER
            XPutPixel(pImage, nX + 1, nY + 1, lPixel4);
            END_XCALL_DEBUG_WRAPPER
          }
        }
      }

    }
  }

}


#if defined(X11WORKBENCH_TOOLKIT_HAVE_XSHM_EXTENSION) || defined(__DOXYGEN__)
int WBXShmQueryExtension(Display *pDisplay)
{
  return XShmQueryExtension(pDisplay) ? 1 : 0;
}
#endif // defined(X11WORKBENCH_TOOLKIT_HAVE_XSHM_EXTENSION) || defined(__DOXYGEN__)

int WBXPutImage(Display *pDisplay, Drawable dw, WBGC gc, XImage *pImage,
                int src_x, int src_y, int dest_x, int dest_y,
                unsigned int width, unsigned int height)
{
int iRval;

  // for now, just do this
  BEGIN_XCALL_DEBUG_WRAPPER
  iRval = XPutImage(pDisplay, dw, gc->gc, pImage, src_x, src_y, dest_x, dest_y, width, height); // for now just do this
  END_XCALL_DEBUG_WRAPPER

  // TODO: I'll need to determine whether or not my image is using shared memory
  //       and also make sure that it's attached to the display [as it should be]
  //       If both of these is NOT the case, then I use XPutImage() to avoid issues

//Bool XShmPutImage(
//            Display *display;
//            Drawable d;
//            GC gc;
//            XImage *image;
//            int src_x, src_y, dest_x, dest_y;
//            unsigned int width, height;
//            bool send_event);

  return iRval;
}

XImage *WBXGetImage(Display *pDisplay, Drawable dw,
                    int x, int y, unsigned int width, unsigned int height,
                    unsigned long plane_mask, int format)
{
XImage *pImage;

  // TODO:  if the drawable has an image locally cached, use it.  This handles the situation
  //        where a remote connection has poor performance grabbing an image from the server,
  //        but sending an image TO the server is reasonably fast by comparison.


#if defined(X11WORKBENCH_TOOLKIT_HAVE_XSHM_EXTENSION) || defined(__DOXYGEN__)
  if(!WBXShmQueryExtension(pDisplay))
  {
#endif // defined(X11WORKBENCH_TOOLKIT_HAVE_XSHM_EXTENSION) || defined(__DOXYGEN__)

    BEGIN_XCALL_DEBUG_WRAPPER
    pImage = XGetImage(pDisplay, dw, x, y, width, height, plane_mask, format);
    END_XCALL_DEBUG_WRAPPER

#if defined(X11WORKBENCH_TOOLKIT_HAVE_XSHM_EXTENSION) || defined(__DOXYGEN__)
  }
  else
  {
//    WB_ERROR_PRINT("TEMPORARY:  %s line %d - 'XShm' not (yet) being invoked\n", __FUNCTION__, __LINE__);

    BEGIN_XCALL_DEBUG_WRAPPER
    pImage = XGetImage(pDisplay, dw, x, y, width, height, plane_mask, format); // for now just do this
    END_XCALL_DEBUG_WRAPPER

    if(!pImage)
    {
      WB_ERROR_PRINT("ERROR - %s - Unable to get XImage:  dw=%08xH x=%d y=%d width=%d height=%d plane_mask=%08lxH format=%d\n",
                     __FUNCTION__, (int)dw, x, y, width, height, (unsigned long)plane_mask, format);
    }

#if 0
    XShmSegmentInfo shminfo;
    int screen = DefaultScreen(pDisplay);
    Visual *pVisual = DefaultVisual(pDisplay, screen);
    int depth = DefaultDepth(pDisplay, screen);

    if(format == XYBitmap)
    {
      depth = 1;
    }

    bzero(&shminfo, sizeof(shminfo));

    pImage = XShmCreateImage(pDisplay, pVisual, depth, format, NULL, &shminfo, width, height);

    if(pImage)
    {
      shminfo.readOnly = False;
      pImage->data = WBAllocShm(pDisplay, image->bytes_per_line * image->height, &shminfo, IPC_PRIVATE, PIC_CREAT | 0777);

      if(!pImage->data)
      {
        WBXDestroyImage(pImage);
        pImage = NULL;
      }

//      shminfo.shmaddr; // shmat(shminfo.shmid, 0, 0);
//      shminfo.readOnly = False;

//      if(!XShmAttach(d, &shminfo))
//      {
//        // this would be an error
//      }

      if(!XShmGetImage(pDisplay, dw, pImage, x, y, plane_mask))
      {
        // is FALSE the error, or is it a TRUE value that's an error?  determine which...

        WBXDestroyImage(pImage);
        pImage = NULL;
      }

      XSync(pDisplay, 0); // must do this to make sure it completes before I return
    }
#endif // 0
  }
#endif // defined(X11WORKBENCH_TOOLKIT_HAVE_XSHM_EXTENSION) || defined(__DOXYGEN__)
  return pImage;
}

int WBXDestroyImage(XImage *pImage)
{
int iRval;

  // TODO:  determine whether the image is using shared memory.  If so, detach
  //        it from the display (if it's attached), and free the shared memory
  //        FIRST, and set the data pointer to NULL.  Then, destroy the image
  //        with XDestroyImage() as if nothing else was different.

  BEGIN_XCALL_DEBUG_WRAPPER
  iRval = XDestroyImage(pImage); // for now, just do this
  END_XCALL_DEBUG_WRAPPER

  return iRval;
}

XImage * WBXCopyImage(Display *pDisplay, XImage *pImage)
{
XImage *pRval;

  if(!pImage)
  {
    return NULL;
  }

  if(!pDisplay)
  {
    pDisplay = WBGetDefaultDisplay();
  }

  BEGIN_XCALL_DEBUG_WRAPPER
  pRval = XCreateImage(pDisplay, DefaultVisual(pDisplay, DefaultScreen(pDisplay)),
                       pImage->depth, pImage->format, pImage->xoffset,
                       pImage->data, pImage->width, pImage->height,
                       pImage->bitmap_pad, pImage->bytes_per_line);
  END_XCALL_DEBUG_WRAPPER


  return pRval;
}


//////////////////////////////////////////////////////////////////////////////////////
// X11 'equivalence' functions for XImage
//
// Some of this code may have been adapted from the Xorg and/or earlier versions
// of the X11 server implementation, and derivatives of it.  The copyright statement
// and license for the X11 server code is included here, for reference:
//
      /*

      Copyright 1988, 1998  The Open Group

      Permission to use, copy, modify, distribute, and sell this software and its
      documentation for any purpose is hereby granted without fee, provided that
      the above copyright notice appear in all copies and that both that
      copyright notice and this permission notice appear in supporting
      documentation.

      The above copyright notice and this permission notice shall be included
      in all copies or substantial portions of the Software.

      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
      IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
      OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
      ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
      OTHER DEALINGS IN THE SOFTWARE.

      Except as contained in this notice, the name of The Open Group shall
      not be used in advertising or otherwise to promote the sale, use or
      other dealings in this Software without prior written authorization
      from The Open Group.

      Copyright 1989 by Digital Equipment Corporation, Maynard, Massachusetts.

                              All Rights Reserved

      Permission to use, copy, modify, and distribute this software and its
      documentation for any purpose and without fee is hereby granted,
      provided that the above copyright notice appear in all copies and that
      both that copyright notice and this permission notice appear in
      supporting documentation, and that the name of Digital not be
      used in advertising or publicity pertaining to distribution of the
      software without specific, written prior permission.

      DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
      ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
      DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
      ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
      WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
      ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
      SOFTWARE.
      */
//
// Please do not remove the above copyright and licensing information from
// any derived work.  Thank you.
//
// Although this code can not be considered 'derived', I most definitely
// examined the licensed code when writing it.  As such I believe it is only
// fair to at least comply with the intent of the license for Xorg and
// related X11 libraries and X11 servers.
//
//////////////////////////////////////////////////////////////////////////////////////



Region WBXImageToRegion(const XImage *pImage)
{
Region rgnRval;

  if(!pImage)
  {
    rgnRval = None;
  }
  else
  {
    // Use 'pImage' "not background pixel" x,y points to create a Region.
    //
    // see 'miCoalesce' in Xorg server; how horizontal 'bands' are used to combine
    // rectangles in a Region. I want to do something very much like that here, so
    // that there are no adjacent rectangles horizontally.
    // After that I fix it vertically.  Pretty straightforward.  Should be fast.


    rgnRval = None; // temporary
  }

  return rgnRval;
}

XImage * WBXImageFromRegion(Region rgnSource, int width, int height)
{
XImage *pRval;

  if(rgnSource == None)
  {
    pRval = NULL;
  }
  else
  {
    // First create an XImage that matches the bounding rectangle of the region.
    // Then,
    // simply figure out what the bounding rect is
    // see 'miCoalesce' in Xorg serve; how horizontal 'bands' are used to combine
    // rectangles in a Region. I want to do something very much like that here, so
    // that there are no adjacent rectangles horizontally.
    // After that I fix it vertically.  Pretty straightforward.  Should be fast.


    pRval = NULL; // temporary
  }

  return pRval;
}

int WBXDrawPoint(XImage *pImage, WBGC hGC, int x, int y)
{
int iRval;
int bNoClip;

  if(!pImage || !hGC)
  {
    return -1;
  }

  iRval = 0;
  bNoClip = hGC->clip_rgn == None || XEmptyRegion(hGC->clip_rgn);

  if(bNoClip ||
     XPointInRegion(hGC->clip_rgn, x, y)) // TODO:  clip origin???
  {
    BEGIN_XCALL_DEBUG_WRAPPER
    iRval = XPutPixel(pImage, x, y, hGC->values.foreground);
    END_XCALL_DEBUG_WRAPPER
  }

  return iRval;
}

int WBXDrawPoints(XImage *pImage, WBGC hGC,
                  XPoint *points, int npoints, int mode)
{
int i1, i2, iX, iY, iRval;
int bNoClip;


  if(!pImage || !hGC || !points || npoints <= 0 ||
     (mode != CoordModeOrigin && mode != CoordModePrevious))
  {
    return -1;
  }

  iX = points[0].x; // warning avoidance, put this here, mostly for CoordModePrevious
  iY = points[0].y;

  bNoClip = hGC->clip_rgn == None || XEmptyRegion(hGC->clip_rgn);

  for(i1=0, iRval = 0; i1 < npoints; i1++)
  {
    if(mode == CoordModeOrigin)
    {
      iX = points[i1].x; // ok this does it again for the first point but so what
      iY = points[i1].y;
    }
    else
    {
      iX += points[i1].x;
      iY += points[i1].y;
    }

    if(!bNoClip) // we have a clip region
    {
      // don't poke the point if it's not inside the clip region
      if(!XPointInRegion(hGC->clip_rgn, iX, iY)) // TODO:  clip origin???
      {
        continue; // skip this point
      }
    }

    BEGIN_XCALL_DEBUG_WRAPPER
    i2 = XPutPixel(pImage, iX, iY, hGC->values.foreground);
    END_XCALL_DEBUG_WRAPPER

    if(i2)
    {
      iRval = i2;
    }
  }

  return iRval;
}

int WBXDrawLine(XImage *pImage, WBGC hGC,
                int x1, int y1, int x2, int y2)
{
//  return -1; // for now
XPoint pt[2];

  pt[0].x = x1;
  pt[0].y = y1;
  pt[1].x = x2;
  pt[1].y = y2;

  return WBXDrawLines(pImage, hGC, &(pt[0]), 2, CoordModeOrigin); // probably the best way
}


// for reference, from x11-servers/xorg-server/work/xorg-server-1.18.4/mi/miwideline.c
//void
//miPolylines(DrawablePtr drawable,
//            GCPtr gc,
//            int mode,
//            int n,
//            DDXPointPtr points)
//{
//    if (gc->lineWidth == 0) {
//        if (gc->lineStyle == LineSolid)
//            miZeroLine(drawable, gc, mode, n, points);
//        else
//            miZeroDashLine(drawable, gc, mode, n, points);
//    } else {
//        if (gc->lineStyle == LineSolid)
//            miWideLine(drawable, gc, mode, n, points);
//        else
//            miWideDash(drawable, gc, mode, n, points);
//    }

int WBXDrawLines(XImage *pImage, WBGC hGC,
                 XPoint *points, int npoints, int mode)
{

  if(!pImage || !hGC || !points || npoints <= 0 ||
     (mode != CoordModeOrigin && mode != CoordModePrevious))
  {
    return -1;
  }

  // by definition, a line width of zero is "minimal line" which is for me the same as 1
  // and would be independent of scaling and other factors (so always 1 pixel)
  // a pixel width greater than 1 should be the width of the line such that horizontal or
  // vertical would be "that many" pixels and I assume diagonal is the same 'appearance'
  // width, meaning you gotta do some simple trig or another algorithm that looks similar


  // TODO: implement this


  return -1; // for now
}

int WBXDrawRectangle(XImage *pImage, WBGC hGC,
                     int x, int y, unsigned int width, unsigned int height)
{
XPoint ptRect[5];

  ptRect[0].x = x;
  ptRect[0].y = y;
  ptRect[1].x = x + width - 1;
  ptRect[1].y = y;
  ptRect[2].x = ptRect[1].x;
  ptRect[2].y = y + height - 1;
  ptRect[3].x = x;
  ptRect[3].y = ptRect[2].y;
  ptRect[4].x = x;
  ptRect[4].y = y; // close up the polygon

  return WBXDrawLines(pImage, hGC, &(ptRect[0]),
                      sizeof(ptRect) / sizeof(ptRect[0]),
                      CoordModeOrigin); // probably the best way
}

int WBXFillRectangle(XImage *pImage, WBGC hGC,
                     int x, int y, unsigned int width, unsigned int height)
{
int iRval;

XPoint ptRect[5];

  ptRect[0].x = x;
  ptRect[0].y = y;
  ptRect[1].x = x + width - 1;
  ptRect[1].y = y;
  ptRect[2].x = ptRect[1].x;
  ptRect[2].y = y + height - 1;
  ptRect[3].x = x;
  ptRect[3].y = ptRect[2].y;
  ptRect[4].x = x;
  ptRect[4].y = y; // close up the polygon

  iRval = WBXFillPolygon(pImage, hGC, &(ptRect[0]),
                         sizeof(ptRect) / sizeof(ptRect[0]),
                         Convex, CoordModeOrigin); // use 'convex' shape for rectangle

  if(!iRval) // fill worked, now draw the outline
  {
    // TODO:  if foreground color is same as fill color, no need to do this next part

    iRval = WBXDrawLines(pImage, hGC, &(ptRect[0]),
                         sizeof(ptRect) / sizeof(ptRect[0]),
                         CoordModeOrigin); // probably the best way
  }

  return -1; // for now
}

int WBXDrawArc(XImage *pImage, WBGC hGC,
               int x, int y, unsigned int width, unsigned int height,
               int angle1, int angle2)
{
XPoint ptPoly[4096]; // 4k points for my arc polygon
XPoint *pPoly = &(ptPoly[0]); // if I need more points, malloc them.
int iRval, nLines = 0;


  // TODO: use integer trig WB_isin(X) and WB_icos(X) to determine the x and y offsets
  //       from the center, and draw a set of lines from point to point.  so simple!
  //
  // NOTE:  'WB_icos(X) uses 'pi == 512' for angular granularity. so a circle is
  //        literally 1024 "angular units" i.e. 0x400


  // TODO:  implement this


  // render the poly lines using WBXDrawLines
  iRval = 0;

  if(nLines > 0)
  {
    iRval = WBXDrawLines(pImage, hGC, pPoly, nLines,
                         CoordModeOrigin); // probably the best way
  }

  return iRval;
}

int WBXFillArc(XImage *pImage, WBGC hGC,
               int x, int y, unsigned int width, unsigned int height,
               int angle1, int angle2)
{
  return -1; // for now (use WBXFillPolygon to do it, similar to what WBXDrawArc does)
}

int WBXFillPolygon(XImage *pImage, WBGC hGC,
                   XPoint *points, int npoints, int shape, int mode)
{
  if(!pImage || !hGC || !points || npoints <= 0 ||
     (shape != Convex && shape != Nonconvex && shape != Complex) ||
     (mode != CoordModeOrigin && mode != CoordModePrevious))
  {
    return -1;
  }

  // shape can be Convex, Nonconvex, or Complex
  // mode can be CoordModeOrigin or CoordModePrevious

  // basic fill algorithm for arbitrary complex polygon:
  //
  // 1.  get a bounding retangle for it
  // 2.  start at one corner, go across or down (either works)
  // 3.  when you reach a boundary for one of the edges, flip the 'fill' bit
  //  3a. this could be done with a mono bitmap except when lines overlap
  //  3b. so instead this should be done mathematically, except it's slower
  // 4.  In cases where lines overlap any of the bits, ignore them
  //
  // a convex polygon makes this quite a bit easier, COULD use a mono bitmap
  // to enclose the polygon and a simpler fill method to test the mono bitmap.


  return -1; // for now
}

int WBXDrawString(XImage *pImage, WB_FONTC pFont, WBGC hGC,
                  int x, int y, const char *string, int length)
{
//Display *pDisplay = WBGetDefaultDisplay(); // in case I need one



// TODO:  if 'pFont' is NULL, use the font assigned to WBGC

#ifdef X11WORKBENCH_TOOLKIT_HAVE_XFT
  if(pFont->pxftFont)
  {
#warning TODO: IMPLEMENT THIS PART for Xft FONTS - this may require legacy font stuff too
  }
  else
#endif // X11WORKBENCH_TOOLKIT_HAVE_XFT
  {
    // Legacy mode
    //
    // Step 1:  draw the text in black on white using a monochrome pixmap, left/bottom justified
    // Step 2:  transfer the pixmap to a 1-plane XY Image
    // Step 3:  Using 'hGC', do a bitwise copy onto the XImage such that the background is transparent
    //          with the 'hGC's foreground color and any anti-alising I might want to add...


  }

  return -1; // for now
}





#ifndef NO_DEBUG
static void DebugDumpXpmAttributes(const char *szFunction, int nLine, XPM_ATTRIBUTES *pAttr)
{
  WBDebugPrint("%s line %d XPM_ATTRIBUTES contain:\n", szFunction, nLine);
#if defined(X11WORKBENCH_TOOLKIT_HAVE_XPM)
  WBDebugPrint("  valuemask:          %ld\n", pAttr->valuemask);
  WBDebugPrint("  visual:             %p\n", pAttr->visual);
  WBDebugPrint("  colormap:           %p\n", (void *)pAttr->colormap);
#endif // defined(X11WORKBENCH_TOOLKIT_HAVE_XPM)

  WBDebugPrint("  depth:              %u\n", pAttr->depth);
  WBDebugPrint("  width:              %u\n", pAttr->width);
  WBDebugPrint("  height:             %u\n", pAttr->height);

// if I'm using libXpm then I have some additional data members...
#if defined(X11WORKBENCH_TOOLKIT_HAVE_XPM)
  WBDebugPrint("  x_hotspot:          %u\n", pAttr->x_hotspot);
  WBDebugPrint("  y_hotspot:          %u\n", pAttr->y_hotspot);
  WBDebugPrint("  cpp:                %u\n", pAttr->cpp);
  WBDebugPrint("  pixels:             %p\n", pAttr->pixels);
  WBDebugPrint("  npixels:            %u\n", pAttr->npixels);
  WBDebugPrint("  colorsymbols:       %p\n", pAttr->colorsymbols);
  WBDebugPrint("  numsymbols:         %u\n", pAttr->numsymbols);
  WBDebugPrint("  rgb_fname:          %s\n", pAttr->rgb_fname);
  WBDebugPrint("  nextensions:        %u\n", pAttr->nextensions);
  WBDebugPrint("  extensions:         %p\n", pAttr->extensions);
  WBDebugPrint("  ncolors:            %u\n", pAttr->ncolors);
  WBDebugPrint("  colorTable:         %p\n", pAttr->colorTable);
  WBDebugPrint("  mask_pixel:         %u\n", pAttr->mask_pixel);
  WBDebugPrint("  exactColors:        %c\n", pAttr->exactColors ? 'T' : 'F');
  WBDebugPrint("  closeness:          %u\n", pAttr->closeness);
  WBDebugPrint("  red_closeness:      %u\n", pAttr->red_closeness);
  WBDebugPrint("  green_closeness:    %u\n", pAttr->green_closeness);
  WBDebugPrint("  blue_closeness:     %u\n", pAttr->blue_closeness);
  WBDebugPrint("  color_key:          %d\n", pAttr->color_key);
  WBDebugPrint("  alloc_pixels:       %p\n", pAttr->alloc_pixels);
  WBDebugPrint("  nalloc_pixels:      %d\n", pAttr->nalloc_pixels);
  WBDebugPrint("  alloc_close_colors: %c\n", pAttr->alloc_close_colors ? 'T' : 'F');
  WBDebugPrint("  bitmap_format:      %d\n", pAttr->bitmap_format);
  WBDebugPrint("  alloc_color:        %p\n", pAttr->alloc_color);
  WBDebugPrint("  free_colors:        %p\n", pAttr->free_colors);
  WBDebugPrint("  color_closure:      %p\n", pAttr->color_closure);
#endif // defined(X11WORKBENCH_TOOLKIT_HAVE_XPM)
}
#endif // !NO_DEBUG


void WBDebugDumpColormap(const char *szTitle, const XStandardColormap *pMap)
{
#ifndef NO_DEBUG
  WBDebugPrint("WBDebugDumpColormap - %s\n", szTitle);
  WBDebugPrint("  XStandardColormap:  %p\n", pMap);
  if(pMap)
  {
    WBDebugPrint("    colormap   = %lld\n", (WB_UINT64)pMap->colormap);
    WBDebugPrint("    red_max    = %ld\n", pMap->red_max);
    WBDebugPrint("    red_mult   = %ld\n", pMap->red_mult);
    WBDebugPrint("    green_max  = %ld\n", pMap->green_max);
    WBDebugPrint("    green_mult = %ld\n", pMap->green_mult);
    WBDebugPrint("    blue_max   = %ld\n", pMap->blue_max);
    WBDebugPrint("    blue_mult  = %ld\n", pMap->blue_mult);
    WBDebugPrint("    base_pixel = %ld (%08lxH)\n", pMap->base_pixel, pMap->base_pixel);
  }
#endif // !NO_DEBUG
}


void WBDebugDumpXColor(const char *szTitle, const XColor *pColor)
{
#ifndef NO_DEBUG
char tbuf[32];

  WBDebugPrint("DebugDumpXColor - %s\n", szTitle);
  WBDebugPrint("  XColor:  %p\n", pColor);
  if(pColor)
  {
    WBDebugPrint("    pixel = %lu \"#%6.6lX\"\n", pColor->pixel, pColor->pixel);
    WBDebugPrint("    red   = %d\n", pColor->red);
    WBDebugPrint("    green = %d\n", pColor->green);
    WBDebugPrint("    blue  = %d\n", pColor->blue);

    tbuf[0] = 0;
    if(pColor->flags & DoRed)
    {
//      if(tbuf[0])
//      {
//        strcat(tbuf, " | ");
//      }

      strcat(tbuf, "DoRed");
    }

    if(pColor->flags & DoGreen)
    {
      if(tbuf[0])
      {
        strcat(tbuf, " | ");
      }

      strcat(tbuf, "DoGreen");
    }

    if(pColor->flags & DoBlue)
    {
      if(tbuf[0])
      {
        strcat(tbuf, " | ");
      }

      strcat(tbuf, "DoBlue");
    }

    if(tbuf[0])
    {
      WBDebugPrint("    flags = %d   %s\n", pColor->flags, tbuf);
    }
    else
    {
      WBDebugPrint("    flags = %d   (%XH)\n", pColor->flags, pColor->flags);
    }
  }
#endif // !NO_DEBUG
}


