/////////////////////////////////////////////////////////////////////////////////////////////
//          _                                     _            _                           //
//   _ __  (_)__  __ _ __ ___    __ _  _ __      | |__    ___ | | _ __    ___  _ __  ___   //
//  | '_ \ | |\ \/ /| '_ ` _ \  / _` || '_ \     | '_ \  / _ \| || '_ \  / _ \| '__|/ __|  //
//  | |_) || | >  < | | | | | || (_| || |_) |    | | | ||  __/| || |_) ||  __/| | _| (__   //
//  | .__/ |_|/_/\_\|_| |_| |_| \__,_|| .__/_____|_| |_| \___||_|| .__/  \___||_|(_)\___|  //
//  |_|                               |_|  |_____|               |_|                       //
//                                                                                         //
//             pixmap and icon helpers (ultimately providing universal support)            //
//                                                                                         //
/////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2018 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.
               Any claims to alleged functionality or features should be
               considered 'preliminary', and might not function as advertised.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <math.h> // and now I'll need -lm

// application header file
#include "pixmap_helper.h" // this will include platform_helper.h and window_helper.h

// include pixmap data

#include "icon_ok.xpm"
#include "icon_stop.xpm"
#include "icon_warn.xpm"
#include "icon_what.xpm"
#include "icon_splat.xpm"

// other pixmaps (some not entirely work safe)
#include "icon_bang.xpm"
#include "icon_barney.xpm"
#include "icon_bear.xpm"
#include "icon_death.xpm"
#include "icon_finger.xpm"
#include "icon_skull.xpm"
#include "icon_triangle.xpm"
#include "icon_what_bold.xpm"
#include "icon_wtf.xpm"
#include "icon_thumbup.xpm"
#include "icon_thumbdown.xpm"



#ifdef NO_DEBUG
#define DEBUG_DUMP_XPM_ATTRIBUTES(X)
#define DEBUG_DUMP_COLORMAP(X)
#else
static void DebugDumpXpmAttributes(const char *szFunction, int nLine, XPM_ATTRIBUTES *pAttr);
#define DEBUG_DUMP_XPM_ATTRIBUTES(X) DebugDumpXpmAttributes(__FUNCTION__, __LINE__, X)
#define DEBUG_DUMP_COLORMAP(X) WBDebugDumpColormap("Called from " __FUNCTION__, X)
#endif // NO_DEBUG


#define _PI_ 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679 /* approximately */


#define MINIMUM_ATOM_RESOURCE_LIST_SIZE 256

typedef struct __INTERNAL_ATOM_RESOURCE_LIST__
{
  Atom aAtom;
  char **ppResource;
} INTERNAL_ATOM_RESOURCE_LIST;

static INTERNAL_ATOM_RESOURCE_LIST *pAtomResourceList = NULL;
static int nAtomResourceList = 0, nAtomResourceListMax = 0;

static char **ppRegAppLarge_Internal = NULL;
static char **ppRegAppSmall_Internal = NULL;

XStandardColormap PXM_StandardColormapFromColormap_rval; // storage for static var for PXM_StandardColormapFromColormap()

//-------------------------
// RGB and YUV conversions
//-------------------------

static int clip255(int iIn)
{
  if(iIn < 0)
  {
    return 0;
  }
  else if(iIn > 255)
  {
    return 255;
  }

  return iIn;
}

void PXM_RGBToYUV(int iR, int iG, int iB, int *piY, int *piU, int *piV)
{
int iY, iU, iV;

  iR = clip255(iR);
  iG = clip255(iG);
  iB = clip255(iB);

  iY = clip255(((  66 * iR + 129 * iG +  25 * iB + 128) >> 8) + 16);
  iU = clip255((( -38 * iR -  74 * iG + 112 * iB + 128) >> 8) + 128);
  iV = clip255((( 112 * iR -  94 * iG -  18 * iB + 128) >> 8) + 128);

  if(piY)
  {
    *piY = iY;
  }

  if(piU)
  {
    *piU = iU;
  }

  if(piV)
  {
    *piV = iV;
  }
}

void PXM_YUVToRGB(int iY, int iU, int iV, int *piR, int *piG, int *piB)
{
int iR, iG, iB;
int iC = iY - 16;
int iD = iU - 128;
int iE = iV - 128;

  iR = clip255(( 298 * iC            + 409 * iE + 128) >> 8);
  iG = clip255(( 298 * iC - 100 * iD - 208 * iE + 128) >> 8);
  iB = clip255(( 298 * iC + 516 * iD            + 128) >> 8);

  if(piR)
  {
    *piR = iR;
  }

  if(piG)
  {
    *piG = iG;
  }

  if(piB)
  {
    *piB = iB;
  }
}

void PXM_HSVToRGB(int iH, int iS, int iV, int *piR, int *piG, int *piB)
{
// this algorithm is similar to what Microsoft uses in their MFC classes, and
// what wxWidgets uses in their classes.  As such, it's an "open" algorithm,
// as the licensing of these two code bases appears to be otherwise incompatible.
// The algorithm has been attributed to A. R. Smith .  It appears to be "a standard"
// (NOTE:  I shall research to make sure it's use here is not stomping on ownership)
int iR, iG, iB;

double dH, dS, dV, dFracH, dR, dG, dB;
int iQuadrant;
double dUnSat, dLinDn, dLinUp;


  if(!iS) // a simple optimization for B&W
  {
    iR = iG = iB = iV; // RGB is equal to the brightness when no color
  }
  else
  {
    dH = (6.0 / 256.0) * iH;    // convert 0-255 angle to 0-360 angle [for the algorithm] and divide by 60
    iQuadrant = (int)floor(dH);  // quadrant 0 through 5 for 0-360 angle
    dFracH = dH - iQuadrant;     // the fractional part of 'dH'

    dS = iS / 255.0; // convert 0-255 saturation to 0-1.0 value
    dV = iV / 255.0; // convert 0-255 'Volume' (brightness, luminocity) to 0-1.0 value

    dUnSat = dV * (1.0 - dS);                  // linear delta based on saturation value
    dLinDn = dV * (1.0 - dS * dFracH);         // NOTE:  an improved algorithm would use a cos/sin function
    dLinUp = dV * (1.0 - dS * (1.0 - dFracH)); // NOTE:  an improved algorithm would use a cos/sin function

    // switch/case is typically slower - using 'if' block instead
    if(iQuadrant < 3) // bottom half
    {
      if(iQuadrant == 0)
      {
        dR = dV;       // red is essentially 'saturated' for +/-60 degrees... (this seems wrong to me)
        dG = dLinUp;   // linear slope increasing
        dB = dUnSat;   // 'un-saturated' value (as dS increases, this goes down, based on dV)
      }
      else if(iQuadrant == 1)
      {
        dR = dLinDn;   // linear slope decreasing
        dG = dV;       // now green is 'saturated'
        dB = dUnSat;   // still 'un-saturated'
      }
      else // 2
      {
        dR = dUnSat;   // now red is 'un-saturated'
        dG = dV;       // green still 'saturated'
        dB = dLinUp;   // blue is 'on the rise' now
      }
    }
    else
    {
      if(iQuadrant == 3)
      {
        dR = dUnSat;  // red is 'un-saturated' still
        dG = dLinDn;  // green is on the way down
        dB = dV;      // now blue is 'saturated'
      }
      else if(iQuadrant == 4)
      {
        dR = dLinUp;  // red is 'on the rise' now
        dG = dUnSat;  // green is 'unsaturated'
        dB = dV;      // blue is 'saturated' again
      }
      else // 5
      {
        dR = dV;      // red is 'saturated' again
        dG = dUnSat;  // green is still 'unsaturated'
        dB = dLinDn;  // blue is 'on the way down'
      }
    }

    iR = clip255((int)floor(256 * dR)); // using 256 rather than 255 gives me some 'rounding up'
    iG = clip255((int)floor(256 * dG));
    iB = clip255((int)floor(256 * dB));
	}

  if(piR)
  {
    *piR = iR;
  }

  if(piG)
  {
    *piG = iG;
  }

  if(piB)
  {
    *piB = iB;
  }
}

void PXM_RGBToHSV(int iR, int iG, int iB, int *piH, int *piS, int *piV)
{
// this algorithm is similar to what Microsoft uses in their MFC classes, and
// what wxWidgets uses in their classes.  As such, it's an "open" algorithm,
// as the licensing of these two code bases appears to be otherwise incompatible.
// The algorithm has been attributed to A. R. Smith .  It appears to be "a standard"
// (NOTE:  I shall research to make sure it's use here is not stomping on ownership)

double dH, dS, dV, dDelta;
int iMinRGB, iMaxRGB;


  iMinRGB = (iR <= iG)
          ? (iR <= iB)
             ? iR : iB
          : (iG <= iB)
             ? iG : iB;

  iMaxRGB = (iR >= iG)
          ? (iR >= iB)
             ? iR : iB
          : (iG >= iB)
             ? iG : iB;

  if(piV)
  {
    *piV = iMaxRGB; // use the max RGB value as my 'volume' (aka brightness, luminocity)
  }

  dV = iMaxRGB / 255.0; // convert to value between 0 and 1 for rest of algorithm

	if(!iMaxRGB) // black
	{
	  if(piH)
	  {
	    *piH = 0; // the color red
	  }
	  if(piS)
	  {
	    *piS = 0; // zero saturation
	  }

		return; // I am done here.  'V' is already equal to the RGB values (which must be the same if I get here)
	}

  dS = 1.0 * (iMaxRGB - iMinRGB) // the delta
	   / (double)iMaxRGB;          // ratio of delta to max = saturation (a value from 0 to 1.0)

  if(piS) // store it
  {
    *piS = clip255((int)floor(256.0 * dS));  // using 256 rather than 255 gives me some 'rounding up'
  }

  // calculating 'H'

  if(!piH) // if not asking for H, bail out now
  {
    return;
  }

	if(iMaxRGB == iMinRGB)
	{
		dH = 0.0; // the color 'red'
	}
	else
	{
	  // NOTE:  this infers the quadrants based on which color is maximum

    dDelta = iMaxRGB - iMinRGB;

    if(iR == iMaxRGB) // maxed out red?
		{
		  // quadrants 5 and 0 (note quadrant 5 goes negative)
      dH = (iG - iB) / dDelta; // calculate diff between yellow and magenta as +/- 1.0
    }
    else if(iG == iMaxRGB) // maxed out green?
    {
      dH = 2.0 + (iB - iR) / dDelta; // calculate diff between cyan and yellow as +/- 1.0
    }
    else // if(iB == iMaxRGB) maxed out blue
    {
      dH = 4.0 + (iR - iG) / dDelta; // calculate diff between magenta and cyan as +/- 1.0
    }
	}

  // dH is a value from -1 to 5.  If it's less than zero, add 6 to it
  if(dH < 0.0)
  {
    dH += 6.0;
  }

  // now dH is a value from 0 to 6, corresponding to values of 0-256.

  if(dH >= 6.0)
  {
    dH = 0.0;  // so it converts correctly
  }

  *piH = clip255((int)floor((256.0 / 6.0) * dH));  // using 256 rather than 255 gives me some 'rounding up'
}


static unsigned short internal_get_rgb_from_pixel(long lPixel, int iMult, int iMax)
{
unsigned long lVal;


  if(WB_LIKELY(iMult == 65536)) // a typical value for 8-bit colors in the pixel
  {
    lVal = lPixel / 65536; // this should compile as a fast bit shift
  }
  else if(WB_LIKELY(iMult == 256)) // a typical value for 8-bit colors in the pixel
  {
    lVal = lPixel / 256; // this should compile as a fast bit shift
  }
  else if(WB_LIKELY(iMult == 1)) // a typical value for 8-bit colors in the pixel
  {
    lVal = lPixel;
  }
  else // other values are possible, deal with them here
  {
    lVal = lPixel / iMult; // an arbitrary multiplier - slower, but functional
  }

  if(WB_LIKELY(iMax == 65535 || iMax == 255))
  {
    lVal = lVal & iMax;

    if(WB_LIKELY(iMax == 255))
    {
      if(lVal == iMax) // so that white is always ffffH
      {
        lVal = 65535;
      }
      else
      {
        lVal *= 256; // to convert it to 0-65535 value
      }
    }
  }
  else // unlikely, but possible - slower code but functional
  {
    lVal %= (iMax + 1);

    if(lVal == iMax) // so that white is always ffffH
    {
      lVal = 65535;
    }
    else
    {
#ifdef HAS_WB_UINT64_BUILTIN
      lVal = (unsigned long)((WB_UINT64)65536    // do math as 'long long' to avoid overflows on 32-bit
                             * (WB_UINT64)lVal
                             / (WB_UINT64)(iMax + 1));
#else  // !HAS_WB_UINT64_BUILTIN
      // NOTE:  some values could cause math overflow (but are not likely)

      lVal = 65536L * lVal
           / (iMax + 1);
#endif // HAS_WB_UINT64_BUILTIN
    }
  }

  return (unsigned short)lVal;
}

void PXM_PixelToRGB(XStandardColormap *pMap, XColor *pColor)
{
unsigned long lColor;
XStandardColormap map;


  if(!pColor)
  {
    return;
  }

  if(!pMap)
  {
    WBDefaultStandardColormap(WBGetDefaultDisplay(), &map);
    pMap = &map;

//    DEBUG_DUMP_COLORMAP(pMap);
  }

  // 'nuking' this one out is a bit difficult.  I have to sort the values properly

  lColor = pColor->pixel - pMap->base_pixel;

  if(!pMap->red_mult && !pMap->green_mult && !pMap->blue_mult)
  {
    return;
  }

  pColor->flags = DoRed | DoGreen | DoBlue; // pre-assign this, re-assign as needed

  if(!pMap->green_mult && !pMap->blue_mult)
  {
    // monochrome

    pColor->red = internal_get_rgb_from_pixel(lColor, pMap->red_mult, pMap->red_max);
    pColor->green = pColor->blue = pColor->red; // make them the same (by convention for now)

    pColor->flags = DoRed; // usually indicates 'monochrome' - only use 'red'
  }
  else
  {
    pColor->red = internal_get_rgb_from_pixel(lColor, pMap->red_mult, pMap->red_max);
    pColor->green = internal_get_rgb_from_pixel(lColor, pMap->green_mult, pMap->green_max);
    pColor->blue = internal_get_rgb_from_pixel(lColor, pMap->blue_mult, pMap->blue_max);
  }
}

void PXM_RGBToPixel(XStandardColormap *pMap, XColor *pColor)
{
unsigned long lR, lG, lB;
XStandardColormap map;


  if(!pColor)
  {
    return;
  }

  if(!pMap)
  {
    WBDefaultStandardColormap(WBGetDefaultDisplay(), &map);
    pMap = &map;

//    DEBUG_DUMP_COLORMAP(pMap);
  }

  // this one is straightforward, right out of the docs for the XStandardColormap structure

  lR = lG = lB = 0; // pre-assign

  if(!pColor->flags) // assume all 3 primaries, assign accordingly
  {
    pColor->flags = DoRed | DoGreen | DoBlue;
  }

  if(pColor->flags & DoRed)
  {
    lR = ((unsigned long)(pColor->red) * (unsigned long)(pMap->red_max + 1))
       / (unsigned long)65536L;
  }

//  if(lR < 0)
//  {
//    lR = 0;
//  }
//  else
  if(lR > pMap->red_max)
  {
    lR = pMap->red_max;
  }

  if(pColor->flags & DoGreen)
  {
    lG = ((unsigned long)(pColor->green) * (unsigned long)(pMap->green_max + 1))
       / (unsigned long)65536L;
  }

//  if(lG < 0)
//  {
//    lG = 0;
//  }
//  else
  if(lG > pMap->green_max)
  {
    lG = pMap->green_max;
  }

  if(pColor->flags & DoBlue)
  {
    lB = (((unsigned long)pColor->blue) * (unsigned long)(pMap->blue_max + 1))
       / (unsigned long)65536L;
  }

//  if(lB < 0)
//  {
//    lB = 0;
//  }
//  else
  if(lB > pMap->blue_max)
  {
    lB = pMap->blue_max;
  }

  pColor->pixel = (pMap->base_pixel
                   + lR * pMap->red_mult
                   + lG * pMap->green_mult
                   + lB * pMap->blue_mult)
                & 0xffffffffL;

//  WB_ERROR_PRINT("TEMPORARY:  %s - pixel=%lX %d,%d,%d  %ld,%ld,%ld  %ld,%ld,%ld  %ld,%ld,%ld %ld\n",
//                 __FUNCTION__,
//                 pColor->pixel, pColor->red, pColor->green, pColor->blue,
//                 lR, lG, lB, pMap->red_mult, pMap->green_mult, pMap->blue_mult,
//                 pMap->red_max, pMap->green_max, pMap->blue_max, pMap->base_pixel);
}


void PXM_RegisterAppIcons(char *ppRegAppLarge[], char *ppRegAppSmall[])
{
  ppRegAppLarge_Internal = ppRegAppLarge;
  ppRegAppSmall_Internal = ppRegAppSmall;
}

static char **GetPreDefinedIconResource(int idIcon)
{
char **pData = NULL;

  switch(idIcon)
  {
    case ID_APPLICATION:
      if(ppRegAppSmall_Internal)
      {
        pData = ppRegAppSmall_Internal;
      }
      else
      {
        pData = icon_ok_xpm; // TODO:  make a 19x19 version
      }
      break;
    case ID_ICON_APP:
      if(ppRegAppLarge_Internal)
      {
        pData = ppRegAppLarge_Internal;
      }
      else
      {
        pData = icon_ok_xpm;
      }
      break;
    case ID_ICON_OK:
      pData = icon_ok_xpm;
      break;
    case ID_ICON_STOP:
      pData = icon_stop_xpm;
      break;
    case ID_ICON_WARN:
      pData = icon_warn_xpm;
      break;
    case ID_ICON_WHAT:
      pData = icon_what_xpm;
      break;
    case ID_ICON_SPLAT:
      pData = icon_splat_xpm;
      break;
    case ID_ICON_BANG:
      pData = icon_bang_xpm;
      break;
    case ID_ICON_TRIANGLE:
      pData = icon_triangle_xpm;
      break;
    case ID_ICON_WHAT_BOLD:
      pData = icon_what_bold_xpm;
      break;
    case ID_ICON_WTF:
      pData = icon_wtf_xpm;
      break;
    case ID_ICON_DEATH:
      pData = icon_death_xpm;
      break;
    case ID_ICON_FINGER:
      pData = icon_finger_xpm;
      break;
    case ID_ICON_SKULL:
      pData = icon_skull_xpm;
      break;
    case ID_ICON_THUMBUP:
      pData = icon_thumbup_xpm;
      break;
    case ID_ICON_THUMBDOWN:
      pData = icon_thumbdown_xpm;
      break;
    case ID_ICON_BEAR:
      pData = icon_bear_xpm;
      break;
    case ID_ICON_BARNEY:  // this is a joke.  really.
      pData = icon_barney_xpm;
      break;
  }

  return pData;
}

static void RegisterIconResource(Atom aIcon, char **ppResource)
{
int i1;

  if(!pAtomResourceList)
  {
    pAtomResourceList = (INTERNAL_ATOM_RESOURCE_LIST *)
                        WBAlloc(MINIMUM_ATOM_RESOURCE_LIST_SIZE * sizeof(*pAtomResourceList));

    if(!pAtomResourceList)
    {
      WB_ERROR_PRINT("%s - not enough memoory for atom resource list\n", __FUNCTION__);
      return;
    }

    nAtomResourceList = 0;
    nAtomResourceListMax = MINIMUM_ATOM_RESOURCE_LIST_SIZE;
  }

  for(i1=0; i1 < nAtomResourceList; i1++)
  {
    if(pAtomResourceList[i1].aAtom == aIcon) // already there?
    {
      WB_ERROR_PRINT("%s - matching atom already in the list (ignoring)\n", __FUNCTION__);
      return;  // fow now I just leave.  later I might allow editing
    }
  }

  if((nAtomResourceList + 1) >= nAtomResourceListMax)
  {
    int iNewSize = MINIMUM_ATOM_RESOURCE_LIST_SIZE / 2 + nAtomResourceListMax;

    void *pTemp = WBReAlloc(pAtomResourceList, iNewSize);
    if(!pTemp)
    {
      WB_ERROR_PRINT("%s - not enough memoory for atom resource list re-alloc\n", __FUNCTION__);
      return;
    }

    pAtomResourceList = (INTERNAL_ATOM_RESOURCE_LIST *)pTemp;
    nAtomResourceListMax += MINIMUM_ATOM_RESOURCE_LIST_SIZE / 2;
  }

  pAtomResourceList[nAtomResourceList].aAtom = aIcon;
  pAtomResourceList[nAtomResourceList].ppResource = ppResource;
  nAtomResourceList++;
}

static const char * const szPreDefinedIconResources[] =
{
  "ID_APPLICATION",
  "ID_ICON_OK",
  "ID_ICON_STOP",
  "ID_ICON_WARN",
  "ID_ICON_WHAT",
  "ID_ICON_QUESTION",
  "ID_ICON_SPLAT",
  "ID_ICON_ASTERISK",
  "ID_ICON_BANG",
  "ID_ICON_TRIANGLE",
  "ID_ICON_WHAT_BOLD",
  "ID_ICON_WTF",
  "ID_ICON_DEATH",
  "ID_ICON_FINGER",
  "ID_ICON_SKULL",
  "ID_ICON_THUMBUP",
  "ID_ICON_THUMBDOWN",
  "ID_ICON_BEAR",
  "ID_ICON_BARNEY",
  "ID_ICON_APP"
};

static char **GetRegisteredIconResource(Atom aIcon)
{
static int iHasBeenRegistered = 0;
int i1, i2;

  // if the pre-defined atoms have not yet been registered, do it NOW

  if(!iHasBeenRegistered)
  {
    for(i1=ID_ICON_FIRST, i2=0;
        i1 <= ID_ICON_LAST
         && i2 < sizeof(szPreDefinedIconResources)/sizeof(szPreDefinedIconResources[0]);
        i1++, i2++)
    {
      Atom aTemp = WBGetAtom(WBGetDefaultDisplay(), szPreDefinedIconResources[i2]);

      if(aTemp != None)
      {
        RegisterIconResource(aTemp, GetPreDefinedIconResource(i1));
      }
    }

    iHasBeenRegistered = 1;
  }

  for(i1=0; i1 < nAtomResourceList; i1++)
  {
    if(pAtomResourceList[i1].aAtom == aIcon) // already there?
    {
      return pAtomResourceList[i1].ppResource;
    }
  }

  return NULL;
}



Pixmap PXM_GetIconPixmap(int idIcon, XPM_ATTRIBUTES *pAttr, Pixmap *pMask)
{
char **pData;


  pData = GetPreDefinedIconResource(idIcon);

  if(!pData)
  {
    if(pAttr)
    {
      bzero(pAttr, sizeof(*pAttr));
    }

    if(pMask)
    {
      *pMask = None;
    }

    return None;
  }

  return PXM_LoadPixmap(pData, pAttr, pMask);
}


Pixmap PXM_GetIconPixmapFromAtom(Atom aIcon, XPM_ATTRIBUTES *pAttr, Pixmap *pMask /* = NULL*/)
{
char **pData;


  pData = GetRegisteredIconResource(aIcon);

  if(!pData)
  {
    if(pAttr)
    {
      bzero(pAttr, sizeof(*pAttr));
    }

    if(pMask)
    {
      *pMask = None;
    }

    return None;
  }

  return PXM_LoadPixmap(pData, pAttr, pMask);
}


Pixmap PXM_LoadPixmap(char *ppXPM[], XPM_ATTRIBUTES *pAttr, Pixmap *pMask /* = NULL*/)
{
Pixmap pixRval = None, pixRval2 = None;
XPM_ATTRIBUTES xattr;
//#ifndef NO_DEBUG
//WB_UINT64 ullTime = WBGetTimeIndex();
//#endif // NO_DEBUG


  if(!ppXPM)
  {
    if(pAttr)
    {
      bzero(pAttr, sizeof(*pAttr));
    }

    if(pMask)
    {
      *pMask = None;
    }

    return None;
  }

  bzero(&xattr, sizeof(xattr));

//  WB_ERROR_PRINT("TEMPORARY:  %s line %d  delta tick %lld\n", __FUNCTION__, __LINE__, (WBGetTimeIndex() - ullTime));

#ifdef X11WORKBENCH_TOOLKIT_HAVE_XPM
  BEGIN_XCALL_DEBUG_WRAPPER
#endif // X11WORKBENCH_TOOLKIT_HAVE_XPM
  XPM_CREATE_PIXMAP_FROM_DATA(WBGetDefaultDisplay(), WBGetHiddenHelperWindow(),
                              ppXPM, &pixRval, &pixRval2, &xattr);
#ifdef X11WORKBENCH_TOOLKIT_HAVE_XPM
  END_XCALL_DEBUG_WRAPPER
#endif // X11WORKBENCH_TOOLKIT_HAVE_XPM

//  WB_ERROR_PRINT("TEMPORARY:  %s line %d  delta tick %lld\n", __FUNCTION__, __LINE__, (WBGetTimeIndex() - ullTime));

  if(pAttr)
  {
    memcpy(pAttr, &xattr, sizeof(xattr));
  }
  else
  {
    WB_IF_DEBUG_LEVEL(DebugLevel_Light | DebugSubSystem_Pixmap)
    {
      DEBUG_DUMP_XPM_ATTRIBUTES(&xattr);
    }

    XPM_FREE_ATTRIBUTES(&xattr);
  }

  if(pMask)
  {
    *pMask = pixRval2;
  }
  else if(pixRval2 != None) // free pixRval2 if it was allocated (it's the 'mask')
  {
    BEGIN_XCALL_DEBUG_WRAPPER
    XFreePixmap(WBGetDefaultDisplay(), pixRval2);
    END_XCALL_DEBUG_WRAPPER
  }

  return(pixRval);
}

Pixmap PXM_ImageToPixmap(Display *pDisplay, Drawable dw, XImage *pImage,
                         unsigned long clrFGPixel, unsigned long clrBGPixel)
{
Pixmap pxRval;
GC gc;
XGCValues gcv;
int iW, iH;

  if(!pDisplay)
  {
    pDisplay = WBGetDefaultDisplay();
  }

  if(!pImage)
  {
    WB_ERROR_PRINT("%s - pImage is NULL\n", __FUNCTION__);
    return None;
  }

  iW = pImage->width;
  iH = pImage->height;

  if(!iW || !iH)
  {
    WB_ERROR_PRINT("%s - Image width/height not valid, iW=%d,iH=%d\n", __FUNCTION__, iW, iH);
    return None;
  }

  BEGIN_XCALL_DEBUG_WRAPPER
  pxRval = XCreatePixmap(pDisplay, dw, iW, iH, DefaultDepth(pDisplay, DefaultScreen(pDisplay)));
  END_XCALL_DEBUG_WRAPPER

  if(pxRval == None)
  {
    WB_ERROR_PRINT("%s - XCreatePixmap failed\n", __FUNCTION__);
    return None;
  }

  // I will need to create a GC.  Make it a simple one that only specifies FG and BG

  gcv.foreground = clrFGPixel;//BlackPixel(pDisplay, DefaultScreen(pDisplay));
  gcv.background = clrBGPixel;//WhitePixel(pDisplay, DefaultScreen(pDisplay));

  // NOTE:  for monochrome masks I'd likely use '1' for foreground, '0' for background

  BEGIN_XCALL_DEBUG_WRAPPER
  gc = XCreateGC(pDisplay, dw, (GCForeground | GCBackground), &gcv);
  END_XCALL_DEBUG_WRAPPER

  if(gc == None)
  {
    WB_ERROR_PRINT("%s - XCreateGC failed\n", __FUNCTION__);

    BEGIN_XCALL_DEBUG_WRAPPER
    XFreePixmap(pDisplay, pxRval);
    END_XCALL_DEBUG_WRAPPER
    return None;
  }
  else
  {
    BEGIN_XCALL_DEBUG_WRAPPER
    XPutImage(pDisplay, pxRval, gc, pImage, 0, 0, 0, 0, iW, iH); // and now I have a copy of it

    XFreeGC(pDisplay, gc);
    END_XCALL_DEBUG_WRAPPER
  }

  return pxRval;
}


Pixmap PXM_ImageToPixmap0(Display *pDisplay, Drawable dw, XImage *pImage)
{
  if(!pDisplay)
  {
    pDisplay = WBGetDefaultDisplay();
  }

  return PXM_ImageToPixmap(pDisplay, dw, pImage,
                           BlackPixel(pDisplay, DefaultScreen(pDisplay)),
                           WhitePixel(pDisplay, DefaultScreen(pDisplay)));
}


XImage *PXM_PixmapToImage(Display *pDisplay, Pixmap pxImage)
{
XImage *pRval;
int iX=0, iY=0;
Window winRoot; // not used, still needed?
unsigned int iWidth=0, iHeight=0, iBorder;
unsigned int uiDepth = 0;


  if(!pDisplay)
  {
    pDisplay = WBGetDefaultDisplay();
  }

  // TODO:  special handling for pxImage == None ???

  if(pxImage == None)
  {
    return NULL;
  }

  BEGIN_XCALL_DEBUG_WRAPPER

  // use XGetGeometry to obtain the characteristics of the pixmap.  iX and iY SHOULD be zero...
  XGetGeometry(pDisplay, pxImage, &winRoot, &iX, &iY, &iWidth, &iHeight, &iBorder, &uiDepth);

  if(!iWidth || !iHeight)
  {
    pRval = NULL;
  }
  else
  {
    // TODO:  do I still need iX and iY?
    pRval = XGetImage(pDisplay, pxImage, 0, 0, iWidth, iHeight, -1L, ZPixmap);
  }

  END_XCALL_DEBUG_WRAPPER

  return pRval;
}




void PXM_OnExit(void)
{
  if(pAtomResourceList)
  {
    WBFree(pAtomResourceList);
    pAtomResourceList = NULL;
  }

  nAtomResourceList = 0;
  nAtomResourceListMax = 0;

  ppRegAppLarge_Internal = NULL;
  ppRegAppSmall_Internal = NULL;
}



#ifndef NO_DEBUG
static void DebugDumpXpmAttributes(const char *szFunction, int nLine, XPM_ATTRIBUTES *pAttr)
{
  WBDebugPrint("%s line %d XPM_ATTRIBUTES contain:\n", szFunction, nLine);
#if defined(X11WORKBENCH_TOOLKIT_HAVE_XPM)
  WBDebugPrint("  valuemask:          %ld\n", pAttr->valuemask);
  WBDebugPrint("  visual:             %p\n", pAttr->visual);
  WBDebugPrint("  colormap:           %p\n", (void *)pAttr->colormap);
#endif // defined(X11WORKBENCH_TOOLKIT_HAVE_XPM)

  WBDebugPrint("  depth:              %u\n", pAttr->depth);
  WBDebugPrint("  width:              %u\n", pAttr->width);
  WBDebugPrint("  height:             %u\n", pAttr->height);

#if defined(X11WORKBENCH_TOOLKIT_HAVE_XPM)
  WBDebugPrint("  x_hotspot:          %u\n", pAttr->x_hotspot);
  WBDebugPrint("  y_hotspot:          %u\n", pAttr->y_hotspot);
  WBDebugPrint("  cpp:                %u\n", pAttr->cpp);
  WBDebugPrint("  pixels:             %p\n", pAttr->pixels);
  WBDebugPrint("  npixels:            %u\n", pAttr->npixels);
  WBDebugPrint("  colorsymbols:       %p\n", pAttr->colorsymbols);
  WBDebugPrint("  numsymbols:         %u\n", pAttr->numsymbols);
  WBDebugPrint("  rgb_fname:          %s\n", pAttr->rgb_fname);
  WBDebugPrint("  nextensions:        %u\n", pAttr->nextensions);
  WBDebugPrint("  extensions:         %p\n", pAttr->extensions);
  WBDebugPrint("  ncolors:            %u\n", pAttr->ncolors);
  WBDebugPrint("  colorTable:         %p\n", pAttr->colorTable);
  WBDebugPrint("  mask_pixel:         %u\n", pAttr->mask_pixel);
  WBDebugPrint("  exactColors:        %c\n", pAttr->exactColors ? 'T' : 'F');
  WBDebugPrint("  closeness:          %u\n", pAttr->closeness);
  WBDebugPrint("  red_closeness:      %u\n", pAttr->red_closeness);
  WBDebugPrint("  green_closeness:    %u\n", pAttr->green_closeness);
  WBDebugPrint("  blue_closeness:     %u\n", pAttr->blue_closeness);
  WBDebugPrint("  color_key:          %d\n", pAttr->color_key);
  WBDebugPrint("  alloc_pixels:       %p\n", pAttr->alloc_pixels);
  WBDebugPrint("  nalloc_pixels:      %d\n", pAttr->nalloc_pixels);
  WBDebugPrint("  alloc_close_colors: %c\n", pAttr->alloc_close_colors ? 'T' : 'F');
  WBDebugPrint("  bitmap_format:      %d\n", pAttr->bitmap_format);
  WBDebugPrint("  alloc_color:        %p\n", pAttr->alloc_color);
  WBDebugPrint("  free_colors:        %p\n", pAttr->free_colors);
  WBDebugPrint("  color_closure:      %p\n", pAttr->color_closure);
#endif // defined(X11WORKBENCH_TOOLKIT_HAVE_XPM)
}
#endif // !NO_DEBUG


void WBDebugDumpColormap(const char *szTitle, const XStandardColormap *pMap)
{
#ifndef NO_DEBUG
  WBDebugPrint("WBDebugDumpColormap - %s\n", szTitle);
  WBDebugPrint("  XStandardColormap:  %p\n", pMap);
  if(pMap)
  {
    WBDebugPrint("    colormap   = %lld\n", (WB_UINT64)pMap->colormap);
    WBDebugPrint("    red_max    = %ld\n", pMap->red_max);
    WBDebugPrint("    red_mult   = %ld\n", pMap->red_mult);
    WBDebugPrint("    green_max  = %ld\n", pMap->green_max);
    WBDebugPrint("    green_mult = %ld\n", pMap->green_mult);
    WBDebugPrint("    blue_max   = %ld\n", pMap->blue_max);
    WBDebugPrint("    blue_mult  = %ld\n", pMap->blue_mult);
    WBDebugPrint("    base_pixel = %ld (%08lxH)\n", pMap->base_pixel, pMap->base_pixel);
  }
#endif // !NO_DEBUG
}


void WBDebugDumpXColor(const char *szTitle, const XColor *pColor)
{
#ifndef NO_DEBUG
char tbuf[32];

  WBDebugPrint("DebugDumpXColor - %s\n", szTitle);
  WBDebugPrint("  XColor:  %p\n", pColor);
  if(pColor)
  {
    WBDebugPrint("    pixel = %lu \"#%6.6lX\"\n", pColor->pixel, pColor->pixel);
    WBDebugPrint("    red   = %d\n", pColor->red);
    WBDebugPrint("    green = %d\n", pColor->green);
    WBDebugPrint("    blue  = %d\n", pColor->blue);

    tbuf[0] = 0;
    if(pColor->flags & DoRed)
    {
//      if(tbuf[0])
//      {
//        strcat(tbuf, " | ");
//      }

      strcat(tbuf, "DoRed");
    }

    if(pColor->flags & DoGreen)
    {
      if(tbuf[0])
      {
        strcat(tbuf, " | ");
      }

      strcat(tbuf, "DoGreen");
    }

    if(pColor->flags & DoBlue)
    {
      if(tbuf[0])
      {
        strcat(tbuf, " | ");
      }

      strcat(tbuf, "DoBlue");
    }

    if(tbuf[0])
    {
      WBDebugPrint("    flags = %d   %s\n", pColor->flags, tbuf);
    }
    else
    {
      WBDebugPrint("    flags = %d   (%XH)\n", pColor->flags, pColor->flags);
    }
  }
#endif // !NO_DEBUG
}

