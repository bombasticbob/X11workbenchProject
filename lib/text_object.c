//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//     _               _               _      _              _              //
//    | |_  ___ __  __| |_       ___  | |__  (_)  ___   ___ | |_     ___    //
//    | __|/ _ \\ \/ /| __|     / _ \ | '_ \ | | / _ \ / __|| __|   / __|   //
//    | |_|  __/ >  < | |_     | (_) || |_) || ||  __/| (__ | |_  _| (__    //
//     \__|\___|/_/\_\ \__|_____\___/ |_.__/_/ | \___| \___| \__|(_)\___|   //
//                        |_____|          |__/                             //
//                                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2016 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no waranties, either implied or explicit.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

/** \file text_object.c
  * \brief Utilities for copying and drawing text, determining text extents, and so on
  *
  * X11 Work Bench Toolkit Toolkit API
*/


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <errno.h>
#include <limits.h>

#include "draw_text.h"
#include "text_object.h"



// INTERNAL STRUCTURES

struct __internal_undo_redo_buffer
{
  struct __internal_undo_redo_buffer *pNext; // singly linked list [for now]
  // NOTE:  a background process can trim this to a reasonable size

  // NOTE:  for a simple row/col insert or paste, left=right, top=bottom
  //        for all other operations, the rctSel will apply accordingly
  WB_RECT rctSelOld; // original select rectangle (as applicable)
  WB_RECT rctSelNew; // new select rectangle after the operation

  int iOperation; // select=0, delete=1, insert/paste=2, replace=3
  int iSelMode;   // selection mode

  int nOld; // size of 'old' buffer (zero if none)
  int nNew; // size of 'new' buffer (zero if none)

  char aData[2]; // actual data for operation
};

#define UNDO_SELECT 0
#define UNDO_DELETE 1
#define UNDO_INSERT 2
#define UNDO_REPLACE 3 /* currently not used */
#define UNDO_INDENT 4


#define SEL_RECT_ALL(X) ((X)->rctSel.left < 0)
#define SEL_RECT_EMPTY(X) (!SEL_RECT_ALL(X) && ((X)->rctSel.left == (X)->rctSel.right && (X)->rctSel.bottom == (X)->rctSel.top))
#define NORMALIZE_SEL_RECT(X) {if((X).top > (X).bottom || ((X).top == (X).bottom && (X).left > (X).right)) \
                               { int i1 = (X).left; (X).left = (X).right; (X).right = i1; i1 = (X).top; (X).top = (X).bottom; (X).bottom = i1; }}


// *************************
// LOCAL FUNCTION PROTOTYPES
// *************************

static void __internal_destroy(struct _text_object_ *pThis);
static void __internal_init(struct _text_object_ *pThis);
static void __internal_highlight_colors(struct _text_object_ *pThis, XColor clrHFG, XColor clrHBG);
static char * __internal_get_text(struct _text_object_ *pThis);
static void __internal_set_text(struct _text_object_ *pThis, const char *szText, unsigned long cbLen);
static int __internal_get_rows(const struct _text_object_ *pThis);
static int __internal_get_cols(struct _text_object_ *pThis);
static int __internal_get_filetype(const struct _text_object_ *pThis);
static void __internal_set_filetype(struct _text_object_ *pThis, int iFileType);
static int __internal_get_linefeed(const struct _text_object_ *pThis);
static void __internal_set_linefeed(struct _text_object_ *pThis, int iLineFeed);
static int __internal_get_insmode(const struct _text_object_ *pThis);
static void __internal_set_insmode(struct _text_object_ *pThis, int iInsMode);
static int __internal_get_selmode(const struct _text_object_ *pThis);
static void __internal_set_selmode(struct _text_object_ *pThis, int iSelMode);
static int __internal_get_tab(const struct _text_object_ *pThis);
static void __internal_set_tab(struct _text_object_ *pThis, int iTab);
static int __internal_get_scrollmode(const struct _text_object_ *pThis);
static void __internal_set_scrollmode(struct _text_object_ *pThis, int iScrollMode);
static void __internal_get_select(const struct _text_object_ *pThis, WB_RECT *pRct);
static void __internal_set_select(struct _text_object_ *pThis, const WB_RECT *pRct);
static int __internal_has_select(const struct _text_object_ *pThis);
static char* __internal_get_sel_text(const struct _text_object_ *pThis, const WB_RECT *pRct);
static int __internal_get_row(const struct _text_object_ *pThis);
static void __internal_set_row(struct _text_object_ *pThis, int iRow);
static int __internal_get_col(const struct _text_object_ *pThis);
static void __internal_set_col(struct _text_object_ *pThis, int iCol);
static void __internal_del_select(struct _text_object_ *pThis);
static void __internal_replace_select(struct _text_object_ *pThis, const char *szText, unsigned long cbLen);
static void __internal_del_chars(struct _text_object_ *pThis, int nChar);
static void __internal_ins_chars(struct _text_object_ *pThis, const char *pChar, int nChar);
static void __internal_indent(struct _text_object_ *pThis, int nCol);
static int __internal_can_undo(struct _text_object_ *pThis);
static void __internal_undo(struct _text_object_ *pThis);
static int __internal_can_redo(struct _text_object_ *pThis);
static void __internal_redo(struct _text_object_ *pThis);
static void __internal_get_view(const struct _text_object_ *pThis, WB_RECT *pRct);
static void __internal_set_view(struct _text_object_ *pThis, const WB_RECT *pRct);
static void __internal_begin_highlight(struct _text_object_ *pThis);
static void __internal_end_highlight(struct _text_object_ *pThis);

static void __internal_mouse_click(struct _text_object_ *pThis, int iMouseXDelta, int iMouseYDelta, int iType, int iACS);
static void __internal_begin_mouse_drag(struct _text_object_ *pThis);
static void __internal_end_mouse_drag(struct _text_object_ *pThis);
static void __internal_cursor_up(struct _text_object_ *pThis);
static void __internal_cursor_down(struct _text_object_ *pThis);
static void __internal_cursor_left(struct _text_object_ *pThis);
static void __internal_cursor_right(struct _text_object_ *pThis);
static void __internal_page_up(struct _text_object_ *pThis);
static void __internal_page_down(struct _text_object_ *pThis);
static void __internal_page_left(struct _text_object_ *pThis);
static void __internal_page_right(struct _text_object_ *pThis);

static void __internal_cursor_home(struct _text_object_ *pThis);
static void __internal_cursor_end(struct _text_object_ *pThis);
static void __internal_cursor_top(struct _text_object_ *pThis);
static void __internal_cursor_bottom(struct _text_object_ *pThis);

static void __internal_do_expose(struct _text_object_ *pThis, Display *pDisplay, Window wID,
                                 GC gc, const WB_GEOM *pPaintGeom, const WB_GEOM *pViewGeom,
                                 XFontSet rFontSet);
static void __internal_cursor_blink(struct _text_object_ *pThis, int bHasFocus);

// *********************************
// LOCALLY DEFINED GLOBAL STRUCTURES
// *********************************

const TEXT_OBJECT_VTABLE WBDefaultTextObjectVTable =
{
  __internal_destroy,
  __internal_init,
  __internal_highlight_colors,
  __internal_get_text,
  __internal_set_text,
  __internal_get_rows,
  __internal_get_cols,
  __internal_get_filetype,
  __internal_set_filetype,
  __internal_get_linefeed,
  __internal_set_linefeed,
  __internal_get_insmode,
  __internal_set_insmode,
  __internal_get_selmode,
  __internal_set_selmode,
  __internal_get_tab,
  __internal_set_tab,
  __internal_get_scrollmode,
  __internal_set_scrollmode,
  __internal_get_select,
  __internal_set_select,
  __internal_has_select,
  __internal_get_sel_text,
  __internal_get_row,
  __internal_set_row,
  __internal_get_col,
  __internal_set_col,
  __internal_del_select,
  __internal_replace_select,
  __internal_del_chars,
  __internal_ins_chars,
  __internal_indent,
  __internal_can_undo,
  __internal_undo,
  __internal_can_redo,
  __internal_redo,
  __internal_get_view,
  __internal_set_view,
  __internal_begin_highlight,
  __internal_end_highlight,
  __internal_mouse_click,
  __internal_begin_mouse_drag,
  __internal_end_mouse_drag,
  __internal_cursor_up,
  __internal_cursor_down,
  __internal_cursor_left,
  __internal_cursor_right,
  __internal_page_up,
  __internal_page_down,
  __internal_page_left,
  __internal_page_right,

  __internal_cursor_home,
  __internal_cursor_end,
  __internal_cursor_top,
  __internal_cursor_bottom,

  __internal_do_expose,
  __internal_cursor_blink
};



////////////////////////////////////////
// GLOBAL (yet static) INLINE UTILITIES
////////////////////////////////////////

// line endings translated from 'enum' to 'const char *'

static __inline__ const char * __internal_get_line_ending_text(enum _LineFeed_ iIndex)
{
  static const char * const szLineEndings[LineFeed_ENTRYCOUNT] =
  {
#ifdef WIN32
  "\r\n"
#else // POSIX
  "\n",
#endif // OS-dependent line endings
  "\n","\r","\r\n","\n\r"
  };

  if((int)iIndex < 0 || (int)iIndex >= LineFeed_ENTRYCOUNT)
  {
    return NULL;  // single-line or invalid
  }
  return szLineEndings[iIndex];
}





// ***********
// TEXT BUFFER
// ***********

// TODO:  an API function for single-line text

#define DEFAULT_TEXT_BUFFER_LINES 16384

TEXT_BUFFER * WBAllocTextBuffer(const char *pBuf, unsigned int cbBufSize)
{
TEXT_BUFFER *pRval;
int nLines = 0;
int cbLen;

  if(pBuf && (cbBufSize || *pBuf))
  {
    nLines = WBStringLineCount(pBuf, cbBufSize);
  }

  if(nLines < DEFAULT_TEXT_BUFFER_LINES)
  {
    nLines = DEFAULT_TEXT_BUFFER_LINES;
  }

  cbLen = sizeof(*pRval) + nLines * sizeof(pRval->aLines[0]);
  pRval = WBAlloc(cbLen);

  if(!pRval)
  {
    WB_ERROR_PRINT("ERROR - %s - not enough memory (%ld)\n", __FUNCTION__,
                   (unsigned long)(sizeof(*pRval) + nLines * sizeof(pRval->aLines[0])));
    return NULL;
  }

  memset(pRval, 0, cbLen); // zero out entire structure (always)

  pRval->nArraySize = nLines; // pre-assigned values
//  pRval->nEntries = 0; already zero, comment left for reference

  if(pBuf && (cbBufSize || *pBuf))
  {
    int nL = 0;
    const char *p1;

    if(!cbBufSize)
    {
      cbBufSize = strlen(pBuf);
    }

    do
    {
      int cbLen;
      char *p2, *p3;

      p1 = WBStringNextLine(pBuf, &cbBufSize);

      if(p1) // another line remains
      {
        cbLen = p1 - pBuf;
      }
      else
      {
        cbLen = cbBufSize;
      }

      p2 = WBAlloc(cbLen + 2);

      if(!p2)
      {
        WBFreeTextBuffer(pRval);
        pRval = NULL;
        break;
      }

      memcpy(p2, pBuf, cbLen); // copy the data

      p3 = p2 + cbLen; // the end of the string
      *p3 = 0; // always zero-byte terminate it first

      while(p3 > p2 && (*(p3 - 1) <= ' ' || *(p3 - 1) == HARD_TAB_CHAR)) // trim ALL trailing white space including CR, LF, tab, space, FF, etc.
      {
        // TODO:  handle <FF> or <VT> differently?
        // TODO:  leave white space to mark 'extent' of line?  naaw, probably not

        *(p3--) = 0; // for now just trim it all
      }

      pRval->aLines[nL++] = p2;

      pBuf = p1;

    } while(pBuf && cbBufSize && nL < nLines);

    pRval->nEntries = nL; // NOTE:  on error, this will be needed for cleanup

    WBTextBufferRefreshCache(pRval);
  }

//  if(pRval)
//  {
//    int nL;
//
//    WB_ERROR_PRINT("\nTEMPORARY - %s - %ld lines\n", __FUNCTION__, pRval->nEntries);
//
//    for(nL=0; nL < pRval->nEntries; nL++)
//    {
//      WB_ERROR_PRINT("  \"%s\"\n", pRval->aLines[nL]);
//    }
//
//    WB_ERROR_PRINT("END TEMPORARY - %s\n\n", __FUNCTION__);
//  }

  return pRval;
}

int WBCheckReAllocTextBuffer(TEXT_BUFFER **ppBuf, int nLinesToAdd)
{
TEXT_BUFFER *pBuf;
int nNew;

  if(!ppBuf || !*ppBuf)
  {
    return -1; // error
  }

  // TODO:  parameter validation

  pBuf = *ppBuf;

  nNew = pBuf->nEntries + nLinesToAdd;

  if(nNew > pBuf->nArraySize)
  {
    nNew += DEFAULT_TEXT_BUFFER_LINES;
    nNew -= (nNew % (DEFAULT_TEXT_BUFFER_LINES / 2));

    pBuf = WBReAlloc(pBuf, sizeof(*pBuf) + nNew * sizeof(pBuf->aLines[0]));

    if(!pBuf)
    {
      return -1; // error
    }

    pBuf->nArraySize = nNew;
    *ppBuf = pBuf; // potentially new pointer - probably is, though
  }

  return 0; // no problems
}

void WBFreeTextBuffer(TEXT_BUFFER *pBuf)
{
int i1;

  if(!pBuf)
  {
    return;
  }

  // TODO:  parameter validation

  for(i1=0; i1 < pBuf->nEntries && i1 < pBuf->nArraySize; i1++)
  {
    if(pBuf->aLines[i1])
    {
      WBFree(pBuf->aLines[i1]);
      pBuf->aLines[i1] = NULL;  // by convention
    }
  }

  WBFree(pBuf);
}

void WBTextBufferLineChange(TEXT_BUFFER *pBuf, unsigned long nLine, int nNewLen)
{
int i1, i2;
unsigned int nNewMax = 0, nNewMinMax = UINT_MAX;


  if(pBuf->nEntries <= 1) // zero or one lines?
  {
    WBTextBufferRefreshCache(pBuf); // always do it THIS way
    return;
  }

  if(nLine > pBuf->nEntries) // line number isn't sane?
  {
    return; // sanity check failed (do nothing)
  }

  // update the line info in my cache.  If this line appears, remove it (always).
  // If I'm deleting the line, subtract one from every line higher than this one.

  for(i1=0; i1 < TEXT_BUFFER_LINE_CACHE_SIZE && pBuf->aLineCacheLen[i1]; i1++)
  {
    if(pBuf->aLineCache[i1] == nLine)
    {
      // move everything up, remove the last entry, decrement i1
      for(i2=i1 + 1; i2 < TEXT_BUFFER_LINE_CACHE_SIZE && pBuf->aLineCacheLen[i2]; i2++)
      {
        pBuf->aLineCache[i2] = pBuf->aLineCache[i2 + 1];
        pBuf->aLineCacheLen[i2] = pBuf->aLineCacheLen[i2 + 1];

        // now by convention mark that last entry as if it's unused
        pBuf->aLineCache[i2 + 1] = 0;
        pBuf->aLineCacheLen[i2 + 1] = 0; // an 'end' marker (if the loop exits, it becomes the new 'end')
      }

      i1--; // so I do the 'next' one as I should
    }
    else
    {
      if(pBuf->aLineCache[i1] > nLine)
      {
        if(nNewLen < 0)             // a line deletion
        {
          pBuf->aLineCache[i1] --;  // line was removed, so new line count must match
        }
      }

      if(nNewMax < pBuf->aLineCacheLen[i1])
      {
        nNewMax = pBuf->aLineCacheLen[i1]; // done this way as sanity check
      }

      if(nNewMinMax > pBuf->aLineCacheLen[i1])
      {
        nNewMinMax = pBuf->aLineCacheLen[i1]; // done this way as sanity check
      }
    }
  }

  // if the cache is NOW empty, re-evaluate it.
  if(!pBuf->aLineCacheLen[0]) // empty
  {
    WBTextBufferRefreshCache(pBuf);
    return;
  }

  // I've re-evaluated the max and min-max from the cache, so use that info

  pBuf->nMaxCol = nNewMax;

  if(nNewMinMax <= nNewMax)  // NOTE: if cache is empty, nNewMinMax will be UINT_MAX
  {
    pBuf->nMinMaxCol = nNewMinMax; // sanity checked value
  }
  else
  {
    pBuf->nMinMaxCol = nNewMax; // don't put insane values in there (just in case)
    // TODO: consider refactoring this code out once the algorithm is proved to work
  }

  if(nNewLen < 0) // a line deletion
  {
    if(!nNewMax) // in case my cache has dwindled to nothing
    {
      WBTextBufferRefreshCache(pBuf); // time to re-evaluate
    }

    return; // I'm done for delete.  The rest is for updates
  }

  // see if the length exceeds any of the maximums, and do an 'insertion sort'
  // into my cache array if it does.  Otherwise I can just leave.

  if(nNewLen >= pBuf->nMaxCol) // bigger than maximum (or equal to it)
  {
    i2 = 0; // my insert point

    pBuf->nMaxCol = nNewLen;  // new 'max'
    if(nNewLen < nNewMinMax) // sanity test for empty cache
    {
      pBuf->nMinMaxCol = nNewLen; // may happen, if new cache is totally empty
    }
  }
  else if(nNewLen >= pBuf->nMinMaxCol) // between min max and max
  {
    // find the place to insert this line into the cache
    i2 = 0; // NOTE:  platform-independent loop structure, probably not necessary, but...
    while(i2 < TEXT_BUFFER_LINE_CACHE_SIZE && pBuf->aLineCacheLen[i2])
    {
      if(pBuf->aLineCacheLen[i2] < nNewLen) // the insert point
      {
        break;
      }

      i2++; // don't forget this or infinite loop will result, heh
    }
  }
  else
  {
    return;  // I'm done - no need to re-insert this line into the cache (yet)
    // NOTE:  re-inserting the line into the cache would require re-doing the
    //        cache information from scratch.  this is an optimization, so I'll
    //        avoid THAT operation until it's truly necessary.
  }

  if(i2 < TEXT_BUFFER_LINE_CACHE_SIZE) // sanity check, might happen
  {
    // insert at 'i2'
    for(i1=TEXT_BUFFER_LINE_CACHE_SIZE - 1; i1 > i2; i1--)
    {
      pBuf->aLineCache[i1] = pBuf->aLineCache[i1 - 1];
      pBuf->aLineCacheLen[i1] = pBuf->aLineCacheLen[i1 - 1];
    }

    pBuf->aLineCache[i2] = nLine;
    pBuf->aLineCacheLen[i2] = nNewLen;
  }

  // everything should be ok now, unless I b0rked something
}

void WBTextBufferRefreshCache(TEXT_BUFFER *pBuf)
{
int iLine, i1, i2, i3;
char *p1;


  // zero out the cache arrays
  memset(pBuf->aLineCache, 0, sizeof(pBuf->aLineCache));
  memset(pBuf->aLineCacheLen, 0, sizeof(pBuf->aLineCacheLen));

  pBuf->nMaxCol = pBuf->nMinMaxCol = 0; // initialize to zero

  if(!pBuf->nEntries)
  {
    return;
  }
  else if(pBuf->nEntries == 1)
  {
    if(pBuf->aLines[0])
    {
      pBuf->aLineCacheLen[0] = // refactored, do this assignment here instead
        pBuf->nMaxCol = pBuf->nMinMaxCol = WBGetMBLength(pBuf->aLines[0]); // assign length to 'max' and 'minmax'
//      if(pBuf->nMaxCol) 'refactored out' (left to document process, remove later)
//      {
//        pBuf->aLineCache[0] = 0; this value already assigned by 'memset'
//        pBuf->aLineCacheLen[0] = pBuf->nMaxCol; refactored code does this
//      }
    }

    return;
  }

  // the big loop

  for(iLine=0; iLine < pBuf->nEntries; i1++)
  {
    // do not consider blank lines or lines with zero length
    p1 = pBuf->aLines[iLine];

    if(!p1)
    {
      continue;
    }

    i1 = WBGetMBLength(p1);

    if(!i1)
    {
      continue;
    }

    if(i1 > pBuf->nMinMaxCol) // assume data is consistent
    {
      // perform an insertion sort into 'aLineCache'

      // step 1:  find the insertion point

      i2 = 0; // NOTE:  platform-independent loop structure, probably not necessary, but...
      while(i2 < TEXT_BUFFER_LINE_CACHE_SIZE && pBuf->aLineCacheLen[i2])
      {
        if(pBuf->aLineCacheLen[i2] < i1) // the insert point
        {
          break;
        }

        i2++; // don't forget this or infinite loop will result, heh
      }

      if(i2 >= TEXT_BUFFER_LINE_CACHE_SIZE) // logic fail, clean it up
      {
        pBuf->nMaxCol = pBuf->aLineCacheLen[0]; // forced re-evaluation
        pBuf->nMinMaxCol = pBuf->aLineCacheLen[TEXT_BUFFER_LINE_CACHE_SIZE - 1];
      }
      else if(i2 == TEXT_BUFFER_LINE_CACHE_SIZE - 1)
      {
        // special case, insert at the end
        pBuf->aLineCache[i2] = iLine;
        pBuf->aLineCacheLen[i2] = i1;

        pBuf->nMinMaxCol = i1;  // the new 'min max'
      }
      else
      {
        // if this is the first line in the cache, update 'nMaxCol'
        if(!i2) // NOTE:  this test is done here 'cause of likely register optimization
        {
          pBuf->nMaxCol = i1;
        }

        i3 = i2 + 1;
        while(i3 < TEXT_BUFFER_LINE_CACHE_SIZE && pBuf->aLineCacheLen[i3])
        {
          i3++; // finding the end
        }

        // move everything down using 'memmove'

        memmove(&(pBuf->aLineCache[i2 + 1]), &(pBuf->aLineCache[i2]),
                (i3 - i2 - 1) * sizeof(pBuf->aLineCache[0]));
        memmove(&(pBuf->aLineCacheLen[i2 + 1]), &(pBuf->aLineCacheLen[i2]),
                (i3 - i2 - 1) * sizeof(pBuf->aLineCacheLen[0]));

        // use the final line's index and re-assign the 'max' and 'min max'
        pBuf->nMinMaxCol = pBuf->aLineCacheLen[i3 - 1];

        // make sure the last element(s) have a zero length (TODO:  optimize?)
        while(i3 < TEXT_BUFFER_LINE_CACHE_SIZE)
        {
          pBuf->aLineCache[i3] = 0; // do this to, just because
          pBuf->aLineCacheLen[i3++] = 0;
        }

        // and finally, insert this line's info at position 'i2'

        pBuf->aLineCache[i2] = iLine;
        pBuf->aLineCacheLen[i2] = i1;
      }
    }
  }
}


// ************************
// TEXT OBJECT CONSTRUCTION
// ************************

TEXT_OBJECT *WBTextObjectConstructor(unsigned long cbStructSize, const char *szText, unsigned long cbLen, Window wIDOwner)
{
TEXT_OBJECT *pRval;

  pRval = (TEXT_OBJECT *)WBAlloc(sizeof(*pRval));

  if(pRval)
  {
//    pRval->vtable = &WBDefaultTextObjectVTable;
//    pRval->ulTag = TEXT_OBJECT_TAG;
//    pRval->vtable->init(pRval);
//
//    pRval->wIDOwner = wIDOwner;

    WBInitializeInPlaceTextObject(pRval, wIDOwner);

    pRval->pText = WBAllocTextBuffer(szText, cbLen);
  }

  return(pRval);
}

void WBTextObjectDestructor(TEXT_OBJECT *pObj)
{
  if(WBIsValidTextObject(pObj))
  {
    pObj->vtable->destroy(pObj);

    WBFree(pObj);
  }
}

int WBTextObjectCalculateLineHeight(int iAscent, int iDescent)  // consistently calculate line height from font ascent/descent
{
int iFontHeight;

  iFontHeight = iAscent + iDescent;
  
  // adjust font height to include line spacing (I'll use this to position the lines)
  if(iDescent > MIN_LINE_SPACING / 2)
  {
    iFontHeight += iDescent / 2; // line spacing is 1/2 of descent, or MIN_LINE_SPACING
  }
  else
  {
    iFontHeight += MIN_LINE_SPACING;
  }

  return iFontHeight;
}



// *****************************
// TEXT OBJECT UTILITY FUNCTIONS
// *****************************

// INTERNAL-ONLY utilities that are NOT part of the vtable

static void __internal_free_undo_redo_buffer(void *pBuffer)
{
  if(pBuffer)
  {
    // TODO:  validate that it's an undo/redo buffer

    struct __internal_undo_redo_buffer *pU = (struct __internal_undo_redo_buffer *)pBuffer;

    do
    {
      struct __internal_undo_redo_buffer *pUsa = pU;

      pU = pU->pNext;
      WBFree(pUsa); // for now just do this

    } while(pU);
  }
}

#define UNDO_LIMIT 256

// NULL 'prctStartSel' or 'prctEndSel' implies 'NONE' selected, i.e. {0,0,0,0}
static void __internal_add_undo(struct _text_object_ *pThis, int iOperation, int iSelMode,
                                int iStartRow, int iStartCol, const WB_RECT *prctStartSel,
                                const char *pStartText, int cbStartText,
                                int iEndRow, int iEndCol, const WB_RECT *prctEndSel,
                                const char *pEndText, int cbEndText)
{
int cbLen, cbLen2, i1;
struct __internal_undo_redo_buffer *pUndo, *pTU, *pTU2;


  if(!WBIsValidTextObject(pThis))
  {
    return;
  }

  pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

  cbLen = cbLen2 = 0;

  if(pStartText)
  {
    if(cbStartText < 0)
    {
      cbStartText = strlen(pStartText); // TODO:  WBGetMBLength ?
    }

    if(cbStartText > 0)
    {
      cbLen += cbStartText;
    }
  }

  if(pEndText)
  {
    if(cbEndText < 0)
    {
      cbEndText = strlen(pEndText); // TODO:  WBGetMBLength?
    }

    if(cbEndText > 0)
    {
      cbLen2 += cbEndText;
    }
  }

  pUndo = (struct __internal_undo_redo_buffer *)WBAlloc(cbLen + cbLen2 + 4 + sizeof(*pUndo));
  if(!pUndo)
  {
    // TODO:  walk the 'undo' chain and start removing stuff, and retry the alloc

    WB_ERROR_PRINT("ERROR - %s - unable to create undo buffer, errno=%d\n", __FUNCTION__, errno);
    return;
  }

  pUndo->iOperation = iOperation;
  pUndo->iSelMode = iSelMode;

  if(prctStartSel)
  {
    memcpy(&(pUndo->rctSelOld), prctStartSel, sizeof(WB_RECT));
  }
  else
  {
    memset(&(pUndo->rctSelOld), 0, sizeof(WB_RECT));
  }

  if(prctEndSel)
  {
    memcpy(&(pUndo->rctSelNew), prctEndSel, sizeof(WB_RECT));
  }
  else
  {
    memset(&(pUndo->rctSelNew), 0, sizeof(WB_RECT));
  }

  // this code should work on multi-byte characters as well...

  pUndo->nOld = cbLen;
  if(cbLen)
  {
    memcpy(pUndo->aData, pStartText, cbLen);
    pUndo->aData[cbLen++] = 0; // just because
  }

  pUndo->nOld = cbLen;

  if(cbLen2)
  {
    memcpy(pUndo->aData + cbLen, pEndText, cbLen2);
    pUndo->aData[cbLen + cbLen2++] = 0; // just because
  }

  pUndo->nNew = cbLen2;

  // insert undo buffer into the 'chain'

  pTU = pUndo->pNext = (struct __internal_undo_redo_buffer *)(pThis->pUndo);
  pThis->pUndo = pUndo;

  // NOW walk the chain and remove things past a certain point.  For now, UNDO_LIMIT
  // NOTE:  this is a compromise - the alternative is a double-link list and an 'end' pointer
  //        along with a running count of items.  If the number of undo/redo items becomes
  //        VERY large, that might be a better alternative. So for now I use a single-link list.

  if(pTU)
  {
    for(i1=1; i1 < UNDO_LIMIT && pTU->pNext; pTU = pTU->pNext, i1++) { }
    // on a modern CPU, this shouldn't take more than a few microseconds

    if(pTU->pNext) // will only be true if I have too many entries
    {
      // free and unhook the chain
      pTU2 = pTU->pNext;
      pTU->pNext = NULL; // generally safer THIS way

      __internal_free_undo_redo_buffer(pTU2); // NOW free what was once chained from here
    }
  }

  // whenever I add an 'undo' HERE, I screw up the 'redo' so blast it away if it exists
  if(pThis->pRedo)
  {
    pTU = pThis->pRedo;
    pThis->pRedo = NULL;

    __internal_free_undo_redo_buffer(pTU);
  }
}


#if 0 /* not currently in use - uncomment to implement its functionality */
static void __internal_add_redo(struct _text_object_ *pThis, struct __internal_undo_redo_buffer *pUndo)
{
struct __internal_undo_redo_buffer *pRedo;
int cbLen;


  if(!WBIsValidTextObject(pThis))
  {
    return;
  }

  // convert an 'undo' into a 'redo' and add it to the 'redo' chain
  // essentially 'just a copy'

  cbLen = pUndo->nOld + pUndo->nNew + sizeof(*pUndo);

  pRedo = (struct __internal_undo_redo_buffer *)WBAlloc(cbLen + 2);

  if(!pRedo)
  {
    // TODO:  walk the 'undo' and 'redo' chains and start removing stuff, and retry the alloc

    WB_ERROR_PRINT("ERROR - %s - unable to create redo buffer, errno=%d\n", __FUNCTION__, errno);
    return;
  }

  memcpy(pRedo, pUndo, cbLen);

  // now add it to the redo chain

  pRedo->pNext = (struct __internal_undo_redo_buffer *)(pThis->pRedo);
  pThis->pRedo = pRedo;
}
#endif // 0

#if 0 /* not currently in use - uncomment to implement its functionality */
static void __internal_perform_undo(struct _text_object_ *pThis, struct __internal_undo_redo_buffer *pUndo)
{
struct __internal_undo_redo_buffer *pDo = NULL;
int iOldSel;


  pDo = pDo; // TEMPORARY, warning avoidance

  if(!WBIsValidTextObject(pThis) || !pUndo)
  {
    return;
  }

  // first, make sure the selection mode is correct

  iOldSel = pThis->iSelMode;
  pThis->iSelMode = pUndo->iSelMode;

  if(pUndo->iOperation == UNDO_SELECT)
  {
  }
  else if(pUndo->iOperation == UNDO_DELETE)
  {
    // perform an insert of 'Old Text' data at the appropriate cursor spot
  }
  else if(pUndo->iOperation == UNDO_INSERT)
  {
    // perform a delete of 'new text' data at the appropriate cursor spot
  }
  else if(pUndo->iOperation == UNDO_REPLACE)
  {
    // replace 'new text' with 'old text' at the appropriate cursor spot
  }
  else if(pUndo->iOperation == UNDO_INDENT)
  {
    // indents a block of text
    // to indent, start col will be 0, end col will be the indent
    // to un-indent, start col will be > 0, end col will be 0
    // The start/end rows define the block of lines to be indented or un-indented

  }

  // re-select the old selection using the old select method


  // restore cursor to appropriate spot


//  // restore the current selection method if restored selection is empty
//  pThis->iSelMode = iOldSel;


  // add a redo buffer that's a copy of the undo operation
  __internal_add_redo(pThis, pUndo);
}
#endif // 0

#if 0 /* not currently in use - uncomment to implement its functionality */
static void __internal_perform_redo(struct _text_object_ *pThis, struct __internal_undo_redo_buffer *pRedo)
{
struct __internal_undo_redo_buffer *pNewUndo;
int iOldSel, cbLen;


  if(!WBIsValidTextObject(pThis) || !pRedo)
  {
    return;
  }

  cbLen = pRedo->nOld + pRedo->nNew + sizeof(*pRedo);

  // first, make sure the selection mode is correct

  iOldSel = pThis->iSelMode;
  pThis->iSelMode = pRedo->iSelMode;

  if(pRedo->iOperation == UNDO_SELECT)
  {
  }
  else if(pRedo->iOperation == UNDO_DELETE)
  {
    // perform an insert of 'new Text' data at the appropriate cursor spot
  }
  else if(pRedo->iOperation == UNDO_INSERT)
  {
    // perform a delete of 'old text' data at the appropriate cursor spot
  }
  else if(pRedo->iOperation == UNDO_REPLACE)
  {
    // replace 'old text' with 'new text' at the appropriate cursor spot
  }
  else if(pRedo->iOperation == UNDO_INDENT)
  {
    // indents a block of text
    // to indent, start col will be 0, end col will be the indent
    // to un-indent, start col will be > 0, end col will be 0
    // The start/end rows define the block of lines to be indented or un-indented

  }

  // re-select the new selection using the applicable select method


  // restore cursor to appropriate spot


//  // restore the current selection method if restored selection is empty
//  pThis->iSelMode = iOldSel;


  // now I must add the 'redo' operation 'as-is' to the 'undo' chain, but NOT blast away the 'redo' chain
  // I'll make a copy of it first, since the caller will need to manage the undo/redo pointers

  pNewUndo = (struct __internal_undo_redo_buffer *)WBAlloc(cbLen + 2);

  if(!pNewUndo)
  {
    // TODO:  walk the 'undo' and 'redo' chains and start removing stuff, and retry the alloc

    WB_ERROR_PRINT("ERROR - %s - unable to create undo buffer from redo buffer, errno=%d\n", __FUNCTION__, errno);
    return;
  }

  memcpy(pNewUndo, pRedo, cbLen);

  // now add it to the undo chain so I can 'undo the re-do' if I want to

  pNewUndo->pNext = (struct __internal_undo_redo_buffer *)(pThis->pUndo);
  pThis->pUndo = pNewUndo;
}
#endif // 0

// ---------------------------------------------------------------------------
// __internal_get_selected_text - arbitrary text retrieval (internal only)
//                                returns WBAlloc'd string pointer
//
// iRow is the starting row position
// iCol is the starting column position
// iEndRow is the ending row position.  In modes OTHER than 'box mode', this may equal 'iCol'
// iEndCol is the ending column position.  In modes OTHER than 'box mode' this may be LESS than 'iCol'
static char * __internal_get_selected_text(const struct _text_object_ *pThis, int iRow, int iCol, int iEndRow, int iEndCol)
{
int i1, i2, i3, cb1, cbLF=0;
char *p1, *pRval = NULL;
const char *szLineFeed = NULL;
TEXT_BUFFER *pTB;
int iIsBoxMode, iIsLineMode;


  if(WBIsValidTextObject(pThis))
  {
    if(!pThis->pText)
    {
      return WBCopyString(""); // return a blank string
    }

    if(iRow < 0)
    {
      iRow = 0;
    }
    if(iCol < 0)
    {
      iCol = 0;
    }
    if(iEndRow < 0)
    {
      iEndRow = INT_MAX;
    }
    if(iEndCol < 0)
    {
      iEndCol = INT_MAX;
    }

    if(iRow == iEndRow)
    {
      iIsBoxMode = iIsLineMode = 0;
    }
    else
    {
      if(pThis->iSelMode == SelectMode_BOX)
      {
        iIsBoxMode = 1;
        iIsLineMode = 0;
      }
      else if(pThis->iSelMode == SelectMode_LINE)
      {
        iIsBoxMode = 0;
        iIsLineMode = 1;
      }
      else // char and default
      {
        iIsBoxMode = 0;
        iIsLineMode = 0;
      }
    }

    if(iRow > iEndRow                           // row exceeds ending row
       || (iRow == iEndRow && iCol >= iEndCol)  // single row with no 'width'
       /* || (box mode && iCol >= iEndCol) */)  // box mode requires iCol < iEndCol
    {
      return WBCopyString(""); // return a blank string
    }

    pTB = (TEXT_BUFFER *)(pThis->pText);

    // NOTE:  when iRow == iEndRow, both box mode and line mode revert to 'stream mode'
    //        and the 'iIsBoxMode' and 'iIsStreamMode' flags will both be zero

    if(iIsBoxMode)
    {
      cb1 = (iEndRow - iRow + 1) * (2 + iEndCol - iCol);
    }
    else
    {
      // FOR NOW just go through the TEXT_BUFFER array, determine the length (later cache it)

      for(i1=iRow, cb1=4; i1 < pTB->nEntries && i1 <= iEndRow; i1++)
      {
        i2 = strlen(pTB->aLines[i1]); // use 'strlen' here, as I want the REAL length

        // last line in 'normal' select mode limits width - 'iEndCol' may be 0
        if(i1 == iEndRow        // i.e. "the last line" in the selected area
           && !iIsLineMode)     // NOT 'line mode' (will be always false for single-row selects)
        {
          if(i2 > iEndCol) // trim the indicated length of the line accordingly
          {
            i2 = WBGetMBCharPtr(pTB->aLines[i1], iEndCol, NULL) - pTB->aLines[i1];
          }
        }

        cb1 += i2 + 2; // do this regardless (it's only to count up max string length)
      }
    }

    // now build the string using the specified line ending and selection mode

    szLineFeed = __internal_get_line_ending_text(pThis->iLineFeed);

    if(!szLineFeed) // single-line
    {
      if(pTB->nEntries > 1)
      {
        szLineFeed = __internal_get_line_ending_text(LineFeed_DEFAULT); // fallback with multi-line data
      }
    }

    if(szLineFeed)
    {
      cbLF = strlen(szLineFeed);
    }

    pRval = WBAlloc(cb1); // allocate the buffer

    if(pRval)
    {
      p1 = pRval;
      for(i1=iRow, p1 = pRval; i1 < pTB->nEntries && i1 <= iEndRow; i1++)
      {
        char *pTheLine = pTB->aLines[i1];

        // TODO:  validate pRval + cb1 > p1 + length of "the stuff that follows"
        i2 = i3 = strlen(pTheLine); // the TRUE 'binary' length

        // TODO: for box mode limit the width on all lines and pad with white space as needed

        // TODO:  handle hard tab translation?  For now "leave it".  Later, I should use a character
        //        that prints as 'white space' but translates as a 'hard tab'.
        //        Example might be 0xA0, i.e. a ' ' + 80H, filling up spaces to the tab point.  Delete
        //        and insert would have to compensate for this.  This function ALSO would have to compensate,
        //        translating tabs to spaces for box mode, and to hard tabs for everything else when 'select all'
        //        is not in effect and tabs are preserved.
        //        For 'select all', hard tabs (when preserved) would be translated into a minimum number of
        //        tab characters; otherwise they would translate into spaces.  Also a hard tab should be displayed
        //        differently (when preserved), such as a greyed |--> or similar.
        //        When 'do not preserve tabs' is set, inserted tabs should automatically become spaces.  ONLY when
        //        the tabs are being preserved should the translation take place.
        //
        // CASE FOR USING 'A0' FOR HARD TAB
        // a) UTF8 does not use it as a marker for multi-byte character data - http://en.wikipedia.org/wiki/UTF-8
        // b) it's basically a ' ' with the high bit set
        // c) it's not used for anything significant in 8-bit ASCII other than "non-breaking space" (i.e. &nbsp;)
        // d) if it's imported, it will translate to actual spaces
        // e) if it's exported by accident, it probably won't matter (other than formatting)
        // f) a definition NOW exists - see HARD_TAB_CHAR (text_object.h)

        // last line in 'normal' select mode limits width - 'iEndCol' may be 0
        if(i1 == iEndRow        // i.e. "the last line" in the selected area
           || iIsBoxMode)       // box mode limits length differently on all lines
        {
          if(iIsBoxMode)
          {
            if(i2 >= iEndCol)
            {
              i2 = WBGetMBCharPtr(pTheLine, iEndCol, NULL) - WBGetMBCharPtr(pTheLine, iCol, NULL);
            }
            else if(iCol > 0)
            {
              i2 -= WBGetMBCharPtr(pTheLine, iCol, NULL) - pTheLine;
            }
          }
          else if(!iIsLineMode)
          {
            if(i2 >= iEndCol)
            {
              i2 = WBGetMBCharPtr(pTheLine, iEndCol, NULL) - pTheLine;
            }
          }
          else if(iEndCol == 0)
          {
            i2 = 0; // typically 'last row'
          }
        }

        // check for stream mode on the first line, and start with 'iCol'
        if(!iIsBoxMode && !iIsLineMode && i1 == iRow) // on first line, start at 'iCol'
        {
          i2 -= WBGetMBCharPtr(pTheLine, iCol, NULL) - pTheLine; // subtract starting column offset for total length
        }

        if(i2 > 0) // might be < 0 depending
        {
          if(iIsLineMode || i1 > iCol) // multi-line select NOT on first line, or line mode
          {
            memcpy(p1, pTheLine, i2);
          }
          else
          {
            memcpy(p1, WBGetMBCharPtr(pTheLine, iCol, NULL), i2);
          }
          p1 += i2;
        }
        else
        {
          i2 = 0; // for box mode, mostly
        }

        if(iIsBoxMode) // iRow < iEndRow also
        {
          // for box mode, pad any 'remaining' length with space
          i2 = iEndCol - iCol // the ending width we're SUPPOSED to have
             - WBGetMBLength(WBGetMBCharPtr(pTheLine, iCol, NULL)); // the actual length in 'columns' starting at 'iCol'

          // I need THAT MANY white spaces for box mode
          if(i2 > 0)
          {
            memset(p1, ' ', i2);
            p1 += i2; // now the width should be exactly 'iEndCol - iCol'
          }
        }

        // don't add final line feed in 'stream' mode or in 'line' mode if it ends on column 0

        if(iIsBoxMode ||                    // box mode ALWAYS
           (iIsLineMode && iEndCol > 0) ||  // I'm in line mode and NOT ending on column 0 on the last line
           i1 < iEndRow)                    // not the last line
        {
          if(szLineFeed)
          {
            memcpy(p1, szLineFeed, cbLF);
            p1 += cbLF;
          }
        }
      }

      *p1 = 0;
    }
  }

  return pRval;
}

static void __internal_invalidate_cursor(const struct _text_object_ *pThis, int bPaintFlag)
{
WB_RECT rctCursor;

  if(WBIsValidTextObject(pThis) && pThis->wIDOwner != None)
  {
    rctCursor.left = pThis->iCursorX - 1;
    rctCursor.top = pThis->iCursorY - 1;
    rctCursor.bottom = rctCursor.top + pThis->iCursorHeight + 2;

    if(pThis->iInsMode == InsertMode_OVERWRITE)
    {
      rctCursor.right = rctCursor.left + pThis->iFontWidth;
    }
    else
    {
      rctCursor.right = rctCursor.left + 3;
    }

    WBInvalidateRect(pThis->wIDOwner, &rctCursor, bPaintFlag);
  }
}

static void __internal_invalidate_rect(const struct _text_object_ *pThis, WB_RECT *pRect, int bPaintFlag)
{
WB_RECT rctInvalid;

  if(WBIsValidTextObject(pThis) && pThis->wIDOwner != None)
  {
    if(!pRect)
    {
      WBInvalidateRect(pThis->wIDOwner, NULL, bPaintFlag);
      return;
    }

    memcpy(&rctInvalid, pRect, sizeof(*pRect));

    if(pThis->rctWinView.left - MIN_BORDER_SPACING > rctInvalid.left)
    {
      rctInvalid.left = pThis->rctWinView.left - MIN_BORDER_SPACING;
    }
    if(pThis->rctWinView.right + MIN_BORDER_SPACING < rctInvalid.right)
    {
      rctInvalid.right = pThis->rctWinView.right + MIN_BORDER_SPACING;
    }
    if(pThis->rctWinView.top - MIN_BORDER_SPACING > rctInvalid.top)
    {
      rctInvalid.top = pThis->rctWinView.top - MIN_BORDER_SPACING;
    }
    if(pThis->rctWinView.bottom + MIN_BORDER_SPACING < rctInvalid.bottom)
    {
      rctInvalid.bottom = pThis->rctWinView.bottom + MIN_BORDER_SPACING;
    }

    WBInvalidateRect(pThis->wIDOwner, &rctInvalid, bPaintFlag);
  }
}

// NOTE:  iStartRow and iStartCol may be 0 but not negative
//        iEndRow and iEndCol can be negative to indicate "all"
static void __internal_calc_rect(const struct _text_object_ *pThis, WB_RECT *pRect, int iStartRow, int iStartCol, int iEndRow, int iEndCol)
{
int iFontHeight;
TEXT_BUFFER *pBuf;

  if(!pRect || !WBIsValidTextObject(pThis))
  {
    if(pRect)
    {
      memset(pRect, 0, sizeof(*pRect));
    }

    return;
  }

  pBuf = (TEXT_BUFFER *)(pThis->pText); // might be NULL, must check before use

  if(iEndRow < 0)
  {
    if(pBuf && pThis->iLineFeed != LineFeed_NONE)
    {
      iEndRow = pBuf->nEntries;
    }
    else
    {
      iEndRow = 0;
    }
  }

  // examine the viewpoint rect, font height, and other info

  iFontHeight = pThis->iAsc + pThis->iDesc;

  if(pThis->iLineFeed == LineFeed_NONE) // i.e. SINGLE LINE (ignore row)
  {
    // top of line will always be centered

    pRect->top = pThis->rctWinView.top
               + (pThis->rctWinView.bottom - pThis->rctWinView.top
                  - pThis->iAsc - pThis->iDesc)
               / 2;

    pRect->bottom = pRect->top + iFontHeight; // always

    pRect->left = pThis->rctWinView.left
                + pThis->iFontWidth * (iStartCol - pThis->rctView.left); // can be negative

    if(iEndCol < 0)
    {
      pRect->right = INT_MAX;
    }
    else
    {
      pRect->right = pThis->iFontWidth * (iEndCol - iStartCol + 1);
    }
  }
  else
  {
//    pThis->rctWinView.top;  what did I intend to do here???

    if(iStartRow == iEndRow) // single row
    {
      pRect->left = pThis->rctWinView.left
                  + pThis->iFontWidth * (iStartCol - pThis->rctView.left); // can be negative

      if(iEndCol < 0)
      {
        pRect->right = INT_MAX;
      }
      else
      {
        pRect->right = pThis->iFontWidth * (iEndCol - iStartCol + 1);
      }

      pRect->top = pThis->rctWinView.top;
      pRect->bottom = pRect->top + iFontHeight; // always
    }
    else // multiple rows implies including the entire line unless ending column is 0 [in which case last line is excluded]
    {
      // ignore columns, use the entire viewport width
      pRect->left = pThis->rctWinView.left;
      pRect->right = INT_MAX; //pThis->rctWinView.right;

      iFontHeight = WBTextObjectCalculateLineHeight(pThis->iAsc, pThis->iDesc); // height PLUS inter-line spacing

      pRect->top = pThis->rctWinView.top
                 + iFontHeight * (iStartRow - pThis->rctView.top);

      if(iEndCol > 0)
      {
        pRect->bottom = pThis->rctWinView.top
                      + iFontHeight * (iEndRow + 1 - pThis->rctView.top);
      }
      else // nothing selected on last row
      {
        pRect->bottom = pThis->rctWinView.top
                       + iFontHeight * (iEndRow - pThis->rctView.top);
      }
    }
  }
}

static void __internal_merge_rect(const struct _text_object_ *pThis, WB_RECT *pRect, int iStartRow, int iStartCol, int iEndRow, int iEndCol)
{
WB_RECT rctMerge;

  if(!pRect || !WBIsValidTextObject(pThis))
  {
    if(pRect)
    {
      memset(pRect, 0, sizeof(*pRect));
    }

    return;
  }

  __internal_calc_rect(pThis, &rctMerge, iStartRow, iStartCol, iEndRow, iEndCol);

  if(rctMerge.left < pRect->left)
  {
    pRect->left = rctMerge.left;
  }
  if(rctMerge.top < pRect->top)
  {
    pRect->top = rctMerge.top;
  }
  if(rctMerge.right > pRect->right)
  {
    pRect->right = rctMerge.right;
  }
  if(rctMerge.bottom > pRect->bottom)
  {
    rctMerge.bottom = pRect->bottom;
  }
}


// ****************************
// TEXT OBJECT VTABLE FUNCTIONS
// ****************************

static void __internal_destroy(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    // TODO:  additional validation

    if(pThis->pText)
    {
      // TODO:  validate pointer
      WBFreeTextBuffer((TEXT_BUFFER *)pThis->pText);
      pThis->pText = NULL;
    }

    // now for the undo/redo buffers

    __internal_free_undo_redo_buffer(pThis->pUndo);
    pThis->pUndo = NULL;
    __internal_free_undo_redo_buffer(pThis->pRedo);
    pThis->pRedo = NULL;
  }
}

static void __internal_init(struct _text_object_ *pThis)
{
  pThis->ulTag = TEXT_OBJECT_TAG;
  pThis->wIDOwner = None;

  bzero(&pThis->rctSel, sizeof(pThis->rctSel));
  bzero(&pThis->rctHighLight, sizeof(pThis->rctHighLight));

  pThis->iFileType = 0;   // plain text
  pThis->iLineFeed = LineFeed_DEFAULT;
  pThis->iInsMode = 1;    // insert
  pThis->iSelMode = 0;    // normal
  pThis->iScrollMode = 0; // normal
  pThis->iRow = 0;
  pThis->iCol = 0;
  pThis->iPos = 0; // reserved
  bzero(&pThis->rctView, sizeof(pThis->rctView));
  pThis->pText = NULL;
  pThis->pUndo = NULL;
  pThis->pRedo = NULL;

  // TODO:  do I re-initialize the owner-maintained values?  for now, NO!
}

static void __internal_highlight_colors(struct _text_object_ *pThis, XColor clrHFG, XColor clrHBG)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->clrHFG = clrHFG;
    pThis->clrHBG = clrHBG;
  }
}

static char * __internal_get_text(struct _text_object_ *pThis)
{
  return __internal_get_selected_text(pThis, -1, -1, -1, -1);
}

static void __internal_set_text(struct _text_object_ *pThis, const char *szText, unsigned long cbLen)
{
TEXT_BUFFER *pTemp;

  if(WBIsValidTextObject(pThis))
  {
    // for now, allocate a NEW text buffer and replace the old one with it

    pTemp = WBAllocTextBuffer(szText, cbLen);

    if(pTemp)
    {
      if(pThis->pText)
      {
        WBFreeTextBuffer(pThis->pText);
      }

      pThis->pText = pTemp; // and I'm spent
    }
    else
    {
      WB_ERROR_PRINT("TEXT OBJECT:  %s - not enough memory for TEXT BUFFER errno=%d (no change)\n", __FUNCTION__, errno);
    }
  }
  else
  {
    WB_ERROR_PRINT("ERROR - %s - NOT a valid TEXT_OBJECT - %p\n", __FUNCTION__, pThis);
  }
}

static int __internal_get_rows(const struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;

  if(WBIsValidTextObject(pThis))
  {
    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(pBuf && pBuf->nEntries > 0) // only if NOT empty
    {
      if(pThis->iLineFeed == LineFeed_NONE ||
         !pBuf->aLines[0] || !*(pBuf->aLines[0])) // strlen(pBuf->aLines[0])) // "blank line"
      {
        return 1;  // for multiline, even a blank line counts as '1'
      }

      return pBuf->nEntries + 1; // include the last line (a blank one) in the line count
    }
  }

  return 0; // assume blank
}
static int __internal_get_cols(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;
int i1;

  if(WBIsValidTextObject(pThis))
  {
    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(pBuf)
    {
      if(pBuf->nMinMaxCol > pBuf->nMaxCol || !pBuf->nMaxCol || !pBuf->nMinMaxCol)
      {
        // cache data not valid, so re-evaluate
        WBTextBufferRefreshCache(pBuf); // re-calculate
      }

      if(pBuf->nMaxCol)
      {
        if(pBuf->nMaxCol < pThis->iCol) // is my current column past the 'max' column?
        {
          i1 = pThis->iCol + DEFAULT_TAB_WIDTH; // use my current column position
        }
        else
        {
          i1 = pBuf->nMaxCol + DEFAULT_TAB_WIDTH; // use the 'max' column position
        }

        return i1 - (i1 % DEFAULT_TAB_WIDTH); // rounded off to 'DEFAULT_TAB_WIDTH'
        // so if DEFAULT_TAB_WIDTH is 8, then 1 becomes 8, 8 becomes 16, etc.
      }
    }
    else if(pThis->iCol > 0) // allow for 'scrolling without any actual data yet'
    {
      i1 = pThis->iCol + DEFAULT_TAB_WIDTH; // use my current column position
      return i1 - (i1 % DEFAULT_TAB_WIDTH); // rounded off to 'DEFAULT_TAB_WIDTH'
    }

    // all other conditions fall through and return 0
  }

  return 0; // assume blank
}

static int __internal_get_filetype(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iFileType;
  }
  return 0; // for now
}
static void __internal_set_filetype(struct _text_object_ *pThis, int iFileType)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iFileType = iFileType;
  }
}
static int __internal_get_linefeed(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return (int) pThis->iLineFeed;
  }
  return 0; // for now
}
static void __internal_set_linefeed(struct _text_object_ *pThis, int iLineFeed)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iLineFeed = (enum _LineFeed_)iLineFeed;
  }
}
static int __internal_get_insmode(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iInsMode;
  }
  return 0; // for now
}
static void __internal_set_insmode(struct _text_object_ *pThis, int iInsMode)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iInsMode = iInsMode;
  }
}
static int __internal_get_selmode(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iSelMode;
  }
  return 0; // for now
}
static void __internal_set_selmode(struct _text_object_ *pThis, int iSelMode)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iSelMode = iSelMode;
  }
}
static int __internal_get_tab(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iTab;
  }
  return 0; // for now
}
static void __internal_set_tab(struct _text_object_ *pThis, int iTab)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iTab = iTab;
  }
}
static int __internal_get_scrollmode(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iScrollMode;
  }
  return 0; // for now
}
static void __internal_set_scrollmode(struct _text_object_ *pThis, int iScrollMode)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iScrollMode = iScrollMode;
  }
}
static void __internal_get_select(const struct _text_object_ *pThis, WB_RECT *pRct)
{
  if(WBIsValidTextObject(pThis))
  {
    if(pRct)
    {
      if(SEL_RECT_ALL(pThis))
      {
        pRct->left = -1;   // 'normalize' 'select all' to return {-1,-1,-1,-1}
        pRct->right = -1;
        pRct->top = -1;
        pRct->bottom = -1;
      }
      else
      {
        memcpy(pRct, &(pThis->rctSel), sizeof(*pRct));

        if(!SEL_RECT_EMPTY(pThis))   // if not empty
        {
          NORMALIZE_SEL_RECT(*pRct); // normalize the results
        }
      }
    }
  }
}
static void __internal_set_select(struct _text_object_ *pThis, const WB_RECT *pRct)
{
  if(WBIsValidTextObject(pThis))
  {
    memcpy(&(pThis->rctSel), pRct, sizeof(*pRct));
  }
}
static int __internal_has_select(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return !SEL_RECT_EMPTY(pThis);
  }
  return 0;
}
static char* __internal_get_sel_text(const struct _text_object_ *pThis, const WB_RECT *pRct)
{
WB_RECT rctSel;

  if(WBIsValidTextObject(pThis))
  {
    if(SEL_RECT_EMPTY(pThis))
    {
      return NULL;
    }
    else if(SEL_RECT_ALL(pThis))
    {
      return __internal_get_selected_text(pThis, -1, -1, -1, -1);
    }

    memcpy(&rctSel, &(pThis->rctSel), sizeof(rctSel));

    NORMALIZE_SEL_RECT(rctSel);

    return __internal_get_selected_text(pThis, rctSel.top, rctSel.left,
                                        rctSel.bottom, rctSel.right);
  }
  return NULL; // for now
}
static int __internal_get_row(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iRow;
  }
  return 0; // for now
}
static void __internal_set_row(struct _text_object_ *pThis, int iRow)
{
  if(WBIsValidTextObject(pThis))
  {
    if(iRow < 0 || !pThis->pText)
    {
      iRow = 0;
    }
    else if(iRow > ((TEXT_BUFFER *)pThis->pText)->nEntries)
    {
      iRow = ((TEXT_BUFFER *)pThis->pText)->nEntries;
    }

    pThis->iRow = iRow;
  }
}
static int __internal_get_col(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iCol;
  }
  return 0; // for now
}
static void __internal_set_col(struct _text_object_ *pThis, int iCol)
{
int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

  if(WBIsValidTextObject(pThis))
  {
    pThis->iCol = iCol; // for now, assign "as-is"

    if(pThis->iLineFeed == LineFeed_NONE && // single-line, do auto-scrolling
       pThis->rctView.right > pThis->rctView.left) // in case the view area is empty
    {
      while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
      {
        iAutoScrollWidth >>= 1;
      }

      // scroll left/right to expose the cursor

      while(pThis->rctView.left > pThis->iCol)
      {
        pThis->rctView.left -= iAutoScrollWidth;
        pThis->rctView.right -= iAutoScrollWidth;
      }
      while(pThis->rctView.right <= pThis->iCol)
      {
        pThis->rctView.left += iAutoScrollWidth;
        pThis->rctView.right += iAutoScrollWidth;
      }
    }
  }
}
static void __internal_del_select(struct _text_object_ *pThis)
{
char *pTemp, *pL;
int iSelAll, iLen, i1, i2;
TEXT_BUFFER *pBuf;
WB_RECT rctSel;


  if(WBIsValidTextObject(pThis))
  {
    __internal_invalidate_cursor(pThis, 0);
    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    iSelAll = SEL_RECT_ALL(pThis); // identifies "select all"

    if(!iSelAll && SEL_RECT_EMPTY(pThis))
    {
      // no selection, do nothing
      return;
    }

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf || (pThis->rctSel.top >= pBuf->nEntries && pThis->rctSel.bottom >= pBuf->nEntries))
    {
      return;  // NO buffer, or select area is outside of buffer area
    }

    // for the undo buffer I will need a copy of the original text.
    // this function only returns NULL on error

    memcpy(&rctSel, &(pThis->rctSel), sizeof(rctSel));

    if(iSelAll)
    {
      pTemp = __internal_get_selected_text(pThis, -1, -1, -1, -1);
    }
    else
    {
      NORMALIZE_SEL_RECT(rctSel);

      pTemp = __internal_get_selected_text(pThis, rctSel.top, rctSel.left,
                                           rctSel.bottom, rctSel.right);
    }

    if(iSelAll)
    {
      // delete all
      if(pThis->pText)
      {
        WBFreeTextBuffer(pThis->pText);
        pThis->pText = NULL;
      }

      if(pTemp)
      {
        __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                            0, 0, &(pThis->rctSel), pTemp, -1,
                            pBuf->nEntries, 0, NULL, NULL, 0);
      }
    }
    else if(pThis->iLineFeed == LineFeed_NONE ||
            rctSel.top == rctSel.bottom) // single-line selection (all methods behave the same)
    {
      // delete from rctSel.left to rctSel.right (exclusive)

      pL = pBuf->aLines[rctSel.top];

      if(pL)
      {
        iLen = WBGetMBLength(pL);
        if(iLen >= rctSel.left)
        {
          if(iLen <= rctSel.right)
          {
            char *pTempL = WBGetMBCharPtr(pL, rctSel.left, NULL);
            if(pTempL)
            {
              *pTempL = 0; // just truncate the string
            }
          }
          else
          {
            char *pTempL = WBGetMBCharPtr(pL, rctSel.left, NULL);
            char *pTempR = WBGetMBCharPtr(pL, rctSel.right, NULL);

            if(pTempL && pTempR)
            {
              strcpy(pTempL, pTempR); // thereby squeezing the string together and deleting the selection
            }
          }
        }
      }

      if(pTemp)
      {
        __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                            rctSel.top, rctSel.left, &(pThis->rctSel),
                            pTemp, -1,
                            rctSel.bottom, rctSel.right, NULL, NULL, 0);
      }

      if(pThis->iLineFeed == LineFeed_NONE && // special case, auto-hscroll
         pThis->rctView.right > pThis->rctView.left)
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
        {
          iAutoScrollWidth >>= 1;
        }

        // scroll left/right to expose the cursor

        while(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.left -= iAutoScrollWidth;
          pThis->rctView.right -= iAutoScrollWidth;
        }
        while(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += iAutoScrollWidth;
          pThis->rctView.right += iAutoScrollWidth;
        }
      }
    }
    else if(pThis->iSelMode == SelectMode_BOX) // multiline delete BOX mode
    {
    }
    else if(pThis->iSelMode == SelectMode_LINE) // multiline delete LINE mode
    {
    }
    else // default 'char'
    {
      if(pBuf->aLines[rctSel.top] && rctSel.left > 0)
      {
        pL = pBuf->aLines[rctSel.top];

        if(rctSel.right > 0)
        {
          char *pJoin, *pNew;

          pJoin = WBGetMBCharPtr(pBuf->aLines[rctSel.bottom], rctSel.right, NULL);
          pNew = WBJoinMBLine(pL, rctSel.left, pJoin);

          if(!pNew) // error
          {
            WB_ERROR_PRINT("ERROR - %s - memory allocation error, errno=%d\n", __FUNCTION__, errno);
            return; // no undo buffer when there's a memory error
          }
          pBuf->aLines[rctSel.top] = pNew;
          if(pL) // just in case
          {
            WBFree(pL);
          }

          i2 = rctSel.bottom + 1; // start copying the NEXT line
        }
        else
        {
          char *pTemp = WBGetMBCharPtr(pL, rctSel.left, NULL);
          if(pTemp) // just in case
          {
            *pTemp = 0; // truncate line at this position
          }

          i2 = rctSel.bottom; // start copying THIS line (since I'm not joining them)
        }

        for(i1=pThis->rctSel.top + 1; i2 < pBuf->nEntries; i1++, i2++)
        {
          if(pBuf->aLines[i1])
          {
            WBFree(pBuf->aLines[i1]);
          }
          pBuf->aLines[i1] = pBuf->aLines[i2];
          pBuf->aLines[i2] = NULL; // for now, to prevent accidental pointer re-use later
        }

        pBuf->nEntries = i1;
      }
      else
      {
        if(rctSel.right == 0) // an even number of lines is being deleted
        {
          for(i1=rctSel.top, i2=rctSel.bottom; i2 < pBuf->nEntries; i1++, i2++)
          {
            if(pBuf->aLines[i1])
            {
              WBFree(pBuf->aLines[i1]);
            }
            pBuf->aLines[i1] = pBuf->aLines[i2];
            pBuf->aLines[i2] = NULL; // for now, to prevent accidental pointer re-use later
          }

          pBuf->nEntries = i1;
        }
        else // uneven lines
        {
          // top line will become partial bottom line
          pL = pBuf->aLines[rctSel.bottom];

          if(pL)
          {
            char *pTempR = WBGetMBCharPtr(pL, rctSel.right, NULL);
            if(pTempR)
            {
              strcpy(pL, pTempR);
            }
            else
            {
              *pL = 0; // for now, truncate the line if this happens
            }
          }

          if(pBuf->aLines[rctSel.top])
          {
            WBFree(pBuf->aLines[rctSel.top]);
            pBuf->aLines[rctSel.top] = NULL; // by convention (it's re-assigned in the next line though)
          }

          pBuf->aLines[rctSel.top] = pL;
          pBuf->aLines[rctSel.bottom] = NULL; // by convention, to prevent re-use of pointer

          for(i1=rctSel.top + 1, i2=rctSel.bottom + 1; i2 < pBuf->nEntries; i1++, i2++)
          {
            if(pBuf->aLines[i1])
            {
              WBFree(pBuf->aLines[i1]);
              pBuf->aLines[i1] = NULL; // by convention (re-assigned in next line)
            }

            pBuf->aLines[i1] = pBuf->aLines[i2];
            pBuf->aLines[i2] = NULL; // by convention, to prevent accidental pointer re-use later
          }

          pBuf->nEntries = i1;
        }
      }

      if(pTemp)
      {
        __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                            rctSel.top, rctSel.left, &(pThis->rctSel),
                            pTemp, -1,
                            rctSel.bottom, rctSel.right, NULL, NULL, 0);
      }
    }

    if(pTemp)
    {
      WBFree(pTemp);
    }

    // once the selection has been deleted, select 'nothing' and re-paint all
    // and of course, iRow and iCol will be at the left/top of the selection

    // NOTE:  this assumes that the data is consistent

    pThis->rctSel.left = pThis->rctSel.top = pThis->rctSel.right = pThis->rctSel.bottom = 0;

    if(iSelAll)
    {
      pThis->iRow = pThis->iCol = 0;
    }
    else
    {
      pThis->iRow = rctSel.top;
      pThis->iCol = rctSel.left;
    }

    __internal_invalidate_rect(pThis, NULL, 1); // TODO:  optimize this
  }
}
static void __internal_replace_select(struct _text_object_ *pThis, const char *szText, unsigned long cbLen)
{
WB_RECT rctSel;
int iSelAll;

  if(WBIsValidTextObject(pThis))
  {
    int iOldIns; //, iOldRow, iOldCol;

    if(pThis->iRow < 0 || pThis->iCol< 0)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }

// NOTE:  iOldRow and iOldCol not being used; commented out because of linux gcc warnings
//    iOldRow = pThis->iRow;
//    iOldCol = pThis->iCol;
    iOldIns = pThis->iInsMode;

    iSelAll = SEL_RECT_ALL(pThis);

    memcpy(&rctSel, &(pThis->rctSel), sizeof(rctSel));

    if(iSelAll)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }
    else if(!SEL_RECT_EMPTY(pThis))
    {
      NORMALIZE_SEL_RECT(rctSel);

      pThis->iRow = rctSel.top;
      pThis->iCol = rctSel.left;
    }

    pThis->iInsMode = InsertMode_INSERT;

    // TODO:  if box mode, height/width may need to match.  for now, don't care

    if(!iSelAll && SEL_RECT_EMPTY(pThis)) // not 'ALL'
    {
      __internal_ins_chars(pThis, szText, cbLen); // just insert the text (no selection)

      // NOTE:  select rectangle remains empty
    }
    else
    {
      // for now delete the selection, then insert the new characters
      // this will take into consideration the select mode
      __internal_del_select(pThis);               // this also clears the selection

     // new selection starts at rctSel.top, rctSel.left

      __internal_ins_chars(pThis, szText, cbLen); // just insert the text (no selection)

      // new selection ends at iRow, iCol

      rctSel.right = pThis->iRow;
      rctSel.bottom = pThis->iCol;

      // assign the new select rectangle to become the text I just added.
      memcpy(&(pThis->rctSel), &rctSel, sizeof(pThis->rctSel));
    }

//    pThis->iRow = iOldRow;
//    pThis->iCol = iOldCol;
    pThis->iInsMode = iOldIns;

    // todo:  mark a NEW selection using the inserted text?  this might mean replicating code for
    //        __internal_del_select and __internal_ins_chars and processing undo here


    __internal_invalidate_rect(pThis, NULL, 1); // TODO:  optimize this
  }
}
static void __internal_del_chars(struct _text_object_ *pThis, int nChar)
{
TEXT_BUFFER *pBuf;
int i1, i2, iLen;
char *pL, *pL2, *pL3;
WB_RECT rctInvalid;


  if(!nChar)
  {
    return; // does nothing
  }

  // NOTE: nChar < 0 deletes to the left (like a backspace), >0 deletes to the right like 'Del' normally would
  //       If the cursor is at the end of the line or the start of the line, an appropriate delete will
  //       merge the previous (or next) line.  Values of |nChar| greater than the number of characters remaining
  //       in the line (from the cursor) _STOP_ at the beginning/end of the line.  Only a delete with cursor
  //       AT the beginning or end of the line will merge.  Merge also considers the virtual cursor position.

  if(!WBIsValidTextObject(pThis))
  {
    return; // error
  }

  __internal_invalidate_cursor(pThis, 0);
  pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

  if(nChar > 0 || pThis->iCol == 0)
  {
    __internal_calc_rect(pThis, &rctInvalid, pThis->iRow, pThis->iCol, pThis->iRow, pThis->iCol + 1);
  }
  else if(pThis->iCol > 0)
  {
    __internal_calc_rect(pThis, &rctInvalid, pThis->iRow, pThis->iCol - 1, pThis->iRow, pThis->iCol);
  }

  pBuf = (TEXT_BUFFER *)(pThis->pText);

  if(!pBuf || !pBuf->nEntries || pThis->iRow > pBuf->nEntries ||
     (pThis->iRow == pBuf->nEntries && nChar > 0)) // ending row only allows a backspace from the 1st column
  {
    return;  // do nothing
  }

  while(nChar) // while I have characters to delete
  {
    // if I hit a limit and 'nChar' is still non-zero, break out and return anyway

    if(pThis->iRow >= pBuf->nEntries || pThis->iRow < 0)
    {
      return; // empty
    }

    pL = pBuf->aLines[pThis->iRow];
    if(!pL)
    {
      return; // do nothing (TODO:  error message?)
    }

    iLen = WBGetMBLength(pL);

    if(nChar < 0 && pThis->iCol == 0 && // backspace prior to beginning of line
       (pThis->iRow <= 0 || pThis->iLineFeed == LineFeed_NONE)) // single line and backspace past begin of column
    {
      return; // exit
    }

    if(nChar > 0 && pThis->iCol >= iLen && // delete past end of line
       (pThis->iRow >= pBuf->nEntries || pThis->iLineFeed == LineFeed_NONE)) // single line and backspace past begin of column
    {
      return; // exit
    }

    // if it's at an edge, merge lines

    if(pThis->iRow > 0 && nChar < 0 && pThis->iCol == 0) // backspace while at the start of a line
    {
      pL2 = pBuf->aLines[pThis->iRow - 1];
      if(!pL2)
      {
        pThis->iCol = 0; // a kind of 'fallback' - put column cursor at zero
      }
      else
      {
        i2 = WBGetMBLength(pL2); // now THIS is the new column position

        pL2 = WBJoinMBLine(pL, i2, pBuf->aLines[pThis->iRow + 1]);

        if(!pL2)
        {
          return; // do nothing (TODO:  error message?)
        }

        WBFree(pL);

        pBuf->aLines[pThis->iRow - 1] = pL2; // the new pointer

        pThis->iCol = i2; // the new position (end of previous line)
      }

      for(i1=pThis->iRow; i1 < pBuf->nEntries; i1++)
      {
        pBuf->aLines[i1 - 1] = pBuf->aLines[i1]; // pack them up by one line
      }

      pBuf->nEntries--;
      pBuf->aLines[pBuf->nEntries] = NULL; // so that pointers aren't accidentally re-used

      WBFree(pL); // free up memory for old line

      pThis->iRow--; // since I moved up

      nChar++; // backspacing, so increment

      __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                          pThis->iRow, pThis->iCol, &(pThis->rctSel),
                          "\n", 1, // this is what I'm deleting - the newline
                          pThis->iRow + 1, 0, NULL, NULL, 0);

      __internal_merge_rect(pThis, &rctInvalid, pThis->iRow, 0, -1, -1);
    }
    else if(pThis->iCol >= iLen && nChar > 0 && pThis->iRow < (pBuf->nEntries - 1))
    {
      pL2 = pBuf->aLines[pThis->iRow + 1];
      if(pL2)
      {
        pL = WBJoinMBLine(pL, pThis->iCol, pBuf->aLines[pThis->iRow + 1]);

        if(!pL)
        {
          return; // do nothing (TODO:  error message?)
        }

        WBFree(pL2);

        pBuf->aLines[pThis->iRow] = pL; // the new pointer
      }

      pBuf->nEntries--;

      // merge UP the lines
      for(i1=pThis->iRow + 1; i1 < pBuf->nEntries; i1++)
      {
        pBuf->aLines[i1] = pBuf->aLines[i1 + 1];
      }

      pBuf->aLines[pBuf->nEntries] = NULL; // so that pointers aren't accidentally re-used

      nChar--;

      __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                          pThis->iRow, iLen, &(pThis->rctSel),
                          "\n", 1,
                          pThis->iRow + 1, 0, NULL, NULL, 0);

      __internal_merge_rect(pThis, &rctInvalid, pThis->iRow, 0, -1, -1); // invalidate entire row and those that follow
    }

    // OK now that _THAT_ is done, delete "up to the end of the string if needed"
    // on either end, depending upon which direction we must travel

    pL = pBuf->aLines[pThis->iRow];

    if(!pL)
    {
      return; // do nothing (TODO:  error message?)
    }

    // TODO:  use WBDelMBChars

    if(nChar < 0 && pThis->iCol > 0)
    {
      // TODO:  handle hard tab translation?  For now "leave it"

      i2 = -nChar;
      if(i2 > pThis->iCol)
      {
        i2 = pThis->iCol;
      }

      // position to which I delete
      pL2 = WBGetMBCharPtr(pL, pThis->iCol - i2, NULL);  // column to which I delete (backspace)
      pL3 = WBGetMBCharPtr(pL, pThis->iCol, NULL);  // position FROM where I delete/backspace


      // create undo record first, before I actually delete things
      __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                          pThis->iRow, pThis->iCol + nChar, &(pThis->rctSel),
                          pL2, pL3 - pL2, // text pointer AND 'true length' in bytes
                          pThis->iRow, pThis->iCol, NULL, NULL, 0);

      strcpy(pL2, pL3); // delete things down

      pThis->iCol -= i2;
      nChar += i2; // # of characters actually deleted (added 'cause nChar is negative)

      __internal_merge_rect(pThis, &rctInvalid, pThis->iRow, pThis->iCol, pThis->iRow, -1); // invalidate remainder of row
    }
    else if(nChar > 0 && iLen > pThis->iCol)
    {
      // TODO:  handle hard tab translation?  For now "leave it"

      i2 = nChar;

      if(i2 > iLen - pThis->iCol)
      {
        i2 = iLen - pThis->iCol;
      }

      // position to which I delete
      pL2 = WBGetMBCharPtr(pL, pThis->iCol + i2, NULL);  // column to which I delete
      pL3 = WBGetMBCharPtr(pL, pThis->iCol, NULL);  // position FROM where I delete/backspace

      // create undo record first, before I actually delete things
      __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                          pThis->iRow, pThis->iCol, &(pThis->rctSel),
                          pL3, pL2 - pL3, // text pointer AND 'true length' in bytes
                          pThis->iRow, pThis->iCol + nChar, NULL, NULL, 0);

      strcpy(pL3, pL2); // delete things down

      nChar -= i2;

      // NOTE:  column does not change
      __internal_merge_rect(pThis, &rctInvalid, pThis->iRow, pThis->iCol, pThis->iRow, -1); // invalidate remainder of row
    }

    // implement auto-hscroll while deleting

    if(pThis->rctView.right > pThis->rctView.left)
    {
      if(pThis->rctView.right <= pThis->iCol ||
         pThis->rctView.left > pThis->iCol)
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
        {
          iAutoScrollWidth >>= 1;
        }

        // scroll left/right to expose the cursor

        while(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.left -= iAutoScrollWidth;
          pThis->rctView.right -= iAutoScrollWidth;
        }
        while(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += iAutoScrollWidth;
          pThis->rctView.right += iAutoScrollWidth;
        }

        __internal_invalidate_rect(pThis, NULL, 1); // scrolling, so invalidate everything
      }
      else
      {
        __internal_invalidate_rect(pThis, &rctInvalid, 1); // invalidate bounding rectangle
      }
    }
    else
    {
      __internal_invalidate_rect(pThis, &rctInvalid, 1); // invalidate bounding rectangle
    }
  }
}
static void __internal_ins_chars(struct _text_object_ *pThis, const char *pChar, int nChar)
{
TEXT_BUFFER *pBuf;
const char *p1, *p2;
char *pL, *pTemp;
int i1, iLen=0, iMultiLine = 0;
WB_RECT rctInvalid;


  if(!pChar || !nChar)
  {
    return;
  }

  if(nChar < 0)
  {
    nChar = strlen(pChar);
  }

  p1 = pChar;
  p2 = pChar + nChar;


  // FIRST, see if the insert is single-line or multi-line and act accordingly

  while(p1 < p2)
  {
    if(*p1 == '\n' || *p1 == '\r')
    {
      iMultiLine = 1;
      break; // this will be used in single-line mode to mark "stop here"
    }

    p1++;
  }


  if(WBIsValidTextObject(pThis))
  {
    if(pThis->iRow < 0 || pThis->iCol< 0)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }

    __internal_invalidate_cursor(pThis, 0);
    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    __internal_calc_rect(pThis, &rctInvalid, pThis->iRow, pThis->iCol, pThis->iRow, -1); // always refresh entire line from 'iCol' forward

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(pThis->iLineFeed == LineFeed_NONE) // single line
    {
      if(iMultiLine)
      {
        iMultiLine = 0;
        p2 = p1; // either end of string, or the position of the newline
      }

      p1 = pChar;

      // insert at 'iCol'

      if(!pBuf) // no buffer, so add text now
      {
        pBuf = pThis->pText = WBAllocTextBuffer(p1, p2 - p1); // this copies the data, too

        pThis->iRow = 0; // always
        pThis->iCol = WBGetMBColIndex(p1, p2); // the col index of 'p2' within 'p1' ('MB' length of 'p1 through p2')
        // new col will be 'end of string'.  by using this value, it's effectively, like pressing 'end' after inserting

        __internal_add_undo(pThis, UNDO_INSERT, pThis->iSelMode,
                            pThis->iRow, 0, &(pThis->rctSel), NULL, 0, // old col was 0, always
                            pThis->iRow, pThis->iCol, NULL,            // new col already assigned
                            p1, p2 - p1); // the new text
      }
      else if(p2 > p1) // adding text to existing buffer
      {
        if(pThis->iRow != 0)
        {
          pThis->iRow = 0; // force it
        }

        iLen = 0; // pre-assign for later (so it won't be "unassigned" by accident on error)

        //------------------------------------------------
        // calculating buffer size, allocating line buffer
        //------------------------------------------------

        if(pBuf->nEntries <= 0 || !pBuf->aLines[0])
        {
          if(pBuf->nEntries <= 0)
          {
            pBuf->nEntries = 1; // single-line, always this, but not verifying for now
          }

          pL = pBuf->aLines[0] = WBAlloc(pThis->iCol + p2 - p1 + 2);

          if(pL)
          {
            if(pThis->iCol > 0) // this works because a space is always 1 byte long
            {
              memset(pL, ' ', pThis->iCol);
              pL[pThis->iCol] = 0;
            }

            iLen = pThis->iCol;
          }
        }
        else
        {
          pTemp = pBuf->aLines[0];

          i1 = strlen(pTemp); // the actual length

          iLen = WBGetMBLength(pTemp); // the # of columns

          if(iLen < pThis->iCol)
          {
            i1 += pThis->iCol - iLen; // add the alloc length for white space following 'iCol'
          }

          if(pThis->iInsMode == InsertMode_OVERWRITE &&
             iLen >= pThis->iCol) // only if I actually overwrite something
          {
            if(iLen < pThis->iCol + WBGetMBColIndex(p1, p2)) // will overwrite extend the string??
            {
              char *pTempC = WBGetMBCharPtr(pTemp, pThis->iCol, NULL);

              if(pTempC)
              {
                i1 = (pTempC - pTemp) + (p2 - p1); // extent of teh text I'm adding when I overwrite
              }
              else
              {
                i1 += p2 - p1; // fallback in case of problems
              }
            }
          }
          else
          {
            i1 += p2 - p1; // I'm extending the string by 'that much'
          }

          pL = WBReAlloc(pTemp, i1 + 2);

          if(pL)
          {
            pBuf->aLines[0] = pL;
          }
          else
          {
            WB_ERROR_PRINT("ERROR:  %s - not enough memory\n", __FUNCTION__);
          }
        }

        //-------------------------------------------
        // copying data into buffer at column 'iCol'
        //-------------------------------------------

        if(pL)
        {
          char *pTempL;
          if(iLen < pThis->iCol)
          {
            pTempL = pL + strlen(pL); // will always be this

            memset(pTempL, ' ', pThis->iCol - iLen); // pad with spaces
            
            pTempL += pThis->iCol - iLen; // advance the pointer to where 'iCol' is
            *pTempL = 0;                  // make sure it ends in a zero byte
          }
          else if(iLen > pThis->iCol &&                    // insert 'in the middle'
                  pThis->iInsMode != InsertMode_OVERWRITE) // NOT overwriting
          {
            pTempL = WBGetMBCharPtr(pL, pThis->iCol, NULL);

            // make room for text
            if(WB_LIKELY((iLen - pThis->iCol + 1) > 0)) // probably always true
            {
              memmove(pTempL + (p2 - p1), pTempL, strlen(pTempL) + 1); // note that this includes the zero byte at the end
            }
          }
          else if((p2 - p1) + pThis->iCol >= iLen) // overwriting AND it extends the buffer?
          {
            pTempL = WBGetMBCharPtr(pL, pThis->iCol, NULL);

            pTempL[p2 - p1] = 0; // I need a terminating zero byte immediately after where the text will go
          }

          __internal_add_undo(pThis, UNDO_INSERT, pThis->iSelMode,
                              pThis->iRow, pThis->iCol, &(pThis->rctSel),
                              (pThis->iInsMode == InsertMode_OVERWRITE && pThis->iCol < iLen ?
                               pL + pThis->iCol : NULL), // for overwrite, it's the original text
                              (pThis->iInsMode == InsertMode_OVERWRITE && pThis->iCol < iLen ?
                               p2 - p1 : 0),  // length of old text for overwrite
                              pThis->iRow, pThis->iCol + (p2 - p1), NULL,
                              p1, p2 - p1); // the new text

          memcpy(pL + pThis->iCol, p1, p2 - p1); // insert the data (but not the terminating zero byte)

          pThis->iCol += WBGetMBColIndex(p1, p2); // always advance the cursor to this point (overwrite OR insert)
        }
      }
    }
    else // multi-line text
    {

      // TODO: auto-vscroll while inserting text, make sure cursor position is visible

      // insert at 'iCol'

      if(!pBuf) // no buffer, so add text now
      {
        p1 = pChar;
        p2 = pChar + nChar;

        pBuf = pThis->pText = WBAllocTextBuffer(pChar, nChar);

        pThis->iRow = 0; // always
        pThis->iCol = nChar; // effectively, like pressing 'end' after inserting

        __internal_add_undo(pThis, UNDO_INSERT, pThis->iSelMode,
                            pThis->iRow, 0, &(pThis->rctSel), NULL, 0, // old col was 0, always
                            pThis->iRow, pThis->iCol, NULL,            // new col already assigned
                            pChar, nChar); // the new text
      }
      else // add to existing buffer
      {
        // NOW, parse into 'lines' and add text as needed
        const char *p3 = pChar + nChar; // p3 is 'end of text' marker now
        p2 = pChar;               // also marks 'end of line' for insertion

//POOBAH convert all this shit to use line buffers as proper MBCS entries, with row/col being non-linear to char length
//POOBAH that means an API that gets you an MBCS char based on col, gets the lenth of the string in cols, handles hard/soft tabs,
//POOBAH and lets you insert/overwrite a string, automatically re-allocating the buffer, and things like that.
        
        while(p2 < p3)
        {
          int nTabs = 0;
          p1 = p2; // new 'start of line' pointer (for insertion)

          while(p2 < p3 && *p2 != '\n' && *p2 != '\r')
          {
            if(*p2 == '\t') // hard tab insertion?
            {
              nTabs++; // count them (for now); this is for allocation purposes

              // NOTE:  if hard tabs are supported, I will be storing the white space
              //        as a special character
            }

            p2++;
          }

          // p2 now points just past the end of the 'line' I am inserting, and points to
          // either a '\r' or a '\n' (which will be inserted)

          // there are 3 scenarious:
          // a) inserting a line feed (no text)
          // b) inserting text without a line feed
          // c) inserting text WITH a line feed (or more than one line feed)
          //
          // and the insert condition:  insert OR overwrite
          // a) if overwrite exceeds the length of the line, it appends to the same line.
          // b) if overwrite 'overwrites' with a line feed, it acts like 'insert' at that point (gedit does this too)
          // c) if insert or overwrite adds a line feed, a new line is created with the remaining text from the line
          //    and subsequent lines are moved down by 1 to make space for it

          // I'll deal with 'inserting text' first, then the line feed separately
        
          if(pBuf->nEntries <= 0 || !pBuf->aLines[0])
          {
            if(pBuf->nEntries <= 0)
            {
              pBuf->nEntries = 1; // single-line, always this, but not verifying for now
            }

            pL = pBuf->aLines[0] = WBAlloc(pThis->iCol + p2 - p1 + 2);

            if(pL)
            {
              if(pThis->iCol > 0)
              {
                memset(pL, ' ', pThis->iCol);
              }

              iLen = pThis->iCol;
            }
          }
          else
          {
            pTemp = pBuf->aLines[0];
            i1 = iLen = strlen(pTemp); // the actual length

            if(iLen < pThis->iCol)
            {
              i1 = pThis->iCol; // the alloc length
            }

            if(pThis->iInsMode == InsertMode_OVERWRITE)
            {
              if(i1 < pThis->iCol + p2 - p1)
              {
                i1 = pThis->iCol + p2 - p1; // extent of the text I'm adding when I overwrite
              }
            }
            else
            {
              i1 += p2 - p1;
            }

            pL = WBReAlloc(pTemp, i1 + 2);

            if(pL)
            {
              pBuf->aLines[0] = pL;
            }
            else
            {
              WB_ERROR_PRINT("ERROR:  %s - not enough memory\n", __FUNCTION__);
            }
          }

          if(pL)
          {
            if(iLen < pThis->iCol)
            {
              memset(pL + iLen, ' ', pThis->iCol - iLen); // pad with spaces

              pL[pThis->iCol + p2 - p1] = 0;              // I need a terminating zero byte
            }
            else if(iLen > pThis->iCol &&                    // insert 'in the middle'
                    pThis->iInsMode != InsertMode_OVERWRITE) // NOT overwriting
            {
              // make room for text
              if(WB_LIKELY((iLen - pThis->iCol + 1) > 0)) // probably always true
              {
                memmove(pL + pThis->iCol + (p2 - p1), pL + pThis->iCol, iLen - pThis->iCol + 1);
                  // note that this includes teh zero byte.
              }
            }
            else if((p2 - p1) + pThis->iCol >= iLen)
            {
              pL[pThis->iCol + p2 - p1] = 0; // I need a terminating zero byte
            }

            __internal_add_undo(pThis, UNDO_INSERT, pThis->iSelMode,
                                pThis->iRow, pThis->iCol, &(pThis->rctSel),
                                (pThis->iInsMode == InsertMode_OVERWRITE && pThis->iCol < iLen ?
                                 pL + pThis->iCol : NULL), // for overwrite, it's the original text
                                (pThis->iInsMode == InsertMode_OVERWRITE && pThis->iCol < iLen ?
                                 p2 - p1 : 0),  // length of old text for overwrite
                                pThis->iRow, pThis->iCol + (p2 - p1), NULL,
                                p1, p2 - p1); // the new text

            memcpy(pL + pThis->iCol, p1, p2 - p1); // insert the data

            pThis->iCol += p2 - p1; // always advance the cursor to this point (overwrite OR insert)
          }
        }
      }

      __internal_invalidate_rect(pThis, NULL, 1); // so invalidate everything
    }

    // auto-hscroll while inserting text, make sure cursor position is visible

    if(pThis->rctView.right > pThis->rctView.left)
    {
      if(iMultiLine ||
         pThis->rctView.right <= pThis->iCol ||
         pThis->rctView.left > pThis->iCol)
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
        {
          iAutoScrollWidth >>= 1;
        }

        // scroll left/right to expose the cursor

        while(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.left -= iAutoScrollWidth;
          pThis->rctView.right -= iAutoScrollWidth;
        }
        while(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += iAutoScrollWidth;
          pThis->rctView.right += iAutoScrollWidth;
        }

        __internal_invalidate_rect(pThis, NULL, 1); // scrolling, so invalidate everything
      }
      else
      {
        __internal_invalidate_rect(pThis, &rctInvalid, 1); // invalidate bounding rectangle
      }
    }
    else
    {
      __internal_invalidate_rect(pThis, NULL, 1); // invalidate everything (confusion handler)
    }
  }
}
static void __internal_indent(struct _text_object_ *pThis, int nCol)
{
  if(WBIsValidTextObject(pThis))
  {
  }
}
static int __internal_can_undo(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
  }
  return 0; // for now
}
static void __internal_undo(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
  }
}
static int __internal_can_redo(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
  }
  return 0; // for now
}
static void __internal_redo(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
  }
}
static void __internal_get_view(const struct _text_object_ *pThis, WB_RECT *pRct)
{
  if(WBIsValidTextObject(pThis))
  {
  }
}
static void __internal_set_view(struct _text_object_ *pThis, const WB_RECT *pRct)
{
  if(WBIsValidTextObject(pThis))
  {
  }
}
static void __internal_begin_highlight(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iDragState = DragState_CURSOR;
  }
}
static void __internal_end_highlight(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iDragState = DragState_NONE;
  }
}
static void __internal_mouse_click(struct _text_object_ *pThis, int iMouseXDelta, int iMouseYDelta, int iType, int iACS)
{
TEXT_BUFFER *pBuf;
int iRow = -1, iCol = -1; // pre-assign error returns
int iFontHeight;
WB_RECT rctSel;

  // NOTE:  if this has never been painted, I can't respond to this request

  if(WBIsValidTextObject(pThis))
  {
    pBuf = (TEXT_BUFFER *)(pThis->pText);

    memset(&rctSel, 0, sizeof(rctSel));

    if(!(pThis->iDragState & DragState_MOUSE)) // not mouse-dragging at the moment
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    iFontHeight = pThis->iAsc + pThis->iDesc;

    if(iFontHeight && pThis->iFontWidth &&
       pThis->rctWinView.left < pThis->rctWinView.right &&
       pThis->rctWinView.top < pThis->rctWinView.bottom)
    {
      if(pThis->iLineFeed == LineFeed_NONE) // i.e. "single line"
      {
        iRow = 0; // always
      }
      else
      {
        iFontHeight = WBTextObjectCalculateLineHeight(pThis->iAsc, pThis->iDesc);

        iRow = pThis->rctView.top
             + (iMouseYDelta + iFontHeight / 4 - pThis->rctWinView.top) / iFontHeight;

        if(iRow < 0 || !pBuf)
        {
          iRow = 0;
        }
        else if(iRow > pBuf->nEntries)
        {
          iRow = pBuf->nEntries;
        }
      }

      // column calculation is no different between single-line and multi-line
      iCol = pThis->rctView.left
           + (iMouseXDelta + pThis->iFontWidth / 4 - pThis->rctWinView.left) / pThis->iFontWidth;

      if(iCol < 0 || !pBuf || iRow >= pBuf->nEntries || !pBuf->aLines[iRow])
      {
        iCol = 0;  // for now also force column 0 if there's no buffer or a NULL entry for it or at end of document
      }
      else if(pThis->iLineFeed == LineFeed_NONE &&
              iCol > WBGetMBLength(pBuf->aLines[iRow]))
      {
        iCol = WBGetMBLength(pBuf->aLines[iRow]);  // don't select pos past end of line for single-line edit
      }
    }

    // if I am doing a mouse-drag, and the selection is empty, start a new selection.
    // if I am doing a cursor-drag, disable it.

    if(pThis->iDragState & DragState_CURSOR)
    {
      pThis->iDragState = DragState_NONE; // turn it off now.

      if(iType == WB_POINTER_BUTTON1 && iACS == 0) // only if left-click for now
      {
        pThis->iCol = iCol;
        pThis->iRow = iRow;
      }
    }
    else if(!(pThis->iDragState & DragState_MOUSE))
    {
      if(iType == WB_POINTER_BUTTON1 && iACS == 0) // only if left-click for now
      {
        pThis->iCol = iCol;
        pThis->iRow = iRow;
      }
      else
      {
        pThis->iDragState = DragState_NONE; // turn dragging off

        // TODO:  check for wheel buttons WB_POINTER_BUTTON4 and WB_POINTER_BUTTON5 ?
      }
    }
    else if(iType == 0 && iACS == 0) // a mouse motion message while dragging
    {
      // see if the select rectangle is empty.  If it is, then I
      // am just starting the drag and I need to anchor the cursor

      // NOTE:  cursor anchor is always (left,top) even if it's a negative distance

      if(SEL_RECT_EMPTY(pThis))
      {
        pThis->rctSel.top = pThis->iRow; // old row
        pThis->rctSel.left = pThis->iCol; // previous column
      }

      pThis->rctSel.bottom = iRow;     // new row
      pThis->rctSel.right = iCol;       // new column

      pThis->iCol = iCol;
      pThis->iRow = iRow;
    }
    else
    {
      // TODO:  cancel dragging?  or not... [maybe check for right-click or scroll]

      // TODO:  check for wheel buttons WB_POINTER_BUTTON4 and WB_POINTER_BUTTON5 ?
      //        for a mouse drag I may enable this, but probably should just shut off the drag
      //        maybe shift+wheel would select...? testing it shows that it scrolls the viewport

      pThis->iDragState = DragState_NONE; // turn dragging off, for now
    }

    // for now mouse-click invalidates the entire rectangle.  Later I fix this.

    __internal_invalidate_rect(pThis, NULL, 1); // POOBAH
  }
}
static void __internal_begin_mouse_drag(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
//    WB_ERROR_PRINT("TEMPORARY - %s\n", __FUNCTION__);
    pThis->iDragState = DragState_MOUSE;
  }
}
static void __internal_end_mouse_drag(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
//    WB_ERROR_PRINT("TEMPORARY - %s\n", __FUNCTION__);
    pThis->iDragState = DragState_NONE;
  }
}
static void __internal_cursor_up(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;
int iPageHeight;


  if(WBIsValidTextObject(pThis))
  {
    int iOldRow = pThis->iRow;

    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    if(pThis->iLineFeed == LineFeed_NONE) // single line
    {
      return; // do nothing
    }

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }
    else if(pBuf->nEntries < pThis->iRow)
    {
      pThis->iRow = pBuf->nEntries;
      pThis->iCol = 0;
    }
    else if(pThis->iRow > 0)
    {
      pThis->iRow--;
    }
    else
    {
      pThis->iRow = 0;
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        pThis->rctSel.left = pThis->iCol;
        pThis->rctSel.top = iOldRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(pThis->rctView.top > pThis->iRow ||
       pThis->rctView.bottom <= pThis->iRow)
    {
      __internal_invalidate_rect(pThis, NULL, 1); // scrolling invalidates all


      iPageHeight = pThis->rctView.bottom - pThis->rctView.top - 1;

      // scroll up/down to expose the cursor

      if(iPageHeight > 0)
      {
        while(pThis->rctView.top > pThis->iRow)
        {
          pThis->rctView.top -= iPageHeight;
          pThis->rctView.bottom -= iPageHeight;
        }

        while(pThis->rctView.bottom <= pThis->iRow)
        {
          pThis->rctView.top += iPageHeight;
          pThis->rctView.bottom += iPageHeight;
        }
      }
    }
    else // re-calculate cursor metrics
    {
      pThis->iCursorY += WBTextObjectCalculateLineHeight(pThis->iAsc, pThis->iDesc)
                       * (pThis->iRow - iOldRow); // will effectively subtract

//                        (pThis->iAsc + pThis->iDesc
//                         + pThis->iDesc > MIN_LINE_SPACING * 2 ?
//                           pThis->iDesc / 2 : MIN_LINE_SPACING)
//                       * (pThis->iRow - iOldRow);

      __internal_invalidate_cursor(pThis, 1); // invalidate the NEW cursor rectangle
    }
  }
}
static void __internal_cursor_down(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;
int iPageHeight;


  if(WBIsValidTextObject(pThis))
  {
    int iOldRow = pThis->iRow;

    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    if(pThis->iLineFeed == LineFeed_NONE) // single line
    {
      return; // do nothing
    }

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }
    else if(pThis->iRow >= (pBuf->nEntries - 1))
    {
      pThis->iRow = pBuf->nEntries;
      pThis->iCol = 0;
    }
    else
    {
      pThis->iRow++;
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        pThis->rctSel.left = pThis->iCol;
        pThis->rctSel.top = iOldRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(pThis->rctView.top > pThis->iRow ||
       pThis->rctView.bottom <= pThis->iRow)
    {
      __internal_invalidate_rect(pThis, NULL, 1); // scrolling invalidates all


      iPageHeight = pThis->rctView.bottom - pThis->rctView.top - 1;

      // scroll up/down to expose the cursor

      if(iPageHeight > 0)
      {
        while(pThis->rctView.top > pThis->iRow)
        {
          pThis->rctView.top -= iPageHeight;
          pThis->rctView.bottom -= iPageHeight;
        }

        while(pThis->rctView.bottom <= pThis->iRow)
        {
          pThis->rctView.top += iPageHeight;
          pThis->rctView.bottom += iPageHeight;
        }
      }
    }
    else // re-calculate cursor metrics
    {
      pThis->iCursorY += WBTextObjectCalculateLineHeight(pThis->iAsc, pThis->iDesc)
                       * (pThis->iRow - iOldRow);

//                        (pThis->iAsc + pThis->iDesc
//                         + pThis->iDesc > MIN_LINE_SPACING * 2 ?
//                           pThis->iDesc / 2 : MIN_LINE_SPACING)
//                       * (pThis->iRow - iOldRow);

      __internal_invalidate_cursor(pThis, 1); // invalidate the NEW cursor rectangle
    }
  }
}
static void __internal_cursor_left(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;


  if(WBIsValidTextObject(pThis))
  {
    int iOldCol = pThis->iCol;

    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }
    else if(pThis->iCol > 0)
    {
      pThis->iCol --;
    }
    else
    {
      pThis->iCol = 0;
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        pThis->rctSel.left = iOldCol;
        pThis->rctSel.top = pThis->iRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(pThis->rctView.right > pThis->rctView.left)
    {
      if(pThis->rctView.right <= pThis->iCol ||
         pThis->rctView.left > pThis->iCol)
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
        {
          iAutoScrollWidth >>= 1;
        }

        // scroll left/right to expose the cursor

        while(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.left -= iAutoScrollWidth;
          pThis->rctView.right -= iAutoScrollWidth;
        }
        while(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += iAutoScrollWidth;
          pThis->rctView.right += iAutoScrollWidth;
        }

        __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
      }
      else // re-calculate cursor metrics
      {
        pThis->iCursorX += (pThis->iCol - iOldCol) * pThis->iFontWidth; // will effectively subtract

        __internal_invalidate_cursor(pThis, 1); // invalidate the NEW cursor rectangle
      }
    }
    else
    {
      __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here (confusion point)
    }
  }
}
static void __internal_cursor_right(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;


  if(WBIsValidTextObject(pThis))
  {
    int iOldCol = pThis->iCol;

    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }
    else if(pThis->iCol < 0)
    {
      pThis->iCol = 0;
    }
    else if(pThis->iCol < INT_MAX)
    {
      if(pThis->iLineFeed == LineFeed_NONE) // single line
      {
        if(pBuf->nEntries <= 0 || !pBuf->aLines[0])
        {
          pThis->iCol = 0;
        }
        else
        {
          int iLen = WBGetMBLength(pBuf->aLines[0]);

          if(pThis->iRow != 0)
          {
            pThis->iRow = 0; // force it
          }

          // no 'virtual space' for single-line but trailing white space OK

          if(pThis->iCol >= iLen)
          {
            pThis->iCol = iLen;
          }
          else
          {
            pThis->iCol++;
          }
        }
      }
      else
      {
        pThis->iCol ++;
      }
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        pThis->rctSel.left = iOldCol;
        pThis->rctSel.top = pThis->iRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(pThis->rctView.right > pThis->rctView.left)
    {
      if(pThis->rctView.right <= pThis->iCol ||
         pThis->rctView.left > pThis->iCol)
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
        {
          iAutoScrollWidth >>= 1;
        }

        // scroll left/right to expose the cursor

        while(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.left -= iAutoScrollWidth;
          pThis->rctView.right -= iAutoScrollWidth;
        }
        while(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += iAutoScrollWidth;
          pThis->rctView.right += iAutoScrollWidth;
        }

        __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
      }
      else // re-calculate cursor metrics
      {
        pThis->iCursorX += (pThis->iCol - iOldCol) * pThis->iFontWidth;

        __internal_invalidate_cursor(pThis, 1); // invalidate the NEW cursor rectangle
      }
    }
    else
    {
      __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here (confusion point)
    }
  }
}
static void __internal_page_up(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something


    __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
  }
}
static void __internal_page_down(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something


    __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
  }
}
static void __internal_page_left(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something


    __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
  }
}
static void __internal_page_right(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something


    __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
  }
}

static void __internal_cursor_home(struct _text_object_ *pThis)
{
const char *pL, *p2;
TEXT_BUFFER *pBuf;


  if(WBIsValidTextObject(pThis))
  {
    int iOldCol = pThis->iCol;

    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf || pThis->iRow >= pBuf->nEntries || pThis->iCol > 0)
    {
      pThis->iCol = 0;
    }
    else
    {
      // find first non-white-space character and assign to THAT
      // TODO:  handle hard tab translation?  For now "leave it"

      pL = pBuf->aLines[pThis->iRow];

      if(pL)
      {
        p2 = pL;
        while(*p2 && *p2 <= ' ') // TODO:  adjust for 'hard tab' char which might be 'U+00A0'...
        {
          p2++;
        }

        if(*p2)
        {
          pThis->iCol = (int)(p2 - pL); // toggling 'beginning of line' and column 0
        }
      }
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        pThis->rctSel.left = iOldCol;
        pThis->rctSel.top = pThis->iRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(pThis->rctView.right > pThis->rctView.left)
    {
      if(pThis->rctView.right <= pThis->iCol ||
         pThis->rctView.left > pThis->iCol)
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
        {
          iAutoScrollWidth >>= 1;
        }

        // scroll left/right to expose the cursor

        while(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.left -= iAutoScrollWidth;
          pThis->rctView.right -= iAutoScrollWidth;
        }
        while(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += iAutoScrollWidth;
          pThis->rctView.right += iAutoScrollWidth;
        }

        __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
      }
      else // re-calculate cursor metrics
      {
        pThis->iCursorX += (pThis->iCol - iOldCol) * pThis->iFontWidth;

        __internal_invalidate_cursor(pThis, 1); // invalidate the NEW cursor rectangle
      }
    }
    else
    {
      __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here (confusion point)
    }
  }
}

static void __internal_cursor_end(struct _text_object_ *pThis)
{
const char *pL;
TEXT_BUFFER *pBuf;


  if(WBIsValidTextObject(pThis))
  {
    int iOldCol = pThis->iCol;

    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf || pThis->iRow >= pBuf->nEntries)
    {
      pThis->iCol = 0;
    }
    else
    {
      pL = pBuf->aLines[pThis->iRow];

      if(!pL)
      {
        pThis->iCol = 0;
      }
      else
      {
        pThis->iCol = WBGetMBLength(pL);
      }
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        pThis->rctSel.left = iOldCol;
        pThis->rctSel.top = pThis->iRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(pThis->rctView.right > pThis->rctView.left)
    {
      if(pThis->rctView.right <= pThis->iCol ||
         pThis->rctView.left > pThis->iCol)
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
        {
          iAutoScrollWidth >>= 1;
        }

        // scroll left/right to expose the cursor

        while(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.left -= iAutoScrollWidth;
          pThis->rctView.right -= iAutoScrollWidth;
        }
        while(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += iAutoScrollWidth;
          pThis->rctView.right += iAutoScrollWidth;
        }

        __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
      }
      else // re-calculate cursor metrics
      {
        pThis->iCursorX += (pThis->iCol - iOldCol) * pThis->iFontWidth;

        __internal_invalidate_cursor(pThis, 1); // invalidate the NEW cursor rectangle
      }
    }
    else
    {
      __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here (confusion point)
    }
  }
}

static void __internal_cursor_top(struct _text_object_ *pThis)
{
int iPageHeight;

  if(WBIsValidTextObject(pThis))
  {
    int iOldRow = pThis->iRow;

    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    pThis->iRow = 0;
    pThis->iCol = 0;

    iPageHeight = pThis->rctView.bottom - pThis->rctView.top - 1;

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        pThis->rctSel.left = pThis->iCol;
        pThis->rctSel.top = iOldRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    // scroll up/down to expose the cursor

    if(iPageHeight > 0)
    {
      while(pThis->rctView.top > pThis->iRow)
      {
        pThis->rctView.top -= iPageHeight;
        pThis->rctView.bottom -= iPageHeight;
      }

      while(pThis->rctView.bottom <= pThis->iRow)
      {
        pThis->rctView.top += iPageHeight;
        pThis->rctView.bottom += iPageHeight;
      }
    }
  }
}

static void __internal_cursor_bottom(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;
int iPageHeight;

  if(WBIsValidTextObject(pThis))
  {
    int iOldRow = pThis->iRow;

    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(pBuf)
    {
      pThis->iRow = pBuf->nEntries;  // last line, which has no text
      pThis->iCol = 0;
    }
    else
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        pThis->rctSel.left = pThis->iCol;
        pThis->rctSel.top = iOldRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    iPageHeight = pThis->rctView.bottom - pThis->rctView.top - 1;

    // scroll up/down to expose the cursor

    if(iPageHeight > 0)
    {
      while(pThis->rctView.top > pThis->iRow)
      {
        pThis->rctView.top -= iPageHeight;
        pThis->rctView.bottom -= iPageHeight;
      }

      while(pThis->rctView.bottom <= pThis->iRow)
      {
        pThis->rctView.top += iPageHeight;
        pThis->rctView.bottom += iPageHeight;
      }
    }
  }
}

static void __internal_do_expose(struct _text_object_ *pThis, Display *pDisplay, Window wID,
                                 GC gc, const WB_GEOM *pPaintGeom, const WB_GEOM *pViewGeom,
                                 XFontSet rFontSet)
{
TEXT_BUFFER *pBuf;
WB_GEOM geomV, geomP, geomC;
XFontStruct *pFont = NULL, **ppFonts = NULL;
char **ppNames, *pL;
int i1, iLen, iFontHeight, iFontWidth, nFonts, iAsc, iDesc, iX, iY, iPX, iPY;
XFontSet fSet;
Pixmap pxTemp;
unsigned long clrFG, clrBG, clrHFG, clrHBG;
GC gc2 = None;


  if(pViewGeom)
  {
    memcpy(&geomV, pViewGeom, sizeof(geomV));
  }
  else
  {
    WBGetWindowGeom(wID, &geomV);

    geomV.y += MIN_BORDER_SPACING;           // need a minimum top/bottom border as well
    geomV.height -= MIN_BORDER_SPACING * 2;
  }

  // in all cases, make room on right/left edges for the cursor

  geomV.x += MIN_BORDER_SPACING; // required for cursor
  geomV.width -= MIN_BORDER_SPACING * 2;

  // TODO:  make use of geomV's "border" parameter??

  if(geomV.width <= MIN_BORDER_SPACING * 2 ||  // absolute minimum width
     geomV.height <= MIN_BORDER_SPACING * 2)   // absolute minimum height
  {
    return; // can't do window that's way too small
  }

  if(pPaintGeom)
  {
    memcpy(&geomP, pPaintGeom, sizeof(geomP));
  }
  else
  {
    memcpy(&geomP, &geomV, sizeof(geomV));
  }

  if(rFontSet == None) /* NULL? */
  {
    pFont = WBGetGCFont(pDisplay, gc);

    if(!pFont)
    {
      WB_ERROR_PRINT("%s - ERROR:  WBGetGCFont returns NULL\n", __FUNCTION__);

      return; // bad
    }

    fSet = WBFontSetFromFont(pDisplay, pFont); // convert font to font set

    XFreeFont(pDisplay, pFont); // free it now (important to do so)
    pFont = NULL;

    if(fSet == None)
    {
      WB_ERROR_PRINT("%s - ERROR:  WBFontSetFromFont returns None\n", __FUNCTION__);

      return; // bad
    }
  }
  else
  {
    fSet = rFontSet; // I must check for this before I free fSet later
  }

  // at this point I must use 'fSet' to do all of the font metrics + drawing

  // NOTE:  doing the call directly instead of calling WBFontSetAscent() etc. so only loop once

  nFonts = XFontsOfFontSet(fSet, &ppFonts, &ppNames); // returns # of items (do NOT free resources!  They are owned by the font set)

  // TODO:  XFontStruct::direction indicates LTR RTL TTB or BTT for painting - for now _ONLY_ LTR_TTB will apply

  if(nFonts <= 0 || !ppFonts) // no fonts?
  {
    WB_ERROR_PRINT("%s - ERROR:  XFontsOfFontSet returns %d\n", __FUNCTION__, nFonts);

    goto the_end;
  }

  // to find the floor of the font, I'll need to determine max iAsc and iDesc

  for(i1=0, iAsc=0, iDesc=0; i1 < nFonts; i1++)
  {
    if(iAsc < ppFonts[i1]->ascent)
    {
      iAsc = ppFonts[i1]->ascent;
    }
    if(iDesc < ppFonts[i1]->descent)
    {
      iDesc = ppFonts[i1]->descent;
    }
  }

  // NOW get the font width for a space (TODO:  average char width instead?)

  iFontWidth = WB_TEXT_ESCAPEMENT(fSet, " ", 1);

  // get FG/BG color information

  clrFG = WBGetGCFGColor(pDisplay, gc);
  clrBG = WBGetGCBGColor(pDisplay, gc);

  // TODO:  compare clrHFG and clrHBG to a "NULL" XColor?
  if(!memcmp(&pThis->clrHFG, &pThis->clrHBG, sizeof(XColor))) // not assigned (they should never match)
  {
    clrHBG = clrFG;
    clrHFG = clrBG;
  }
  else
  {
    clrHBG = pThis->clrHBG.pixel;
    clrHFG = pThis->clrHFG.pixel;
  }

  // make a copy of the GC since I'm probably going to mess with it

  gc2 = XCreateGC(pDisplay, wID, 0, NULL);

  if(gc2 != None)
  {
    // NOTE:  docs wrong for XCopyGC, header correct - see WBBeginPaint()
    if(!XCopyGC(pDisplay, gc, GCAll, gc2))
    {
      XFreeGC(pDisplay, gc2);
      gc2 = None;
    }
  }

  // font metrics complete. Now THAT wasn't so bad, was it?  OK it was but only need to do it here

  if(WBIsValidTextObject(pThis))
  {
    // cache the window ID
    pThis->wIDOwner = wID;

    // cache the font metrics
    pThis->iAsc = iAsc;
    pThis->iDesc = iDesc;
    pThis->iFontWidth = iFontWidth;

    iFontHeight = iAsc + iDesc; // does not include interline spacing (that comes later for multi-line only)


    // keep track of the total viewport in window coordinates.
    // this will be used later for mouse translation

    pThis->rctWinView.left = geomV.x;
    pThis->rctWinView.top  = geomV.y;
    pThis->rctWinView.right = pThis->rctWinView.left + geomV.width;
    pThis->rctWinView.bottom = pThis->rctWinView.top + geomV.height;

    // convert selection rectangle into

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf || pBuf->nEntries <= 0)
    {
//      WB_ERROR_PRINT("TEMPORARY:  %s - no text\n", __FUNCTION__);
      goto the_end; // I use the goto so I can put cleanup code there - it's safer
    }

    // CALCULATING THE CORRECT VIEWPORT
    //
    // NOTE:  if the owning window has reset the viewport, the entire window SHOULD
    //        be invalid.  If not, it won't paint properly.

    if(pThis->iLineFeed == LineFeed_NONE) // SINGLE LINE
    {
      // AUTO-ASSIGN the viewport whenever right <= left (i.e. viewport is 'NULL' or 'empty')
      // or whenever the viewport is not properly assigned (window re-size re-paint)

      if(pThis->rctView.top || pThis->rctView.bottom ||
         pThis->rctView.right != pThis->rctView.left + geomV.width / iFontWidth) // not PROPERLY assigned
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        if(pThis->rctView.left < 0) // not already assigned
        {
          pThis->rctView.left = 0;
        }

        pThis->rctView.top = pThis->rctView.bottom = 0; // single line forces this (always)

        pThis->rctView.right = pThis->rctView.left + geomV.width / iFontWidth;

        if(pThis->rctView.right > pThis->rctView.left)
        {
          while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
          {
            iAutoScrollWidth >>= 1;
          }

          // scroll right to expose the cursor

          while(pThis->rctView.right <= pThis->iCol)
          {
            pThis->rctView.left += iAutoScrollWidth;
            pThis->rctView.right += iAutoScrollWidth;
          }
        }
        else
        {
          pThis->rctView.right = pThis->rctView.left = pThis->iCol; // desperate to have something there
        }
      }
    }
    else
    {
      int iWindowHeightInLines;

      // adjust font height to include line spacing (I'll use this to position the lines)

      iFontHeight = WBTextObjectCalculateLineHeight(pThis->iAsc, pThis->iDesc);

      iWindowHeightInLines = geomV.height / iFontHeight; // window height (in lines)
      if(!iWindowHeightInLines)
      {
        iWindowHeightInLines = 1; // just in case so I don't divide by zero
      }

      // AUTO-ASSIGN the viewport whenever right <= left (i.e. viewport is 'NULL' or 'empty')
      // or whenever the viewport is not properly assigned (window re-size re-paint)

      if(pThis->rctView.right - pThis->rctView.left
            != geomV.width / iFontWidth                   // viewport needs re-calculation
         || pThis->rctView.bottom - pThis->rctView.top
            != iWindowHeightInLines                       // viewport needs re-calculation
         || pThis->rctView.top > pBuf->nEntries)          // top exceeds total # of lines
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        if(pThis->rctView.left < 0) // not already assigned
        {
          pThis->rctView.left = 0;
        }

        if(pThis->rctView.top < 0 || pThis->rctView.top > pBuf->nEntries
           || (pThis->rctView.top && pBuf->nEntries < iWindowHeightInLines))
        {
          pThis->rctView.top = 0; // set viewport to top
        }

        if(pThis->rctView.bottom - pThis->rctView.top
            != iWindowHeightInLines)
        {
          pThis->rctView.bottom = pThis->rctView.top + iWindowHeightInLines;

          // always scroll row into view

          while(pThis->rctView.top > pThis->iCol)
          {
            pThis->rctView.top -= iWindowHeightInLines - 1;
            pThis->rctView.bottom -= iWindowHeightInLines - 1;
          }
          while(pThis->rctView.bottom <= pThis->iCol)
          {
            pThis->rctView.top += iWindowHeightInLines - 1;
            pThis->rctView.bottom += iWindowHeightInLines - 1;
          }
        }

        if(pThis->rctView.right - pThis->rctView.left != geomV.width / iFontWidth)
        {
          pThis->rctView.right = pThis->rctView.left + geomV.width / iFontWidth;

          if(pThis->rctView.right > pThis->rctView.left) // just in case, test it
          {
            while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
            {
              iAutoScrollWidth >>= 1;
            }

            // scroll right to expose the cursor

            while(pThis->rctView.right <= pThis->iCol)
            {
              pThis->rctView.left += iAutoScrollWidth;
              pThis->rctView.right += iAutoScrollWidth;
            }
          }
          else
          {
            pThis->rctView.right = pThis->rctView.left = pThis->iCol; // desperate to have something there
          }
        }
      }
    }

    // convert the highlight rectangle into screen coordinates

    if(!SEL_RECT_EMPTY(pThis))
    {
      WB_RECT rctSel;

      if(SEL_RECT_ALL(pThis))
      {
        memcpy(&rctSel, &(pThis->rctView), sizeof(rctSel)); // use entire viewport for hightlight rect
        // TODO:  single-line, only select to end of string?
      }
      else
      {
        memcpy(&rctSel, &(pThis->rctSel), sizeof(rctSel));
        NORMALIZE_SEL_RECT(rctSel);
      }

      pThis->rctHighLight.left = pThis->rctWinView.left
                               + (rctSel.left - pThis->rctView.left) * iFontWidth;

      pThis->rctHighLight.top  = pThis->rctWinView.top
                               + (rctSel.top - pThis->rctView.top) * iFontHeight;

      if(pThis->iLineFeed == LineFeed_NONE)
      {
        pThis->rctHighLight.top += (geomV.height - iAsc - iDesc) / 2; // since single-line text is centered
      }

      pThis->rctHighLight.right = pThis->rctHighLight.left
                                + (rctSel.right - rctSel.left) * iFontWidth;

      pThis->rctHighLight.bottom = pThis->rctHighLight.top // NOTE add 1 to # of lines, always
                                + (rctSel.bottom - rctSel.top + 1) * iFontHeight;

      // NOTE:  this is independent of the selection method.  In the special case
      //        that a single line or an entire line is selected, I may have
      //        to handle this differently
    }
    else
    {
      memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
    }


    // if it's a single-line object, center it within the window and display only ONE line

    if(pThis->iLineFeed == LineFeed_NONE) // i.e. SINGLE LINE
    {
      ///////////////////////
      // SINGLE LINE PAINTING
      ///////////////////////

      int iXDelta = 0, iYDelta = 0;

      iY = geomV.y + (geomV.height - iAsc - iDesc) / 2 + iAsc; // iY is now "the baseline" for the font
      iX = geomV.x;

      pL = pBuf->aLines[0];
      if(!pL)
      {
        goto the_end;
      }

      // pixmap (for speeding up the process)

      iPX = pThis->rctWinView.right - pThis->rctWinView.left + 2 * MIN_BORDER_SPACING;
      iPY = pThis->rctWinView.bottom - pThis->rctWinView.top + 2 * MIN_BORDER_SPACING;

      if(gc2 != None && iPX > 0 && iPY > 0)
      {
        pxTemp = XCreatePixmap(pDisplay, wID, iPX, iPY,
                               DefaultDepth(pDisplay, DefaultScreen(pDisplay)));
      }
      else
      {
        pxTemp = None;
      }

      //--------------------------------------------
      // DRAWING BACKGROUND AND HIGHLIGHT RECTANGLE
      //--------------------------------------------

      if(pxTemp != None)
      {
        iXDelta = geomV.x - MIN_BORDER_SPACING;
        iYDelta = geomV.y - MIN_BORDER_SPACING;

        XSetClipOrigin(pDisplay, gc2, -iXDelta, -iYDelta);  // so that it matches the display's clipping in gc

        XSetForeground(pDisplay, gc2, clrBG);
        XFillRectangle(pDisplay, pxTemp, gc2, 0, 0, iPX, iPY);

        // if I have highlighted text, fill the rectangle in with the highlight color

        if(pThis->rctHighLight.right > pThis->rctHighLight.left &&
           WBRectOverlapped(pThis->rctHighLight, pThis->rctWinView))
        {
          XSetForeground(pDisplay, gc2, clrHBG); // highlight background color

          XFillRectangle(pDisplay, pxTemp, gc2,
                         pThis->rctHighLight.left - iXDelta,
                         pThis->rctHighLight.top - iYDelta,
                         pThis->rctHighLight.right - pThis->rctHighLight.left,
                         pThis->rctHighLight.bottom - pThis->rctHighLight.top);
        }

        XSetForeground(pDisplay, gc2, clrFG);
      }
      else // FALLBACK, if no pixmap, go to window directly
      {
        XSetForeground(pDisplay, gc, clrBG);
        XFillRectangle(pDisplay, wID, gc,
                       pThis->rctWinView.left,
                       pThis->rctWinView.top,
                       pThis->rctWinView.right - pThis->rctWinView.left,
                       pThis->rctWinView.bottom - pThis->rctWinView.top);

        // if I have highlighted text, fill the rectangle in with the highlight color

        if(pThis->rctHighLight.right > pThis->rctHighLight.left &&
           WBRectOverlapped(pThis->rctHighLight, pThis->rctWinView))
        {
          XSetForeground(pDisplay, gc, clrHBG); // highlight background color

          XFillRectangle(pDisplay, wID, gc,
                         pThis->rctHighLight.left,
                         pThis->rctHighLight.top,
                         pThis->rctHighLight.right - pThis->rctHighLight.left,
                         pThis->rctHighLight.bottom - pThis->rctHighLight.top);
        }

        XSetForeground(pDisplay, gc, clrFG);
      }

      //---------------------------------------
      // DRAW the text and the vertical cursor
      //---------------------------------------

      iLen = WBGetMBLength(pL);

      pThis->iCursorX = pThis->iCursorY = pThis->iCursorHeight = 0; // to indicate "not drawn"

      for(i1=pThis->rctView.left; i1 < pThis->rctView.right; i1++, iX += iFontWidth)
      {
        WB_RECT rctChar, rctCursor;

        if(i1 == pThis->iCol) // display the cursor (NOTE:  row ALWAYS matches)
        {
          pThis->iCursorX = iX - 1;

          if(pThis->iInsMode == InsertMode_OVERWRITE)
          {
            pThis->iCursorY = iY + iDesc + 1;
            pThis->iCursorHeight = 1;

            rctCursor.left = pThis->iCursorX - iXDelta;
            rctCursor.top = pThis->iCursorY - iYDelta;
            rctCursor.right = pThis->iCursorX + iFontWidth - iXDelta;
            rctCursor.bottom = pThis->iCursorY - iYDelta;
          }
          else // INSERT mode cursor
          {
            pThis->iCursorY = iY - iAsc - 1;
            pThis->iCursorHeight = iY + iDesc + 1 - pThis->iCursorY;

            rctCursor.left = pThis->iCursorX - iXDelta;
            rctCursor.top = pThis->iCursorY - iYDelta;
            rctCursor.right = pThis->iCursorX - iXDelta;
            rctCursor.bottom = pThis->iCursorY + pThis->iCursorHeight - iYDelta;
          }


          if(pThis->iBlinkState != 0) // horizontal cursor for overwrite
          {
            if(WBRectOverlapped(rctCursor, pThis->rctHighLight))
            {
              XSetForeground(pDisplay, gc2 != None ? gc2 : gc, clrHFG);
              XSetBackground(pDisplay, gc2 != None ? gc2 : gc, clrHBG);
            }
            else
            {
              XSetForeground(pDisplay, gc2 != None ? gc2 : gc, clrFG);
              XSetBackground(pDisplay, gc2 != None ? gc2 : gc, clrBG);
            }

            XDrawLine(pDisplay, pxTemp != None ? pxTemp : wID,
                      gc2 != None ? gc2 : gc,
                      rctCursor.left, rctCursor.top, rctCursor.right, rctCursor.bottom);
          }
        }

        rctChar.top = iY - iAsc;
        rctChar.bottom = iY + iDesc;
        rctChar.left = iX + 1;
        rctChar.right = iX + iFontWidth - 1; // since I'm checking overlap, make it a bit 'skinnier'

        if(WBRectOverlapped(rctChar, pThis->rctHighLight))
        {
          XSetForeground(pDisplay, gc2 != None ? gc2 : gc, clrHFG);
          XSetBackground(pDisplay, gc2 != None ? gc2 : gc, clrHBG);
        }
        else
        {
          XSetForeground(pDisplay, gc2 != None ? gc2 : gc, clrFG);
          XSetBackground(pDisplay, gc2 != None ? gc2 : gc, clrBG);
        }

        // for NOW, draw one character at a time. But make sure it's within
        // the invalid region first...

        geomC.x = iX;
        geomC.y = iY; // TODO:  for single line, move this and the next 2 outside the loop?
        geomC.width = iFontWidth;
        geomC.height = iFontHeight;

        if(i1 < iLen)
        {
          if(WBGeomOverlapped(geomC, geomP)) // only if the character's geometry overlaps the paint geometry
          {
            int iLen;
            const char *p1 = WBGetMBCharPtr(pL, i1, &iLen);

            if(p1 && iLen > 0)
            {
              if(iLen > 1)
              {
                WB_ERROR_PRINT("TEMPORARY:  %s - iLen=%d, %d, %d, p1 = %02xH,%02xH\n", __FUNCTION__,
                               iLen, iX - iXDelta, iY - iYDelta, (unsigned char)p1[0], (unsigned char)p1[1]);
              }

              WB_DRAW_STRING(pDisplay, pxTemp ? pxTemp : wID, fSet,
                             gc2 != None ? gc2 : gc,
                             iX - iXDelta, iY - iYDelta, p1, iLen);
            }
          }
        }
        else if(i1 > pThis->iCol)
        {
          break; // slight optimization
        }
      }

      if(pxTemp != None) // OPTIMIZATION (using pixmap)
      {
        int iX0=0, iY0=0, iW0=iPX, iH0=iPY;

        iX = pThis->rctWinView.left - MIN_BORDER_SPACING;
        iY = pThis->rctWinView.top - MIN_BORDER_SPACING;

        // only copy the invalid area (this should save some time)

        if(geomP.x > iX)
        {
          iX0 = geomP.x - iX;
          iW0 -= iX0;
          iX = geomP.x;
        }

        if(geomP.x + geomP.width < iX + iW0)
        {
          iW0 = geomP.x + geomP.width - iX;
        }

        if(geomP.y > iY)
        {
          iY0 = geomP.y - iY;
          iH0 -= iY0;
          iY = geomP.y;
        }

        if(geomP.y + geomP.height < iY + iH0)
        {
          iH0 = geomP.y + geomP.height - iY;
        }

        if(iH0 > 0 && iW0 > 0)
        {
          XCopyArea(pDisplay, pxTemp, wID, gc, // this time use GC to do the copy
                    iX0, iY0, iW0, iH0, iX, iY);
        }

        XFreePixmap(pDisplay, pxTemp);
      }
    }
    else // MULTI-LINE
    {
      //////////////////////
      // MULTI LINE PAINTING
      //////////////////////



//      POOBAH


      WB_ERROR_PRINT("TEMPORARY:  %s - MULTI-LINE NOT IMPLEMENTED\n", __FUNCTION__);
    }
  }

the_end:

  // mandatory resource free-up goes here, hence the 'goto' label

  if(gc2 != None)
  {
    XFreeGC(pDisplay, gc2);
  }

  if(rFontSet == None) // that is, I created one
  {
    XFreeFontSet(pDisplay, fSet);
  }
}

static void __internal_cursor_blink(struct _text_object_ *pThis, int bHasFocus)
{
  if(WBIsValidTextObject(pThis))
  {
//    WB_RECT rctCursor;

    if(!bHasFocus)
    {
      if(pThis->iBlinkState)
      {
        pThis->iBlinkState = 0; // no cursor

        __internal_invalidate_cursor(pThis, 1);
      }
    }
    else
    {
      pThis->iBlinkState = (pThis->iBlinkState + 1) % 3;

      __internal_invalidate_cursor(pThis, pThis->iBlinkState == 0 || pThis->iBlinkState == 1);
    }
  }
}


// ----------------------------
// MBCS UTF-8 UTILITY FUNCTIONS
// ----------------------------

// see RFC3629 and https://en.wikipedia.org/wiki/UTF-8#Codepage_layout

static int internal_IsMBCharValid(const char *pChar, int *piLen)
{
const unsigned char *p1;
int iRval;


  if((unsigned char)*pChar < 0x80) // normal ASCII (including '0' byte)
  {
    if(piLen)
    {
      if(*pChar)
      {
        *piLen = 1;
      }
      else
      {
        *piLen = 0;
      }
    }

    return 1; // valid char
  }

  p1 = (const unsigned char *)pChar;
  iRval = 0; // initially, call it 'invalid'

  // 80-BF - values 0-3F 'continuation' bytes for mbcs [sequence will not start with this]
  // C0-DF - 2-byte character
  //         (C0=0, C1=40H, C2=80H, up to 7C0H for DF; values C0 and C1 are actually 'not valid' as it's pointless)
  // E0-EF - 3-byte character
  //         (E0 adds 800H; E1 adds 1000H; E2 2000H; etc. up to F000H for EF.  not all E0 sequences are valid)
  // F0-FF - 4+byte character
  //         (F0 is 10000H; F1 40000H; F2 80000H; F3 C0000H; F4 100000H; values F5 and above are 'not valid'
  //          Not all F0's are valid, either)
  //
  // For invalid sequences, this function will attempt to work around it; however RFC3629 requires them to be error conditions
  // to avoid security-related problems caused by invalid UTF8 sequences.

  if(*p1 < 0xc2 || // a continuation character? an 'invalid' sequence?
     *p1 >= 0xf5)  // assume value cannot be > 0xff, right?
  {
    p1++;  // invalid; length is 1 (like ASCII)
  }
  else if(*p1 < 0xe0) // 2-byte sequence
  {
    if((unsigned char)p1[1] >= 0x80 && (unsigned char)p1[1] <= 0xbf) // valid 2-byte sequence
    {
      p1 += 2;
      iRval = 1;
    }
    else
    {
      p1++;  // invalid; length is 1 (like ASCII)
    }
  }
  else if(*p1 < 0xf0) // 3-byte sequence
  {            
    if(p1[1] >= 0x80 && p1[1] <= 0xbf && // valid 3-byte sequence
       p1[2] >= 0x80 && p1[2] <= 0xbf)
    {
      // TODO:  validate E0 sequences

      p1 += 3;
      iRval = 1;
    }
    else // now it gets trickier...
    {
      // by convention, treat it like 8-bit ASCII with a length of 1
      p1++;
    }
  }
  else // if(*p1 < 0xf5)
  {
    if(p1[1] >= 0x80 && p1[1] <= 0xbf && // valid 4-byte sequence
       p1[2] >= 0x80 && p1[2] <= 0xbf &&
       p1[3] >= 0x80 && p1[3] <= 0xbf)
    {
      // TODO:  validate F0 sequences

      p1 += 4;
      iRval = 1;
    }
    else // now it gets trickier...
    {
      // by convention, treat it like 8-bit ASCII with a length of 1
      p1++;
    }
  }

  if(piLen)
  {
    *piLen = (const char *)p1 - pChar;  // this simplified length indicator helps with copy/pasta [if I need it]
  }

#ifndef NO_DEBUG
  if(!iRval || ((const char *)p1 - pChar) > 1)
  {
    int iLen = ((const char *)p1 - pChar);

    WBDebugPrint("TEMPORARY:  %s - return=%d  char=%02xH", __FUNCTION__, iRval, (unsigned char)*pChar);
    while(iLen > 1)
    {
      iLen--;
      pChar++;

      WBDebugPrint(",%02xH", (unsigned char)*pChar);
    }
    WBDebugPrint("\n");
  }
#endif // NO_DEBUG

  return iRval;
}

static int internal_MBstrlen(const char *pString)
{
const char *p1 = pString;
int iLen, iRval;


  iRval = 0;

  while(*p1)
  {
    // step through 1 character at a time until I reach the end of the string, or iCol reaches zero

    if(!internal_IsMBCharValid(p1, &iLen))
    {
      p1++; // treat like 8-bit ASCII if it's an invalid UTF-8 sequence

      // NOTE:  may change or render as EF BF BD i.e. U+FFFD (a diamond with question mark)
    }
    else
    {
      p1 += iLen;
    }

    iRval++; // we only count blue cars (and multi-byte chars as "1")
  }

  return iRval;
}

// return the 'character' index for the 'column' specified by 'iCol' for MBCS

static int internal_MBColIndex(const char *pString, int iCol)
{
const char *p1 = pString;
int iLen;


  while(iCol > 0 && *p1)
  {
    // step through 1 character at a time until I reach the end of the string, or iCol reaches zero

    if(!internal_IsMBCharValid(p1, &iLen))
    {
      p1++; // treat like 8-bit ASCII if it's an invalid UTF-8 sequence

      // NOTE:  may change or render as EF BF BD i.e. U+FFFD (a diamond with question mark)
    }
    else
    {
      p1 += iLen;
    }

    iCol--;
  }

  return (p1 - pString); // NOTE: need to verify length before calling or this could be WRONG
}


char * WBInsertMBChars(char *pString, int iCol, const char *pszMBString, int cbString,
                       int fTab, int fOverwrite, int *piNewCol, char **ppInserted)
{
  if(ppInserted)
  {
    *ppInserted = NULL; // initial value
  }
  
  if(piNewCol)
  {
    *piNewCol = iCol; // initial value
  }


//  POOBAH


  return NULL;
}

char * WBSplitMBLine(char *pString, int iCol)
{
char *p1, *pRval;
int iLen, i1;


  iLen = internal_MBstrlen(pString);

  if(iCol >= iLen) // past end of string?
  {
    pRval = WBCopyString(""); // allocated pointer that's a copy of an empty string - it's what I'll start with
  }
  else
  {
    i1 = internal_MBColIndex(pString, iCol);

    pRval = WBCopyString(pString + i1);

    if(pRval)
    {
      pString[i1] = 0; // terminate it here (my 'split')
    }
  }

  if(pRval) // if I have a valid return, right-trim the original line
  {
    p1 = pString + strlen(pString);

    while(p1 > pString && *(p1 - 1) <= ' ') // right-trim it
    {
      *(--p1) = 0; // right-trim the string - make ALL white space GO AWAY
    }
  }

  return(pRval);
}

char * WBJoinMBLine(char *pString, int iCol, const char *pJoin)
{
int iLen, iLenNew, iJoin;
char *pRval, *p1;


  iLen = internal_MBstrlen(pString);
  if(iLen < iCol)
  {
    iLenNew = iCol;
  }
  else
  {
    iLenNew = iLen;
  }

  iJoin = internal_MBstrlen(pJoin);

  pRval = WBReAlloc(pString, iLenNew + iJoin + 2);
  if(!pRval)
  {
    return NULL;
  }

  p1 = pRval + strlen(pRval); // regardless of actual length, this works  

  while(iLen < iLenNew)
  {
    *(p1++) = ' '; // add white space up to 'iCol'
    iLen++;
  }

  strcpy(p1, pJoin);

  return pRval;
}

int WBDelMBChars(char *pString, int iCol, int nDel, int *piNewCol, char **ppDeleted)
{
int iLen, iIndex, i1, iRval = nDel;
char *pDelChar, *p1;


  if(ppDeleted)
  {
    *ppDeleted = NULL; // initial value
  }
  
  if(piNewCol)
  {
    *piNewCol = iCol; // initial value
  }

  if(!pString || !nDel || !*pString)
  {
    if(piNewCol)
    {
      *piNewCol = iCol; // for now, just do this, even if string is blank
    }

    return nDel; // parameter validation
  }

  iLen = internal_MBstrlen(pString);

  if(iRval > 0)
  {
    if(ppDeleted && iLen > iCol)
    {
      pDelChar = WBAlloc(4 // max size of MB char
                         * (iLen - iCol + 1) // 1 more than # of chars to delete
                         + 1); // additional storage for zero byte

      *ppDeleted = pDelChar; // NOTE:  caller checks for NULL to determine error state

      if(pDelChar)
      {
        *pDelChar = 0; // make sure
      }
    }
    else
    {
      pDelChar = NULL;
    }

    while(iLen > iCol && iRval > 0)
    {
      iIndex = internal_MBColIndex(pString, iCol);

      p1 = pString + iIndex; // always

      if(!*p1)
      {
        break; // I'm at the end of the string (sanity test)
      }

      if(!internal_IsMBCharValid(p1, &i1))
      {
        // invalid character - truncate the line here!

        *p1 = 0;
        iRval = 0;  // assume 'end of line' and terminate deleting

        break;
      }

      if(pDelChar && i1 > 0)
      {
        memcpy(pDelChar, p1, i1);
        pDelChar += i1;

        *pDelChar = 0; // mark the end of the string
      }

      iRval --; // deleting one character (so remove a 'delete')
      iLen--; // update the new length

      // i1 is the length of the next character.  slide 'em down! [this is less efficient, but more 'stable']
      strcpy(p1, p1 + i1); // simplest method
    }
  }
  else
  {
    if(ppDeleted && iCol > 0)
    {
      pDelChar = WBAlloc(4 // max size of MB char
                         * (iCol + 1) // 1 more than # of chars to delete
                         + 1); // additional storage for zero byte

      *ppDeleted = pDelChar; // NOTE:  caller checks for NULL to determine error state

      if(pDelChar)
      {
        *pDelChar = 0; // make sure
      }
    }
    else
    {
      pDelChar = NULL;
    }

    // NOW we do backspacing, which preserves the character at 'iCol'.  this is a little trickier.
    // when we end up at column zero, we return the 'iRval' count.

    while(iCol > 0 && iRval < 0)
    {
      if(iCol <= iLen) // I'm NOT past the end
      {
        iIndex = internal_MBColIndex(pString, iCol - 1); // PREVIOUS column

        p1 = pString + iIndex; // always

        if(!*p1)
        {
          break; // I'm at the end of the string (sanity test, unlikely to happen)
        }

        if(!internal_IsMBCharValid(p1, &i1))
        {
          // invalid character - truncate the line here!

          *p1 = 0;
          iRval = 0; // assume 'end of line' at this point, and terminate deleting

          break;
        }

        if(pDelChar && i1 > 0)
        {
          // insert this character into the beginning of the 'undo' info string
          // there are probably BETTER ways to do this, but this is what I'll do.

          memmove(pDelChar + i1, pDelChar, strlen(pDelChar) + 1); // open up space.  make sure ending zero byte is included.
          memcpy(pDelChar, p1, i1);
        }

        // i1 is the length of the prev character, so slide 'em down! [this is less efficient, but more 'stable']
        strcpy(p1, p1 + i1); // simplest method (I could also get the pointer to the 'iCol'th char, but this is more consistent)
      }
      else
      {
        // since I'm at the end, just delete the last char in the line (effectively) by decrementing the column
        // so nothing else to do here other than the end of the loop
      }

      iCol--;
      iRval++; // because it's NEGATIVE, so we increment it
    }
  }

  // it seems in both cases (above) this section remains exactly the same
  // how amazing that works out!

  if(piNewCol)
  {
    *piNewCol = iCol; // 'iCol' will be the NEW column for the cursor
  }

  return iRval;
}

int WBGetMBLength(const char *pString)
{
  if(!pString)
  {
    return 0;
  }

  return internal_MBstrlen(pString);
}

char * WBGetMBCharPtr(char *pString, int iCol, int *pcbLen)
{
int iIndex;


  if(!pString)
  {
    return NULL;
  }

  iIndex = internal_MBColIndex(pString, iCol);

  if(pString[iIndex])  // it's not a 0-byte
  {
    if(!internal_IsMBCharValid(pString + iIndex, pcbLen))
    {
      return NULL; // character is not valid
    }
  }
  else
  {
    if(pcbLen)
    {
      *pcbLen = 0;
    }

    // TODO:  anything else?
  }

  return pString + iIndex;
}

int WBGetMBColIndex(const char *pString, const char *pChar)
{
const char *p1 = pString;
int iLen, iRval;


  if(pChar <= pString)
  {
    return 0;
  }

  iRval = 0;

  while(*p1 && p1 < pChar)
  {
    // step through 1 character at a time until I reach the end of the string, or iCol reaches zero

    if(!internal_IsMBCharValid(p1, &iLen))
    {
      p1++; // treat like 8-bit ASCII if it's an invalid UTF-8 sequence

      // NOTE:  may change or render as EF BF BD i.e. U+FFFD (a diamond with question mark)
    }
    else
    {
      p1 += iLen;
    }

    iRval++; // we only count blue cars (and multi-byte chars as "1")
  }

  if(p1 != pChar)
  {
    return 0; // this is an error condition
  }

  return iRval; // returns the actual column index for 'pChar' within the string pointed by 'pString'
}


