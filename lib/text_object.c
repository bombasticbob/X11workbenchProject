//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//     _               _               _      _              _              //
//    | |_  ___ __  __| |_       ___  | |__  (_)  ___   ___ | |_     ___    //
//    | __|/ _ \\ \/ /| __|     / _ \ | '_ \ | | / _ \ / __|| __|   / __|   //
//    | |_|  __/ >  < | |_     | (_) || |_) || ||  __/| (__ | |_  _| (__    //
//     \__|\___|/_/\_\ \__|_____\___/ |_.__/_/ | \___| \___| \__|(_)\___|   //
//                        |_____|          |__/                             //
//                                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2019 by Bob Frazier (aka 'Big Bad Bombastic Bob')


  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.
               Any claims to alleged functionality or features should be
               considered 'preliminary', and might not function as advertised.

  MIT-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  MIT-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

/** \file text_object.c
  * \brief Utilities for copying and drawing text, determining text extents, and so on
  *
  * X11 Work Bench Toolkit Toolkit API
*/


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <errno.h>
#include <limits.h>

#include "draw_text.h"
#include "text_object.h"
#include "conf_help.h"


// INTERNAL STRUCTURES

struct __internal_undo_redo_buffer
{
  struct __internal_undo_redo_buffer *pNext; // singly linked list [for now]
  // NOTE:  a background process can trim this to a reasonable size

  // NOTE:  for a simple row/col insert or paste, left=right, top=bottom
  //        for all other operations, the rctSel will apply accordingly
  WB_RECT rctSelOld; // original select rectangle (as applicable)
  WB_RECT rctSelNew; // new select rectangle after the operation

  int iOperation; // see 'enum _undo_operation_' below
  int iSelMode;   // selection mode

  int nOld; // size of 'old' buffer (zero if none)
  int nNew; // size of 'new' buffer (zero if none)

  char aData[2]; // actual data for operation
};

typedef enum _undo_operation_
{
  UNDO_NONE=-1,   /* for initialization purposes only */
  UNDO_SELECT=0,
  UNDO_DELETE=1,
  UNDO_INSERT=2,
  UNDO_REPLACE=3, /* currently not used */
  UNDO_INDENT=4,
  UNDO_LAST=4
} UNDO_OPERATION;


#define SEL_RECT_ALL(X) ((X)->rctSel.left < 0)
#define SEL_RECT_EMPTY(X) (!SEL_RECT_ALL(X) && ((X)->rctSel.left == (X)->rctSel.right && (X)->rctSel.bottom == (X)->rctSel.top))
#define NORMALIZE_SEL_RECT(X) {if(( (X).top > (X).bottom ) || ( (X).top == (X).bottom && (X).left > (X).right) ) \
                               { int i1 = (X).left; (X).left = (X).right; (X).right = i1; \
                                 i1 = (X).top; (X).top = (X).bottom; (X).bottom = i1; }}


#define CURSOR_BLINK_RESET 0 /* shows blinking cursor for max time */
#define CURSOR_BLINK_PERIOD 3
#define CURSOR_BLINK_OFF (CURSOR_BLINK_PERIOD - 1)


// *************************
// LOCAL FUNCTION PROTOTYPES
// *************************

static void __internal_destroy(struct _text_object_ *pThis);
static void __internal_init(struct _text_object_ *pThis);
static void __internal_highlight_colors(struct _text_object_ *pThis, XColor clrHFG, XColor clrHBG);
static char * __internal_get_text(struct _text_object_ *pThis);
static void __internal_set_text(struct _text_object_ *pThis, const char *szText, unsigned long cbLen);
static int __internal_get_rows(const struct _text_object_ *pThis);
static int __internal_get_cols(struct _text_object_ *pThis);
static int __internal_get_filetype(const struct _text_object_ *pThis);
static void __internal_set_filetype(struct _text_object_ *pThis, int iFileType);
static int __internal_get_linefeed(const struct _text_object_ *pThis);
static void __internal_set_linefeed(struct _text_object_ *pThis, int iLineFeed);
static int __internal_get_insmode(const struct _text_object_ *pThis);
static void __internal_set_insmode(struct _text_object_ *pThis, int iInsMode);
static int __internal_get_selmode(const struct _text_object_ *pThis);
static void __internal_set_selmode(struct _text_object_ *pThis, int iSelMode);
static int __internal_get_tab(const struct _text_object_ *pThis);
static void __internal_set_tab(struct _text_object_ *pThis, int iTab);
static int __internal_get_scrollmode(const struct _text_object_ *pThis);
static void __internal_set_scrollmode(struct _text_object_ *pThis, int iScrollMode);
static void __internal_get_select(const struct _text_object_ *pThis, WB_RECT *pRct);
static void __internal_set_select(struct _text_object_ *pThis, const WB_RECT *pRct);
static int __internal_has_select(const struct _text_object_ *pThis);
static char* __internal_get_sel_text(const struct _text_object_ *pThis, const WB_RECT *pRct);
static int __internal_get_row(const struct _text_object_ *pThis);
static void __internal_set_row(struct _text_object_ *pThis, int iRow);
static int __internal_get_col(const struct _text_object_ *pThis);
static void __internal_set_col(struct _text_object_ *pThis, int iCol);
static void __internal_del_select(struct _text_object_ *pThis);
static void __internal_replace_select(struct _text_object_ *pThis, const char *szText, unsigned long cbLen);
static void __internal_del_chars(struct _text_object_ *pThis, int nChar);
static void __internal_ins_chars(struct _text_object_ *pThis, const char *pChar, int nChar);
static void __internal_indent(struct _text_object_ *pThis, int nCol);
static int __internal_can_undo(struct _text_object_ *pThis);
static void __internal_undo(struct _text_object_ *pThis);
static int __internal_can_redo(struct _text_object_ *pThis);
static void __internal_redo(struct _text_object_ *pThis);
static void __internal_get_view(const struct _text_object_ *pThis, WB_RECT *pRct);
static void __internal_set_view_origin(struct _text_object_ *pThis, const WB_POINT *pOrig);
static void __internal_begin_highlight(struct _text_object_ *pThis);
static void __internal_end_highlight(struct _text_object_ *pThis);

static void __internal_mouse_click(struct _text_object_ *pThis, int iMouseXDelta, int iMouseYDelta, int iType, int iACS);
static void __internal_begin_mouse_drag(struct _text_object_ *pThis);
static void __internal_end_mouse_drag(struct _text_object_ *pThis);
static void __internal_cursor_up(struct _text_object_ *pThis);
static void __internal_cursor_down(struct _text_object_ *pThis);
static void __internal_cursor_left(struct _text_object_ *pThis);
static void __internal_cursor_right(struct _text_object_ *pThis);
static void __internal_page_up(struct _text_object_ *pThis);
static void __internal_page_down(struct _text_object_ *pThis);
static void __internal_page_left(struct _text_object_ *pThis);
static void __internal_page_right(struct _text_object_ *pThis);

static void __internal_cursor_home(struct _text_object_ *pThis);
static void __internal_cursor_end(struct _text_object_ *pThis);
static void __internal_cursor_top(struct _text_object_ *pThis);
static void __internal_cursor_bottom(struct _text_object_ *pThis);

static void __internal_scroll_vertical(struct _text_object_ *pThis, int nRows);
static void __internal_scroll_horizontal(struct _text_object_ *pThis, int nCols);

static void __internal_do_expose(struct _text_object_ *pThis, Display *pDisplay, Window wID,
                                 WBGC gc, const WB_GEOM *pPaintGeom, const WB_GEOM *pViewGeom,
                                 WB_FONTC pFont);
static void __internal_cursor_blink(struct _text_object_ *pThis, int bHasFocus);
static int __internal_cursor_show(int iBlinkState);

static void __internal_set_save_point(struct _text_object_ *pThis);
static int __internal_get_modified(struct _text_object_ *pThis);


// *********************************
// LOCALLY DEFINED GLOBAL STRUCTURES
// *********************************

const TEXT_OBJECT_VTABLE WBDefaultTextObjectVTable =
{
  __internal_destroy,
  __internal_init,
  __internal_highlight_colors,
  __internal_get_text,
  __internal_set_text,
  __internal_get_rows,
  __internal_get_cols,
  __internal_get_filetype,
  __internal_set_filetype,
  __internal_get_linefeed,
  __internal_set_linefeed,
  __internal_get_insmode,
  __internal_set_insmode,
  __internal_get_selmode,
  __internal_set_selmode,
  __internal_get_tab,
  __internal_set_tab,
  __internal_get_scrollmode,
  __internal_set_scrollmode,
  __internal_get_select,
  __internal_set_select,
  __internal_has_select,
  __internal_get_sel_text,
  __internal_get_row,
  __internal_set_row,
  __internal_get_col,
  __internal_set_col,
  __internal_del_select,
  __internal_replace_select,
  __internal_del_chars,
  __internal_ins_chars,
  __internal_indent,
  __internal_can_undo,
  __internal_undo,
  __internal_can_redo,
  __internal_redo,
  __internal_get_view,
  __internal_set_view_origin,
  __internal_begin_highlight,
  __internal_end_highlight,
  __internal_mouse_click,
  __internal_begin_mouse_drag,
  __internal_end_mouse_drag,
  __internal_cursor_up,
  __internal_cursor_down,
  __internal_cursor_left,
  __internal_cursor_right,
  __internal_page_up,
  __internal_page_down,
  __internal_page_left,
  __internal_page_right,

  __internal_cursor_home,
  __internal_cursor_end,
  __internal_cursor_top,
  __internal_cursor_bottom,

  __internal_scroll_vertical,
  __internal_scroll_horizontal,

  __internal_do_expose,
  __internal_cursor_blink,

  __internal_set_save_point,
  __internal_get_modified

};



////////////////////////////////////////
// GLOBAL (yet static) INLINE UTILITIES
////////////////////////////////////////

// line endings translated from 'enum' to 'const char *'

static __inline__ const char * __internal_get_line_ending_text(enum _LineFeed_ iIndex)
{
  static const char * const szLineEndings[LineFeed_ENTRYCOUNT] =
  {
#ifdef WIN32
  "\r\n"
#else // POSIX
  "\n",
#endif // WIN32 or POSIX - OS-dependent line endings
  "\n","\r","\r\n","\n\r"
  };

  if((int)iIndex < 0 || (int)iIndex >= LineFeed_ENTRYCOUNT)
  {
    return NULL;  // single-line or invalid
  }

  return szLineEndings[iIndex];
}





// ***********
// TEXT BUFFER
// ***********

// TODO:  an API function for single-line text

#define DEFAULT_TEXT_BUFFER_LINES 16384

TEXT_BUFFER * WBAllocTextBuffer(const char *pBuf, unsigned int cbBufSize)
{
TEXT_BUFFER *pRval;
int nLines = 0;
int cbLen;

  if(pBuf && (cbBufSize || *pBuf))
  {
    nLines = WBStringLineCount(pBuf, cbBufSize);

    WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d allocate for %d lines\n", __FUNCTION__, __LINE__, nLines);
  }

  if(nLines < DEFAULT_TEXT_BUFFER_LINES)
  {
    nLines = DEFAULT_TEXT_BUFFER_LINES;
  }

  cbLen = sizeof(*pRval) + nLines * sizeof(pRval->aLines[0]);
  pRval = WBAlloc(cbLen);

  if(!pRval)
  {
    WB_ERROR_PRINT("ERROR - %s - not enough memory (%ld)\n", __FUNCTION__,
                   (unsigned long)(sizeof(*pRval) + nLines * sizeof(pRval->aLines[0])));
    return NULL;
  }

  memset(pRval, 0, cbLen); // zero out entire structure (always)

  pRval->nArraySize = nLines; // pre-assigned values
//  pRval->nEntries = 0; already zero, comment left for reference

  if(pBuf && (cbBufSize || *pBuf))
  {
    int nL = 0;
    const char *p1;

    if(!cbBufSize)
    {
      cbBufSize = strlen(pBuf);
    }

    do
    {
      int cbLen;
      char *p2, *p3;

      cbLen = cbBufSize; // size before I begin
      p1 = WBStringNextLine(pBuf, &cbBufSize);

      if(p1) // another line remains
      {
        cbLen = p1 - pBuf; // re-calc length based on new pointer
      }

      p2 = WBAlloc(cbLen + 2);

      if(!p2)
      {
        WBFreeTextBuffer(pRval);
        pRval = NULL;
        break;
      }

      if(cbLen) // it's possible it may be zero
      {
        memcpy(p2, pBuf, cbLen); // copy the data
      }

      p3 = p2 + cbLen; // the end of the string
      *p3 = 0; // always zero-byte terminate it first

      while(p3 > p2 && (*(p3 - 1) <= ' ' ||
            *(p3 - 1) == HARD_TAB_CHAR)) // trim ALL trailing white space including CR, LF, tab, space, FF, etc.
      {
        // TODO:  handle <FF> or <VT> differently?
        // TODO:  leave white space to mark 'extent' of line?  naaw, probably not

        *(--p3) = 0; // for now just trim it all (p3 always points past end of string)
      }

      pRval->aLines[nL++] = p2;

//      WB_ERROR_PRINT("TEMPORARY - %s - %4d: %s\n", __FUNCTION__, nL, p2);

      pBuf = p1;

    } while(pBuf && cbBufSize && nL < nLines);

    pRval->nEntries = nL; // NOTE:  on error, this will be needed for cleanup

//    WB_ERROR_PRINT("TEMPORARY - %s - %ld lines\n", __FUNCTION__, pRval->nEntries);

    WBTextBufferRefreshCache(pRval);
  }

//  if(pRval)
//  {
//    int nL;
//
//    WB_ERROR_PRINT("\nTEMPORARY - %s - %ld lines\n", __FUNCTION__, pRval->nEntries);
//
//    for(nL=0; nL < pRval->nEntries; nL++)
//    {
//      WB_ERROR_PRINT("  \"%s\"\n", pRval->aLines[nL]);
//    }
//
//    WB_ERROR_PRINT("END TEMPORARY - %s\n\n", __FUNCTION__);
//  }

//  WB_ERROR_PRINT("TEMPORARY - %s returns %p\n", __FUNCTION__, pRval);

  return pRval;
}

int WBCheckReAllocTextBuffer(TEXT_BUFFER **ppBuf, int nLinesToAdd)
{
TEXT_BUFFER *pBuf;
int nNew;

  if(!ppBuf || !*ppBuf)
  {
    return -1; // error
  }

  // TODO:  parameter validation

  pBuf = *ppBuf;

  nNew = pBuf->nEntries + nLinesToAdd;

  if(nNew > pBuf->nArraySize)
  {
    nNew += DEFAULT_TEXT_BUFFER_LINES;
    nNew -= (nNew % (DEFAULT_TEXT_BUFFER_LINES / 2));

    pBuf = WBReAlloc(pBuf, sizeof(*pBuf) + nNew * sizeof(pBuf->aLines[0]));

    if(!pBuf)
    {
      return -1; // error
    }

    pBuf->nArraySize = nNew;
    *ppBuf = pBuf; // potentially new pointer - probably is, though
  }

  return 0; // no problems
}

void WBFreeTextBuffer(TEXT_BUFFER *pBuf)
{
int i1;

  if(!pBuf)
  {
    return;
  }

  // TODO:  parameter validation

  for(i1=0; i1 < pBuf->nEntries && i1 < pBuf->nArraySize; i1++)
  {
    if(pBuf->aLines[i1])
    {
      WBFree(pBuf->aLines[i1]);
      pBuf->aLines[i1] = NULL;  // by convention
    }
  }

  WBFree(pBuf);
}

int WBTextBufferLineLength(TEXT_BUFFER *pBuf, unsigned long nLine)
{
int i1;

  if(!pBuf || pBuf->nEntries <= nLine) // not enough lines in buffer?
  {
    return 0;
  }

  // TODO:  hashing, sorted, ?

  for(i1=0; i1 < TEXT_BUFFER_LINE_CACHE_SIZE && pBuf->aLineCacheLen[i1]; i1++)
  {
    if(pBuf->aLineCache[i1] == nLine)
    {
      return pBuf->aLineCacheLen[i1];
    }
  }

  return 0;
}

void WBTextBufferLineChange(TEXT_BUFFER *pBuf, unsigned long nLine, int nNewLen)
{
int i1, i2;
unsigned int nNewMax = 0, nNewMinMax = UINT_MAX;


  if(pBuf->nEntries <= 1) // zero or one lines?
  {
    WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - (single line) nLine=%ld, nNewLen = %d\n",
                   __FUNCTION__, __LINE__, nLine, nNewLen);

    WBTextBufferRefreshCache(pBuf); // always do it THIS way

    return;
  }

  if(nLine > pBuf->nEntries) // line number isn't sane?
  {
    return; // sanity check failed (do nothing)
  }

  WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - nLine=%ld, nNewLen = %d\n",
                 __FUNCTION__, __LINE__, nLine, nNewLen);

  // update the line info in my cache.  If this line appears, remove it (always).
  // If I'm deleting the line, subtract one from every line higher than this one.

  i1 = 0;

  while(i1 < TEXT_BUFFER_LINE_CACHE_SIZE && pBuf->aLineCacheLen[i1])
  {
    if(pBuf->aLineCache[i1] == nLine)
    {
      // move everything up, remove the last entry
      for(i2=i1 + 1; i2 < TEXT_BUFFER_LINE_CACHE_SIZE && pBuf->aLineCacheLen[i2]; i2++)
      {
        pBuf->aLineCache[i2 - 1] = pBuf->aLineCache[i2];
        pBuf->aLineCacheLen[i2 - 1] = pBuf->aLineCacheLen[i2];
      }

      // at this point 'i2 - 1' _was_ the last entry.  make sure it has zeros in it.
      i2--;
      if(i2 < TEXT_BUFFER_LINE_CACHE_SIZE)
      {
        pBuf->aLineCache[i2] = 0;
        pBuf->aLineCacheLen[i2] = 0;
      }
    }
    else // if it's a line that follows this one, make sure I decrement the line number if I deleted it
    {
      if(pBuf->aLineCache[i1] > nLine)
      {
        if(nNewLen < 0)             // a line deletion
        {
          pBuf->aLineCache[i1] --;  // line was removed, so new line count must match
        }
      }

      if(nNewMax < pBuf->aLineCacheLen[i1])
      {
        nNewMax = pBuf->aLineCacheLen[i1]; // done this way as sanity check
      }

      if(nNewMinMax > pBuf->aLineCacheLen[i1])
      {
        nNewMinMax = pBuf->aLineCacheLen[i1]; // done this way as sanity check
      }

      i1++;
    }
  }

  // if the cache is NOW empty, re-evaluate it.
  if(!pBuf->aLineCacheLen[0]) // empty
  {
    WB_DEBUG_PRINT(DebugLevel_Verbose, "%s exit (d) after WBTextBufferRefreshCache()\n", __FUNCTION__);

    WBTextBufferRefreshCache(pBuf);
    return;
  }

  // I've re-evaluated the max and min-max from the cache, so use that info

  pBuf->nMaxCol = nNewMax;

  if(nNewMinMax <= nNewMax)  // NOTE: if cache is empty, nNewMinMax will be UINT_MAX
  {
    pBuf->nMinMaxCol = nNewMinMax; // sanity checked value
  }
  else
  {
    pBuf->nMinMaxCol = nNewMax; // don't put insane values in there (just in case)
    // TODO: consider refactoring this code out once the algorithm is proved to work
  }

  if(nNewLen < 0) // a line deletion
  {
    if(!nNewMax) // in case my cache has dwindled to nothing
    {
      WB_DEBUG_PRINT(DebugLevel_Verbose, "%s exit (c) after WBTextBufferRefreshCache()\n", __FUNCTION__);

      WBTextBufferRefreshCache(pBuf); // time to re-evaluate
    }
    else
    {
      WB_DEBUG_PRINT(DebugLevel_Verbose, "%s exit (c)\n", __FUNCTION__);
    }

    return; // I'm done for delete.  The rest is for updates
  }

  // see if the length exceeds any of the maximums, and do an 'insertion sort'
  // into my cache array if it does.  Otherwise I can just leave.

  if(!nNewLen) // don't bother, it has a zero length
  {
    WB_DEBUG_PRINT(DebugLevel_Verbose, "%s exit (f)\n", __FUNCTION__);

    return;  // I'm done - no need to re-insert this line into the cache (yet)
  }

  if(nNewLen >= pBuf->nMaxCol) // bigger than maximum (or equal to it)
  {
    i2 = 0; // my insert point

    pBuf->nMaxCol = nNewLen;  // new 'max'
    if(nNewLen < nNewMinMax) // sanity test for empty cache
    {
      pBuf->nMinMaxCol = nNewLen; // may happen, if new cache is totally empty
    }
  }
  else if(nNewLen >= pBuf->nMinMaxCol) // between min max and max
  {
    // find the place to insert this line into the cache
    i2 = 0; // NOTE:  platform-independent loop structure, probably not necessary, but...
    while(i2 < TEXT_BUFFER_LINE_CACHE_SIZE && pBuf->aLineCacheLen[i2])
    {
      if(pBuf->aLineCacheLen[i2] < nNewLen) // the insert point
      {
        break;
      }

      i2++; // don't forget this or infinite loop will result, heh
    }
  }
  else
  {
    WB_DEBUG_PRINT(DebugLevel_Verbose, "%s exit (a)\n", __FUNCTION__);

    return;  // I'm done - no need to re-insert this line into the cache (yet)
    // NOTE:  re-inserting the line into the cache would require re-doing the
    //        cache information from scratch.  this is an optimization, so I'll
    //        avoid THAT operation until it's truly necessary.
  }

  // at this point, 'i2' is the insertion point for the line length info

  if(i2 < TEXT_BUFFER_LINE_CACHE_SIZE) // sanity check, might happen
  {
    // insert at 'i2'
    for(i1=TEXT_BUFFER_LINE_CACHE_SIZE - 1; i1 > i2; i1--)
    {
      pBuf->aLineCache[i1] = pBuf->aLineCache[i1 - 1];
      pBuf->aLineCacheLen[i1] = pBuf->aLineCacheLen[i1 - 1];
    }

    pBuf->aLineCache[i2] = nLine;
    pBuf->aLineCacheLen[i2] = nNewLen;
  }

  // everything should be ok now, unless I b0rked something

  WB_DEBUG_PRINT(DebugLevel_Verbose, "%s exit (b)\n", __FUNCTION__);
}

void WBTextBufferRefreshCache(TEXT_BUFFER *pBuf)
{
int iLine, i1, i2, i3;
char *p1;

  if(!pBuf)
  {
    return;
  }

  WB_DEBUG_PRINT(DebugLevel_Verbose, "%s\n", __FUNCTION__);

  // zero out the cache arrays
  memset(pBuf->aLineCache, 0, sizeof(pBuf->aLineCache));
  memset(pBuf->aLineCacheLen, 0, sizeof(pBuf->aLineCacheLen));

  pBuf->nMaxCol = pBuf->nMinMaxCol = 0; // initialize to zero

  if(!pBuf->nEntries)
  {
    return;
  }
  else if(pBuf->nEntries == 1)
  {
    if(pBuf->aLines[0])
    {
      pBuf->aLineCacheLen[0] = // refactored, do this assignment here instead
        pBuf->nMaxCol = pBuf->nMinMaxCol = WBGetMBLength(pBuf->aLines[0]); // assign length to 'max' and 'minmax'
//      if(pBuf->nMaxCol) 'refactored out' (left to document process, remove later)
//      {
//        pBuf->aLineCache[0] = 0; this value already assigned by 'memset'
//        pBuf->aLineCacheLen[0] = pBuf->nMaxCol; refactored code does this
//      }
    }

    return;
  }

  // the big loop

  for(iLine=0; iLine < pBuf->nEntries; iLine++)
  {
    // do not consider blank lines or lines with zero length
    p1 = pBuf->aLines[iLine];

    if(!p1)
    {
      continue;
    }

    i1 = WBGetMBLength(p1);

    if(!i1)
    {
      continue;
    }

    if(i1 > pBuf->nMinMaxCol) // assume data is consistent
    {
      // perform an insertion sort into 'aLineCache'

      // step 1:  find the insertion point

      i2 = 0; // NOTE:  platform-independent loop structure, probably not necessary, but...
      while(i2 < TEXT_BUFFER_LINE_CACHE_SIZE && pBuf->aLineCacheLen[i2])
      {
        if(pBuf->aLineCacheLen[i2] < i1) // the insert point
        {
          break;
        }

        i2++; // don't forget this or infinite loop will result, heh
      }

      if(i2 >= TEXT_BUFFER_LINE_CACHE_SIZE) // logic fail, clean it up
      {
        pBuf->nMaxCol = pBuf->aLineCacheLen[0]; // forced re-evaluation
        pBuf->nMinMaxCol = pBuf->aLineCacheLen[TEXT_BUFFER_LINE_CACHE_SIZE - 1];
      }
      else if(i2 == TEXT_BUFFER_LINE_CACHE_SIZE - 1)
      {
        // special case, insert at the end
        pBuf->aLineCache[i2] = iLine;
        pBuf->aLineCacheLen[i2] = i1;

        pBuf->nMinMaxCol = i1;  // the new 'min max'
      }
      else
      {
        // if this is the first line in the cache, update 'nMaxCol'
        if(!i2) // NOTE:  this test is done here 'cause of likely register optimization
        {
          pBuf->nMaxCol = i1;
        }

        i3 = i2 + 1;
        while(i3 < TEXT_BUFFER_LINE_CACHE_SIZE && pBuf->aLineCacheLen[i3])
        {
          i3++; // finding the end
        }

        // move everything down using 'memmove'

        memmove(&(pBuf->aLineCache[i2 + 1]), &(pBuf->aLineCache[i2]),
                (i3 - i2 - 1) * sizeof(pBuf->aLineCache[0]));
        memmove(&(pBuf->aLineCacheLen[i2 + 1]), &(pBuf->aLineCacheLen[i2]),
                (i3 - i2 - 1) * sizeof(pBuf->aLineCacheLen[0]));

        // use the final line's index and re-assign the 'max' and 'min max'
        pBuf->nMinMaxCol = pBuf->aLineCacheLen[i3 - 1];

        // make sure the last element(s) have a zero length (TODO:  optimize?)
        while(i3 < TEXT_BUFFER_LINE_CACHE_SIZE)
        {
          pBuf->aLineCache[i3] = 0; // do this to, just because
          pBuf->aLineCacheLen[i3] = 0;

          i3++;
        }

        // and finally, insert this line's info at position 'i2'

        pBuf->aLineCache[i2] = iLine;
        pBuf->aLineCacheLen[i2] = i1;
      }
    }
  }

  WB_DEBUG_PRINT(DebugLevel_Verbose, "%s exit point\n", __FUNCTION__);
}

// *********************************
// TEXT OBJECT CONSTRUCTION AND APIs
// *********************************

TEXT_OBJECT *WBTextObjectConstructor(unsigned long cbStructSize, const char *szText, unsigned long cbLen, Window wIDOwner)
{
TEXT_OBJECT *pRval;

  pRval = (TEXT_OBJECT *)WBAlloc(sizeof(*pRval));

  if(pRval)
  {
//    pRval->vtable = &WBDefaultTextObjectVTable;
//    pRval->ulTag = TEXT_OBJECT_TAG;
//    pRval->vtable->init(pRval);
//
//    pRval->wIDOwner = wIDOwner;

    WBInitializeInPlaceTextObject(pRval, wIDOwner);

    pRval->pText = WBAllocTextBuffer(szText, cbLen);
  }

  return(pRval);
}

void WBTextObjectDestructor(TEXT_OBJECT *pObj)
{
  if(WBIsValidTextObject(pObj))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pObj iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pObj->iRow, pObj->iCol,
                   pObj->rctSel.left, pObj->rctSel.top, pObj->rctSel.right, pObj->rctSel.bottom);

    pObj->vtable->destroy(pObj);

    WBFree(pObj);
  }
}

int WBTextObjectCalculateLineHeight(int iAscent, int iDescent)  // consistently calculate line height from font ascent/descent
{
int iFontHeight;

  iFontHeight = iAscent + iDescent;

  // adjust font height to include line spacing (I'll use this to position the lines)
  if(iDescent > MIN_LINE_SPACING / 2)
  {
    iFontHeight += iDescent / 2; // line spacing is 1/2 of descent, or MIN_LINE_SPACING
  }
  else
  {
    iFontHeight += MIN_LINE_SPACING;
  }

  return iFontHeight;
}

void WBTextObjectSetColorContextCallback(TEXT_OBJECT *pThis,
                                         unsigned long (*callback)(TEXT_OBJECT *pThis, int nX, int nY),
                                         void *pColorContextPointer)
{
  if(!pThis)
  {
    return;
  }

  pThis->pColorContext = pColorContextPointer;
  pThis->pColorContextCallback = callback;

  if(pThis->pColorContextCallback)
  {
    pThis->pColorContextCallback(pThis, -1, -1); // to refresh it
  }
}




// *****************************
// TEXT OBJECT UTILITY FUNCTIONS
// *****************************

// INTERNAL-ONLY utilities that are NOT part of the vtable

static void __internal_free_undo_redo_buffer(void *pBuffer)
{
  if(pBuffer)
  {
    // TODO:  validate that it's an undo/redo buffer

    struct __internal_undo_redo_buffer *pU = (struct __internal_undo_redo_buffer *)pBuffer;

    do
    {
      struct __internal_undo_redo_buffer *pUsa = pU;

      pU = pU->pNext;
      WBFree(pUsa); // for now just do this

    } while(pU);
  }
}

#define UNDO_LIMIT 256

// NULL 'prctStartSel' or 'prctEndSel' implies 'NONE' selected, i.e. {0,0,0,0}
static void __internal_add_undo(struct _text_object_ *pThis, int iOperation, int iSelMode,
                                int iStartRow, int iStartCol, const WB_RECT *prctStartSel,
                                const char *pStartText, int cbStartText,
                                int iEndRow, int iEndCol, const WB_RECT *prctEndSel,
                                const char *pEndText, int cbEndText)
{
int cbLen, cbLen2, i1;
struct __internal_undo_redo_buffer *pUndo, *pTU, *pTU2;


  if(!WBIsValidTextObject(pThis))
  {
    return;
  }

  WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                 "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                 __FUNCTION__, __LINE__,
                 pThis->iRow, pThis->iCol,
                 pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

  pThis->iBlinkState = CURSOR_BLINK_RESET; // this affects the cursor blink, basically resetting it whenever I edit something

  cbLen = cbLen2 = 0;

  if(pStartText)
  {
    if(cbStartText < 0)
    {
      cbStartText = strlen(pStartText); // TODO:  WBGetMBLength ?
    }

    if(cbStartText > 0)
    {
      cbLen += cbStartText;
    }
  }

  if(pEndText)
  {
    if(cbEndText < 0)
    {
      cbEndText = strlen(pEndText); // TODO:  WBGetMBLength?
    }

    if(cbEndText > 0)
    {
      cbLen2 += cbEndText;
    }
  }

  pUndo = (struct __internal_undo_redo_buffer *)WBAlloc(cbLen + cbLen2 + 4 + sizeof(*pUndo));
  if(!pUndo)
  {
    // TODO:  walk the 'undo' chain and start removing stuff, and retry the alloc

    WB_ERROR_PRINT("ERROR - %s - unable to create undo buffer, errno=%d\n", __FUNCTION__, errno);
    return;
  }

  pUndo->iOperation = iOperation;
  pUndo->iSelMode = iSelMode;

  if(prctStartSel)
  {
    memcpy(&(pUndo->rctSelOld), prctStartSel, sizeof(WB_RECT));
  }
  else
  {
    memset(&(pUndo->rctSelOld), 0, sizeof(WB_RECT));
  }

  if(prctEndSel)
  {
    memcpy(&(pUndo->rctSelNew), prctEndSel, sizeof(WB_RECT));
  }
  else
  {
    memset(&(pUndo->rctSelNew), 0, sizeof(WB_RECT));
  }

  // this code should work on multi-byte characters as well...

  pUndo->nOld = cbLen;
  if(cbLen)
  {
    memcpy(pUndo->aData, pStartText, cbLen);
    pUndo->aData[cbLen++] = 0; // just because
  }

  pUndo->nOld = cbLen;

  if(cbLen2)
  {
    memcpy(pUndo->aData + cbLen, pEndText, cbLen2);
    pUndo->aData[cbLen + cbLen2++] = 0; // just because
  }

  pUndo->nNew = cbLen2;

  // insert undo buffer into the 'chain'

  pTU = pUndo->pNext = (struct __internal_undo_redo_buffer *)(pThis->pUndo);
  pThis->pUndo = pUndo;

  // NOW walk the chain and remove things past a certain point.  For now, UNDO_LIMIT
  // NOTE:  this is a compromise - the alternative is a double-link list and an 'end' pointer
  //        along with a running count of items.  If the number of undo/redo items becomes
  //        VERY large, that might be a better alternative. So for now I use a single-link list.

  if(pTU)
  {
    for(i1=1; i1 < UNDO_LIMIT && pTU->pNext; pTU = pTU->pNext, i1++) { }
    // on a modern CPU, this shouldn't take more than a few microseconds

    if(pTU->pNext) // will only be true if I have too many entries
    {
      // free and unhook the chain
      pTU2 = pTU->pNext;
      pTU->pNext = NULL; // generally safer THIS way

      __internal_free_undo_redo_buffer(pTU2); // NOW free what was once chained from here
    }
  }

  // whenever I add an 'undo' HERE, I screw up the 'redo' so blast it away if it exists
  if(pThis->pRedo)
  {
    pTU = pThis->pRedo;
    pThis->pRedo = NULL;

    __internal_free_undo_redo_buffer(pTU);
  }
}


#if 0 /* not currently in use - uncomment to implement its functionality */
static void __internal_add_redo(struct _text_object_ *pThis, struct __internal_undo_redo_buffer *pUndo)
{
struct __internal_undo_redo_buffer *pRedo;
int cbLen;


  if(!WBIsValidTextObject(pThis))
  {
    return;
  }

  WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                 "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                 __FUNCTION__, __LINE__,
                 pThis->iRow, pThis->iCol,
                 pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

  // convert an 'undo' into a 'redo' and add it to the 'redo' chain
  // essentially 'just a copy'

  cbLen = pUndo->nOld + pUndo->nNew + sizeof(*pUndo);

  pRedo = (struct __internal_undo_redo_buffer *)WBAlloc(cbLen + 2);

  if(!pRedo)
  {
    // TODO:  walk the 'undo' and 'redo' chains and start removing stuff, and retry the alloc

    WB_ERROR_PRINT("ERROR - %s - unable to create redo buffer, errno=%d\n", __FUNCTION__, errno);
    return;
  }

  memcpy(pRedo, pUndo, cbLen);

  // now add it to the redo chain

  pRedo->pNext = (struct __internal_undo_redo_buffer *)(pThis->pRedo);
  pThis->pRedo = pRedo;
}
#endif // 0

#if 0 /* not currently in use - uncomment to implement its functionality */
static void __internal_perform_undo(struct _text_object_ *pThis, struct __internal_undo_redo_buffer *pUndo)
{
struct __internal_undo_redo_buffer *pDo = NULL;
int iOldSel;


  pDo = pDo; // TEMPORARY, warning avoidance

  if(!WBIsValidTextObject(pThis) || !pUndo)
  {
    return;
  }

  WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                 "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                 __FUNCTION__, __LINE__,
                 pThis->iRow, pThis->iCol,
                 pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

  // first, make sure the selection mode is correct

  iOldSel = pThis->iSelMode;
  pThis->iSelMode = pUndo->iSelMode;

  if(pUndo->iOperation == UNDO_SELECT)
  {
  }
  else if(pUndo->iOperation == UNDO_DELETE)
  {
    // perform an insert of 'Old Text' data at the appropriate cursor spot
  }
  else if(pUndo->iOperation == UNDO_INSERT)
  {
    // perform a delete of 'new text' data at the appropriate cursor spot
  }
  else if(pUndo->iOperation == UNDO_REPLACE)
  {
    // replace 'new text' with 'old text' at the appropriate cursor spot
  }
  else if(pUndo->iOperation == UNDO_INDENT)
  {
    // indents a block of text
    // to indent, start col will be 0, end col will be the indent
    // to un-indent, start col will be > 0, end col will be 0
    // The start/end rows define the block of lines to be indented or un-indented

  }

  // re-select the old selection using the old select method


  // restore cursor to appropriate spot


//  // restore the current selection method if restored selection is empty
//  pThis->iSelMode = iOldSel;


  // add a redo buffer that's a copy of the undo operation
  __internal_add_redo(pThis, pUndo);
}
#endif // 0

#if 0 /* not currently in use - uncomment to implement its functionality */
static void __internal_perform_redo(struct _text_object_ *pThis, struct __internal_undo_redo_buffer *pRedo)
{
struct __internal_undo_redo_buffer *pNewUndo;
int iOldSel, cbLen;


  if(!WBIsValidTextObject(pThis) || !pRedo)
  {
    return;
  }

  WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                 "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                 __FUNCTION__, __LINE__,
                 pThis->iRow, pThis->iCol,
                 pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

  cbLen = pRedo->nOld + pRedo->nNew + sizeof(*pRedo);

  // first, make sure the selection mode is correct

  iOldSel = pThis->iSelMode;
  pThis->iSelMode = pRedo->iSelMode;

  if(pRedo->iOperation == UNDO_SELECT)
  {
  }
  else if(pRedo->iOperation == UNDO_DELETE)
  {
    // perform an insert of 'new Text' data at the appropriate cursor spot
  }
  else if(pRedo->iOperation == UNDO_INSERT)
  {
    // perform a delete of 'old text' data at the appropriate cursor spot
  }
  else if(pRedo->iOperation == UNDO_REPLACE)
  {
    // replace 'old text' with 'new text' at the appropriate cursor spot
  }
  else if(pRedo->iOperation == UNDO_INDENT)
  {
    // indents a block of text
    // to indent, start col will be 0, end col will be the indent
    // to un-indent, start col will be > 0, end col will be 0
    // The start/end rows define the block of lines to be indented or un-indented

  }

  // re-select the new selection using the applicable select method


  // restore cursor to appropriate spot


//  // restore the current selection method if restored selection is empty
//  pThis->iSelMode = iOldSel;


  // now I must add the 'redo' operation 'as-is' to the 'undo' chain, but NOT blast away the 'redo' chain
  // I'll make a copy of it first, since the caller will need to manage the undo/redo pointers

  pNewUndo = (struct __internal_undo_redo_buffer *)WBAlloc(cbLen + 2);

  if(!pNewUndo)
  {
    // TODO:  walk the 'undo' and 'redo' chains and start removing stuff, and retry the alloc

    WB_ERROR_PRINT("ERROR - %s - unable to create undo buffer from redo buffer, errno=%d\n", __FUNCTION__, errno);
    return;
  }

  memcpy(pNewUndo, pRedo, cbLen);

  // now add it to the undo chain so I can 'undo the re-do' if I want to

  pNewUndo->pNext = (struct __internal_undo_redo_buffer *)(pThis->pUndo);
  pThis->pUndo = pNewUndo;
}
#endif // 0

// ---------------------------------------------------------------------------
// __internal_get_selected_text - arbitrary text retrieval (internal only)
//                                returns WBAlloc'd string pointer
//
// iRow is the starting row position
// iCol is the starting column position
// iEndRow is the ending row position.  In modes OTHER than 'box mode', this may equal 'iCol'
// iEndCol is the ending column position.  In modes OTHER than 'box mode' this may be LESS than 'iCol'
static char * __internal_get_selected_text(const struct _text_object_ *pThis,
                                           int iRow, int iCol, int iEndRow, int iEndCol)
{
int i1, i2, i3, cb1, cbLF=0;
char *p1, *pRval = NULL;
const char *szLineFeed = NULL;
TEXT_BUFFER *pTB;
int iIsBoxMode, iIsLineMode;


  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    WB_DEBUG_PRINT(DebugLevel_Verbose, "calling %s(%d,%d,%d,%d)\n", __FUNCTION__, iRow, iCol, iEndRow, iEndCol);

    if(!pThis->pText)
    {
      return WBCopyString(""); // return a blank string
    }

    if(iRow < 0)
    {
      iRow = 0;
    }
    if(iCol < 0)
    {
      iCol = 0;
    }
    if(iEndRow < 0)
    {
      iEndRow = INT_MAX;
    }
    if(iEndCol < 0)
    {
      iEndCol = INT_MAX;
    }

    if(iRow == iEndRow)
    {
      iIsBoxMode = iIsLineMode = 0;
    }
    else
    {
      if(pThis->iSelMode == SelectMode_BOX)
      {
        iIsBoxMode = 1;
        iIsLineMode = 0;
      }
      else if(pThis->iSelMode == SelectMode_LINE)
      {
        iIsBoxMode = 0;
        iIsLineMode = 1;
      }
      else // char and default
      {
        iIsBoxMode = 0;
        iIsLineMode = 0;
      }
    }

    if(iRow > iEndRow                           // row exceeds ending row
       || (iRow == iEndRow && iCol >= iEndCol)  // single row with no 'width'
       /* || (box mode && iCol >= iEndCol) */)  // box mode requires iCol < iEndCol
    {
      return WBCopyString(""); // return a blank string
    }

    pTB = (TEXT_BUFFER *)(pThis->pText);

    // NOTE:  when iRow == iEndRow, both box mode and line mode revert to 'stream mode'
    //        and the 'iIsBoxMode' and 'iIsStreamMode' flags will both be zero

    if(iIsBoxMode)
    {
      cb1 = (iEndRow - iRow + 1) * (2 + iEndCol - iCol);
    }
    else
    {
      // FOR NOW just go through the TEXT_BUFFER array, determine the length (later cache it)

      for(i1=iRow, cb1=4; i1 < pTB->nEntries && i1 <= iEndRow; i1++)
      {
        i2 = strlen(pTB->aLines[i1]); // use 'strlen' here, as I want the REAL length

        // last line in 'normal' select mode limits width - 'iEndCol' may be 0
        if(i1 == iEndRow        // i.e. "the last line" in the selected area
           && !iIsLineMode)     // NOT 'line mode' (will be always false for single-row selects)
        {
          if(i2 > iEndCol) // trim the indicated length of the line accordingly
          {
            i2 = WBGetMBCharPtr(pTB->aLines[i1], iEndCol, NULL) - pTB->aLines[i1];
          }
        }

        cb1 += i2 + 2; // do this regardless (it's only to count up max string length)
      }
    }

    // now build the string using the specified line ending and selection mode

    szLineFeed = __internal_get_line_ending_text(pThis->iLineFeed);

    if(!szLineFeed) // single-line
    {
      if(pTB->nEntries > 1)
      {
        szLineFeed = __internal_get_line_ending_text(LineFeed_DEFAULT); // fallback with multi-line data
      }
    }

    if(szLineFeed)
    {
      cbLF = strlen(szLineFeed);
    }

    pRval = WBAlloc(cb1); // allocate the buffer

    if(pRval)
    {
      p1 = pRval;
      for(i1=iRow, p1 = pRval; i1 < pTB->nEntries && i1 <= iEndRow; i1++)
      {
        char *pTheLine = pTB->aLines[i1];

        // TODO:  validate pRval + cb1 > p1 + length of "the stuff that follows"
        i2 = i3 = strlen(pTheLine); // the TRUE 'binary' length

        // TODO: for box mode limit the width on all lines and pad with white space as needed

        // TODO:  handle hard tab translation?  For now "leave it".  Later, I should use a character
        //        that prints as 'white space' but translates as a 'hard tab'.
        //        Example might be 0xA0, i.e. a ' ' + 80H, filling up spaces to the tab point.  Delete
        //        and insert would have to compensate for this.  This function ALSO would have to compensate,
        //        translating tabs to spaces for box mode, and to hard tabs for everything else when 'select all'
        //        is not in effect and tabs are preserved.
        //        For 'select all', hard tabs (when preserved) would be translated into a minimum number of
        //        tab characters; otherwise they would translate into spaces.  Also a hard tab should be displayed
        //        differently (when preserved), such as a greyed |--> or similar.
        //        When 'do not preserve tabs' is set, inserted tabs should automatically become spaces.  ONLY when
        //        the tabs are being preserved should the translation take place.
        //
        // CASE FOR USING 'A0' FOR HARD TAB
        // a) UTF8 does not use it as a marker for multi-byte character data - http://en.wikipedia.org/wiki/UTF-8
        // b) it's basically a ' ' with the high bit set
        // c) it's not used for anything significant in 8-bit ASCII other than "non-breaking space" (i.e. &nbsp;)
        // d) if it's imported, it will translate to actual spaces
        // e) if it's exported by accident, it probably won't matter (other than formatting)
        // f) a definition NOW exists - see HARD_TAB_CHAR (text_object.h)

        // last line in 'normal' select mode limits width - 'iEndCol' may be 0
        if(i1 == iEndRow        // i.e. "the last line" in the selected area
           || iIsBoxMode)       // box mode limits length differently on all lines
        {
          if(iIsBoxMode)
          {
            if(i2 >= iEndCol)
            {
              i2 = WBGetMBCharPtr(pTheLine, iEndCol, NULL) - WBGetMBCharPtr(pTheLine, iCol, NULL);
            }
            else if(iCol > 0)
            {
              i2 -= WBGetMBCharPtr(pTheLine, iCol, NULL) - pTheLine;
            }
          }
          else if(!iIsLineMode)
          {
            if(i2 >= iEndCol)
            {
              i2 = WBGetMBCharPtr(pTheLine, iEndCol, NULL) - pTheLine;
            }
          }
          else if(iEndCol == 0)
          {
            i2 = 0; // typically 'last row'
          }
        }

        // check for stream mode on the first line, and start with 'iCol'
        if(!iIsBoxMode && !iIsLineMode && i1 == iRow) // on first line, start at 'iCol'
        {
          i2 -= WBGetMBCharPtr(pTheLine, iCol, NULL) - pTheLine; // subtract starting column offset for total length
        }

        if(i2 > 0) // might be < 0 depending
        {
          if(iIsLineMode || i1 > iCol) // multi-line select NOT on first line, or line mode
          {
            memcpy(p1, pTheLine, i2);
          }
          else
          {
            memcpy(p1, WBGetMBCharPtr(pTheLine, iCol, NULL), i2);
          }
          p1 += i2;
        }
        else
        {
          i2 = 0; // for box mode, mostly
        }

        if(iIsBoxMode) // iRow < iEndRow also
        {
          // for box mode, pad any 'remaining' length with space
          i2 = iEndCol - iCol // the ending width we're SUPPOSED to have
             - WBGetMBLength(WBGetMBCharPtr(pTheLine, iCol, NULL)); // the actual length in 'columns' starting at 'iCol'

          // I need THAT MANY white spaces for box mode
          if(i2 > 0)
          {
            memset(p1, ' ', i2);
            p1 += i2; // now the width should be exactly 'iEndCol - iCol'
          }
        }

        // don't add final line feed in 'stream' mode or in 'line' mode if it ends on column 0

        if(iIsBoxMode ||                    // box mode ALWAYS
           (iIsLineMode && iEndCol > 0) ||  // I'm in line mode and NOT ending on column 0 on the last line
           i1 < iEndRow)                    // not the last line
        {
          if(szLineFeed)
          {
            memcpy(p1, szLineFeed, cbLF);
            p1 += cbLF;
          }
        }
      }

      *p1 = 0;
    }
  }

  return pRval;
}

static void __internal_invalidate_cursor(const struct _text_object_ *pThis, int bPaintFlag)
{
WB_RECT rctCursor;

  if(WBIsValidTextObject(pThis) && pThis->wIDOwner != None)
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    rctCursor.left = pThis->iCursorX - 1;
    rctCursor.top = pThis->iCursorY - 1;
    rctCursor.bottom = rctCursor.top + pThis->iCursorHeight + 2;

    if(pThis->iInsMode == InsertMode_OVERWRITE)
    {
      rctCursor.right = rctCursor.left + pThis->iFontWidth;
    }
    else
    {
      rctCursor.right = rctCursor.left + 3;
    }

    WBInvalidateRect(pThis->wIDOwner, &rctCursor, bPaintFlag);
  }
}

static void __internal_invalidate_rect(struct _text_object_ *pThis, WB_RECT *pRect, int bPaintFlag)
{
WB_RECT rctInvalid;

  if(WBIsValidTextObject(pThis) && pThis->wIDOwner != None)
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    if(pThis->rctView.right <= pThis->rctView.left || pThis->rctView.bottom <= pThis->rctView.top ||
       pThis->rctWinView.right <= pThis->rctWinView.left || pThis->rctWinView.bottom <= pThis->rctWinView.top ||
       memcmp(&pThis->rctView, &pThis->rctViewOld, sizeof(pThis->rctView)) ||
       memcmp(&pThis->rctWinView, &pThis->rctWinViewOld, sizeof(pThis->rctWinView)))
    {
      XClientMessageEvent evt;

      bzero(&evt, sizeof(evt));
      evt.type = ClientMessage;
      evt.display = WBGetWindowDisplay(pThis->wIDOwner);
      evt.window = pThis->wIDOwner;
      evt.message_type = aRECALC_LAYOUT;
      evt.format = 32;

      WBPostPriorityEvent(pThis->wIDOwner, (XEvent *)&evt); // async (for now)

      memcpy(&pThis->rctViewOld, &pThis->rctView, sizeof(pThis->rctViewOld));
      memcpy(&pThis->rctWinViewOld, &pThis->rctWinView, sizeof(pThis->rctWinViewOld));

      WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_EditWindow | DebugSubSystem_Expose,
                     "%s,%d - force recalc layout, window %u (%08xH)\n",
                     __FUNCTION__, __LINE__, (int)pThis->wIDOwner, (int)pThis->wIDOwner);
    }

    if(!pRect)
    {
      WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_EditWindow | DebugSubSystem_Expose,
                     "%s - invalidate entire window %u (%08xH)\n",
                     __FUNCTION__, (int)pThis->wIDOwner, (int)pThis->wIDOwner);

      WBInvalidateRect(pThis->wIDOwner, NULL, bPaintFlag);
      return;
    }

    memcpy(&rctInvalid, pRect, sizeof(*pRect));

    if(pThis->rctWinView.left - MIN_BORDER_SPACING > rctInvalid.left)
    {
      rctInvalid.left = pThis->rctWinView.left - MIN_BORDER_SPACING;
    }
    if(pThis->rctWinView.right + MIN_BORDER_SPACING < rctInvalid.right)
    {
      rctInvalid.right = pThis->rctWinView.right + MIN_BORDER_SPACING;
    }
    if(pThis->rctWinView.top - MIN_BORDER_SPACING > rctInvalid.top)
    {
      rctInvalid.top = pThis->rctWinView.top - MIN_BORDER_SPACING;
    }
    if(pThis->rctWinView.bottom + MIN_BORDER_SPACING < rctInvalid.bottom)
    {
      rctInvalid.bottom = pThis->rctWinView.bottom + MIN_BORDER_SPACING;
    }

    WBInvalidateRect(pThis->wIDOwner, &rctInvalid, bPaintFlag);

    WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - invalidate %d,%d,%d,%d for %u (%08xH)\n",
                   __FUNCTION__, __LINE__,
                   rctInvalid.left, rctInvalid.top, rctInvalid.right, rctInvalid.bottom,
                   (int)pThis->wIDOwner, (int)pThis->wIDOwner);

  }
//  else
//  {
//    if(!WBIsValidTextObject(pThis))
//    {
//      WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - invalid text object\n", __FUNCTION__, __LINE__);
//    }
//    else
//    {
//      WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - owner window ID is 'None'\n", __FUNCTION__, __LINE__);
//    }
//  }
}

// NOTE:  iStartRow and iStartCol may be 0 but not negative
//        iEndRow and iEndCol can be negative to indicate "all"
static void __internal_calc_rect(const struct _text_object_ *pThis, WB_RECT *pRect,
                                 int iStartRow, int iStartCol, int iEndRow, int iEndCol)
{
int iFontHeight;
TEXT_BUFFER *pBuf;

  if(!pRect || !WBIsValidTextObject(pThis))
  {
    if(pRect)
    {
      memset(pRect, 0, sizeof(*pRect));
    }

    return;
  }

  WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                 "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                 __FUNCTION__, __LINE__,
                 pThis->iRow, pThis->iCol,
                 pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

  pBuf = (TEXT_BUFFER *)(pThis->pText); // might be NULL, must check before use

  if(iEndRow < 0)
  {
    if(pBuf && pThis->iLineFeed != LineFeed_NONE)
    {
      iEndRow = pBuf->nEntries;
    }
    else
    {
      iEndRow = 0;
    }
  }

  // examine the viewpoint rect, font height, and other info

  iFontHeight = pThis->iAsc + pThis->iDesc;

  if(pThis->iLineFeed == LineFeed_NONE) // i.e. SINGLE LINE (ignore row)
  {
    // top of line will always be centered

    pRect->top = pThis->rctWinView.top
               + (pThis->rctWinView.bottom - pThis->rctWinView.top
                  - pThis->iAsc - pThis->iDesc)
               / 2;

    pRect->bottom = pRect->top + iFontHeight; // always

    pRect->left = pThis->rctWinView.left
                + pThis->iFontWidth * (iStartCol - pThis->rctView.left); // can be negative

    if(iEndCol < 0)
    {
      pRect->right = INT_MAX;
    }
    else
    {
      pRect->right = pThis->iFontWidth * (iEndCol - iStartCol + 1);
    }
  }
  else
  {
//    pThis->rctWinView.top;  what did I intend to do here???

    if(iStartRow == iEndRow) // single row
    {
      pRect->left = pThis->rctWinView.left
                  + pThis->iFontWidth * (iStartCol - pThis->rctView.left); // can be negative

      if(iEndCol < 0)
      {
        pRect->right = INT_MAX;
      }
      else
      {
        pRect->right = pThis->iFontWidth * (iEndCol - iStartCol + 1);
      }

      pRect->top = pThis->rctWinView.top; // already calculated from earlier
      pRect->bottom = pRect->top + iFontHeight; // always
    }
    else // multiple rows implies including the entire line unless ending column is 0 [in which case last line is excluded]
    {
      // ignore columns, use the entire viewport width
      pRect->left = pThis->rctWinView.left;
      pRect->right = INT_MAX; //pThis->rctWinView.right;

      iFontHeight = WBTextObjectCalculateLineHeight(pThis->iAsc, pThis->iDesc); // height PLUS inter-line spacing

      pRect->top = pThis->rctWinView.top
                 + iFontHeight * (iStartRow - pThis->rctView.top);

      if(iEndCol > 0)
      {
        pRect->bottom = pThis->rctWinView.top
                      + iFontHeight * (iEndRow + 1 - pThis->rctView.top);
      }
      else // nothing selected on last row
      {
        pRect->bottom = pThis->rctWinView.top
                       + iFontHeight * (iEndRow - pThis->rctView.top);
      }

      WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - merged rect %d,%d,%d,%d\n",
                     __FUNCTION__, __LINE__,
                     pRect->left, pRect->top, pRect->right, pRect->bottom);
    }
  }
}

static void __internal_merge_rect(const struct _text_object_ *pThis, WB_RECT *pRect,
                                  int iStartRow, int iStartCol, int iEndRow, int iEndCol)
{
WB_RECT rctMerge;

  if(!pRect || !WBIsValidTextObject(pThis))
  {
    if(pRect)
    {
      memset(pRect, 0, sizeof(*pRect));
    }

    return;
  }

  WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                 "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                 __FUNCTION__, __LINE__,
                 pThis->iRow, pThis->iCol,
                 pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

  __internal_calc_rect(pThis, &rctMerge, iStartRow, iStartCol, iEndRow, iEndCol);

  if(rctMerge.left < pRect->left)
  {
    pRect->left = rctMerge.left;
  }
  if(rctMerge.top < pRect->top)
  {
    pRect->top = rctMerge.top;
  }
  if(rctMerge.right > pRect->right)
  {
    pRect->right = rctMerge.right;
  }
  if(rctMerge.bottom > pRect->bottom)
  {
    rctMerge.bottom = pRect->bottom;
  }
}


// ****************************
// TEXT OBJECT VTABLE FUNCTIONS
// ****************************

static void __internal_destroy(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    // TODO:  additional validation

    if(pThis->pText)
    {
      // TODO:  validate pointer
      WBFreeTextBuffer((TEXT_BUFFER *)pThis->pText);
      pThis->pText = NULL;
    }

    // now for the undo/redo buffers

    __internal_free_undo_redo_buffer(pThis->pUndo);
    pThis->pUndo = NULL;
    __internal_free_undo_redo_buffer(pThis->pRedo);
    pThis->pRedo = NULL;
  }
}

static void __internal_init(struct _text_object_ *pThis)
{
  pThis->ulTag = TEXT_OBJECT_TAG;
  pThis->wIDOwner = None;

  bzero(&pThis->rctSel, sizeof(pThis->rctSel));
  bzero(&pThis->rctHighLight, sizeof(pThis->rctHighLight));

  pThis->iFileType = 0;   // plain text
  pThis->iLineFeed = LineFeed_DEFAULT;
  pThis->iInsMode = 1;    // insert
  pThis->iSelMode = 0;    // normal
  pThis->iScrollMode = 0; // normal
  pThis->iRow = 0;
  pThis->iCol = 0;
  pThis->iPos = 0; // reserved
  bzero(&pThis->rctView, sizeof(pThis->rctView));
  bzero(&pThis->rctWinView, sizeof(pThis->rctWinView));
  bzero(&pThis->rctViewOld, sizeof(pThis->rctViewOld));
  bzero(&pThis->rctWinViewOld, sizeof(pThis->rctWinViewOld));
  pThis->pText = NULL;
  pThis->pUndo = NULL;
  pThis->pRedo = NULL;

  // get initial default highlight colors

  {
    char szHFG[16], szHBG[16];
    Colormap colormap = DefaultColormap(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));

//#define LOAD_COLOR(X,Y,Z) \
//    if(CHGetResourceString(WBGetDefaultDisplay(), X, Y, sizeof(Y)) <= 0) \
//    { WB_WARN_PRINT("%s - WARNING:  can't find color %s, using default value %s\n", \
//                    __FUNCTION__, X, Z); strcpy(Y,Z); }
//
//    LOAD_COLOR("selected_bg_color", szHBG, "#0040FF"); // a slightly greenish blue for the 'selected' BG color
//    LOAD_COLOR("selected_fg_color", szHFG, "white");   // white FG when selected
//
//#undef LOAD_COLOR

#define COPY_COLOR_NAME(X,Y,Z) {const char *pX = X(WBGetDefaultDisplay()); if(pX) strncpy(Y,pX,sizeof(Y)); else strncpy(Y,Z,sizeof(Y));}
    COPY_COLOR_NAME(CHGetHighlightForegroundColor,szHFG,"#ffffff");
    COPY_COLOR_NAME(CHGetHighlightBackgroundColor,szHBG,"#0040FF");

    XParseColor(WBGetDefaultDisplay(), colormap, szHFG, &(pThis->clrHFG));
    XAllocColor(WBGetDefaultDisplay(), colormap, &(pThis->clrHFG)); // TODO:  calculate missing pieces myself?
    XParseColor(WBGetDefaultDisplay(), colormap, szHBG, &(pThis->clrHBG));
    XAllocColor(WBGetDefaultDisplay(), colormap, &(pThis->clrHBG)); // TODO:  calculate missing pieces myself?
  }

  // TODO:  do I re-initialize the owner-maintained values?  for now, NO!

  if(pThis->pColorContextCallback)
  {
    pThis->pColorContextCallback(pThis, -1, -1); // to refresh it (or in this case, erase it)
  }
}

static void __internal_highlight_colors(struct _text_object_ *pThis, XColor clrHFG, XColor clrHBG)
{
  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pThis->clrHFG = clrHFG;
    pThis->clrHBG = clrHBG;
  }
}

static char * __internal_get_text(struct _text_object_ *pThis)
{
  return __internal_get_selected_text(pThis, -1, -1, -1, -1);
}

static void __internal_set_text(struct _text_object_ *pThis, const char *szText, unsigned long cbLen)
{
TEXT_BUFFER *pTemp;

  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    // for now, allocate a NEW text buffer and replace the old one with it

    pTemp = WBAllocTextBuffer(szText, cbLen);

    if(pTemp)
    {
      if(pThis->pText)
      {
        WBFreeTextBuffer(pThis->pText);
      }

      pThis->pText = pTemp; // and I'm spent

      if(pThis->pColorContextCallback)
      {
        pThis->pColorContextCallback(pThis, -1, -1); // to refresh it
      }
    }
    else
    {
      WB_ERROR_PRINT("TEXT OBJECT:  %s - not enough memory for TEXT BUFFER errno=%d (no change)\n", __FUNCTION__, errno);
    }
  }
  else
  {
    WB_ERROR_PRINT("ERROR - %s - NOT a valid TEXT_OBJECT - %p\n", __FUNCTION__, pThis);
  }

  if(pThis->pText)
  {
    WBTextBufferRefreshCache(pThis->pText);
  }
}

static int __internal_get_rows(const struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;

  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(pBuf && pBuf->nEntries > 0) // only if NOT empty
    {
      if(pThis->iLineFeed == LineFeed_NONE ||
         !pBuf->aLines[0] || !*(pBuf->aLines[0])) // strlen(pBuf->aLines[0])) // "blank line"
      {
        return 1;  // for multiline, even a blank line counts as '1'
      }

      return pBuf->nEntries + 1; // include the last line (a blank one) in the line count
    }
  }

  return 0; // assume blank
}
static int __internal_get_cols(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;
int i1;

  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(pBuf)
    {
      if(pBuf->nMinMaxCol > pBuf->nMaxCol || !pBuf->nMaxCol || !pBuf->nMinMaxCol)
      {
        // cache data not valid, so re-evaluate
        WBTextBufferRefreshCache(pBuf); // re-calculate
      }

      if(pBuf->nMaxCol)
      {
        if(pBuf->nMaxCol < pThis->iCol) // is my current column past the 'max' column?
        {
          i1 = pThis->iCol + DEFAULT_TAB_WIDTH; // use my current column position
        }
        else
        {
          i1 = pBuf->nMaxCol + DEFAULT_TAB_WIDTH; // use the 'max' column position
        }

        return i1 - (i1 % DEFAULT_TAB_WIDTH); // rounded off to 'DEFAULT_TAB_WIDTH'
        // so if DEFAULT_TAB_WIDTH is 8, then 1 becomes 8, 8 becomes 16, etc.
      }
    }
    else if(pThis->iCol > 0) // allow for 'scrolling without any actual data yet'
    {
      i1 = pThis->iCol + DEFAULT_TAB_WIDTH; // use my current column position
      return i1 - (i1 % DEFAULT_TAB_WIDTH); // rounded off to 'DEFAULT_TAB_WIDTH'
    }

    // all other conditions fall through and return 0
  }

  return 0; // assume blank
}

static int __internal_get_filetype(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iFileType;
  }
  return 0; // for now
}
static void __internal_set_filetype(struct _text_object_ *pThis, int iFileType)
{
  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pThis->iFileType = iFileType;

    if(pThis->pColorContextCallback)
    {
      pThis->pColorContextCallback(pThis, -1, -1); // to refresh it
    }
  }
}
static int __internal_get_linefeed(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return (int) pThis->iLineFeed;
  }
  return 0; // for now
}
static void __internal_set_linefeed(struct _text_object_ *pThis, int iLineFeed)
{
  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pThis->iLineFeed = (enum _LineFeed_)iLineFeed;
  }
}
static int __internal_get_insmode(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iInsMode;
  }
  return 0; // for now
}
static void __internal_set_insmode(struct _text_object_ *pThis, int iInsMode)
{
  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pThis->iInsMode = iInsMode;

    pThis->iBlinkState = CURSOR_BLINK_RESET; // this affects the cursor blink, basically resetting it whenever I edit something

    __internal_invalidate_cursor(pThis, 1);  // invalidate the cursor immediately
  }
}
static int __internal_get_selmode(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iSelMode;
  }
  return 0; // for now
}
static void __internal_set_selmode(struct _text_object_ *pThis, int iSelMode)
{
  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pThis->iSelMode = iSelMode;
  }
}
static int __internal_get_tab(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iTab;
  }

  return 0; // for now
}
static void __internal_set_tab(struct _text_object_ *pThis, int iTab)
{
  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pThis->iTab = iTab;
  }
}
static int __internal_get_scrollmode(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iScrollMode;
  }
  return 0; // for now
}
static void __internal_set_scrollmode(struct _text_object_ *pThis, int iScrollMode)
{
  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pThis->iScrollMode = iScrollMode;
  }
}
static void __internal_get_select(const struct _text_object_ *pThis, WB_RECT *pRct)
{
  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    if(pRct)
    {
      if(SEL_RECT_ALL(pThis))
      {
        pRct->left = -1;   // 'normalize' 'select all' to return {-1,-1,-1,-1}
        pRct->right = -1;
        pRct->top = -1;
        pRct->bottom = -1;
      }
      else
      {
        memcpy(pRct, &(pThis->rctSel), sizeof(*pRct));

        if(!SEL_RECT_EMPTY(pThis))   // if not empty
        {
          NORMALIZE_SEL_RECT(*pRct); // normalize the results
        }
      }
    }
  }
}
static void __internal_set_select(struct _text_object_ *pThis, const WB_RECT *pRct)
{
  // setting NULL for the selection rectangle selects 'none'

  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    if(!pRct)
    {
      pThis->rctSel.left = pThis->rctSel.top = pThis->rctSel.right = pThis->rctSel.bottom
       = 0; // select NONE
    }
    else
    {
      memcpy(&(pThis->rctSel), pRct, sizeof(*pRct));
    }
  }
}
static int __internal_has_select(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return !SEL_RECT_EMPTY(pThis);
  }
  return 0;
}
static char* __internal_get_sel_text(const struct _text_object_ *pThis, const WB_RECT *pRct)
{
WB_RECT rctSel;

  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    if(pRct)
    {
      if(pRct->left == pRct->right && pRct->top == pRct->bottom)
      {
        return NULL; // empty
      }
      else if(pRct->left < 0) // a flag for 'select all'
      {
        return __internal_get_selected_text(pThis, -1, -1, -1, -1);
      }

      memcpy(&rctSel, pRct, sizeof(rctSel));
    }
    else
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        return NULL;
      }
      else if(SEL_RECT_ALL(pThis))
      {
        return __internal_get_selected_text(pThis, -1, -1, -1, -1);
      }

      memcpy(&rctSel, &(pThis->rctSel), sizeof(rctSel));
    }

    NORMALIZE_SEL_RECT(rctSel);

    return __internal_get_selected_text(pThis, rctSel.top, rctSel.left,
                                        rctSel.bottom, rctSel.right);
  }
  return NULL; // for now
}
static int __internal_get_row(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iRow;
  }
  return 0; // for now
}
static void __internal_set_row(struct _text_object_ *pThis, int iRow)
{
  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    if(iRow < 0 || !pThis->pText)
    {
      iRow = 0;
    }
    else if(iRow > ((TEXT_BUFFER *)pThis->pText)->nEntries)
    {
      iRow = ((TEXT_BUFFER *)pThis->pText)->nEntries;
    }

    pThis->iRow = iRow;
  }
}
static int __internal_get_col(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iCol;
  }
  return 0; // for now
}
static void __internal_set_col(struct _text_object_ *pThis, int iCol)
{
int iAutoScrollWidth = AUTO_HSCROLL_SIZE;


  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pThis->iCol = iCol; // for now, assign "as-is"

    // auto-scroll viewport for single-line only

    if(pThis->iLineFeed == LineFeed_NONE && // single-line, do auto-scrolling
       pThis->rctView.right > pThis->rctView.left) // in case the view area is empty
    {
      while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
      {
        iAutoScrollWidth >>= 1;
      }

      // scroll left/right to expose the cursor

      while(pThis->rctView.left > pThis->iCol)
      {
        pThis->rctView.left -= iAutoScrollWidth;
        pThis->rctView.right -= iAutoScrollWidth;
      }
      while(pThis->rctView.right <= pThis->iCol)
      {
        pThis->rctView.left += iAutoScrollWidth;
        pThis->rctView.right += iAutoScrollWidth;
      }
    }

    if(pThis->pText &&
       WBTextBufferLineLength(pThis->pText, pThis->iRow) < iCol)
    {
      WBTextBufferLineChange(pThis->pText, pThis->iRow, iCol);
//      WBTextBufferRefreshCache(pThis->pText);
    }
  }
}
static void __internal_del_select(struct _text_object_ *pThis)
{
char *pTemp, *pL;
int iSelAll, iLen, i1, i2;
TEXT_BUFFER *pBuf;
WB_RECT rctSel;


  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    __internal_invalidate_cursor(pThis, 0);
    pThis->iBlinkState = CURSOR_BLINK_RESET; // this affects the cursor blink, basically resetting it whenever I edit something

    iSelAll = SEL_RECT_ALL(pThis); // identifies "select all"

    if(!iSelAll && SEL_RECT_EMPTY(pThis))
    {
      WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject, "%s line %d - empty selection\n", __FUNCTION__, __LINE__);

      // no selection, do nothing
      return;
    }

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf || (pThis->rctSel.top >= pBuf->nEntries && pThis->rctSel.bottom >= pBuf->nEntries))
    {
      WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject,
                     "%s line %d: no selection to delete\n", __FUNCTION__, __LINE__);

      return;  // NO buffer, or select area is outside of buffer area
    }

    // for the undo buffer I will need a copy of the original text.
    // this function only returns NULL on error

    memcpy(&rctSel, &(pThis->rctSel), sizeof(rctSel));

    if(iSelAll)
    {
      pTemp = __internal_get_selected_text(pThis, -1, -1, -1, -1);
    }
    else
    {
      NORMALIZE_SEL_RECT(rctSel);

      pTemp = __internal_get_selected_text(pThis, rctSel.top, rctSel.left,
                                           rctSel.bottom, rctSel.right);
    }

    if(iSelAll)
    {
      WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject,
                     "%s line %d: delete 'select all'\n", __FUNCTION__, __LINE__);
      // delete all
      if(pThis->pText)
      {
        WBFreeTextBuffer(pThis->pText);
        pThis->pText = NULL;
      }

      if(pTemp)
      {
        __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                            0, 0, &(pThis->rctSel), pTemp, -1,
                            pBuf->nEntries, 0, NULL, NULL, 0);
      }
    }
    else if(pThis->iLineFeed == LineFeed_NONE ||
            rctSel.top == rctSel.bottom) // single-line selection (all methods behave the same)
    {
      // delete from rctSel.left to rctSel.right (exclusive)
      WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject,
                     "%s line %d: delete single line, %d to %d (top=%d, bottom=%d)\n",
                      __FUNCTION__, __LINE__,
                      rctSel.left, rctSel.right, rctSel.top, rctSel.bottom);

      pL = pBuf->aLines[rctSel.top];

      if(pL)
      {
        iLen = WBGetMBLength(pL);
        if(iLen >= rctSel.left)
        {
          if(iLen <= rctSel.right)
          {
            char *pTempL = WBGetMBCharPtr(pL, rctSel.left, NULL);
            if(pTempL)
            {
              *pTempL = 0; // just truncate the string
            }
          }
          else
          {
            char *pTempL = WBGetMBCharPtr(pL, rctSel.left, NULL);
            char *pTempR = WBGetMBCharPtr(pL, rctSel.right, NULL);

            if(pTempL && pTempR)
            {
              strcpy(pTempL, pTempR); // thereby squeezing the string together and deleting the selection
            }
          }
        }
      }

      if(pTemp)
      {
        __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                            rctSel.top, rctSel.left, &(pThis->rctSel),
                            pTemp, -1,
                            rctSel.bottom, rctSel.right, NULL, NULL, 0);
      }

      if(pThis->iLineFeed == LineFeed_NONE && // special case, auto-hscroll
         pThis->rctView.right > pThis->rctView.left)
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
        {
          iAutoScrollWidth >>= 1;
        }

        // scroll left/right to expose the cursor

        while(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.left -= iAutoScrollWidth;
          pThis->rctView.right -= iAutoScrollWidth;
        }
        while(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += iAutoScrollWidth;
          pThis->rctView.right += iAutoScrollWidth;
        }
      }

      WBTextBufferRefreshCache(pThis->pText);
    }
    else if(pThis->iSelMode == SelectMode_BOX) // multiline delete BOX mode
    {
      WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject,
                     "%s line %d: BOX MODE delete multiline, %d,%d to %d,%d\n",
                      __FUNCTION__, __LINE__,
                      rctSel.left, rctSel.top,
                      rctSel.right, rctSel.right);
    }
    else if(pThis->iSelMode == SelectMode_LINE) // multiline delete LINE mode
    {
      WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject,
                     "%s line %d: LINE MODE delete multiline, %d,%d to %d,%d\n",
                      __FUNCTION__, __LINE__,
                      rctSel.left, rctSel.top,
                      rctSel.right, rctSel.right);
    }
    else // default 'char'
    {
      WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject,
                     "%s line %d: delete multiline, %d,%d to %d,%d\n",
                      __FUNCTION__, __LINE__,
                      rctSel.left, rctSel.top,
                      rctSel.right, rctSel.right);

      if(pBuf->aLines[rctSel.top] && rctSel.left > 0)
      {
        pL = pBuf->aLines[rctSel.top];

        if(rctSel.right > 0)
        {
          char *pJoin, *pNew;

          pJoin = WBGetMBCharPtr(pBuf->aLines[rctSel.bottom], rctSel.right, NULL);
          pNew = WBJoinMBLine(pL, rctSel.left, pJoin);

          if(!pNew) // error
          {
            WB_ERROR_PRINT("ERROR - %s - memory allocation error, errno=%d\n", __FUNCTION__, errno);
            return; // no undo buffer when there's a memory error
          }
          pBuf->aLines[rctSel.top] = pNew;
          if(pL) // just in case
          {
            WBFree(pL);
          }

          i2 = rctSel.bottom + 1; // start copying the NEXT line
        }
        else
        {
          char *pTemp = WBGetMBCharPtr(pL, rctSel.left, NULL);
          if(pTemp) // just in case
          {
            *pTemp = 0; // truncate line at this position
          }

          i2 = rctSel.bottom; // start copying THIS line (since I'm not joining them)
        }

        for(i1=pThis->rctSel.top + 1; i2 < pBuf->nEntries; i1++, i2++)
        {
          if(pBuf->aLines[i1])
          {
            WBFree(pBuf->aLines[i1]);
          }
          pBuf->aLines[i1] = pBuf->aLines[i2];
          pBuf->aLines[i2] = NULL; // for now, to prevent accidental pointer re-use later
        }

        pBuf->nEntries = i1;
      }
      else
      {
        if(rctSel.right == 0) // an even number of lines is being deleted
        {
          for(i1=rctSel.top, i2=rctSel.bottom; i2 < pBuf->nEntries; i1++, i2++)
          {
            if(pBuf->aLines[i1])
            {
              WBFree(pBuf->aLines[i1]);
            }
            pBuf->aLines[i1] = pBuf->aLines[i2];
            pBuf->aLines[i2] = NULL; // for now, to prevent accidental pointer re-use later
          }

          pBuf->nEntries = i1;
        }
        else // uneven lines
        {
          // top line will become partial bottom line
          pL = pBuf->aLines[rctSel.bottom];

          if(pL)
          {
            char *pTempR = WBGetMBCharPtr(pL, rctSel.right, NULL);
            if(pTempR)
            {
              strcpy(pL, pTempR);
            }
            else
            {
              *pL = 0; // for now, truncate the line if this happens
            }
          }

          if(pBuf->aLines[rctSel.top])
          {
            WBFree(pBuf->aLines[rctSel.top]);
            pBuf->aLines[rctSel.top] = NULL; // by convention (it's re-assigned in the next line though)
          }

          pBuf->aLines[rctSel.top] = pL;
          pBuf->aLines[rctSel.bottom] = NULL; // by convention, to prevent re-use of pointer

          for(i1=rctSel.top + 1, i2=rctSel.bottom + 1; i2 < pBuf->nEntries; i1++, i2++)
          {
            if(pBuf->aLines[i1])
            {
              WBFree(pBuf->aLines[i1]);
              pBuf->aLines[i1] = NULL; // by convention (re-assigned in next line)
            }

            pBuf->aLines[i1] = pBuf->aLines[i2];
            pBuf->aLines[i2] = NULL; // by convention, to prevent accidental pointer re-use later
          }

          pBuf->nEntries = i1;
        }
      }

      // update cached line length info

      if(rctSel.bottom == rctSel.top) // same line delete
      {
        int iNewLen = 0;

        if(pBuf->aLines[rctSel.top])
        {
          iNewLen = WBGetMBLength(pBuf->aLines[rctSel.top]);
        }

        WBTextBufferLineChange(pThis->pText, rctSel.top, iNewLen);
      }
      else if((rctSel.bottom - rctSel.top) == 1) // single-line delete
      {
        WBTextBufferLineChange(pThis->pText, rctSel.top, -1); // deleted line
      }
      else // multi-line
      {
        WBTextBufferRefreshCache(pThis->pText);
      }

      if(pTemp)
      {
        __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                            rctSel.top, rctSel.left, &(pThis->rctSel),
                            pTemp, -1,
                            rctSel.bottom, rctSel.right, NULL, NULL, 0);
      }
    }

    if(pTemp)
    {
      WBFree(pTemp);
    }

    // once the selection has been deleted, select 'nothing' and re-paint all
    // and of course, iRow and iCol will be at the left/top of the selection

    // NOTE:  this assumes that the data is consistent

    pThis->rctSel.left = 0;
    pThis->rctSel.top = 0;
    pThis->rctSel.right = 0;
    pThis->rctSel.bottom = 0;

    if(iSelAll) // everything was deleted
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }
    else
    {
      if(rctSel.top >= 0)
        pThis->iRow = rctSel.top;
      else
      {
        WB_WARN_PRINT("WARNING - %s line %d - rctSel.top == %d\n", __FUNCTION__, __LINE__, rctSel.top);
        pThis->iRow = 0;
      }

      if(rctSel.left >= 0)
        pThis->iCol = rctSel.left;
      else
      {
        WB_WARN_PRINT("WARNING - %s line %d - rctSel.left == %d\n", __FUNCTION__, __LINE__, rctSel.left);
        pThis->iCol = 0;
      }
    }

    if(pThis->pColorContextCallback)
    {
      pThis->pColorContextCallback(pThis, -1, -1); // to refresh it
    }

    WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - need to optimize invalidate rect\n", __FUNCTION__, __LINE__);

    __internal_invalidate_rect(pThis, NULL, 1); // TODO:  optimize this
  }
}
static void __internal_replace_select(struct _text_object_ *pThis, const char *szText, unsigned long cbLen)
{
WB_RECT rctSel;
int iSelAll;


  if(WBIsValidTextObject(pThis))
  {
    int iOldIns; //, iOldRow, iOldCol;

    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    if(pThis->iRow < 0 || pThis->iCol< 0)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }

// NOTE:  iOldRow and iOldCol not being used; commented out because of linux gcc warnings
//    iOldRow = pThis->iRow;
//    iOldCol = pThis->iCol;
    iOldIns = pThis->iInsMode;

    iSelAll = SEL_RECT_ALL(pThis);

    memcpy(&rctSel, &(pThis->rctSel), sizeof(rctSel));

    if(iSelAll)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }
    else if(!SEL_RECT_EMPTY(pThis))
    {
      NORMALIZE_SEL_RECT(rctSel);

      pThis->iRow = rctSel.top;
      pThis->iCol = rctSel.left;
    }

    pThis->iInsMode = InsertMode_INSERT;

    // TODO:  if box mode, height/width may need to match.  for now, don't care

    if(!iSelAll && SEL_RECT_EMPTY(pThis)) // not 'ALL'
    {
      WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject, "%s line %d - replace an empty select\n", __FUNCTION__, __LINE__);

      __internal_ins_chars(pThis, szText, cbLen); // just insert the text (no selection)

      // NOTE:  select rectangle remains empty
    }
    else
    {
      // for now delete the selection, then insert the new characters, and make new selection match inserted text
      // this will take into consideration the select mode
      __internal_del_select(pThis);               // this also clears the selection

       // new selection starts at rctSel.top, rctSel.left
      __internal_ins_chars(pThis, szText, cbLen); // just insert the text (no selection)

      // new selection ends at iRow, iCol
      rctSel.bottom = pThis->iRow;
      rctSel.right = pThis->iCol;

      // assign the new select rectangle to become the text I just added.
      memcpy(&(pThis->rctSel), &rctSel, sizeof(pThis->rctSel));
    }

//    pThis->iRow = iOldRow;
//    pThis->iCol = iOldCol;
    pThis->iInsMode = iOldIns;

    // todo:  mark a NEW selection using the inserted text?  this might mean replicating code for
    //        __internal_del_select and __internal_ins_chars and processing undo here


    if(pThis->pColorContextCallback)
    {
      pThis->pColorContextCallback(pThis, -1, -1); // to refresh it
    }

     WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - need to optimize invalidate rect\n", __FUNCTION__, __LINE__);
    __internal_invalidate_rect(pThis, NULL, 1); // TODO:  optimize this

    // NOTE:  no need to call WBTextBufferRefreshCache(), the 'del_select' and 'ins_chars' would've done it

  }
}
static void __internal_del_chars(struct _text_object_ *pThis, int nChar)
{
TEXT_BUFFER *pBuf;
int i1, i2, iLen;
char *pL, *pL2, *pL3;
WB_RECT rctInvalid;


  if(!nChar)
  {
    return; // does nothing
  }

  // NOTE: nChar < 0 deletes to the left (like a backspace), >0 deletes to the right like 'Del' normally would
  //       If the cursor is at the end of the line or the start of the line, an appropriate delete will
  //       merge the previous (or next) line.  Values of |nChar| greater than the number of characters remaining
  //       in the line (from the cursor) _STOP_ at the beginning/end of the line.  Only a delete with cursor
  //       AT the beginning or end of the line will merge.  Merge also considers the virtual cursor position.

  if(!WBIsValidTextObject(pThis))
  {
    return; // error
  }

  WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                 "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                 __FUNCTION__, __LINE__,
                 pThis->iRow, pThis->iCol,
                 pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

  __internal_invalidate_cursor(pThis, 0);
  pThis->iBlinkState = CURSOR_BLINK_RESET; // this affects the cursor blink, basically resetting it whenever I edit something

  if(nChar > 0 || (pThis->iCol == 0 && pThis->iLineFeed == LineFeed_NONE))
  {
    __internal_calc_rect(pThis, &rctInvalid, pThis->iRow, pThis->iCol, pThis->iRow, pThis->iCol + 1);
  }
  else if(pThis->iCol > 0) // backspace, don't merge lines
  {
    __internal_calc_rect(pThis, &rctInvalid, pThis->iRow, pThis->iCol - 1, pThis->iRow, pThis->iCol);
  }
  else if(pThis->iLineFeed != LineFeed_NONE)
  {
    __internal_calc_rect(pThis, &rctInvalid, pThis->iRow - 1, 0, -1, -1);
  }


  pBuf = (TEXT_BUFFER *)(pThis->pText);

  if(!pBuf || !pBuf->nEntries || pThis->iRow > pBuf->nEntries ||
     (pThis->iRow == pBuf->nEntries && nChar > 0)) // ending row only allows a backspace from the 1st column
  {
    return;  // do nothing
  }

  while(nChar) // while I have characters to delete
  {
    // if I hit a limit and 'nChar' is still non-zero, break out and return anyway

    if(pThis->iRow > pBuf->nEntries || pThis->iRow < 0)  // allow row == nEntries
    {
      return; // empty
    }

    pL = pBuf->aLines[pThis->iRow];

    iLen = WBGetMBLength(pL);

    if(nChar < 0 && pThis->iCol == 0 && // backspace prior to beginning of line
       (pThis->iRow <= 0 || pThis->iLineFeed == LineFeed_NONE)) // single line and backspace past begin of column
    {
      WB_DEBUG_PRINT(DebugLevel_Verbose, "%s - backspace while I'm at start of file\n", __FUNCTION__);
      return; // exit
    }

    if(nChar > 0 && pThis->iCol >= iLen && // delete past end of line
       (pThis->iRow >= pBuf->nEntries ||
        pThis->iLineFeed == LineFeed_NONE))              // single line and backspace past begin of column
    {
      WB_DEBUG_PRINT(DebugLevel_Verbose, "%s - delete while I'm past end of file\n", __FUNCTION__);

      return; // exit
    }

    // if it's at an edge, merge lines

    if(nChar < 0 &&                         // backspacing
       pThis->iRow > 0 && pThis->iCol == 0) // backspace while at the start of a line NOT the first line
    {
      // this backspace will merge the previous line with this one

      pL2 = pBuf->aLines[pThis->iRow - 1];
      if(!pL2)
      {
        pThis->iCol = 0; // a kind of 'fallback' - put column cursor at zero

        pBuf->aLines[pThis->iRow - 1] = pL;  // move line to THIS position
        pBuf->aLines[pThis->iRow] = NULL; // pre-emptive, avoid sharing pointers

        pL = NULL;
      }
      else
      {
        if(pL) // can be NULL, which is a blank line
        {
          i2 = WBGetMBLength(pL2); // now THIS is the new column position

          pL2 = WBJoinMBLine(pL2, i2, pL);

          if(!pL2)
          {
            WB_ERROR_PRINT("ERROR:  %s - not enough memory to join lines\n", __FUNCTION__);

            return; // do nothing (TODO:  error message?)
          }

          pBuf->aLines[pThis->iRow - 1] = pL2; // the new pointer
        }
        else
        {
          i2 = 0;
        }

        pBuf->aLines[pThis->iRow] = NULL; // pre-emptive, avoid sharing pointers

        pThis->iCol = i2; // the new position (end of previous line)

        WBFree(pL);
        pL = NULL; // pre-emptive, avoid shared pointers
      }

      // if I hit backspace while on row==nEntries, just move the cursor to the end
      // of the previous line.  I'm not really deleting anything.
      if(pThis->iRow >= pBuf->nEntries) // beyond the last line?
      {
        pThis->iRow--;
        if(pBuf->aLines[pThis->iRow])
        {
          pThis->iCol = WBGetMBLength(pBuf->aLines[pThis->iRow]);
        }

        // NOTE:  no need to update the line's length in the buffer cache, I didn't change anything
      }
      else
      {
        // at this point, 'iRow - 1' is the 'replaced' row, so I need to move rows such that
        // I start with 'iRow + 1' and assign to 'i1 - 1'.  this works.
        for(i1=pThis->iRow + 1; i1 < pBuf->nEntries; i1++)
        {
          pBuf->aLines[i1 - 1] = pBuf->aLines[i1]; // pack them up by one line
        }

        pBuf->nEntries--;
        pBuf->aLines[pBuf->nEntries] = NULL; // so that pointers aren't accidentally re-used

        WBTextBufferLineChange(pThis->pText, pThis->iRow, -1); // deleted line (current 'iRow')

        pThis->iRow--; // since I moved up

        WBTextBufferLineChange(pThis->pText, pThis->iRow,
                               WBGetMBLength(pBuf->aLines[pThis->iRow])); // 'replaced' line (new length)
      }

      nChar++; // backspacing, so increment

      __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                          pThis->iRow, pThis->iCol, &(pThis->rctSel),
                          "\n", 1, // this is what I'm deleting - the newline
                          pThis->iRow + 1, 0, NULL, NULL, 0);

      __internal_merge_rect(pThis, &rctInvalid, pThis->iRow, 0, -1, -1);
    }
    else if(nChar > 0 && // deleting
            pThis->iCol >= iLen && pThis->iRow < (pBuf->nEntries - 1)) // not at end of 'last row'
    {
      // delete at end of line which merges with the next line

      pL2 = pBuf->aLines[pThis->iRow + 1];

      if(pL2)
      {
        if(*pL2)
        {
          WB_DEBUG_PRINT(DebugLevel_Verbose, "%s - joining \"%s\" at %d with \"%s\"\n", __FUNCTION__,
                         pL, pThis->iCol, pL2);

          pL = WBJoinMBLine(pL, pThis->iCol, pL2);

          if(!pL)
          {
            WB_ERROR_PRINT("ERROR:  %s - not enough memory to join\n", __FUNCTION__);

            return; // do nothing ELSE
          }

          pBuf->aLines[pThis->iRow] = pL; // the new pointer
        }

        WBFree(pL2);
      }

      pBuf->nEntries--;

      // merge UP the lines, starting with 'iRow + 1' getting 'iRow + 2'
      for(i1=pThis->iRow + 1; i1 < pBuf->nEntries; i1++)
      {
        pBuf->aLines[i1] = pBuf->aLines[i1 + 1];
      }

      pBuf->aLines[pBuf->nEntries] = NULL; // so that pointers aren't accidentally re-used

      WBTextBufferLineChange(pThis->pText, pThis->iRow + 1, -1); // deleted line (the one that follows 'iRow')

      WBTextBufferLineChange(pThis->pText, pThis->iRow,
                             WBGetMBLength(pBuf->aLines[pThis->iRow])); // 'replaced' line (new length)

      nChar--; // deleting, so decrement

      __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                          pThis->iRow, iLen, &(pThis->rctSel),
                          "\n", 1,
                          pThis->iRow + 1, 0, NULL, NULL, 0);


      WB_DEBUG_PRINT(DebugLevel_Verbose, "%s %d - fix the optimization for __internal_merge_rect\n", __FUNCTION__, __LINE__);
//      __internal_merge_rect(pThis, &rctInvalid, pThis->iRow, 0, -1, -1); // invalidate entire row and those that follow

      // bug workaround, mark everything 'invalid'
      __internal_merge_rect(pThis, &rctInvalid, 0, 0, -1, -1);
    }
    else
    {
      // OK now that _THAT_ is done, delete "up to the end of the string if needed"
      // on either end, depending upon which direction we must travel

      pL = pBuf->aLines[pThis->iRow];

//      if(!pL)
//      {
//        WB_ERROR_PRINT("UNEXPECTED:  %s - NULL pointer at row %d\n", __FUNCTION__, pThis->iRow);
//
//        return; // do nothing (TODO:  error message?)
//      }

      // TODO:  use WBDelMBChars

      if(nChar < 0 && pThis->iCol > 0)
      {
        // backspacing

        // TODO:  handle hard tab translation?  For now "leave it"

        i2 = -nChar;
        if(i2 > pThis->iCol)
        {
          i2 = pThis->iCol;
        }

        if(pL) // could be NULL
        {
          // position to which I delete
          pL2 = WBGetMBCharPtr(pL, pThis->iCol - i2, NULL);  // column to which I delete (backspace)
          pL3 = WBGetMBCharPtr(pL, pThis->iCol, NULL);  // position FROM where I delete/backspace

// TEMPORARY DEBUG CODE - remove when I fix this, it's here to remind me
          {
            const char *pL2a;
            const char *pL3a;
            int i2a;

            for(i2a=0; i2a < i2; i2a++)
            {
              pL2a = WBGetMBCharPtr(pL, pThis->iCol - i2 + i2a, NULL);
              pL3a = WBGetMBCharPtr(pL, pThis->iCol - i2 + i2a + 1, NULL);

              if(pL2a && (pL3a - pL2a) == 1 &&
                 ((unsigned char)*pL2a == (unsigned char)HARD_TAB_CHAR || *pL2a == '\t'))
              {
                WB_DEBUG_PRINT(DebugLevel_Verbose, "%s %d - hard tab (%02xH) at row %d column %d\n",
                               __FUNCTION__, __LINE__, (unsigned char)*pL2a,
                               pThis->iRow, pThis->iCol - i2 + i2a);
              }
            }
          }


          // create undo record first, before I actually delete things
          __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                              pThis->iRow, pThis->iCol + nChar, &(pThis->rctSel),
                              pL2, pL3 - pL2, // text pointer AND 'true length' in bytes
                              pThis->iRow, pThis->iCol, NULL, NULL, 0);

          strcpy(pL2, pL3); // delete things down
        }

        pThis->iCol -= i2;
        nChar += i2; // # of characters actually deleted (added 'cause nChar is negative)

        WBTextBufferLineChange(pThis->pText, pThis->iRow,
                               WBGetMBLength(pBuf->aLines[pThis->iRow])); // new length

        __internal_merge_rect(pThis, &rctInvalid, pThis->iRow, pThis->iCol, pThis->iRow, -1); // invalidate remainder of row
      }
      else if(nChar > 0 && iLen > pThis->iCol)
      {
        // TODO:  handle hard tab translation?  For now "leave it"

        i2 = nChar;

        if(i2 > iLen - pThis->iCol)
        {
          i2 = iLen - pThis->iCol;
        }

        if(pL)
        {
          // position to which I delete
          pL2 = WBGetMBCharPtr(pL, pThis->iCol + i2, NULL);  // column to which I delete
          pL3 = WBGetMBCharPtr(pL, pThis->iCol, NULL);  // position FROM where I delete/backspace

// TEMPORARY DEBUG CODE - remove when I fix this, it's here to remind me
          {
            const char *pL2a;
            const char *pL3a;
            int i2a;

            for(i2a=0; i2a < i2; i2a++)
            {
              pL2a = WBGetMBCharPtr(pL, pThis->iCol + i2a, NULL);
              pL3a = WBGetMBCharPtr(pL, pThis->iCol + i2a + 1, NULL);

              if(pL3a && (pL2a - pL3a) == 1 &&
                 ((unsigned char)*pL3a == (unsigned char)HARD_TAB_CHAR || *pL3a == '\t'))
              {
                WB_DEBUG_PRINT(DebugLevel_Verbose, "%s %d - hard tab (%02xH) at row %d column %d\n",
                               __FUNCTION__, __LINE__, (unsigned char)*pL3a,
                               pThis->iRow, pThis->iCol - i2 + i2a);
              }
            }
          }

          // create undo record first, before I actually delete things
          __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                              pThis->iRow, pThis->iCol, &(pThis->rctSel),
                              pL3, pL2 - pL3, // text pointer AND 'true length' in bytes
                              pThis->iRow, pThis->iCol + nChar, NULL, NULL, 0);

          strcpy(pL3, pL2); // delete things down
        }

        nChar -= i2;

        WBTextBufferLineChange(pThis->pText, pThis->iRow,
                               WBGetMBLength(pBuf->aLines[pThis->iRow])); // new length

        // NOTE:  column does not change
        __internal_merge_rect(pThis, &rctInvalid, pThis->iRow, pThis->iCol, pThis->iRow, -1); // invalidate remainder of row
      }
      else
      {
        // this is a condition that might infinite loop since it doesn't inc/dec nChar
        // so it's a condition that was SUPPOSED to be tested for, but wasn't.

        WB_ERROR_PRINT("UNEXPECTED:  %s - nChar=%d, iCol=%d, iRow=%d   nEntries=%d\n",
                       __FUNCTION__, nChar, pThis->iCol, pThis->iRow, (int)pBuf->nEntries);

        break;
      }
    }

    // implement auto-hscroll while deleting

    if(pThis->rctView.right > pThis->rctView.left)
    {
      if(pThis->rctView.right <= pThis->iCol ||
         pThis->rctView.left > pThis->iCol)
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
        {
          iAutoScrollWidth >>= 1;
        }

        // scroll left/right to expose the cursor

        while(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.left -= iAutoScrollWidth;
          pThis->rctView.right -= iAutoScrollWidth;
        }
        while(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += iAutoScrollWidth;
          pThis->rctView.right += iAutoScrollWidth;
        }

        if(pThis->pColorContextCallback) // TODO: if I only need to invalidate one line, should I just do that?
        {
          pThis->pColorContextCallback(pThis, -1, -1); // to refresh it
        }

        WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - need to optimize invalidate rect\n", __FUNCTION__, __LINE__);
        __internal_invalidate_rect(pThis, NULL, 1); // scrolling, so invalidate everything
      }
      else
      {
        if(pThis->pColorContextCallback) // TODO: if I only need to invalidate one line, should I just do that?
        {
          pThis->pColorContextCallback(pThis, -1, -1); // to refresh it
        }

        WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - need to optimize invalidate rect\n", __FUNCTION__, __LINE__);
        // for now, always do this
        __internal_invalidate_rect(pThis, NULL, 1); // scrolling, so invalidate everything
//        __internal_invalidate_rect(pThis, &rctInvalid, 1); // invalidate bounding rectangle
      }
    }
    else
    {
      if(pThis->pColorContextCallback) // assume multi-line
      {
        pThis->pColorContextCallback(pThis, -1, -1); // to refresh it
      }

      // for now, always do this
      WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - need to optimize invalidate rect\n", __FUNCTION__, __LINE__);

      __internal_invalidate_rect(pThis, NULL, 1); // scrolling, so invalidate everything

//      __internal_invalidate_rect(pThis, &rctInvalid, 1); // invalidate bounding rectangle
    }
  }
}
static void __internal_ins_chars(struct _text_object_ *pThis, const char *pChar, int nChar)
{
TEXT_BUFFER *pBuf;
const char *p1, *p2;
char *pL, *pTemp;
int i1, iLen=0, iMultiLine = 0;
WB_RECT rctInvalid;


  if(!pChar || !nChar)
  {
    return;
  }

  if(nChar < 0)
  {
    nChar = strlen(pChar);
  }

  p1 = pChar;
  p2 = pChar + nChar;


  // FIRST, see if the insert is single-line or multi-line and act accordingly

  while(p1 < p2)
  {
    if(*p1 == '\n' || *p1 == '\r')
    {
      iMultiLine = 1;
      break; // this will be used in single-line mode to mark "stop here"
    }

    p1++;
  }

  __internal_invalidate_cursor(pThis, 0); // always do this

  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    if(pThis->iRow < 0 || pThis->iCol< 0)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }

    __internal_invalidate_cursor(pThis, 0);
    pThis->iBlinkState = CURSOR_BLINK_RESET;
      // this affects the cursor blink, basically resetting it whenever I edit something

    __internal_calc_rect(pThis, &rctInvalid, pThis->iRow, pThis->iCol, pThis->iRow, -1);
      // always refresh entire line from 'iCol' forward

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(pThis->iLineFeed == LineFeed_NONE) // single line
    {
      if(iMultiLine)
      {
        iMultiLine = 0;
        p2 = p1; // either end of string, or the position of the newline
      }

      p1 = pChar;

      // insert at 'iCol'

      if(!pBuf) // no buffer, so add text now
      {
        pBuf = pThis->pText = WBAllocTextBuffer(p1, p2 - p1); // this copies the data, too

        pThis->iRow = 0; // always
        pThis->iCol = WBGetMBColIndex(p1, p2); // the col index of 'p2' within 'p1' ('MB' length of 'p1 through p2')
        // new col will be 'end of string'.  by using this value, it's effectively, like pressing 'end' after inserting

        __internal_add_undo(pThis, UNDO_INSERT, pThis->iSelMode,
                            pThis->iRow, 0, &(pThis->rctSel), NULL, 0, // old col was 0, always
                            pThis->iRow, pThis->iCol, NULL,            // new col already assigned
                            p1, p2 - p1); // the new text
      }
      else if(p2 > p1) // adding text to existing buffer
      {
        if(pThis->iRow != 0)
        {
          pThis->iRow = 0; // force it
        }

        iLen = 0; // pre-assign for later (so it won't be "unassigned" by accident on error)

        //------------------------------------------------
        // calculating buffer size, allocating line buffer
        //------------------------------------------------

        if(pBuf->nEntries <= 0 || !pBuf->aLines[0])
        {
          if(pBuf->nEntries <= 0)
          {
            pBuf->nEntries = 1; // single-line, always this, but not verifying for now
          }

          pL = pBuf->aLines[0] = WBAlloc(pThis->iCol + p2 - p1 + 2);

          if(pL)
          {
            if(pThis->iCol > 0) // this works because a space is always 1 byte long
            {
              memset(pL, ' ', pThis->iCol);
              pL[pThis->iCol] = 0;
            }

            iLen = pThis->iCol;
          }
        }
        else
        {
          pTemp = pBuf->aLines[0];

          i1 = strlen(pTemp); // the actual length

          iLen = WBGetMBLength(pTemp); // the # of columns

          if(iLen < pThis->iCol)
          {
            i1 += pThis->iCol - iLen; // add the alloc length for white space following 'iCol'
          }

          if(pThis->iInsMode == InsertMode_OVERWRITE &&
             iLen >= pThis->iCol) // only if I actually overwrite something
          {
            if(iLen < pThis->iCol + WBGetMBColIndex(p1, p2)) // will overwrite extend the string??
            {
              char *pTempC = WBGetMBCharPtr(pTemp, pThis->iCol, NULL);

              if(pTempC)
              {
                i1 = (pTempC - pTemp) + (p2 - p1); // extent of teh text I'm adding when I overwrite
              }
              else
              {
                i1 += p2 - p1; // fallback in case of problems
              }
            }
          }
          else
          {
            i1 += p2 - p1; // I'm extending the string by 'that much'
          }

          pL = WBReAlloc(pTemp, i1 + 2);

          if(pL)
          {
            pBuf->aLines[0] = pL;
          }
          else
          {
            WB_ERROR_PRINT("ERROR:  %s - not enough memory\n", __FUNCTION__);
          }
        }

        //-------------------------------------------
        // copying data into buffer at column 'iCol'
        //-------------------------------------------

        if(pL)
        {
          char *pTempL;
          if(iLen < pThis->iCol)
          {
            pTempL = pL + strlen(pL); // will always be this

            memset(pTempL, ' ', pThis->iCol - iLen); // pad with spaces

            pTempL += pThis->iCol - iLen; // advance the pointer to where 'iCol' is
            *pTempL = 0;                  // make sure it ends in a zero byte
          }
          else if(iLen > pThis->iCol &&                    // insert 'in the middle'
                  pThis->iInsMode != InsertMode_OVERWRITE) // NOT overwriting
          {
            pTempL = WBGetMBCharPtr(pL, pThis->iCol, NULL);

            // make room for text
            if(WB_LIKELY((iLen - pThis->iCol + 1) > 0)) // probably always true
            {
              memmove(pTempL + (p2 - p1), pTempL, strlen(pTempL) + 1); // note that this includes the zero byte at the end
            }
          }
          else if((p2 - p1) + pThis->iCol >= iLen) // overwriting AND it extends the buffer?
          {
            pTempL = WBGetMBCharPtr(pL, pThis->iCol, NULL);

            pTempL[p2 - p1] = 0; // I need a terminating zero byte immediately after where the text will go
          }

          __internal_add_undo(pThis, UNDO_INSERT, pThis->iSelMode,
                              pThis->iRow, pThis->iCol, &(pThis->rctSel),
                              (pThis->iInsMode == InsertMode_OVERWRITE && pThis->iCol < iLen ?
                               pL + pThis->iCol : NULL), // for overwrite, it's the original text
                              (pThis->iInsMode == InsertMode_OVERWRITE && pThis->iCol < iLen ?
                               p2 - p1 : 0),  // length of old text for overwrite
                              pThis->iRow, pThis->iCol + (p2 - p1), NULL,
                              p1, p2 - p1); // the new text

          memcpy(pL + pThis->iCol, p1, p2 - p1); // insert the data (but not the terminating zero byte)

          pThis->iCol += WBGetMBColIndex(p1, p2); // always advance the cursor to this point (overwrite OR insert)
        }
      }

      if(pThis->pColorContextCallback)
      {
        pThis->pColorContextCallback(pThis, -1, -1); // to refresh it
      }
    }
    else // multi-line text
    {

      // TODO: auto-vscroll while inserting text, make sure cursor position is visible

      // insert at 'iCol'

      if(!pBuf) // no buffer, so add text now
      {
        p1 = pChar;
        p2 = pChar + nChar;

        pBuf = pThis->pText = WBAllocTextBuffer(pChar, nChar);

        pThis->iRow = 0; // always
        pThis->iCol = nChar; // effectively, like pressing 'end' after inserting

        __internal_add_undo(pThis, UNDO_INSERT, pThis->iSelMode,
                            pThis->iRow, 0, &(pThis->rctSel), NULL, 0, // old col was 0, always
                            pThis->iRow, pThis->iCol, NULL,            // new col already assigned
                            pChar, nChar); // the new text
      }
      else // add to existing buffer
      {
        // NOW, parse into 'lines' and add text as needed
        const char *p3 = pChar + nChar; // p3 is 'end of text' marker now
        p2 = pChar;               // also marks 'end of line' for insertion


        while(p2 < p3)
        {
          int nTabs = 0;
          p1 = p2; // new 'start of line' pointer (for insertion)

          while(p2 < p3 && *p2 != '\n' && *p2 != '\r')
          {
            if(*p2 == '\t') // hard tab insertion?
            {
              nTabs++; // count them (for now); this is for allocation purposes

              // NOTE:  if hard tabs are supported, I will be storing the white space
              //        as a special character
            }

            p2++;
          }

          // p2 now points just past the end of the 'line' I am inserting, and points to
          // either a '\r' or a '\n' (which will be inserted)

          // there are 3 scenarious:
          // a) inserting a line feed (no text)
          // b) inserting text without a line feed
          // c) inserting text WITH a line feed (or more than one line feed)
          //
          // and the insert condition:  insert OR overwrite
          // a) if overwrite exceeds the length of the line, it appends to the same line.
          // b) if overwrite 'overwrites' with a line feed, it acts like 'insert' at that point (gedit does this too)
          // c) if insert or overwrite adds a line feed, a new line is created with the remaining text from the line
          //    and subsequent lines are moved down by 1 to make space for it

          // I'll deal with 'inserting text' first, then the line feed separately

          // TODO:  use WBSplitMBLine() if there's a linefeed
          //        otherwise, WBInsertMBChars()

          if(pBuf->nEntries <= 0 || !pBuf->aLines[0])
          {
            if(pBuf->nEntries <= 0)
            {
              pBuf->nEntries = 1; // single-line, always this, but not verifying for now
            }

            pL = pBuf->aLines[0] = WBAlloc(pThis->iCol + (p2 - p1)
                                           + nTabs * pThis->iTab // extra space for tabs
                                           +  2); // 2 additional spaces

            if(pL)
            {
              if(pThis->iCol > 0) // prepend with spaces
              {
                memset(pL, ' ', pThis->iCol);
              }

              pL[pThis->iCol] = 0; // mark end of string

              iLen = pThis->iCol; // in this case it will be
            }
          }
          else
          {
            pL = NULL; // a flag for success-testing

            if(WBCheckReAllocTextBuffer(&pBuf, 1) || !pBuf)
            {
              WB_ERROR_PRINT("ERROR:  %s - not enough memory to add line\n", __FUNCTION__);
            }
            else
            {
              pThis->pText = pBuf; // re-assign in case there's a new ptr

              pTemp = pBuf->aLines[pThis->iRow];

              // pTemp may be NULL if I'm at the end...
              if(pTemp)
              {
                i1 = strlen(pTemp); // the actual length
                iLen = WBGetMBLength(pTemp); // # of columns
              }
              else
              {
                i1 = iLen = 0;
              }

              if(iLen < pThis->iCol)
              {
                i1 += pThis->iCol - iLen; // the necessary alloc length
              }

              if(pThis->iInsMode == InsertMode_OVERWRITE
                 && iLen > pThis->iCol)
              {
                if(iLen < pThis->iCol + (p2 - p1))
                {
                  i1 += (p2 - p1) - (iLen - pThis->iCol); // estimated extent of the text I'm adding
                }
              }
              else
              {
                i1 += p2 - p1; // extending string length
              }

              if(pTemp)
              {
                pL = WBReAlloc(pTemp, i1
                                      + nTabs * pThis->iTab // extra space for tabs
                                      +  2); // re-allocate to fit (plus 2 extra chars)
              }
              else
              {
                pL = WBAlloc(i1
                             + nTabs * pThis->iTab // extra space for tabs
                             +  2); // allocate to fit (plus 2 extra chars)
              }

              if(pL)
              {
                pBuf->aLines[pThis->iRow] = pL;
              }
              else
              {
                WB_ERROR_PRINT("ERROR:  %s - not enough memory\n", __FUNCTION__);
              }
            }
          }

          if(pL) // only if above section worked properly
          {
            if(iLen < pThis->iCol)
            {
              pTemp = WBGetMBCharPtr(pL, iLen, NULL);

              memset(pTemp, ' ', pThis->iCol - iLen); // pad with spaces
              pTemp[pThis->iCol - iLen] = 0;              // I need a terminating zero byte

              iLen = pThis->iCol;
            }
            else if(iLen > pThis->iCol &&                    // insert 'in the middle'
                    pThis->iInsMode != InsertMode_OVERWRITE) // NOT overwriting
            {
              // make room for text
              if(WB_LIKELY((iLen - pThis->iCol + 1) > 0)) // probably always true
              {
                memmove(pL + pThis->iCol + (p2 - p1), pL + pThis->iCol, iLen - pThis->iCol + 1);
                  // note that this includes teh zero byte.
              }
            }
            else if((p2 - p1) + pThis->iCol >= iLen)
            {
              pL[pThis->iCol + p2 - p1] = 0; // I need a terminating zero byte
            }

            __internal_add_undo(pThis, UNDO_INSERT, pThis->iSelMode,
                                pThis->iRow, pThis->iCol, &(pThis->rctSel),
                                (pThis->iInsMode == InsertMode_OVERWRITE && pThis->iCol < iLen ?
                                 pL + pThis->iCol : NULL), // for overwrite, it's the original text
                                (pThis->iInsMode == InsertMode_OVERWRITE && pThis->iCol < iLen ?
                                 p2 - p1 : 0),  // length of old text for overwrite
                                pThis->iRow, pThis->iCol + (p2 - p1), NULL,
                                p1, p2 - p1); // the new text

            memcpy(pL + pThis->iCol, p1, p2 - p1); // insert the data

            // the end of the loop

            if(p2 > p1)
            {
              pThis->iCol += p2 - p1; // always advance the cursor to this point (overwrite OR insert)
            }

            // if last char is a newline, split the line at 'iCol'

            if(p2 < p3 && (*p2 == '\r' || *p2 == '\n')) // a newline
            {
              char c1 = *p2;

              p2++; // advance past the newline

              if(p2 < p3 && *p2 != c1 &&
                 (*p2 == '\r' || *p2 == '\n')) // CRLF or LFCR
              {
                p2++; // skip this one too
              }

              // insert a new row after this one.  But first, does pBuf have enough space?

              if(WBCheckReAllocTextBuffer(&pBuf, 1) || !pBuf)
              {
                WB_ERROR_PRINT("ERROR:  %s - not enough memory to add line\n", __FUNCTION__);

                break;  // bust out of loop - cannot insert any more
              }
              else
              {
                pThis->pText = pBuf; // re-assign in case there's a new ptr

                WB_DEBUG_PRINT(DebugLevel_Verbose, "%s - split line, %d, %d, %d\n", __FUNCTION__,
                               pThis->iRow, pThis->iCol, (int)pBuf->nEntries);

                for(i1=pBuf->nEntries; i1 > (pThis->iRow + 1); i1--)
                {
                  pBuf->aLines[i1] = pBuf->aLines[i1 - 1]; // make room for new line
                }

                pBuf->nEntries++;

                // TODO:  if insert blank line, do I just leave it 'NULL' and not make a copy?

                pTemp = WBGetMBCharPtr(pL, pThis->iCol, NULL); // point at which I insert the newline

                pBuf->aLines[pThis->iRow + 1] = WBCopyString(pTemp); // make a copy of previous at "that point"
                *pTemp = 0; // terminate line at "that point" (TODO: trim right?)

                WB_DEBUG_PRINT(DebugLevel_Verbose, "%s - split line into \"%s\", \"%s\"\n", __FUNCTION__,
                               pBuf->aLines[pThis->iRow],
                               pBuf->aLines[pThis->iRow + 1]);


                pThis->iRow++; // advance row position
                pThis->iCol = 0; // newline forces column 0, always

              }
            }
          }
        }
      }

      if(pThis->pColorContextCallback) // TODO: if I only need to invalidate one line, should I just do that?
      {
        pThis->pColorContextCallback(pThis, -1, -1); // to refresh it
      }

      WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - need to optimize invalidate rect\n", __FUNCTION__, __LINE__);

      __internal_invalidate_rect(pThis, NULL, 1); // so invalidate everything (for NOW)
    }

    // auto-hscroll while inserting text, make sure cursor position is visible

    if(pThis->rctView.right > pThis->rctView.left)
    {
      if(iMultiLine ||
         pThis->rctView.right <= pThis->iCol ||
         pThis->rctView.left > pThis->iCol)
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
        {
          iAutoScrollWidth >>= 1;
        }

        // scroll left/right to expose the cursor

        while(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.left -= iAutoScrollWidth;
          pThis->rctView.right -= iAutoScrollWidth;
        }
        while(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += iAutoScrollWidth;
          pThis->rctView.right += iAutoScrollWidth;
        }

        WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - need to optimize invalidate rect\n", __FUNCTION__, __LINE__);
        __internal_invalidate_rect(pThis, NULL, 1); // scrolling, so invalidate everything
      }
      else
      {
        __internal_invalidate_rect(pThis, &rctInvalid, 1); // invalidate bounding rectangle
      }
    }
    else
    {
      WB_WARN_PRINT("WARNING:  %s line %d - invalidate entire window rect\n", __FUNCTION__, __LINE__);

      __internal_invalidate_rect(pThis, NULL, 1); // invalidate everything (confusion handler)
    }

    if(iMultiLine || !pBuf)
    {
      WBTextBufferRefreshCache(pThis->pText);
    }
    else if(pThis->iRow < pBuf->nEntries)
    {
      WBTextBufferLineChange(pThis->pText, pThis->iRow,
                             WBGetMBLength(pBuf->aLines[pThis->iRow])); // new length
    }
  }

  // TODO:  anything else??
}
static void __internal_indent(struct _text_object_ *pThis, int nCol)
{
  if(WBIsValidTextObject(pThis))
  {
    WB_ERROR_PRINT("TODO:  %s - implement 'indent'\n", __FUNCTION__);
  }
}
static int __internal_can_undo(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
  }

  return 0; // for now
}
static void __internal_undo(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    WB_ERROR_PRINT("TODO:  %s - implement 'undo'\n", __FUNCTION__);
  }
}
static int __internal_can_redo(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
  }

  return 0; // for now
}
static void __internal_redo(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    WB_ERROR_PRINT("TODO:  %s - implement 'redo'\n", __FUNCTION__);
  }
}
static void __internal_get_view(const struct _text_object_ *pThis, WB_RECT *pRct)
{
  if(!pRct)
  {
    return;
  }

  if(WBIsValidTextObject(pThis))
  {
    memcpy(pRct, &(pThis->rctView), sizeof(*pRct));
  }
}
static void __internal_set_view_origin(struct _text_object_ *pThis, const WB_POINT *pOrig)
{
  if(!pOrig)
  {
    return;
  }

  if(WBIsValidTextObject(pThis))
  {
    int nRows = __internal_get_rows(pThis);
    int nCols = __internal_get_cols(pThis);

    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    nRows -= (pThis->rctView.bottom - pThis->rctView.top); // note that 'nRows' includes the blank line at the end
    if(nRows < 0)
    {
      nRows = 0;
    }

    nCols -= (pThis->rctView.right - pThis->rctView.left - 4); // TODO:  what constant do I subtract?
    if(nCols < 0)
    {
      nCols = 0;
    }

    if(pOrig->x < 0)
    {
      nCols = 0;
    }
    else if(pOrig->x < nCols)
    {
      nCols = pOrig->x;
    }

    if(pOrig->y < 0)
    {
      nRows = 0;
    }
    else if(pOrig->y < nRows)
    {
      nRows = pOrig->y;
    }

    if(nRows != pThis->rctView.top || nCols != pThis->rctView.left)
    {
      pThis->rctView.bottom = (pThis->rctView.bottom - pThis->rctView.top)
                            + nRows;
      pThis->rctView.top = nRows;

      pThis->rctView.right = (pThis->rctView.right - pThis->rctView.left)
                           + nCols;
      pThis->rctView.left = nCols;

      __internal_invalidate_rect(pThis, NULL, 1); // invalidate the display and re-draw
    }
  }
}
static void __internal_begin_highlight(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pThis->iDragState = DragState_CURSOR;
  }
}
static void __internal_end_highlight(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pThis->iDragState = DragState_NONE;
  }
}
static void __internal_mouse_click(struct _text_object_ *pThis, int iMouseXDelta, int iMouseYDelta, int iType, int iACS)
{
TEXT_BUFFER *pBuf;
int iRow = -1, iCol = -1; // pre-assign error returns
int iFontHeight;
WB_RECT rctSel;

  // NOTE:  if this has never been painted, I can't respond to this request

  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    memset(&rctSel, 0, sizeof(rctSel));

    if(!(pThis->iDragState & DragState_MOUSE)) // not mouse-dragging at the moment
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle

        // clearing the selection (TODO:  do this with a utility function?)
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    iFontHeight = pThis->iAsc + pThis->iDesc;

    if(iFontHeight && pThis->iFontWidth &&
       pThis->rctWinView.left < pThis->rctWinView.right &&
       pThis->rctWinView.top < pThis->rctWinView.bottom)
    {
      if(pThis->iLineFeed == LineFeed_NONE) // i.e. "single line"
      {
        iRow = 0; // always
      }
      else
      {
        iFontHeight = WBTextObjectCalculateLineHeight(pThis->iAsc, pThis->iDesc);

        iRow = pThis->rctView.top
             + (iMouseYDelta + iFontHeight / 4 - pThis->rctWinView.top) / iFontHeight;

        if(iRow < 0 || !pBuf)
        {
          iRow = 0;
        }
        else if(iRow > pBuf->nEntries)
        {
          iRow = pBuf->nEntries;
        }
      }

      // column calculation is no different between single-line and multi-line
      iCol = pThis->rctView.left
           + (iMouseXDelta + pThis->iFontWidth / 4 - pThis->rctWinView.left) / pThis->iFontWidth;

      if(iCol < 0 || !pBuf || iRow >= pBuf->nEntries || !pBuf->aLines[iRow])
      {
        iCol = 0;  // for now also force column 0 if there's no buffer or a NULL entry for it or at end of document
      }
      else if(pThis->iLineFeed == LineFeed_NONE &&
              iCol > WBGetMBLength(pBuf->aLines[iRow]))
      {
        iCol = WBGetMBLength(pBuf->aLines[iRow]);  // don't select pos past end of line for single-line edit
      }
    }

    // if I am doing a mouse-drag, and the selection is empty, start a new selection.
    // if I am doing a cursor-drag, disable it.

    if(pThis->iDragState & DragState_CURSOR)
    {
      pThis->iDragState = DragState_NONE; // turn it off now.

      if(iType == WB_POINTER_BUTTON1 && iACS == 0) // only if left-click for now
      {
        pThis->iCol = iCol;
        pThis->iRow = iRow;
      }
    }
    else if(!(pThis->iDragState & DragState_MOUSE))
    {
      if(iType == WB_POINTER_BUTTON1 && iACS == 0) // only if left-click for now
      {
        pThis->iCol = iCol;
        pThis->iRow = iRow;
      }
      else
      {
        pThis->iDragState = DragState_NONE; // turn dragging off

        // TODO:  check for wheel buttons WB_POINTER_BUTTON4 and WB_POINTER_BUTTON5 ?
      }
    }
    else if(iType == 0 && iACS == 0) // a mouse motion message while dragging
    {
      // see if the select rectangle is empty.  If it is, then I
      // am just starting the drag and I need to anchor the cursor

      // NOTE:  cursor anchor is always (left,top) even if it's a negative distance

      if(SEL_RECT_EMPTY(pThis))
      {
        WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject, "%s line %d - empty selection, starting the drag\n", __FUNCTION__, __LINE__);

        pThis->rctSel.top = pThis->iRow; // old row
        pThis->rctSel.left = pThis->iCol; // previous column
      }

      pThis->rctSel.bottom = iRow;     // new row
      pThis->rctSel.right = iCol;       // new column

      pThis->iCol = iCol;
      pThis->iRow = iRow;
    }
    else
    {
      // TODO:  cancel dragging?  or not... [maybe check for right-click or scroll]

      // TODO:  check for wheel buttons WB_POINTER_BUTTON4 and WB_POINTER_BUTTON5 ?
      //        for a mouse drag I may enable this, but probably should just shut off the drag
      //        maybe shift+wheel would select...? testing it shows that it scrolls the viewport

      pThis->iDragState = DragState_NONE; // turn dragging off, for now
    }

    // for now mouse-click invalidates the entire rectangle.  Later I fix this.

    WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - need to optimize invalidate rect\n", __FUNCTION__, __LINE__);

    __internal_invalidate_rect(pThis, NULL, 1);
  }
}
static void __internal_begin_mouse_drag(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

//    WB_ERROR_PRINT("TEMPORARY - %s\n", __FUNCTION__);
    pThis->iDragState = DragState_MOUSE;
  }
}
static void __internal_end_mouse_drag(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

//    WB_ERROR_PRINT("TEMPORARY - %s\n", __FUNCTION__);
    pThis->iDragState = DragState_NONE;
  }
}
static void __internal_cursor_up(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;


  if(!WBIsValidTextObject(pThis))
  {
    WB_ERROR_PRINT("ERROR:  %p - invalid text object %p\n", __FUNCTION__, pThis);
  }
  else
  {
    int iOldRow = pThis->iRow;

    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pThis->iBlinkState = CURSOR_BLINK_RESET; // this affects the cursor blink, basically resetting it whenever I edit something

    if(pThis->iLineFeed == LineFeed_NONE) // single line
    {
      return; // do nothing
    }

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }
    else if(pBuf->nEntries < pThis->iRow)
    {
      pThis->iRow = pBuf->nEntries;
      pThis->iCol = 0;
    }
    else if(pThis->iRow > 0)
    {
      pThis->iRow--;
    }
    else
    {
      pThis->iRow = 0;
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject, "%s line %d - empty selection, starting select\n", __FUNCTION__, __LINE__);

        pThis->rctSel.left = pThis->iCol;
        pThis->rctSel.top = iOldRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(pThis->rctView.top > pThis->iRow ||
       pThis->rctView.bottom <= pThis->iRow)
    {
      WB_WARN_PRINT("WARNING:  %s line %d - invalidate entire window rect\n", __FUNCTION__, __LINE__);

      __internal_invalidate_rect(pThis, NULL, 1); // scrolling invalidates all

      // scroll right/left so that I have one additional white space visible
      if(pThis->rctView.top > pThis->iRow)
      {
        pThis->rctView.bottom -= (pThis->rctView.top - pThis->iRow);
        pThis->rctView.top = pThis->iRow; // new top row
      }
      else if(pThis->rctView.bottom <= pThis->iRow)
      {
        pThis->rctView.top += pThis->iRow + 1 - pThis->rctView.bottom;
        pThis->rctView.bottom = pThis->iRow + 1;
      }
    }
    else // re-calculate cursor metrics
    {
      pThis->iCursorY += WBTextObjectCalculateLineHeight(pThis->iAsc, pThis->iDesc)
                       * (pThis->iRow - iOldRow); // will effectively subtract

      __internal_invalidate_cursor(pThis, 1); // invalidate the NEW cursor rectangle
    }
  }
}
static void __internal_cursor_down(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;


  if(!WBIsValidTextObject(pThis))
  {
    WB_ERROR_PRINT("ERROR:  %p - invalid text object %p\n", __FUNCTION__, pThis);
  }
  else
  {
    int iOldRow = pThis->iRow;

    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pThis->iBlinkState = CURSOR_BLINK_RESET; // this affects the cursor blink, basically resetting it whenever I edit something

    if(pThis->iLineFeed == LineFeed_NONE) // single line
    {
      return; // do nothing
    }

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }
    else if(pThis->iRow >= (pBuf->nEntries - 1))
    {
      pThis->iRow = pBuf->nEntries;
      pThis->iCol = 0;
    }
    else
    {
      pThis->iRow++;
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject, "%s line %d - empty selection, starting select\n", __FUNCTION__, __LINE__);

        pThis->rctSel.left = pThis->iCol;
        pThis->rctSel.top = iOldRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(pThis->rctView.top > pThis->iRow ||
       pThis->rctView.bottom <= pThis->iRow)
    {
      WB_WARN_PRINT("WARNING:  %s line %d - invalidate entire window rect\n", __FUNCTION__, __LINE__);

      __internal_invalidate_rect(pThis, NULL, 1); // scrolling invalidates all

      // scroll down so that I have one additional white space visible
      if(pThis->rctView.top > pThis->iRow)
      {
        pThis->rctView.bottom -= (pThis->rctView.top - pThis->iRow);
        pThis->rctView.top = pThis->iRow; // new top row
      }
      else if(pThis->rctView.bottom <= pThis->iRow)
      {
        pThis->rctView.top += pThis->iRow + 1 - pThis->rctView.bottom;
        pThis->rctView.bottom = pThis->iRow + 1;
      }
    }
    else // re-calculate cursor metrics
    {
      pThis->iCursorY += WBTextObjectCalculateLineHeight(pThis->iAsc, pThis->iDesc)
                       * (pThis->iRow - iOldRow);

      __internal_invalidate_cursor(pThis, 1); // invalidate the NEW cursor rectangle
    }
  }
}
static void __internal_cursor_left(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;


  if(!WBIsValidTextObject(pThis))
  {
    WB_ERROR_PRINT("ERROR:  %p - invalid text object %p\n", __FUNCTION__, pThis);
  }
  else
  {
    int iOldCol = pThis->iCol;

    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pThis->iBlinkState = CURSOR_BLINK_RESET; // this affects the cursor blink, basically resetting it whenever I edit something

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }
    else if(pThis->iCol > 0)
    {
      pThis->iCol --;
    }
    else
    {
      pThis->iCol = 0;
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject, "%s line %d - empty selection, starting select\n", __FUNCTION__, __LINE__);

        pThis->rctSel.left = iOldCol;
        pThis->rctSel.top = pThis->iRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(pThis->rctView.right > pThis->rctView.left)
    {
      if(pThis->rctView.right <= pThis->iCol ||
         pThis->rctView.left > pThis->iCol)
      {
        // scroll right/left so that I have one additional white space visible
        if(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.right -= (pThis->rctView.left - pThis->iCol);
          pThis->rctView.left = pThis->iCol;
        }
        else if(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += pThis->iCol + 1 - pThis->rctView.right;
          pThis->rctView.right = pThis->iCol + 1;
        }

        WB_WARN_PRINT("WARNING:  %s line %d - invalidate entire window rect\n", __FUNCTION__, __LINE__);

        __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
      }
      else // re-calculate cursor metrics
      {
        pThis->iCursorX += (pThis->iCol - iOldCol) * pThis->iFontWidth; // will effectively subtract

        __internal_invalidate_cursor(pThis, 1); // invalidate the NEW cursor rectangle
      }
    }
    else
    {
      WB_WARN_PRINT("WARNING:  %s line %d - invalidate entire window rect\n", __FUNCTION__, __LINE__);

      __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here (confusion point)
    }
  }
}
static void __internal_cursor_right(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;


  if(!WBIsValidTextObject(pThis))
  {
    WB_ERROR_PRINT("ERROR:  %p - invalid text object %p\n", __FUNCTION__, pThis);
  }
  else
  {
    int iOldCol = pThis->iCol;

    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pThis->iBlinkState = CURSOR_BLINK_RESET; // this affects the cursor blink, basically resetting it whenever I edit something

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }
    else if(pThis->iCol < 0)
    {
      pThis->iCol = 0;
    }
    else if(pThis->iCol < INT_MAX)
    {
      if(pThis->iLineFeed == LineFeed_NONE) // single line
      {
        if(pBuf->nEntries <= 0 || !pBuf->aLines[0])
        {
          pThis->iCol = 0;
        }
        else
        {
          int iLen = WBGetMBLength(pBuf->aLines[0]);

          if(pThis->iRow != 0)
          {
            pThis->iRow = 0; // force it
          }

          // no 'virtual space' for single-line but trailing white space OK

          if(pThis->iCol >= iLen)
          {
            pThis->iCol = iLen;
          }
          else
          {
            pThis->iCol++;
          }
        }
      }
      else
      {
        pThis->iCol ++;
      }
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject, "%s line %d - empty selection, starting select\n", __FUNCTION__, __LINE__);

        pThis->rctSel.left = iOldCol;
        pThis->rctSel.top = pThis->iRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(pThis->rctView.right > pThis->rctView.left)
    {
      if(pThis->rctView.right <= pThis->iCol ||
         pThis->rctView.left > pThis->iCol)
      {
        // scroll right/left so that I have one additional white space visible
        if(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.right -= (pThis->rctView.left - pThis->iCol);
          pThis->rctView.left = pThis->iCol;
        }
        else if(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += pThis->iCol + 1 - pThis->rctView.right;
          pThis->rctView.right = pThis->iCol + 1;
        }

        WB_WARN_PRINT("WARNING:  %s line %d - invalidate entire window rect\n", __FUNCTION__, __LINE__);

        __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
      }
      else // re-calculate cursor metrics
      {
        pThis->iCursorX += (pThis->iCol - iOldCol) * pThis->iFontWidth;

        __internal_invalidate_cursor(pThis, 1); // invalidate the NEW cursor rectangle
      }
    }
    else
    {
      WB_WARN_PRINT("WARNING:  %s line %d - invalidate entire window rect\n", __FUNCTION__, __LINE__);

      __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here (confusion point)
    }
  }
}
static void __internal_page_up(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;

  if(!WBIsValidTextObject(pThis))
  {
    WB_ERROR_PRINT("ERROR:  %p - invalid text object %p\n", __FUNCTION__, pThis);
  }
  else
  {
    int iOldRow = pThis->iRow;
    int iPageHeight = pThis->rctView.bottom - pThis->rctView.top;

    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pThis->iBlinkState = CURSOR_BLINK_RESET; // this affects the cursor blink, basically resetting it whenever I edit something

    if(pThis->iLineFeed == LineFeed_NONE) // single line
    {
      return; // do nothing
    }

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }
    else if(pThis->iRow <= iPageHeight)
    {
      if(pThis->iRow <= 0) // check for negatives anyway
      {
        pThis->iCol = 0; // page-up on top line homes the cursor
      }

      pThis->iRow = 0;
    }
    else
    {
      pThis->iRow -= iPageHeight;
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject, "%s line %d - empty selection, starting select\n", __FUNCTION__, __LINE__);

        pThis->rctSel.left = pThis->iCol;
        pThis->rctSel.top = iOldRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(WB_LIKELY(pThis->rctView.top > pThis->iRow ||
                 pThis->rctView.bottom <= pThis->iRow))
    {
      int iDelta = iOldRow - pThis->iRow;

      if((pThis->rctView.top - iDelta) > 0)
      {
        pThis->rctView.top -= iDelta;
        pThis->rctView.bottom -= iDelta;
      }
      else
      {
        pThis->rctView.bottom -= pThis->rctView.top;
        pThis->rctView.top = 0;
      }

      if(pThis->rctView.top > pThis->iRow) // still?
      {
        iDelta = pThis->rctView.top - pThis->iRow;

        pThis->rctView.bottom -= iDelta;
        pThis->rctView.top = pThis->iRow;
      }
      else if(pThis->rctView.bottom <= pThis->iRow) // still?
      {
        iDelta = (pThis->iRow + 1) - pThis->rctView.bottom;

        pThis->rctView.top += iDelta;
        pThis->rctView.bottom = pThis->iRow + 1;
      }
    }

    // in this case, since I updated the position by an entire page, the entire window is probably invalid

    __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
  }

}
static void __internal_page_down(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;

  if(!WBIsValidTextObject(pThis))
  {
    WB_ERROR_PRINT("ERROR:  %p - invalid text object %p\n", __FUNCTION__, pThis);
  }
  else
  {
    int iOldRow = pThis->iRow;
    int iPageHeight = pThis->rctView.bottom - pThis->rctView.top;

    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pThis->iBlinkState = CURSOR_BLINK_RESET; // this affects the cursor blink, basically resetting it whenever I edit something

    if(pThis->iLineFeed == LineFeed_NONE) // single line
    {
      return; // do nothing
    }

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }
    else if((int)pThis->iRow >= ((int)pBuf->nEntries - iPageHeight))
    {
      if(pThis->iRow >= 0) // check for negatives anyway
      {
        pThis->iCol = 0; // page-up on top line homes the cursor
      }

      pThis->iRow = pBuf->nEntries;
    }
    else
    {
      pThis->iRow += iPageHeight;
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject, "%s line %d - empty selection, starting select\n", __FUNCTION__, __LINE__);

        pThis->rctSel.left = pThis->iCol;
        pThis->rctSel.top = iOldRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(WB_LIKELY(pThis->rctView.top > pThis->iRow ||
                 pThis->rctView.bottom <= pThis->iRow))
    {
      int iDelta = pThis->iRow - iOldRow;

      if(!pBuf || (pThis->rctView.bottom + iDelta) <= pBuf->nEntries)
      {
        pThis->rctView.top += iDelta;
        pThis->rctView.bottom += iDelta;
      }
      else
      {
        pThis->rctView.top = pBuf->nEntries + 1
                           - (pThis->rctView.bottom - pThis->rctView.top);
        pThis->rctView.bottom = pBuf->nEntries + 1;
      }

      if(pThis->rctView.top > pThis->iRow) // still?
      {
        iDelta = pThis->rctView.top - pThis->iRow;

        pThis->rctView.bottom -= iDelta;
        pThis->rctView.top = pThis->iRow;
      }
      else if(pThis->rctView.bottom <= pThis->iRow) // still?
      {
        iDelta = (pThis->iRow + 1) - pThis->rctView.bottom;

        pThis->rctView.top += iDelta;
        pThis->rctView.bottom = pThis->iRow + 1;
      }
    }

    // in this case, since I updated the position by an entire page, the entire window is probably invalid

    __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
  }
}
static void __internal_page_left(struct _text_object_ *pThis)
{
//int iAutoScrollWidth = AUTO_HSCROLL_SIZE;
TEXT_BUFFER *pBuf;


  if(!WBIsValidTextObject(pThis))
  {
    WB_ERROR_PRINT("ERROR:  %p - invalid text object %p\n", __FUNCTION__, pThis);
  }
  else
  {
    int iOldCol = pThis->iCol;
    int iPageWidth = pThis->rctView.right - pThis->rctView.left;

    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_ScrollBar,
                   "%s %d - page left by %d, iCol=%d\n",
                   __FUNCTION__, __LINE__, iPageWidth, pThis->iCol);

    pThis->iBlinkState = CURSOR_BLINK_RESET; // this affects the cursor blink, basically resetting it whenever I edit something

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }
    else if(pThis->iCol > iPageWidth)
    {
      pThis->iCol -= iPageWidth;
    }
    else
    {
      pThis->iCol = 0;
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject, "%s line %d - empty selection, starting select\n", __FUNCTION__, __LINE__);

        pThis->rctSel.left = iOldCol;
        pThis->rctSel.top = pThis->iRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(WB_LIKELY(pThis->rctView.left > pThis->iCol ||
                 pThis->rctView.right <= pThis->iCol))
    {
      int iDelta = pThis->iCol - iOldCol;

      if(pThis->rctView.left > iDelta)
      {
        pThis->rctView.left -= iDelta;
        pThis->rctView.right -= iDelta;
      }
      else
      {
        pThis->rctView.right = iPageWidth;
        pThis->rctView.left = 0;
      }

      if(pThis->rctView.left > pThis->iCol) // still?
      {
        iDelta = pThis->rctView.left - pThis->iCol;

        pThis->rctView.right -= iDelta;
        pThis->rctView.left = pThis->iCol;
      }
      else if(pThis->rctView.right <= pThis->iCol) // still?
      {
        iDelta = (pThis->iCol + 1) - pThis->rctView.right;

        pThis->rctView.left += iDelta;
        pThis->rctView.right = pThis->iCol + 1;
      }
    }

    // in this case, since I updated the position by an entire page, the entire window is probably invalid

    __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
  }
}
static void __internal_page_right(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;


  if(!WBIsValidTextObject(pThis))
  {
    WB_ERROR_PRINT("ERROR:  %p - invalid text object %p\n", __FUNCTION__, pThis);
  }
  else
  {
    int iOldCol = pThis->iCol;
    int iPageWidth = pThis->rctView.right - pThis->rctView.left;

    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_ScrollBar,
                   "%s %d - page right by %d, iCol=%d\n",
                   __FUNCTION__, __LINE__, iPageWidth, pThis->iCol);

    pThis->iBlinkState = CURSOR_BLINK_RESET; // this affects the cursor blink, basically resetting it whenever I edit something

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }
    else if(pThis->iCol < (INT_MAX - iPageWidth))
    {
      pThis->iCol += iPageWidth;

      if(pThis->iCol < 0) // in case of wrap/overflow?
      {
        pThis->iCol = 0;
      }
    }
    else
    {
      pThis->iCol = INT_MAX; // can't scroll any more
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject, "%s line %d - empty selection, starting select\n", __FUNCTION__, __LINE__);

        pThis->rctSel.left = iOldCol;
        pThis->rctSel.top = pThis->iRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(WB_LIKELY(pThis->rctView.left > pThis->iCol ||
                 pThis->rctView.right <= pThis->iCol))
    {
      int iDelta = pThis->iCol - iOldCol;

      pThis->rctView.left += iDelta; // TODO:  scroll forever? (maybe MAX_INT as a limit)
      pThis->rctView.right += iDelta;

      if(pThis->rctView.left > pThis->iCol) // still?
      {
        iDelta = pThis->rctView.left - pThis->iCol;

        pThis->rctView.right -= iDelta;
        pThis->rctView.left = pThis->iCol;
      }
      else if(pThis->rctView.right <= pThis->iCol) // still?
      {
        iDelta = (pThis->iCol + 1) - pThis->rctView.right;

        pThis->rctView.left += iDelta;
        pThis->rctView.right = pThis->iCol + 1;
      }
    }

    // in this case, since I updated the position by an entire page, the entire window is probably invalid

    __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
  }
}

static void __internal_cursor_home(struct _text_object_ *pThis)
{
const char *pL, *p2;
TEXT_BUFFER *pBuf;


  if(!WBIsValidTextObject(pThis))
  {
    WB_ERROR_PRINT("ERROR:  %p - invalid text object %p\n", __FUNCTION__, pThis);
  }
  else
  {
    int iOldCol = pThis->iCol;

    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pThis->iBlinkState = CURSOR_BLINK_RESET; // this affects the cursor blink, basically resetting it whenever I edit something

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf || pThis->iRow >= pBuf->nEntries || pThis->iCol > 0)
    {
      pThis->iCol = 0;
    }
    else
    {
      // find first non-white-space character and assign to THAT
      // TODO:  handle hard tab translation?  For now "leave it"

      pL = pBuf->aLines[pThis->iRow];

      if(pL)
      {
        p2 = pL;
        while(*p2 && *p2 <= ' ') // TODO:  adjust for 'hard tab' char which might be 'U+00A0'...
        {
          p2++;
        }

        if(*p2)
        {
          pThis->iCol = (int)(p2 - pL); // toggling 'beginning of line' and column 0
        }
      }
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject, "%s line %d - empty selection, starting select\n", __FUNCTION__, __LINE__);

        pThis->rctSel.left = iOldCol;
        pThis->rctSel.top = pThis->iRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(pThis->rctView.right > pThis->rctView.left)
    {
      if(pThis->rctView.right <= pThis->iCol ||
         pThis->rctView.left > pThis->iCol)
      {
        if(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.right -= (pThis->rctView.left - pThis->iCol);
          pThis->rctView.left = pThis->iCol;
        }
        else if(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += pThis->iCol + 1 - pThis->rctView.right;
          pThis->rctView.right = pThis->iCol + 1;
        }

        WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - need to optimize invalidate rect\n", __FUNCTION__, __LINE__);

        __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
      }
      else // re-calculate cursor metrics
      {
        pThis->iCursorX += (pThis->iCol - iOldCol) * pThis->iFontWidth;

        __internal_invalidate_cursor(pThis, 1); // invalidate the NEW cursor rectangle
      }
    }
    else
    {
      WB_WARN_PRINT("WARNING:  %s line %d - invalidate entire window rect\n", __FUNCTION__, __LINE__);

      __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here (confusion point)
    }
  }
}

static void __internal_cursor_end(struct _text_object_ *pThis)
{
const char *pL;
TEXT_BUFFER *pBuf;


  if(!WBIsValidTextObject(pThis))
  {
    WB_ERROR_PRINT("ERROR:  %p - invalid text object %p\n", __FUNCTION__, pThis);
  }
  else
  {
    int iOldCol = pThis->iCol;

    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pThis->iBlinkState = CURSOR_BLINK_RESET; // this affects the cursor blink, basically resetting it whenever I edit something

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf || pThis->iRow >= pBuf->nEntries)
    {
      pThis->iCol = 0;
    }
    else
    {
      pL = pBuf->aLines[pThis->iRow];

      if(!pL)
      {
        pThis->iCol = 0;
      }
      else
      {
        pThis->iCol = WBGetMBLength(pL);
      }
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject, "%s line %d - empty selection, starting select\n", __FUNCTION__, __LINE__);

        pThis->rctSel.left = iOldCol;
        pThis->rctSel.top = pThis->iRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(pThis->rctView.right > pThis->rctView.left)
    {
      if(pThis->rctView.right <= pThis->iCol ||
         pThis->rctView.left > pThis->iCol)
      {
        if(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.right -= (pThis->rctView.left - pThis->iCol);
          pThis->rctView.left = pThis->iCol;
        }
        else if(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += pThis->iCol + 1 - pThis->rctView.right;
          pThis->rctView.right = pThis->iCol + 1;
        }

        WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - need to optimize invalidate rect\n", __FUNCTION__, __LINE__);

        __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
      }
      else // re-calculate cursor metrics
      {
        pThis->iCursorX += (pThis->iCol - iOldCol) * pThis->iFontWidth;

        __internal_invalidate_cursor(pThis, 1); // invalidate the NEW cursor rectangle
      }
    }
    else
    {
      WB_WARN_PRINT("WARNING:  %s line %d - invalidate entire window rect\n", __FUNCTION__, __LINE__);

      __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here (confusion point)
    }
  }
}

static void __internal_cursor_top(struct _text_object_ *pThis)
{
//TEXT_BUFFER *pBuf;


  if(!WBIsValidTextObject(pThis))
  {
    WB_ERROR_PRINT("ERROR:  %p - invalid text object %p\n", __FUNCTION__, pThis);
  }
  else
  {
    int iOldRow = pThis->iRow;
    int iPageHeight = pThis->rctView.bottom - pThis->rctView.top;

    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pThis->iBlinkState = CURSOR_BLINK_RESET; // this affects the cursor blink, basically resetting it whenever I edit something

    pThis->iRow = 0;
    pThis->iCol = 0;

//    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject, "%s line %d - empty selection, starting select\n", __FUNCTION__, __LINE__);

        pThis->rctSel.left = pThis->iCol;
        pThis->rctSel.top = iOldRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    // force scroll to top
    pThis->rctView.top = 0;
    pThis->rctView.bottom = iPageHeight;

    WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - need to optimize invalidate rect\n", __FUNCTION__, __LINE__);

    __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
  }
}

static void __internal_cursor_bottom(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;


  if(!WBIsValidTextObject(pThis))
  {
    WB_ERROR_PRINT("ERROR:  %p - invalid text object %p\n", __FUNCTION__, pThis);
  }
  else
  {
    int iOldRow = pThis->iRow;
    int iPageHeight = pThis->rctView.bottom - pThis->rctView.top;

    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    pThis->iBlinkState = CURSOR_BLINK_RESET; // this affects the cursor blink, basically resetting it whenever I edit something

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(pBuf)
    {
      pThis->iRow = pBuf->nEntries;  // last line, which has no text
      pThis->iCol = 0;
    }
    else
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_TextObject, "%s line %d - empty selection, starting select\n", __FUNCTION__, __LINE__);

        pThis->rctSel.left = pThis->iCol;
        pThis->rctSel.top = iOldRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    // force scroll to bottom (with an extra line)
    if(!pBuf || iPageHeight > pBuf->nEntries)
    {
      pThis->rctView.top = 0;
      pThis->rctView.bottom = iPageHeight;
    }
    else
    {
      pThis->rctView.top = pBuf->nEntries + 1 - iPageHeight;
      pThis->rctView.bottom = pBuf->nEntries + 1;
    }

    WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - need to optimize invalidate rect\n", __FUNCTION__, __LINE__);

    __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
  }
}

static void __internal_scroll_vertical(struct _text_object_ *pThis, int nRows)
{
TEXT_BUFFER *pBuf;

  if(!WBIsValidTextObject(pThis))
  {
    WB_ERROR_PRINT("ERROR:  %p - invalid text object %p\n", __FUNCTION__, pThis);
  }
  else
  {
//    int iOldRow WB_UNUSED = pThis->iRow; // TODO:  do I still need this assignment?  For now, mark 'unused' and leave for reference

    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_ScrollBar,
                   "%s %d - scroll vertical by %d, iCol=%d\n",
                   __FUNCTION__, __LINE__, nRows, pThis->iCol);

    pThis->iBlinkState = CURSOR_BLINK_RESET; // this affects the cursor blink, basically resetting it whenever I edit something

    if(!nRows)
    {
      return; // do nothing
    }

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;

      pThis->rctView.bottom -= pThis->rctView.top; // assuming it's right
      pThis->rctView.top = 0;
      pThis->rctView.right -= pThis->rctView.left; // assuming it's right
      pThis->rctView.left = 0;
    }
    else if(nRows < 0)
    {
      if(pThis->rctView.top + nRows < 0)
      {
        pThis->rctView.bottom -= pThis->rctView.top;
        pThis->rctView.top = 0;
      }
      else
      {
        pThis->rctView.bottom += nRows;
        pThis->rctView.top += nRows;
      }
    }
    else // if(nRows > 0)
    {
      if(pThis->rctView.bottom + nRows > pBuf->nEntries)
      {
        pThis->rctView.top += pBuf->nEntries - pThis->rctView.bottom;
        pThis->rctView.bottom = pBuf->nEntries;
      }
      else
      {
        pThis->rctView.bottom += nRows;
        pThis->rctView.top += nRows;
      }
    }

    WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - need to optimize invalidate rect\n", __FUNCTION__, __LINE__);

    __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
  }
}

static void __internal_scroll_horizontal(struct _text_object_ *pThis, int nCols)
{
TEXT_BUFFER *pBuf;

  if(!WBIsValidTextObject(pThis))
  {
    WB_ERROR_PRINT("ERROR:  %p - invalid text object %p\n", __FUNCTION__, pThis);
  }
  else
  {
//    int iOldCol WB_UNUSED = pThis->iCol; // TODO:  do I still need this assignment?  For now, mark 'unused' and leave for reference

    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_ScrollBar,
                   "%s %d - scroll horizontal by %d, iCol=%d\n",
                   __FUNCTION__, __LINE__, nCols, pThis->iCol);

    pThis->iBlinkState = CURSOR_BLINK_RESET; // this affects the cursor blink, basically resetting it whenever I edit something

    if(!nCols)
    {
      return; // do nothing
    }

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;

      pThis->rctView.bottom -= pThis->rctView.top; // assuming it's right
      pThis->rctView.top = 0;
      pThis->rctView.right -= pThis->rctView.left; // assuming it's right
      pThis->rctView.left = 0;
    }
    else if(pThis->iCol < 0)
    {
      pThis->iCol = 0; // always

      pThis->rctView.right -= pThis->rctView.left; // assuming it's right
      pThis->rctView.left = 0;
    }
    else if(pThis->iCol + nCols > -INT_MAX && pThis->iCol + nCols < INT_MAX) // for now, ignore scroll on overflow
    {
      if(pThis->iLineFeed == LineFeed_NONE) // single line
      {
        if(pBuf->nEntries <= 0 || !pBuf->aLines[0])
        {
          pThis->iCol = 0;

          pThis->rctView.right -= pThis->rctView.left; // assuming it's right
          pThis->rctView.left = 0;
        }
        else
        {
          int iLen = WBGetMBLength(pBuf->aLines[0]);

          if(pThis->iRow != 0)
          {
            pThis->iRow = 0; // force it
          }

          // no 'virtual space' for single-line but trailing white space OK
          if(nCols > 0)
          {
            if(pThis->rctView.right + nCols > iLen + 1)
            {
              pThis->rctView.left += (iLen + 1 - nCols - pThis->rctView.right);
              pThis->rctView.right = iLen + 1;
            }
            else
            {
              pThis->rctView.left += nCols;
              pThis->rctView.right += nCols;
            }
          }
          else
          {
            if(pThis->rctView.left + nCols < 0)
            {
              pThis->rctView.right -= pThis->rctView.left;
              pThis->rctView.left = 0;
            }
            else
            {
              pThis->rctView.left += nCols;
              pThis->rctView.right += nCols;
            }
          }
        }
      }
      else
      {
        if(nCols > 0)
        {
          pThis->rctView.left += nCols; // scroll right always
          pThis->rctView.right += nCols;
        }
        else
        {
          if(pThis->rctView.left + nCols < 0)
          {
            pThis->rctView.right -= pThis->rctView.left;
            pThis->rctView.left = 0;
          }
          else
          {
            pThis->rctView.left += nCols;
            pThis->rctView.right += nCols;
          }
        }
      }
    }

    WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - need to optimize invalidate rect\n", __FUNCTION__, __LINE__);

    __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
  }
}


#if 0
static XFontSet __attribute__((noinline)) __internal_verify_get_fontset(Display *pDisplay, XFontSet rFontSet, WBGC gc)
{
XFontSet fSet;

  if(rFontSet == None) /* NULL? */
  {
    WB_FONT pFont = WBQueryGCFont(pDisplay, gc);

    if(!pFont)
    {
      WB_ERROR_PRINT("%s - ERROR:  WBQueryGCFont returns NULL\n", __FUNCTION__);

      return None; // bad
    }

    fSet = WBFontSetFromFont(pDisplay, pFont); // convert font to font set

    XFreeFont(pDisplay, pFont); // free it now (important to do so)
    pFont = NULL;

    if(fSet == None)
    {
      WB_ERROR_PRINT("%s - ERROR:  WBFontSetFromFont returns None\n", __FUNCTION__);
    }
  }
  else
  {
    fSet = rFontSet;
  }

  return fSet;
}
#endif // 0

#if 0
int __attribute__((noinline)) __internal_get_fontset_count_and_max_asc_desc(XFontSet fSet, int *pAsc, int *pDesc)
{
int nFonts, i1, iAsc, iDesc;
XFontStruct **ppFonts = NULL;
char **ppNames = NULL;

  nFonts = XFontsOfFontSet(fSet, &ppFonts, &ppNames); // returns # of items (do NOT free resources!  They are owned by the font set)

  if(nFonts <= 0 || !ppFonts)
  {
    return -1;
  }

  for(i1=0, iAsc=0, iDesc=0; i1 < nFonts; i1++)
  {
    if(iAsc < ppFonts[i1]->ascent)
    {
      iAsc = ppFonts[i1]->ascent;
    }
    if(iDesc < ppFonts[i1]->descent)
    {
      iDesc = ppFonts[i1]->descent;
    }
  }

  if(pAsc)
  {
    *pAsc = iAsc;
  }

  if(pDesc)
  {
    *pDesc = iDesc;
  }

  return nFonts;
}
#endif // 0

static void __internal_do_expose(struct _text_object_ *pThis, Display *pDisplay, Window wID,
                                 WBGC gc, const WB_GEOM *pPaintGeom, const WB_GEOM *pViewGeom,
                                 WB_FONTC pFont)
{
TEXT_BUFFER *pBuf = NULL;
WB_GEOM geomV, geomP, geomC;
char *pL = NULL;
int iXDelta, iYDelta;
int i1, iLen, iFontHeight, iFontWidth, iAsc, iDesc, iX, iY, iPX, iPY;
//int nFonts;
//XFontSet fSet;
Pixmap pxTemp;
unsigned long clrFG, clrBG, clrHFG, clrHBG;
WBGC gc2 = None;
WB_RECT rctSel; // the NORMALIZED selection rectangle (calculated)
int nEntries, iAutoScrollWidth, iWindowHeightInLines;


  if(!WBIsValidTextObject(pThis))
  {
    WB_ERROR_PRINT("ERROR:  %s - text object %p not valid\n", __FUNCTION__, pThis);
    return;
  }

  WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_TextObject,
                 "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                 __FUNCTION__, __LINE__,
                 pThis->iRow, pThis->iCol,
                 pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

  iXDelta = iYDelta = 0; // make sure, as they're used in a few places

  if(pViewGeom)
  {
    memcpy(&geomV, pViewGeom, sizeof(geomV));
  }
  else
  {
    WBGetWindowGeom(wID, &geomV);

    geomV.x = geomV.y = 0; // ALWAYS (make sure) - it's client coords now

    if(geomV.height <= MIN_BORDER_SPACING * 4)   // absolute minimum height
    {
      return; // can't do window that's way too small
    }

    geomV.y += MIN_BORDER_SPACING;           // need a minimum top/bottom border as well
    geomV.height -= MIN_BORDER_SPACING * 2;
  }

//  WB_ERROR_PRINT("TEMPORARY:  %s.%d  window geometry:  %d, %d, %d, %d\n",
//                  __FUNCTION__, __LINE__, geomV.x, geomV.y, geomV.width, geomV.height);

  if(geomV.width <= MIN_BORDER_SPACING * 4)  // absolute minimum width
  {
    return; // can't do window that's way too small
  }

  // in all cases, make room on right/left edges for the cursor

  geomV.x += MIN_BORDER_SPACING; // required for cursor
  geomV.width -= MIN_BORDER_SPACING * 2;

  // TODO:  make use of geomV's "border" parameter??

  if(pPaintGeom)
  {
    memcpy(&geomP, pPaintGeom, sizeof(geomP));
  }
  else
  {
    memcpy(&geomP, &geomV, sizeof(geomP));
  }

//  fSet = __internal_verify_get_fontset(pDisplay, rFontSet, gc);
//  // NOTE:  at this point I must use 'fSet' to do all of the font metrics + drawing
//
//
//  // NOTE:  to find the floor of the font, I'll need to determine max iAsc and iDesc
//  //        this next function call tells me how many fonts I have, and determines the
//  //        max ascent and descent and stores that in iAsc and iDesc
//  nFonts = __internal_get_fontset_count_and_max_asc_desc(fSet, &iAsc, &iDesc);

  iAsc = 0;
  iDesc = 0;

  if(!pFont)
  {
    // TODO:  optimize this with cached information so it goes faster, and have
    //        some 'font query' APIs for the GC as well

    pFont = WBQueryGCFont(gc); // TODO:  optimize this

    if(!pFont)
    {
      pFont = WBGetDefaultFont();
    }
  }

  if(pFont)
  {
    iAsc  = WBFontAscent(pFont);
    iDesc  = WBFontDescent(pFont);

//    WB_ERROR_PRINT("TEMPORARY:  %s.%d  font ascent=%d, descent=%d\n", __FUNCTION__, __LINE__, iAsc, iDesc);
  }
  else
  {
    WB_ERROR_PRINT("%s - ERROR:  no fonts!\n", __FUNCTION__);

    goto the_end;
  }

  // TODO:  XFontStruct::direction indicates LTR RTL TTB or BTT for painting - for now _ONLY_ LTR_TTB will apply


  // NOW get the font width for a space (TODO:  average char width instead?)
  iFontWidth = WBFontAvgCharWidth(pFont); // WBTextWidth(pFont, " ", 1); // WB_TEXT_ESCAPEMENT(fSet, " ", 1);

  // get FG/BG color information
  clrFG = WBGetGCFGColor(gc);
  clrBG = WBGetGCBGColor(gc);

  // TODO:  compare clrHFG and clrHBG to a "NULL" XColor?
  if(!(pThis->clrHFG.flags & (DoRed | DoGreen | DoBlue)) && //!memcmp(&pThis->clrHFG, &pThis->clrHBG, sizeof(XColor)))
     !(pThis->clrHFG.flags & (DoRed | DoGreen | DoBlue)))   // the colors have not been assigned
  {
    clrHBG = clrFG;
    clrHFG = clrBG;
  }
  else
  {
    clrHBG = pThis->clrHBG.pixel;
    clrHFG = pThis->clrHFG.pixel;
  }

  // make a copy of the WBGC since I'm probably going to mess with it

  gc2 = WBCreateGC(pDisplay, wID, 0, NULL);

  if(gc2 != None)
  {
    if(!WBCopyGC2(gc, GCAll, gc2))
    {
      WBFreeGC(gc2);
      gc2 = None;
    }
  }

  // font metrics complete. Now THAT wasn't so bad, was it?  OK it was but only need to do it here

  // cache the owner window ID
  pThis->wIDOwner = wID;

  // cache the font metrics
  pThis->iAsc = iAsc;
  pThis->iDesc = iDesc;

  pThis->iMaxFontWidth = WBFontMaxCharWidth(pFont);
  pThis->iFontWidth = iFontWidth;

#warning support proportional pitch fonts by assigning a font width < 0 ???  For now only fixed-pitch are supported by this object

  // keep track of the total viewport in window coordinates.
  // this will be used later for mouse translation

  pThis->rctWinView.left = geomV.x;
  pThis->rctWinView.top  = geomV.y;
  pThis->rctWinView.right = pThis->rctWinView.left + geomV.width;
  pThis->rctWinView.bottom = pThis->rctWinView.top + geomV.height;

  // cache the pointer to the TEXT BUFFER
  pBuf = (TEXT_BUFFER *)(pThis->pText);

  // NOTE:  in the next sections, deal with NULL pBuf by cacheing 'nEntries'

  if(!pBuf || pBuf->nEntries <= 0)   // also test for this condition and treat it as single-line also (temporary)
  {
    nEntries = 0;
  }
  else
  {
    nEntries = pBuf->nEntries;
  }


  // ------------------------------------------
  // CALCULATING THE CORRECT VIEWPORT (rctView)
  // ------------------------------------------
  //
  // NOTE:  if the owning window has reset the viewport, the entire window SHOULD
  //        be invalid.  If not, it won't paint properly.

  if(pThis->iLineFeed == LineFeed_NONE) // SINGLE LINE
  {
//    WB_ERROR_PRINT("TEMPORARY:  %s.%d single line text object expose\n", __FUNCTION__, __LINE__);

    // AUTO-ASSIGN the viewport whenever right <= left (i.e. viewport is 'NULL' or 'empty')
    // or whenever the viewport is not properly assigned (window re-size re-paint)

    iFontHeight = iAsc + iDesc; // does not include interline spacing (that comes later for multi-line only)

//    WB_ERROR_PRINT("TEMPORARY:  %s.%d  font height=%d\n", __FUNCTION__, __LINE__, iFontHeight);

    if(pThis->rctView.top || pThis->rctView.bottom ||
       pThis->rctView.right != pThis->rctView.left + geomV.width / iFontWidth) // not PROPERLY assigned
    {
      iAutoScrollWidth = AUTO_HSCROLL_SIZE;

      if(pThis->rctView.left < 0) // not already assigned
      {
        pThis->rctView.left = 0;
      }

      pThis->rctView.top = pThis->rctView.bottom = 0; // single line forces this (always)

      pThis->rctView.right = pThis->rctView.left + geomV.width / iFontWidth;

      if(pThis->rctView.right > pThis->rctView.left)
      {
        while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
        {
          iAutoScrollWidth >>= 1;
        }

        // scroll right to expose the cursor

        while(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += iAutoScrollWidth;
          pThis->rctView.right += iAutoScrollWidth;
        }
      }
      else
      {
        pThis->rctView.right = pThis->rctView.left = pThis->iCol; // desperate to have something there
      }
    }
  }
  else                                  // MULTI-LINE
  {
//    WB_ERROR_PRINT("TEMPORARY:  %s.%d multi-line text object expose\n", __FUNCTION__, __LINE__);

    // adjust font height to include line spacing (I'll use this to position the lines)

    iFontHeight = WBTextObjectCalculateLineHeight(pThis->iAsc, pThis->iDesc);

    iWindowHeightInLines = geomV.height / iFontHeight; // window height (in lines)
    if(!iWindowHeightInLines)
    {
      iWindowHeightInLines = 1; // just in case so I don't divide by zero
    }

    // AUTO-ASSIGN the viewport whenever right <= left (i.e. viewport is 'NULL' or 'empty')
    // or whenever the viewport is not properly assigned (window re-size re-paint)

    if(pThis->rctView.right - pThis->rctView.left
          != geomV.width / iFontWidth                   // viewport needs re-calculation
       || pThis->rctView.bottom - pThis->rctView.top
          != iWindowHeightInLines                       // viewport needs re-calculation
       || pThis->rctView.top > nEntries)          // top exceeds total # of lines
    {
      iAutoScrollWidth = AUTO_HSCROLL_SIZE;

      if(pThis->rctView.left < 0) // not already assigned
      {
        pThis->rctView.left = 0;
      }

      if(pThis->rctView.top < 0 || pThis->rctView.top > nEntries
         || (pThis->rctView.top && nEntries < iWindowHeightInLines))
      {
        pThis->rctView.top = 0; // set viewport to top
      }

      if(pThis->rctView.bottom - pThis->rctView.top
          != iWindowHeightInLines)
      {
        pThis->rctView.bottom = pThis->rctView.top + iWindowHeightInLines;

        // always scroll row into view

        while(pThis->rctView.top > pThis->iRow)
        {
          pThis->rctView.top -= iWindowHeightInLines - 1;
          pThis->rctView.bottom -= iWindowHeightInLines - 1;
        }
        while(pThis->rctView.bottom <= pThis->iRow)
        {
          pThis->rctView.top += iWindowHeightInLines - 1;
          pThis->rctView.bottom += iWindowHeightInLines - 1;
        }
      }

      if(pThis->rctView.right - pThis->rctView.left != geomV.width / iFontWidth)
      {
        pThis->rctView.right = pThis->rctView.left + geomV.width / iFontWidth;

        if(pThis->rctView.right > pThis->rctView.left) // just in case, test it
        {
          while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
          {
            iAutoScrollWidth >>= 1;
          }

          // scroll right to expose the cursor

          while(pThis->rctView.right <= pThis->iCol)
          {
            pThis->rctView.left += iAutoScrollWidth;
            pThis->rctView.right += iAutoScrollWidth;
          }
        }
        else
        {
          pThis->rctView.right = pThis->rctView.left = pThis->iCol; // desperate to have something there
        }
      }
    }
  }


  //--------------------------------------------------------------------------
  // convert the highlight rectangle into screen coordinates (fills in rctSel)
  //--------------------------------------------------------------------------

  if(!SEL_RECT_EMPTY(pThis))
  {
    if(SEL_RECT_ALL(pThis))
    {
      memcpy(&rctSel, &(pThis->rctView), sizeof(rctSel)); // use entire viewport for hightlight rect
      // TODO:  single-line, only select to end of string?

//      WB_ERROR_PRINT("TEMPORARY:  %s.%d select rect is 'select all' - font height %d\n", __FUNCTION__, __LINE__, iFontHeight);
    }
    else
    {
      memcpy(&rctSel, &(pThis->rctSel), sizeof(rctSel));
      NORMALIZE_SEL_RECT(rctSel);

//      WB_ERROR_PRINT("TEMPORARY:  %s.%d select rectangle not empty - font height %d\n", __FUNCTION__, __LINE__, iFontHeight);
    }

    pThis->rctHighLight.left = pThis->rctWinView.left
                             + (rctSel.left - pThis->rctView.left) * iFontWidth;

    pThis->rctHighLight.top  = pThis->rctWinView.top
                             + (rctSel.top - pThis->rctView.top) * iFontHeight;

    if(pThis->iLineFeed == LineFeed_NONE)
    {
      if(geomV.height >= iAsc + iDesc)
        pThis->rctHighLight.top += (geomV.height - (iAsc + iDesc)) / 2; // since single-line text is centered
    }

    pThis->rctHighLight.right = pThis->rctHighLight.left
                              + (rctSel.right - rctSel.left) * iFontWidth;

    pThis->rctHighLight.bottom = pThis->rctHighLight.top // NOTE add 1 to # of lines, always
                              + (rctSel.bottom - rctSel.top + 1) * iFontHeight;

    // NOTE:  this is independent of the selection method.  In the special case
    //        that a single line or an entire line is selected, I may have
    //        to handle this differently

//    WB_ERROR_PRINT("TEMPORARY:  %s.%d select rect: %d, %d, %d, %d  of  %d, %d, %d, %d\n",
//                   __FUNCTION__, __LINE__,
//                   rctSel.left, rctSel.top, rctSel.right, rctSel.bottom,
//                   pThis->rctView.left, pThis->rctView.top, pThis->rctView.right, pThis->rctView.bottom);
//
//    WB_ERROR_PRINT("TEMPORARY:  %s.%d highlight rect: %d, %d, %d, %d  of  %d, %d, %d, %d\n",
//                   __FUNCTION__, __LINE__,
//                   pThis->rctHighLight.left, pThis->rctHighLight.top, pThis->rctHighLight.right, pThis->rctHighLight.bottom,
//                   pThis->rctWinView.left, pThis->rctWinView.top, pThis->rctWinView.right, pThis->rctWinView.bottom);



//    WB_ERROR_PRINT("TEMPORARY:  %s.%d   geomV.height = %d   FG/BG colors  %08lxH %08lxH    %08lxH %08lxH\n",
//                   __FUNCTION__, __LINE__, geomV.height,
//                   (unsigned long)clrFG, (unsigned long)clrBG, (unsigned long)clrHFG, (unsigned long)clrHBG);
  }
  else
  {
    bzero(&rctSel, sizeof(rctSel)); // zero out selection rectangle
    bzero(&(pThis->rctHighLight), sizeof(pThis->rctHighLight));

//    WB_ERROR_PRINT("TEMPORARY:  %s.%d select rectangle *EMPTY*\n", __FUNCTION__, __LINE__);
  }


  //--------------------------------------------
  // CREATE PIXMAP (for speeding up the process)
  //--------------------------------------------

  iPX = pThis->rctWinView.right - pThis->rctWinView.left + 2 * MIN_BORDER_SPACING;
  iPY = pThis->rctWinView.bottom - pThis->rctWinView.top + 2 * MIN_BORDER_SPACING;

//    WB_DEBUG_PRINT(DebugLevel_Verbose, "%s window %u (%08xH) pixmap dimensions %d,%d\n"
//                   "            row/col %d,%d\n",
//                   __FUNCTION__, (int)wID, (int)wID, iPX, iPY,
//                   pThis->iRow, pThis->iCol);

  if(gc2 != None && iPX > 0 && iPY > 0)
  {
    pxTemp = XCreatePixmap(pDisplay, wID, iPX, iPY,
                           DefaultDepth(pDisplay, DefaultScreen(pDisplay)));
  }
  else
  {
    pxTemp = None;
  }

  //-----------------------
  // FILL/ERASE BACKGROUND
  //-----------------------

  if(pxTemp != None)
  {
    iXDelta = geomV.x - MIN_BORDER_SPACING;
    iYDelta = geomV.y - MIN_BORDER_SPACING;

    // sometimes the clipping origin, when filling the background, might matter, especially if patterns are involved
    WBSetClipOrigin(gc2, -iXDelta, -iYDelta);  // so that it matches the display's clipping in gc

    WBSetForeground(gc2, clrBG);
    WBFillRectangle(pDisplay, pxTemp, gc2, 0, 0, iPX, iPY);

    WBSetForeground(gc2, clrFG);
  }
  else // FALLBACK, if no pixmap, go to window directly
  {
    iXDelta = 0;
    iYDelta = 0; // make sure, as they're used in a few places

    WBSetForeground(gc, clrBG);
    WBFillRectangle(pDisplay, wID, gc,
                    pThis->rctWinView.left,
                    pThis->rctWinView.top,
                    pThis->rctWinView.right - pThis->rctWinView.left,
                    pThis->rctWinView.bottom - pThis->rctWinView.top);

    WBSetForeground(gc, clrFG);
  }

//  WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - iXDelta is %d, iYDelta is %d\n", __FUNCTION__, __LINE__, iXDelta, iYDelta);

  // At this point, if pBuf is NULL or the # of entries zero, the background is *STILL* erased
  // and the cursor has to be drawn.

//  if(!pBuf || pBuf->nEntries <= 0)
//  {
////      WB_DEBUG_PRINT(DebugLevel_Verbose, "%s - no text\n", __FUNCTION__);
//    goto almost_the_end; // I use the goto so I can put cleanup code there - it's safer
//  }


  // if it's a single-line object, center it within the window and display only ONE line

  if(pThis->iLineFeed == LineFeed_NONE) // i.e. SINGLE LINE
  {
    ///////////////////////
    // SINGLE LINE PAINTING
    ///////////////////////

    iY = geomV.height - iFontHeight;
    if(iY < 0) // when this happens it screws the calculation up
    {
      iY = 0;
    }

    // calculate a Y position that's essentially centered within the single-line display area

    iY = geomV.y + iY / 2 + iAsc; // iY is now "the baseline" for the font, where it needs to be drawn
    iX = geomV.x;

    if(pBuf)
    {
      pL = pBuf->aLines[0];
    }
    else
    {
      pL= NULL;
    }

//    if(!pL)
//    {
//      goto the_end;
//    }


    //-----------------------------
    // DRAWING HIGHLIGHT RECTANGLE
    //-----------------------------

    if(pThis->rctHighLight.right > pThis->rctHighLight.left &&
       WBRectOverlapped(pThis->rctHighLight, pThis->rctWinView))
    {
      if(pxTemp != None)
      {
        // NOTE:  iXDelta and iYDelta were calculated before, when background was erased
        //        and the clip origin was also assigned for gc2
//          XSetClipOrigin(pDisplay, gc2, -iXDelta, -iYDelta);  // so that it matches the display's clipping in gc

        WBSetForeground(gc2, clrHBG); // highlight background color

        WBFillRectangle(pDisplay, pxTemp, gc2,
                        pThis->rctHighLight.left - iXDelta,
                        pThis->rctHighLight.top - iYDelta,
                        pThis->rctHighLight.right - pThis->rctHighLight.left,
                        pThis->rctHighLight.bottom - pThis->rctHighLight.top);

        WBSetForeground(gc2, clrFG);
      }
      else // FALLBACK, if no pixmap, go to window directly
      {
        WBSetForeground(gc, clrHBG); // highlight background color

        WBFillRectangle(pDisplay, wID, gc,
                        pThis->rctHighLight.left,
                        pThis->rctHighLight.top,
                        pThis->rctHighLight.right - pThis->rctHighLight.left,
                        pThis->rctHighLight.bottom - pThis->rctHighLight.top);

        WBSetForeground(gc, clrFG);
      }
    }

    //---------------------------------------
    // DRAW the text and the vertical cursor
    //---------------------------------------

    if(pL)
    {
      iLen = WBGetMBLength(pL);
    }
    else
    {
      iLen = 0;
    }

    pThis->iCursorX = pThis->iCursorY = pThis->iCursorHeight = 0; // to indicate "not drawn"

    for(i1=pThis->rctView.left; i1 < pThis->rctView.right; i1++, iX += iFontWidth)
    {
      WB_RECT rctChar, rctCursor;

      if(i1 == pThis->iCol) // display the cursor (NOTE:  row ALWAYS matches)
      {
        pThis->iCursorX = iX - 1;

        if(pThis->iInsMode == InsertMode_OVERWRITE)
        {
          pThis->iCursorY = iY + iDesc + 1;
          pThis->iCursorHeight = 1;

          rctCursor.left = pThis->iCursorX - iXDelta;
          rctCursor.top = pThis->iCursorY - iYDelta;
          rctCursor.right = pThis->iCursorX + iFontWidth - iXDelta;
          rctCursor.bottom = pThis->iCursorY - iYDelta;
        }
        else // INSERT mode cursor
        {
          pThis->iCursorY = iY - iAsc - 1;
          pThis->iCursorHeight = iY + iDesc + 1 - pThis->iCursorY;

          rctCursor.left = pThis->iCursorX - iXDelta;
          rctCursor.top = pThis->iCursorY - iYDelta;
          rctCursor.right = pThis->iCursorX - iXDelta;
          rctCursor.bottom = pThis->iCursorY + pThis->iCursorHeight - iYDelta;
        }


        if(__internal_cursor_show(pThis->iBlinkState)) // do I draw the horizontal cursor for overwrite?
        {
          if(WBRectOverlapped(rctCursor, pThis->rctHighLight))
          {
            WBSetForeground(gc2 != None ? gc2 : gc, clrHFG);
            WBSetBackground(gc2 != None ? gc2 : gc, clrHBG);
          }
          else
          {
            WBSetForeground(gc2 != None ? gc2 : gc, clrFG);
            WBSetBackground(gc2 != None ? gc2 : gc, clrBG);
          }

          WBDrawLine(pDisplay, pxTemp != None ? pxTemp : wID,
                     gc2 != None ? gc2 : gc,
                     rctCursor.left, rctCursor.top, rctCursor.right, rctCursor.bottom);
        }
      }

      rctChar.top = iY - iAsc;
      rctChar.bottom = iY + iDesc;
      rctChar.left = iX + 1;
      rctChar.right = iX + iFontWidth - 1; // since I'm checking overlap, make it a bit 'skinnier'

      if(WBRectOverlapped(rctChar, pThis->rctHighLight))
      {
        WBSetForeground(gc2 != None ? gc2 : gc, clrHFG);
        WBSetBackground(gc2 != None ? gc2 : gc, clrHBG);
      }
      else
      {
        WBSetForeground(gc2 != None ? gc2 : gc, clrFG);
        WBSetBackground(gc2 != None ? gc2 : gc, clrBG);
      }

      // for NOW, draw one character at a time. But make sure it's within
      // the invalid region first...

      geomC.x = iX;
      geomC.y = iY; // TODO:  for single line, move this and the next 2 outside the loop?
      geomC.width = iFontWidth;
      geomC.height = iFontHeight;

      if(pL && i1 < iLen) // NOTE:  pL can be NULL, but iLen should be zero - test anyway
      {
        if(WBGeomOverlapped(geomC, geomP)) // only if the character's geometry overlaps the paint geometry
        {
          int iLen2;
          const char *p1 = WBGetMBCharPtr(pL, i1, &iLen2);

          if(p1 && iLen2 > 0)
          {
            DTDrawString(pDisplay, pxTemp ? pxTemp : wID, pFont,
                         gc2 != None ? gc2 : gc,
                         iX - iXDelta, iY - iYDelta, p1, iLen2);
          }
        }
      }
      else if(i1 > pThis->iCol)
      {
        break; // slight optimization
      }
    }
  }
  else // MULTI-LINE
  {
    int iCurRow; // my counter

    //////////////////////
    // MULTI LINE PAINTING
    //////////////////////

    // 3 different important conditions that affect painting:
    // 1.  the cursor is (or is not) on this row
    // 2.  the row has highlighting in it
    // 3.  if 2, the row is either fully or partially highlighted

    // if 1 and 2 are FALSE, paint the string 'as-is' with DTDrawString
    // if 2 is TRUE, but 3 is false, paint the entire line "highlighted".
    // otherwise, duplicate (for this row) what single-line painting does,
    // dealing with cursor and highlight rectangles as needed, 1 char at a time

    pThis->iCursorX = pThis->iCursorY = pThis->iCursorHeight = 0; // to indicate "not drawn"

    for(iCurRow=pThis->rctView.top; iCurRow <= nEntries && iCurRow <= pThis->rctView.bottom; iCurRow++)
    {
      int bHighlight = 0;

      // NOTE:  geomV already has 'border spacing' taken into account

      iY = geomV.y + iFontHeight * (iCurRow - pThis->rctView.top)
         + iAsc; // add the ascent to the top of the text to get "the baseline" for the font

      iX = geomV.x;

      if(pBuf && iCurRow < nEntries) // 'nEntries' was cached from before
      {
        pL = pBuf->aLines[iCurRow];
      }
      else
      {
        pL = NULL;
      }

      if(pL)
      {
        iLen = WBGetMBLength(pL); // length in "characters"
      }
      else
      {
        iLen = 0;
      }

      // if the row might be highlighted, it will be within 'rctSel', which can
      // span multiple lines.  It identifies the starting and ending row/col combo, but in pixels.

      if((rctSel.left != rctSel.right || rctSel.top != rctSel.bottom) && // has a selection
         iCurRow >= pThis->rctSel.top &&         // row is in range below or equal to 'top'
         (iCurRow < pThis->rctSel.bottom ||      // above 'last' row
          (iCurRow == pThis->rctSel.bottom && pThis->rctSel.right > 0))) // last row but has column > 0
      {
        bHighlight = 1; // flag for later
      }

      if(iCurRow == pThis->iRow ||            // current row is cursor row
         (bHighlight &&                       // I am highlighting this row AND
          (iCurRow == pThis->rctSel.top ||    // it's the starting row for highlight
           iCurRow == pThis->rctSel.bottom))) // it's the ending row for highlight
      {
        for(i1=pThis->rctView.left; i1 <= pThis->rctView.right; i1++, iX += iFontWidth)
        {
          WB_RECT rctCursor;
          int iLen2;
          const char *p1;

          if(pL && i1 < iLen)
          {
            p1 = WBGetMBCharPtr(pL, i1, &iLen2);
          }
          else
          {
            p1 = NULL; // past end of string
          }

          if(bHighlight &&
             ((iCurRow > pThis->rctSel.top &&
               iCurRow < pThis->rctSel.bottom) ||
              (iCurRow == pThis->rctSel.top &&
               i1 >= pThis->rctSel.left &&
               (i1 < pThis->rctSel.right || iCurRow != pThis->rctSel.bottom)) ||
              (iCurRow == pThis->rctSel.bottom && i1 < pThis->rctSel.right)))
          {
            int iY0 = iY - iAsc; // NOTE:  iY is the BASE of the font, so I need to font ascent to get top of rect

            // fill the rectangle for this character with the correct background color.

            if(pxTemp != None)
            {
              WBSetForeground(gc2, clrHBG); // highlight background color
              WBSetBackground(gc2, clrHBG);

              WBFillRectangle(pDisplay, pxTemp, gc2,
                              iX - iXDelta, iY0 - iYDelta,
                              iFontWidth, iFontHeight);

              WBSetForeground(gc2, clrHFG);
            }
            else // FALLBACK, if no pixmap, go to window directly
            {
              WBSetForeground(gc, clrHBG); // highlight background color
              WBSetBackground(gc, clrHBG);

              WBFillRectangle(pDisplay, wID, gc,
                              iX, iY0,
                              iFontWidth, iFontHeight);

              WBSetForeground(gc, clrHFG);
            }
          }
          else // non-highlighted character
          {
            WBSetForeground(gc2 != None ? gc2 : gc, clrFG);
            WBSetBackground(gc2 != None ? gc2 : gc, clrBG);
          }


          //------------
          // draw cursor
          //------------

          if(iCurRow == pThis->iRow && i1 == pThis->iCol) // display the cursor (matching row/col)
          {
            pThis->iCursorX = iX - 1;

            if(pThis->iInsMode == InsertMode_OVERWRITE)  // NOTE:  horizontal cursor for overwrite
            {
              int iY0 = iY + iDesc + 1;

              // there WAS a bizarre compile error here, optimizing sub-expressions incorrectly, maybe

              pThis->iCursorY = iY0;
              pThis->iCursorHeight = 1;

              rctCursor.left = pThis->iCursorX - iXDelta;
              rctCursor.top = iY0 - iYDelta;
              rctCursor.right = pThis->iCursorX + iFontWidth - iXDelta;
              rctCursor.bottom = rctCursor.top;

//                WB_DEBUG_PRINT(DebugLevel_Verbose, "%s - iX=%d, iY=%d A=%d,D=%d dX=%d, dY=%d  cursor %d,%d  %d,%d,%d,%d\n", __FUNCTION__,
//                               iX, iY, iAsc, iDesc, iXDelta, iYDelta,
//                               pThis->iCursorX, pThis->iCursorY,
//                               rctCursor.left, rctCursor.top, rctCursor.right, rctCursor.bottom);
            }
            else // INSERT mode cursor (normally will be this)
            {
              int iY0 = iY - iAsc - 1;
              int iY1 = iY + iDesc + 1;

              pThis->iCursorY = iY0;
              pThis->iCursorHeight = iY1 - iY0;

              rctCursor.left = pThis->iCursorX - iXDelta;
              rctCursor.top = iY0 - iYDelta;
              rctCursor.right = rctCursor.left;
              rctCursor.bottom = iY1 - iYDelta;
            }

            if(__internal_cursor_show(pThis->iBlinkState)) // do I draw the cursor?
            {
              WBDrawLine(pDisplay, pxTemp != None ? pxTemp : wID,
                         gc2 != None ? gc2 : gc,
                         rctCursor.left, rctCursor.top, rctCursor.right, rctCursor.bottom);
            }

//              WB_DEBUG_PRINT(DebugLevel_Verbose, "%s - cursor x,y = %d,%d\n", __FUNCTION__, pThis->iCursorX, pThis->iCursorY);
          }
//            else
//            {
//              WB_DEBUG_PRINT(DebugLevel_Verbose, "%s - pThis->iRow=%d,iCol=%d,iCurRow=%d,i1=%d\n",
//                             __FUNCTION__, pThis->iRow, pThis->iCol, iCurRow, i1);
//            }


          if(p1 && iLen2 > 0)
          {
            DTDrawString(pDisplay, pxTemp ? pxTemp : wID, pFont,
                         gc2 != None ? gc2 : gc,
                         iX - iXDelta, iY - iYDelta, p1, iLen2);
          }
        }
      }
      else if(pL) // current row is NOT cursor row (and line is not blank)
      {
        const char *p1 = WBGetMBCharPtr(pL, pThis->rctView.left, NULL);
        const char *p2 = WBGetMBCharPtr(pL, pThis->rctView.right, NULL);

        if(bHighlight)
        {
          int iY0 = iY - iAsc; // NOTE:  iY is the BASE of the font, so I need to font ascent to get top of rect

          if(pxTemp != None)
          {
            WBSetForeground(gc2, clrHBG); // highlight background color
            WBSetBackground(gc2, clrHBG);

            WBFillRectangle(pDisplay, pxTemp, gc2,
                            iX - iXDelta, iY0 - iYDelta,
                            geomV.width, iFontHeight);  // entire line

            WBSetForeground(gc2, clrHFG);
          }
          else // FALLBACK, if no pixmap, go to window directly
          {
            WBSetForeground(gc, clrHBG); // highlight background color
            WBSetBackground(gc, clrHBG);

            WBFillRectangle(pDisplay, wID, gc,
                            iX, iY0,
                            geomV.width, iFontHeight);  // entire line

            WBSetForeground(gc, clrHFG);
          }
        }
        else
        {
          WBSetForeground(gc2 != None ? gc2 : gc, clrFG);
          WBSetBackground(gc2 != None ? gc2 : gc, clrBG);
        }

        if(p1 && p1 && p2 > p1)
        {
          DTDrawString(pDisplay, pxTemp ? pxTemp : wID, pFont,
                       gc2 != None ? gc2 : gc,
                       iX - iXDelta, iY - iYDelta,
                       p1, p2 - p1);
        }
//          else  (this happens when lines are blank)
//          {
//            WB_DEBUG_PRINT(DebugLevel_Verbose, "%s - NOT drawing \"%s\"\n          p1=%p  p2=%p  delta=%d\n",
//                           __FUNCTION__, pL, p1, p2, (int)(p2 - p1));
//          }
      }
    }
  }

  //------------------------------------------
  // PIXMAP OPTIMIZATION - TRANSFER TO WINDOW
  //------------------------------------------

//almost_the_end:

  if(pxTemp != None) // OPTIMIZATION (using pixmap)
  {
    int iX0=0, iY0=0, iW0=iPX, iH0=iPY;

    iX = pThis->rctWinView.left - MIN_BORDER_SPACING;
    iY = pThis->rctWinView.top - MIN_BORDER_SPACING;

    // only copy the invalid area (this should save some time)

    if(geomP.x > iX)
    {
      iX0 = geomP.x - iX;
      iW0 -= iX0;
      iX = geomP.x;
    }

    if(geomP.x + geomP.width < iX + iW0)
    {
      iW0 = geomP.x + geomP.width - iX;
    }

    if(geomP.y > iY)
    {
      iY0 = geomP.y - iY;
      iH0 -= iY0;
      iY = geomP.y;
    }

    if(geomP.y + geomP.height < iY + iH0)
    {
      iH0 = geomP.y + geomP.height - iY;
    }

    if(iH0 > 0 && iW0 > 0)
    {
      XCopyArea(pDisplay, pxTemp, wID, gc->gc, // this time use GC to do the copy
                iX0, iY0, iW0, iH0, iX, iY);
    }

    XFreePixmap(pDisplay, pxTemp);
  }


the_end:

  // mandatory resource free-up goes here, hence the 'goto' label

  if(gc2 != None)
  {
    WBFreeGC(gc2);
  }
}

static int __internal_cursor_show(int iBlinkState) // determines if blink state shows the cursor
{
  return iBlinkState != CURSOR_BLINK_OFF ? 1 : 0;
}

static void __internal_cursor_blink(struct _text_object_ *pThis, int bHasFocus)
{
  if(WBIsValidTextObject(pThis))
  {
    int bShow = __internal_cursor_show(pThis->iBlinkState);

    WB_DEBUG_PRINT(DebugLevel_Verbose | DebugSubSystem_TextObject,
                   "%s line %d:  pThis iRow=%d iCol=%d rctSel=(%d,%d,%d,%d)\n",
                   __FUNCTION__, __LINE__,
                   pThis->iRow, pThis->iCol,
                   pThis->rctSel.left, pThis->rctSel.top, pThis->rctSel.right, pThis->rctSel.bottom);

    if(!bHasFocus)
    {
      if(pThis->iBlinkState != CURSOR_BLINK_OFF)
      {
        pThis->iBlinkState = CURSOR_BLINK_OFF; // no cursor

        __internal_invalidate_cursor(pThis, 1);
      }
    }
    else
    {
      pThis->iBlinkState = (pThis->iBlinkState + 1) % CURSOR_BLINK_PERIOD;

      __internal_invalidate_cursor(pThis, bShow != __internal_cursor_show(pThis->iBlinkState));
        //pThis->iBlinkState == 0 || pThis->iBlinkState == 1);
    }
  }
}

static void __internal_set_save_point(struct _text_object_ *pThis)
{
  // TODO:  implement

  WB_DEBUG_PRINT(DebugLevel_Verbose, "%s - not yet implemented\n", __FUNCTION__);
}

static int __internal_get_modified(struct _text_object_ *pThis)
{
  WB_DEBUG_PRINT(DebugLevel_Verbose, "%s - not yet implemented - returning 'modified'\n", __FUNCTION__);

  return 1; // for now, ALWAYS modified
}




// ----------------------------
// MBCS UTF-8 UTILITY FUNCTIONS
// ----------------------------

// see RFC3629 and https://en.wikipedia.org/wiki/UTF-8#Codepage_layout

static int internal_IsMBCharValid(const char *pChar, int *piLen)
{
const unsigned char *p1;
int iRval;


  if((unsigned char)*pChar < 0x80) // normal ASCII (including '0' byte)
  {
    if(piLen)
    {
      if(*pChar)
      {
        *piLen = 1;
      }
      else
      {
        *piLen = 0;
      }
    }

    return 1; // valid char
  }

  p1 = (const unsigned char *)pChar;
  iRval = 0; // initially, call it 'invalid'

  // 80-BF - values 0-3F 'continuation' bytes for mbcs [sequence will not start with this]
  // C0-DF - 2-byte character
  //         (C0=0, C1=40H, C2=80H, up to 7C0H for DF; values C0 and C1 are actually 'not valid' as it's pointless)
  // E0-EF - 3-byte character
  //         (E0 adds 800H; E1 adds 1000H; E2 2000H; etc. up to F000H for EF.  not all E0 sequences are valid)
  // F0-FF - 4+byte character
  //         (F0 is 10000H; F1 40000H; F2 80000H; F3 C0000H; F4 100000H; values F5 and above are 'not valid'
  //          Not all F0's are valid, either)
  //
  // For invalid sequences, this function will attempt to work around it; however RFC3629 requires them to be error conditions
  // to avoid security-related problems caused by invalid UTF8 sequences.

  if(*p1 < 0xc2 || // a continuation character? an 'invalid' sequence?
     *p1 >= 0xf5)  // assume value cannot be > 0xff, right?
  {
    p1++;  // invalid; length is 1 (like ASCII)
  }
  else if(*p1 < 0xe0) // 2-byte sequence
  {
    if((unsigned char)p1[1] >= 0x80 && (unsigned char)p1[1] <= 0xbf) // valid 2-byte sequence
    {
      p1 += 2;
      iRval = 1;
    }
    else
    {
      p1++;  // invalid; length is 1 (like ASCII)
    }
  }
  else if(*p1 < 0xf0) // 3-byte sequence
  {
    if(p1[1] >= 0x80 && p1[1] <= 0xbf && // valid 3-byte sequence
       p1[2] >= 0x80 && p1[2] <= 0xbf)
    {
      // TODO:  validate E0 sequences

      p1 += 3;
      iRval = 1;
    }
    else // now it gets trickier...
    {
      // by convention, treat it like 8-bit ASCII with a length of 1
      p1++;
    }
  }
  else // if(*p1 < 0xf5)
  {
    if(p1[1] >= 0x80 && p1[1] <= 0xbf && // valid 4-byte sequence
       p1[2] >= 0x80 && p1[2] <= 0xbf &&
       p1[3] >= 0x80 && p1[3] <= 0xbf)
    {
      // TODO:  validate F0 sequences

      p1 += 4;
      iRval = 1;
    }
    else // now it gets trickier...
    {
      // by convention, treat it like 8-bit ASCII with a length of 1
      p1++;
    }
  }

  if(piLen)
  {
    *piLen = (const char *)p1 - pChar;  // this simplified length indicator helps with copy/pasta [if I need it]
  }

#ifndef NO_DEBUG
  if(!iRval || ((const char *)p1 - pChar) > 1)
  {
    int iLen = ((const char *)p1 - pChar);

    WB_DEBUG_PRINT(DebugLevel_Verbose, "%s line %d - return=%d  char=%02xH", __FUNCTION__, __LINE__, iRval, (unsigned char)*pChar);
    while(iLen > 1)
    {
      iLen--;
      pChar++;

      WBDebugPrint(",%02xH", (unsigned char)*pChar);
    }
    WBDebugPrint("\n");
  }
#endif // NO_DEBUG

  return iRval;
}

static int internal_MBstrlen(const char *pString)
{
const char *p1 = pString;
int iLen, iRval;


  iRval = 0;

  while(*p1)
  {
    // step through 1 character at a time until I reach the end of the string, or iCol reaches zero

    if(!internal_IsMBCharValid(p1, &iLen))
    {
      p1++; // treat like 8-bit ASCII if it's an invalid UTF-8 sequence

      // NOTE:  may change or render as EF BF BD i.e. U+FFFD (a diamond with question mark)
    }
    else
    {
      p1 += iLen;
    }

    iRval++; // we only count blue cars (and multi-byte chars as "1")
  }

  return iRval;
}

// return the 'character' index for the 'column' specified by 'iCol' for MBCS

static int internal_MBColIndex(const char *pString, int iCol)
{
const char *p1 = pString;
int iLen;


  while(iCol > 0 && *p1)
  {
    // step through 1 character at a time until I reach the end of the string, or iCol reaches zero

    if(!internal_IsMBCharValid(p1, &iLen))
    {
      p1++; // treat like 8-bit ASCII if it's an invalid UTF-8 sequence

      // NOTE:  may change or render as EF BF BD i.e. U+FFFD (a diamond with question mark)
    }
    else
    {
      p1 += iLen;
    }

    iCol--;
  }

  return (p1 - pString); // NOTE: need to verify length before calling or this could be WRONG
}


char * WBInsertMBChars(char *pString, int iCol, const char *pszMBString, int cbString,
                       int fTab, int fOverwrite, int *piNewCol, char **ppInserted)
{
  if(ppInserted)
  {
    *ppInserted = NULL; // initial value
  }

  if(piNewCol)
  {
    *piNewCol = iCol; // initial value
  }


//  POOBAH


  return NULL;
}

char * WBSplitMBLine(char *pString, int iCol)
{
char *p1, *pRval;
int iLen, i1;


  iLen = internal_MBstrlen(pString);

  if(iCol >= iLen) // past end of string?
  {
    pRval = WBCopyString(""); // allocated pointer that's a copy of an empty string - it's what I'll start with
  }
  else
  {
    i1 = internal_MBColIndex(pString, iCol);

    pRval = WBCopyString(pString + i1);

    if(pRval)
    {
      pString[i1] = 0; // terminate it here (my 'split')
    }
  }

  if(pRval) // if I have a valid return, right-trim the original line
  {
    p1 = pString + strlen(pString);

    while(p1 > pString && *(p1 - 1) <= ' ') // right-trim it
    {
      *(--p1) = 0; // right-trim the string - make ALL white space GO AWAY
    }
  }

  return(pRval);
}

char * WBJoinMBLine(char *pString, int iCol, const char *pJoin)
{
int iLen, iLenNew, iJoin;
char *pRval, *p1;


  iLen = internal_MBstrlen(pString);
  if(iLen < iCol)
  {
    iLenNew = iCol;
  }
  else
  {
    iLenNew = iLen;
  }

  iJoin = internal_MBstrlen(pJoin);

  pRval = WBReAlloc(pString, iLenNew + iJoin + 2);
  if(!pRval)
  {
    return NULL;
  }

  p1 = pRval + strlen(pRval); // regardless of actual length, this works

  while(iLen < iLenNew)
  {
    *(p1++) = ' '; // add white space up to 'iCol'
    iLen++;
  }

  strcpy(p1, pJoin);

  return pRval;
}

int WBDelMBChars(char *pString, int iCol, int nDel, int *piNewCol, char **ppDeleted)
{
int iLen, iIndex, i1, iRval = nDel;
char *pDelChar, *p1;


  if(ppDeleted)
  {
    *ppDeleted = NULL; // initial value
  }

  if(piNewCol)
  {
    *piNewCol = iCol; // initial value
  }

  if(!pString || !nDel || !*pString)
  {
    if(piNewCol)
    {
      *piNewCol = iCol; // for now, just do this, even if string is blank
    }

    return nDel; // parameter validation
  }

  iLen = internal_MBstrlen(pString);

  if(iRval > 0)
  {
    if(ppDeleted && iLen > iCol)
    {
      pDelChar = WBAlloc(4 // max size of MB char
                         * (iLen - iCol + 1) // 1 more than # of chars to delete
                         + 1); // additional storage for zero byte

      *ppDeleted = pDelChar; // NOTE:  caller checks for NULL to determine error state

      if(pDelChar)
      {
        *pDelChar = 0; // make sure
      }
    }
    else
    {
      pDelChar = NULL;
    }

    while(iLen > iCol && iRval > 0)
    {
      iIndex = internal_MBColIndex(pString, iCol);

      p1 = pString + iIndex; // always

      if(!*p1)
      {
        break; // I'm at the end of the string (sanity test)
      }

      if(!internal_IsMBCharValid(p1, &i1))
      {
        // invalid character - truncate the line here!

        *p1 = 0;
        iRval = 0;  // assume 'end of line' and terminate deleting

        break;
      }

      if(pDelChar && i1 > 0)
      {
        memcpy(pDelChar, p1, i1);
        pDelChar += i1;

        *pDelChar = 0; // mark the end of the string
      }

      iRval --; // deleting one character (so remove a 'delete')
      iLen--; // update the new length

      // i1 is the length of the next character.  slide 'em down! [this is less efficient, but more 'stable']
      strcpy(p1, p1 + i1); // simplest method
    }
  }
  else
  {
    if(ppDeleted && iCol > 0)
    {
      pDelChar = WBAlloc(4 // max size of MB char
                         * (iCol + 1) // 1 more than # of chars to delete
                         + 1); // additional storage for zero byte

      *ppDeleted = pDelChar; // NOTE:  caller checks for NULL to determine error state

      if(pDelChar)
      {
        *pDelChar = 0; // make sure
      }
    }
    else
    {
      pDelChar = NULL;
    }

    // NOW we do backspacing, which preserves the character at 'iCol'.  this is a little trickier.
    // when we end up at column zero, we return the 'iRval' count.

    while(iCol > 0 && iRval < 0)
    {
      if(iCol <= iLen) // I'm NOT past the end
      {
        iIndex = internal_MBColIndex(pString, iCol - 1); // PREVIOUS column

        p1 = pString + iIndex; // always

        if(!*p1)
        {
          break; // I'm at the end of the string (sanity test, unlikely to happen)
        }

        if(!internal_IsMBCharValid(p1, &i1))
        {
          // invalid character - truncate the line here!

          *p1 = 0;
          iRval = 0; // assume 'end of line' at this point, and terminate deleting

          break;
        }

        if(pDelChar && i1 > 0)
        {
          // insert this character into the beginning of the 'undo' info string
          // there are probably BETTER ways to do this, but this is what I'll do.

          memmove(pDelChar + i1, pDelChar, strlen(pDelChar) + 1); // open up space.  make sure ending zero byte is included.
          memcpy(pDelChar, p1, i1);
        }

        // i1 is the length of the prev character, so slide 'em down! [this is less efficient, but more 'stable']
        strcpy(p1, p1 + i1); // simplest method (I could also get the pointer to the 'iCol'th char, but this is more consistent)
      }
      else
      {
        // since I'm at the end, just delete the last char in the line (effectively) by decrementing the column
        // so nothing else to do here other than the end of the loop
      }

      iCol--;
      iRval++; // because it's NEGATIVE, so we increment it
    }
  }

  // it seems in both cases (above) this section remains exactly the same
  // how amazing that works out!

  if(piNewCol)
  {
    *piNewCol = iCol; // 'iCol' will be the NEW column for the cursor
  }

  return iRval;
}

int WBGetMBLength(const char *pString)
{
  if(!pString)
  {
    return 0;
  }

  return internal_MBstrlen(pString);
}

char * WBGetMBCharPtr(char *pString, int iCol, int *pcbLen)
{
int iIndex;


  if(!pString)
  {
    return NULL;
  }

  iIndex = internal_MBColIndex(pString, iCol);

  if(pString[iIndex])  // it's not a 0-byte
  {
    if(!internal_IsMBCharValid(pString + iIndex, pcbLen))
    {
      return NULL; // character is not valid
    }
  }
  else
  {
    if(pcbLen)
    {
      *pcbLen = 0;
    }

    // TODO:  anything else?
  }

  return pString + iIndex;
}

int WBGetMBColIndex(const char *pString, const char *pChar)
{
const char *p1 = pString;
int iLen, iRval;


  if(pChar <= pString)
  {
    return 0;
  }

  iRval = 0;

  while(*p1 && p1 < pChar)
  {
    // step through 1 character at a time until I reach the end of the string, or iCol reaches zero

    if(!internal_IsMBCharValid(p1, &iLen))
    {
      p1++; // treat like 8-bit ASCII if it's an invalid UTF-8 sequence

      // NOTE:  may change or render as EF BF BD i.e. U+FFFD (a diamond with question mark)
    }
    else
    {
      p1 += iLen;
    }

    iRval++; // we only count blue cars (and multi-byte chars as "1")
  }

  if(p1 != pChar)
  {
    return 0; // this is an error condition
  }

  return iRval; // returns the actual column index for 'pChar' within the string pointed by 'pString'
}


