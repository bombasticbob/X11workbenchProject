//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//     _               _               _      _              _              //
//    | |_  ___ __  __| |_       ___  | |__  (_)  ___   ___ | |_     ___    //
//    | __|/ _ \\ \/ /| __|     / _ \ | '_ \ | | / _ \ / __|| __|   / __|   //
//    | |_|  __/ >  < | |_     | (_) || |_) || ||  __/| (__ | |_  _| (__    //
//     \__|\___|/_/\_\ \__|_____\___/ |_.__/_/ | \___| \___| \__|(_)\___|   //
//                        |_____|          |__/                             //
//                                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2016 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no waranties, either implied or explicit.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

/** \file text_object.c
  * \brief Utilities for copying and drawing text, determining text extents, and so on
  *
  * X11 Work Bench Toolkit Toolkit API
*/


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <errno.h>
#include <limits.h>

#include "draw_text.h"
#include "text_object.h"


#ifdef HAVE_MALLOC_USABLE_SIZE
#ifdef __FreeBSD__
#include <malloc_np.h>
#else
#include <malloc.h>
#endif // __FreeBSD__
#endif // HAVE_MALLOC_USABLE_SIZE


// UTF-8 HANDLING
// X11 has XFree86 extensions with 'Xutf8' versions of a lot of things
// which is only applicable with the following
//#ifdef X_HAVE_UTF8_STRING
//   I use the utf8 version
// etc.
//
// Unfortunately many things that I use don't have that available
// like XTextWidth for one (maybe I could use Xutf8TextExtents?)
// Using Xmb and Xwc equivalent methods should work on Interix
//
// SEE ALSO:  draw_text.c (similar section)
//
//#ifdef X_HAVE_UTF8_STRING
#if 0

#define WB_TEXT_EXTENTS Xutf8TextExtents
#define WB_TEXT_ESCAPEMENT Xutf8TextEscapement
#define WB_DRAW_STRING Xutf8DrawString

#else  // X_HAVE_UTF8_STRING

#define WB_TEXT_EXTENTS XmbTextExtents
#define WB_TEXT_ESCAPEMENT XmbTextEscapement
#define WB_DRAW_STRING XmbDrawString

#endif // X_HAVE_UTF8_STRING


// INTERNAL STRUCTURES

struct __internal_undo_redo_buffer
{
  struct __internal_undo_redo_buffer *pNext; // singly linked list [for now]
  // NOTE:  a background process can trim this to a reasonable size

  // NOTE:  for a simple row/col insert or paste, left=right, top=bottom
  //        for all other operations, the rctSel will apply accordingly
  WB_RECT rctSelOld; // original select rectangle (as applicable)
  WB_RECT rctSelNew; // new select rectangle after the operation

  int iOperation; // select=0, delete=1, insert/paste=2, replace=3
  int iSelMode;   // selection mode

  int nOld; // size of 'old' buffer (zero if none)
  int nNew; // size of 'new' buffer (zero if none)

  char aData[2]; // actual data for operation
};

#define UNDO_SELECT 0
#define UNDO_DELETE 1
#define UNDO_INSERT 2
#define UNDO_REPLACE 3 /* currently not used */
#define UNDO_INDENT 4


#define SEL_RECT_ALL(X) ((X)->rctSel.left < 0)
#define SEL_RECT_EMPTY(X) (!SEL_RECT_ALL(X) && ((X)->rctSel.left == (X)->rctSel.right && (X)->rctSel.bottom == (X)->rctSel.top))
#define NORMALIZE_SEL_RECT(X) {if((X).top > (X).bottom || ((X).top == (X).bottom && (X).left > (X).right)) \
                               { int i1 = (X).left; (X).left = (X).right; (X).right = i1; i1 = (X).top; (X).top = (X).bottom; (X).bottom = i1; }}


// *************************
// LOCAL FUNCTION PROTOTYPES
// *************************

static void __internal_destroy(struct _text_object_ *pThis);
static void __internal_init(struct _text_object_ *pThis);
static void __internal_highlight_colors(struct _text_object_ *pThis, XColor clrHFG, XColor clrHBG);
static char * __internal_get_text(struct _text_object_ *pThis);
static void __internal_set_text(struct _text_object_ *pThis, const char *szText, unsigned long cbLen);
static int __internal_get_rows(const struct _text_object_ *pThis);
static int __internal_get_cols(struct _text_object_ *pThis);
static int __internal_get_filetype(const struct _text_object_ *pThis);
static void __internal_set_filetype(struct _text_object_ *pThis, int iFileType);
static int __internal_get_linefeed(const struct _text_object_ *pThis);
static void __internal_set_linefeed(struct _text_object_ *pThis, int iLineFeed);
static int __internal_get_insmode(const struct _text_object_ *pThis);
static void __internal_set_insmode(struct _text_object_ *pThis, int iInsMode);
static int __internal_get_selmode(const struct _text_object_ *pThis);
static void __internal_set_selmode(struct _text_object_ *pThis, int iSelMode);
static int __internal_get_tab(const struct _text_object_ *pThis);
static void __internal_set_tab(struct _text_object_ *pThis, int iTab);
static int __internal_get_scrollmode(const struct _text_object_ *pThis);
static void __internal_set_scrollmode(struct _text_object_ *pThis, int iScrollMode);
static void __internal_get_select(const struct _text_object_ *pThis, WB_RECT *pRct);
static void __internal_set_select(struct _text_object_ *pThis, const WB_RECT *pRct);
static int __internal_has_select(const struct _text_object_ *pThis);
static char* __internal_get_sel_text(const struct _text_object_ *pThis, const WB_RECT *pRct);
static int __internal_get_row(const struct _text_object_ *pThis);
static void __internal_set_row(struct _text_object_ *pThis, int iRow);
static int __internal_get_col(const struct _text_object_ *pThis);
static void __internal_set_col(struct _text_object_ *pThis, int iCol);
static void __internal_del_select(struct _text_object_ *pThis);
static void __internal_replace_select(struct _text_object_ *pThis, const char *szText, unsigned long cbLen);
static void __internal_del_chars(struct _text_object_ *pThis, int nChar);
static void __internal_ins_chars(struct _text_object_ *pThis, const char *pChar, int nChar);
static void __internal_indent(struct _text_object_ *pThis, int nCol);
static int __internal_can_undo(struct _text_object_ *pThis);
static void __internal_undo(struct _text_object_ *pThis);
static int __internal_can_redo(struct _text_object_ *pThis);
static void __internal_redo(struct _text_object_ *pThis);
static void __internal_get_view(const struct _text_object_ *pThis, WB_RECT *pRct);
static void __internal_set_view(struct _text_object_ *pThis, const WB_RECT *pRct);
static void __internal_begin_highlight(struct _text_object_ *pThis);
static void __internal_end_highlight(struct _text_object_ *pThis);

static void __internal_mouse_click(struct _text_object_ *pThis, int iMouseXDelta, int iMouseYDelta, int iType, int iACS);
static void __internal_begin_mouse_drag(struct _text_object_ *pThis);
static void __internal_end_mouse_drag(struct _text_object_ *pThis);
static void __internal_cursor_up(struct _text_object_ *pThis);
static void __internal_cursor_down(struct _text_object_ *pThis);
static void __internal_cursor_left(struct _text_object_ *pThis);
static void __internal_cursor_right(struct _text_object_ *pThis);
static void __internal_page_up(struct _text_object_ *pThis);
static void __internal_page_down(struct _text_object_ *pThis);
static void __internal_page_left(struct _text_object_ *pThis);
static void __internal_page_right(struct _text_object_ *pThis);

static void __internal_cursor_home(struct _text_object_ *pThis);
static void __internal_cursor_end(struct _text_object_ *pThis);
static void __internal_cursor_top(struct _text_object_ *pThis);
static void __internal_cursor_bottom(struct _text_object_ *pThis);

static void __internal_do_expose(struct _text_object_ *pThis, Display *pDisplay, Window wID,
                                 GC gc, const WB_GEOM *pPaintGeom, const WB_GEOM *pViewGeom,
                                 XFontSet rFontSet);
static void __internal_cursor_blink(struct _text_object_ *pThis, int bHasFocus);

// *********************************
// LOCALLY DEFINED GLOBAL STRUCTURES
// *********************************

const TEXT_OBJECT_VTABLE WBDefaultTextObjectVTable =
{
  __internal_destroy,
  __internal_init,
  __internal_highlight_colors,
  __internal_get_text,
  __internal_set_text,
  __internal_get_rows,
  __internal_get_cols,
  __internal_get_filetype,
  __internal_set_filetype,
  __internal_get_linefeed,
  __internal_set_linefeed,
  __internal_get_insmode,
  __internal_set_insmode,
  __internal_get_selmode,
  __internal_set_selmode,
  __internal_get_tab,
  __internal_set_tab,
  __internal_get_scrollmode,
  __internal_set_scrollmode,
  __internal_get_select,
  __internal_set_select,
  __internal_has_select,
  __internal_get_sel_text,
  __internal_get_row,
  __internal_set_row,
  __internal_get_col,
  __internal_set_col,
  __internal_del_select,
  __internal_replace_select,
  __internal_del_chars,
  __internal_ins_chars,
  __internal_indent,
  __internal_can_undo,
  __internal_undo,
  __internal_can_redo,
  __internal_redo,
  __internal_get_view,
  __internal_set_view,
  __internal_begin_highlight,
  __internal_end_highlight,
  __internal_mouse_click,
  __internal_begin_mouse_drag,
  __internal_end_mouse_drag,
  __internal_cursor_up,
  __internal_cursor_down,
  __internal_cursor_left,
  __internal_cursor_right,
  __internal_page_up,
  __internal_page_down,
  __internal_page_left,
  __internal_page_right,

  __internal_cursor_home,
  __internal_cursor_end,
  __internal_cursor_top,
  __internal_cursor_bottom,

  __internal_do_expose,
  __internal_cursor_blink
};



////////////////////////////////////////
// GLOBAL (yet static) INLINE UTILITIES
////////////////////////////////////////

// line endings translated from 'enum' to 'const char *'

static __inline__ const char * __internal_get_line_ending_text(enum _LineFeed_ iIndex)
{
  static const char * const szLineEndings[LineFeed_ENTRYCOUNT] =
  {
#ifdef WIN32
  "\r\n"
#else // POSIX
  "\n",
#endif // OS-dependent line endings
  "\n","\r","\r\n","\n\r"
  };

  if((int)iIndex < 0 || (int)iIndex >= LineFeed_ENTRYCOUNT)
  {
    return NULL;  // single-line or invalid
  }
  return szLineEndings[iIndex];
}




// ********************
// MEMORY SUB-ALLOCATOR
// ********************

// NOTES TO SELF (design notes)
// a) allocate Xk blocks of memory for suballocator blocks of a specific size
// b) the first 'page' of the memory block is an array of indices (double-link list)
// c) the remainder of the block is an ordered set of memory blocks of a fixed size
// d) as more blocks are added, they are added to a linked list associated with the size
// e) blocks "more than Xk" will be malloc'd and added to the 'malloc' list.
// f) malloc'd blocks will have a double-link list and a header with extra info
// This way an allocated address will auto-indicate which memory block it belongs to

static const char szWBAllocTag[]="WB_M";
#define WB_ALLOC_TAG (*((const unsigned int *)szWBAllocTag))

struct __malloc_header__
{
  struct __malloc_header__ *pPrev, *pNext;
  unsigned int iTag;   // see WB_ALLOC_TAG
  unsigned int cbSize; // size used for last malloc/realloc
};

static struct __malloc_header__ *pMallocList = NULL, *pMallocListEnd = NULL;

// TODO:  sync object for pMallocList etc.

void *WBAlloc(int nSize)
{
unsigned char *pRval;
struct __malloc_header__ *pMH;
unsigned int nAllocSize, nNewSize, nLimit;


  if(nSize <= 0)
  {
    return NULL;
  }

  // TODO:  implement allocation of smaller memory blocks as 'power of 2' blocks.
  //

  nAllocSize = nSize + sizeof(*pMH);
  // nAllocSize will be converted to the next higher power of 2

  nLimit = nAllocSize + (nAllocSize >> 1);
  for(nNewSize=64; nNewSize < nLimit; nNewSize <<= 1) { } // NOTE:  64 bytes is the smallest allocation unit

//  if(nNewSize < 4096) TODO:  internally sub-allocated blocks
//  {
//    TODO:  maintain lists of pre-allocated blocks of memory, allocating new memory as needed
//           (this memory will need to be re-used intelligently so trash mashing can work properly
//  }

  pRval = (unsigned char *)malloc(nNewSize); // for now

  if(pRval)
  {
    pMH = (struct __malloc_header__ *)pRval;

    pRval += sizeof(*pMH);

    pMH->pPrev = NULL;
    pMH->pNext = NULL;
    pMH->iTag = WB_ALLOC_TAG;
    pMH->cbSize = nNewSize - sizeof(*pMH); // nSize; // TODO:  actual allocated size via malloc_usable_size
  }

  return pRval;
}

void WBFree(void *pBuf)
{
struct __malloc_header__ *pMH;

  if(!pBuf)
  {
    return;
  }

  // validate pointer
  // TODO:  check against linked list of 'allocated' blocks first

  pMH = ((struct __malloc_header__ *)pBuf) - 1;

  if(pMH->iTag == WB_ALLOC_TAG)
  {
    free(pMH);
  }
  else
  {
    WB_ERROR_PRINT("ERROR - %s NOT freeing memory %p\n", __FUNCTION__, pBuf);
  }
}

void * WBReAlloc(void *pBuf, int nNewSize)
{
struct __malloc_header__ *pMH;
unsigned char *pRval = NULL;
unsigned int nAllocSize, nNewNewSize, nLimit;


  if(!pBuf || nNewSize <= 0)
  {
    return NULL;
  }

  // validate pointer
  // TODO:  check against linked list of 'allocated' blocks first

  pMH = ((struct __malloc_header__ *)pBuf) - 1;

  if(pMH->iTag == WB_ALLOC_TAG)
  {
    // the whole point of this is to minimize the actual need to re-allocate the
    // memory block by maintaining a LARGER block than is actually needed when
    // allocated or re-allocated.  Gradually increasing size is pretty much assumed.

    if(pMH->cbSize >= nNewSize)
    {
      return pBuf; // no change (same pointer) since it's large enough already
    }

    // TODO:  implement re-allocation of smaller memory blocks as 'power of 2' blocks.
    //

    nAllocSize = nNewSize + sizeof(*pMH);
    // nAllocSize will be converted to the next higher power of 2

    nLimit = nAllocSize + (nAllocSize >> 1);
    for(nNewNewSize=64; nNewNewSize < nLimit; nNewNewSize <<= 1) { } // NOTE:  64 bytes is the smallest allocation unit

//    if(nNewSize < 4096) TODO:  internally sub-allocated blocks
//    {
//      TODO:  maintain lists of pre-allocated blocks of memory, allocating new memory as needed
//             (this memory will need to be re-used intelligently so trash mashing can work properly
//    }

    pRval = realloc(pMH, nNewNewSize);
    if(pRval)
    {
      pMH = (struct __malloc_header__ *)pRval;
      pRval += sizeof(*pMH);

      pMH->cbSize = nNewNewSize - sizeof(*pMH);
    }
  }
  else
  {
    WB_ERROR_PRINT("ERROR - %s NOT re-allocating memory %p\n", __FUNCTION__, pBuf);
  }

  return pRval; // realloc(pBuf, nNewSize); // for now
}

void WBSubAllocTrashMasher(void)
{
  // do nothing (for now)
  // later, walk memory list to see if any blocks are completely unused, and free them.
}


// ***********
// TEXT BUFFER
// ***********

// TODO:  an API function for single-line text

#define DEFAULT_TEXT_BUFFER_LINES 16384

TEXT_BUFFER * WBAllocTextBuffer(const char *pBuf, unsigned int cbBufSize)
{
TEXT_BUFFER *pRval;
int nLines = 0;
int cbLen;

  if(pBuf && (cbBufSize || *pBuf))
  {
    nLines = WBStringLineCount(pBuf, cbBufSize);
  }

  if(nLines < DEFAULT_TEXT_BUFFER_LINES)
  {
    nLines = DEFAULT_TEXT_BUFFER_LINES;
  }

  cbLen = sizeof(*pRval) + nLines * sizeof(pRval->aLines[0]);
  pRval = malloc(cbLen);

  if(!pRval)
  {
    WB_ERROR_PRINT("ERROR - %s - not enough memory (%ld)\n", __FUNCTION__,
                   (unsigned long)(sizeof(*pRval) + nLines * sizeof(pRval->aLines[0])));
    return NULL;
  }

  memset(pRval, 0, cbLen); // zero out entire structure (always)

  pRval->nArraySize = nLines; // pre-assigned values
//  pRval->nEntries = 0; already zero, comment left for reference

  if(pBuf && (cbBufSize || *pBuf))
  {
    int nL = 0;
    const char *p1;

    if(!cbBufSize)
    {
      cbBufSize = strlen(pBuf);
    }

    do
    {
      int cbLen;
      char *p2, *p3;

      p1 = WBStringNextLine(pBuf, &cbBufSize);

      if(p1) // another line remains
      {
        cbLen = p1 - pBuf;
      }
      else
      {
        cbLen = cbBufSize;
      }

      p2 = WBAlloc(cbLen + 2);

      if(!p2)
      {
        WBFreeTextBuffer(pRval);
        pRval = NULL;
        break;
      }

      memcpy(p2, pBuf, cbLen); // copy the data

      p3 = p2 + cbLen; // the end of the string
      *p3 = 0; // always zero-byte terminate it first

      while(p3 > p2 && (*(p3 - 1) <= ' ' || *(p3 - 1) == HARD_TAB_CHAR)) // trim ALL trailing white space including CR, LF, tab, space, FF, etc.
      {
        // TODO:  handle <FF> or <VT> differently?
        // TODO:  leave white space to mark 'extent' of line?  naaw, probably not

        *(p3--) = 0; // for now just trim it all
      }

      pRval->aLines[nL++] = p2;

      pBuf = p1;

    } while(pBuf && cbBufSize && nL < nLines);

    pRval->nEntries = nL; // NOTE:  on error, this will be needed for cleanup

    WBTextBufferRefreshCache(pRval);
  }

//  if(pRval)
//  {
//    int nL;
//
//    WB_ERROR_PRINT("\nTEMPORARY - %s - %ld lines\n", __FUNCTION__, pRval->nEntries);
//
//    for(nL=0; nL < pRval->nEntries; nL++)
//    {
//      WB_ERROR_PRINT("  \"%s\"\n", pRval->aLines[nL]);
//    }
//
//    WB_ERROR_PRINT("END TEMPORARY - %s\n\n", __FUNCTION__);
//  }

  return pRval;
}

int WBCheckReAllocTextBuffer(TEXT_BUFFER **ppBuf, int nLinesToAdd)
{
TEXT_BUFFER *pBuf;
int nNew;

  if(!ppBuf || !*ppBuf)
  {
    return -1; // error
  }

  // TODO:  parameter validation

  pBuf = *ppBuf;

  nNew = pBuf->nEntries + nLinesToAdd;

  if(nNew > pBuf->nArraySize)
  {
    nNew += DEFAULT_TEXT_BUFFER_LINES;
    nNew -= (nNew % (DEFAULT_TEXT_BUFFER_LINES / 2));

    pBuf = realloc(pBuf, sizeof(*pBuf) + nNew * sizeof(pBuf->aLines[0]));

    if(!pBuf)
    {
      return -1; // error
    }

    pBuf->nArraySize = nNew;
    *ppBuf = pBuf; // potentially new pointer - probably is, though
  }

  return 0; // no problems
}

void WBFreeTextBuffer(TEXT_BUFFER *pBuf)
{
int i1;

  if(!pBuf)
  {
    return;
  }

  // TODO:  parameter validation

  for(i1=0; i1 < pBuf->nEntries && i1 < pBuf->nArraySize; i1++)
  {
    if(pBuf->aLines[i1])
    {
      WBFree(pBuf->aLines[i1]);
      pBuf->aLines[i1] = NULL;  // by convention
    }
  }

  free(pBuf);
}

void WBTextBufferLineChange(TEXT_BUFFER *pBuf, unsigned long nLine, int nNewLen)
{
int i1, i2;
unsigned int nNewMax = 0, nNewMinMax = UINT_MAX;


  if(pBuf->nEntries <= 1) // zero or one lines?
  {
    WBTextBufferRefreshCache(pBuf); // always do it THIS way
    return;
  }

  if(nLine > pBuf->nEntries) // line number isn't sane?
  {
    return; // sanity check failed (do nothing)
  }

  // update the line info in my cache.  If this line appears, remove it (always).
  // If I'm deleting the line, subtract one from every line higher than this one.

  for(i1=0; i1 < TEXT_BUFFER_LINE_CACHE_SIZE && pBuf->aLineCacheLen[i1]; i1++)
  {
    if(pBuf->aLineCache[i1] == nLine)
    {
      // move everything up, remove the last entry, decrement i1
      for(i2=i1 + 1; i2 < TEXT_BUFFER_LINE_CACHE_SIZE && pBuf->aLineCacheLen[i2]; i2++)
      {
        pBuf->aLineCache[i2] = pBuf->aLineCache[i2 + 1];
        pBuf->aLineCacheLen[i2] = pBuf->aLineCacheLen[i2 + 1];

        // now by convention mark that last entry as if it's unused
        pBuf->aLineCache[i2 + 1] = 0;
        pBuf->aLineCacheLen[i2 + 1] = 0; // an 'end' marker (if the loop exits, it becomes the new 'end')
      }

      i1--; // so I do the 'next' one as I should
    }
    else
    {
      if(pBuf->aLineCache[i1] > nLine)
      {
        if(nNewLen < 0)             // a line deletion
        {
          pBuf->aLineCache[i1] --;  // line was removed, so new line count must match
        }
      }

      if(nNewMax < pBuf->aLineCacheLen[i1])
      {
        nNewMax = pBuf->aLineCacheLen[i1]; // done this way as sanity check
      }

      if(nNewMinMax > pBuf->aLineCacheLen[i1])
      {
        nNewMinMax = pBuf->aLineCacheLen[i1]; // done this way as sanity check
      }
    }
  }

  // if the cache is NOW empty, re-evaluate it.
  if(!pBuf->aLineCacheLen[0]) // empty
  {
    WBTextBufferRefreshCache(pBuf);
    return;
  }

  // I've re-evaluated the max and min-max from the cache, so use that info

  pBuf->nMaxCol = nNewMax;

  if(nNewMinMax <= nNewMax)  // NOTE: if cache is empty, nNewMinMax will be UINT_MAX
  {
    pBuf->nMinMaxCol = nNewMinMax; // sanity checked value
  }
  else
  {
    pBuf->nMinMaxCol = nNewMax; // don't put insane values in there (just in case)
    // TODO: consider refactoring this code out once the algorithm is proved to work
  }

  if(nNewLen < 0) // a line deletion
  {
    if(!nNewMax) // in case my cache has dwindled to nothing
    {
      WBTextBufferRefreshCache(pBuf); // time to re-evaluate
    }

    return; // I'm done for delete.  The rest is for updates
  }

  // see if the length exceeds any of the maximums, and do an 'insertion sort'
  // into my cache array if it does.  Otherwise I can just leave.

  if(nNewLen >= pBuf->nMaxCol) // bigger than maximum (or equal to it)
  {
    i2 = 0; // my insert point

    pBuf->nMaxCol = nNewLen;  // new 'max'
    if(nNewLen < nNewMinMax) // sanity test for empty cache
    {
      pBuf->nMinMaxCol = nNewLen; // may happen, if new cache is totally empty
    }
  }
  else if(nNewLen >= pBuf->nMinMaxCol) // between min max and max
  {
    // find the place to insert this line into the cache
    i2 = 0; // NOTE:  platform-independent loop structure, probably not necessary, but...
    while(i2 < TEXT_BUFFER_LINE_CACHE_SIZE && pBuf->aLineCacheLen[i2])
    {
      if(pBuf->aLineCacheLen[i2] < nNewLen) // the insert point
      {
        break;
      }

      i2++; // don't forget this or infinite loop will result, heh
    }
  }
  else
  {
    return;  // I'm done - no need to re-insert this line into the cache (yet)
    // NOTE:  re-inserting the line into the cache would require re-doing the
    //        cache information from scratch.  this is an optimization, so I'll
    //        avoid THAT operation until it's truly necessary.
  }

  if(i2 < TEXT_BUFFER_LINE_CACHE_SIZE) // sanity check, might happen
  {
    // insert at 'i2'
    for(i1=TEXT_BUFFER_LINE_CACHE_SIZE - 1; i1 > i2; i1--)
    {
      pBuf->aLineCache[i1] = pBuf->aLineCache[i1 - 1];
      pBuf->aLineCacheLen[i1] = pBuf->aLineCacheLen[i1 - 1];
    }

    pBuf->aLineCache[i2] = nLine;
    pBuf->aLineCacheLen[i2] = nNewLen;
  }

  // everything should be ok now, unless I b0rked something
}

void WBTextBufferRefreshCache(TEXT_BUFFER *pBuf)
{
int iLine, i1, i2, i3;
char *p1;


  // zero out the cache arrays
  memset(pBuf->aLineCache, 0, sizeof(pBuf->aLineCache));
  memset(pBuf->aLineCacheLen, 0, sizeof(pBuf->aLineCacheLen));

  pBuf->nMaxCol = pBuf->nMinMaxCol = 0; // initialize to zero

  if(!pBuf->nEntries)
  {
    return;
  }
  else if(pBuf->nEntries == 1)
  {
    if(pBuf->aLines[0])
    {
      pBuf->aLineCacheLen[0] = // refactored, do this assignment here instead
        pBuf->nMaxCol = pBuf->nMinMaxCol = strlen(pBuf->aLines[0]); // assign length to 'max' and 'minmax'
//      if(pBuf->nMaxCol) 'refactored out' (left to document process, remove later)
//      {
//        pBuf->aLineCache[0] = 0; this value already assigned by 'memset'
//        pBuf->aLineCacheLen[0] = pBuf->nMaxCol; refactored code does this
//      }
    }

    return;
  }

  // the big loop

  for(iLine=0; iLine < pBuf->nEntries; i1++)
  {
    // do not consider blank lines or lines with zero length
    p1 = pBuf->aLines[iLine];

    if(!p1)
    {
      continue;
    }

    i1 = strlen(p1);

    if(!i1)
    {
      continue;
    }

    if(i1 > pBuf->nMinMaxCol) // assum data is consistent
    {
      // perform an insertion sort into 'aLineCache'

      // step 1:  find the insertion point

      i2 = 0; // NOTE:  platform-independent loop structure, probably not necessary, but...
      while(i2 < TEXT_BUFFER_LINE_CACHE_SIZE && pBuf->aLineCacheLen[i2])
      {
        if(pBuf->aLineCacheLen[i2] < i1) // the insert point
        {
          break;
        }

        i2++; // don't forget this or infinite loop will result, heh
      }

      if(i2 >= TEXT_BUFFER_LINE_CACHE_SIZE) // logic fail, clean it up
      {
        pBuf->nMaxCol = pBuf->aLineCacheLen[0]; // forced re-evaluation
        pBuf->nMinMaxCol = pBuf->aLineCacheLen[TEXT_BUFFER_LINE_CACHE_SIZE - 1];
      }
      else if(i2 == TEXT_BUFFER_LINE_CACHE_SIZE - 1)
      {
        // special case, insert at the end
        pBuf->aLineCache[i2] = iLine;
        pBuf->aLineCacheLen[i2] = i1;

        pBuf->nMinMaxCol = i1;  // the new 'min max'
      }
      else
      {
        // if this is the first line in the cache, update 'nMaxCol'
        if(!i2) // NOTE:  this test is done here 'cause of likely register optimization
        {
          pBuf->nMaxCol = i1;
        }

        i3 = i2 + 1;
        while(i3 < TEXT_BUFFER_LINE_CACHE_SIZE && pBuf->aLineCacheLen[i3])
        {
          i3++; // finding the end
        }

        // move everything down using 'memmove'

        memmove(&(pBuf->aLineCache[i2 + 1]), &(pBuf->aLineCache[i2]),
                (i3 - i2 - 1) * sizeof(pBuf->aLineCache[0]));
        memmove(&(pBuf->aLineCacheLen[i2 + 1]), &(pBuf->aLineCacheLen[i2]),
                (i3 - i2 - 1) * sizeof(pBuf->aLineCacheLen[0]));

        // use the final line's index and re-assign the 'max' and 'min max'
        pBuf->nMinMaxCol = pBuf->aLineCacheLen[i3 - 1];

        // make sure the last element(s) have a zero length (TODO:  optimize?)
        while(i3 < TEXT_BUFFER_LINE_CACHE_SIZE)
        {
          pBuf->aLineCache[i3] = 0; // do this to, just because
          pBuf->aLineCacheLen[i3++] = 0;
        }

        // and finally, insert this line's info at position 'i2'

        pBuf->aLineCache[i2] = iLine;
        pBuf->aLineCacheLen[i2] = i1;
      }
    }
  }
}


// ************************
// TEXT OBJECT CONSTRUCTION
// ************************

TEXT_OBJECT *WBTextObjectConstructor(unsigned long cbStructSize, const char *szText, unsigned long cbLen, Window wIDOwner)
{
TEXT_OBJECT *pRval;

  pRval = (TEXT_OBJECT *)malloc(sizeof(*pRval));

  if(pRval)
  {
    pRval->vtable = &WBDefaultTextObjectVTable;
    pRval->ulTag = TEXT_OBJECT_TAG;
    pRval->vtable->init(pRval);

    pRval->wIDOwner = wIDOwner;

    pRval->pText = WBAllocTextBuffer(szText, cbLen);
  }

  return(pRval);
}

void WBTextObjectDestructor(TEXT_OBJECT *pObj)
{
  if(WBIsValidTextObject(pObj))
  {
    pObj->vtable->destroy(pObj);

    free(pObj);
  }
}



// *****************************
// TEXT OBJECT UTILITY FUNCTIONS
// *****************************

// INTERNAL-ONLY utilities that are NOT part of the vtable

static void __internal_free_undo_redo_buffer(void *pBuffer)
{
  if(pBuffer)
  {
    // TODO:  validate that it's an undo/redo buffer

    struct __internal_undo_redo_buffer *pU = (struct __internal_undo_redo_buffer *)pBuffer;

    do
    {
      struct __internal_undo_redo_buffer *pUsa = pU;

      pU = pU->pNext;
      WBFree(pUsa); // for now just do this

    } while(pU);
  }
}

#define UNDO_LIMIT 256

// NULL 'prctStartSel' or 'prctEndSel' implies 'NONE' selected, i.e. {0,0,0,0}
static void __internal_add_undo(struct _text_object_ *pThis, int iOperation, int iSelMode,
                                int iStartRow, int iStartCol, const WB_RECT *prctStartSel,
                                const char *pStartText, int cbStartText,
                                int iEndRow, int iEndCol, const WB_RECT *prctEndSel,
                                const char *pEndText, int cbEndText)
{
int cbLen, cbLen2, i1;
struct __internal_undo_redo_buffer *pUndo, *pTU, *pTU2;


  if(!WBIsValidTextObject(pThis))
  {
    return;
  }

  pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

  cbLen = cbLen2 = 0;

  if(pStartText)
  {
    if(cbStartText < 0)
    {
      cbStartText = strlen(pStartText);
    }

    if(cbStartText > 0)
    {
      cbLen += cbStartText;
    }
  }

  if(pEndText)
  {
    if(cbEndText < 0)
    {
      cbEndText = strlen(pEndText);
    }

    if(cbEndText > 0)
    {
      cbLen2 += cbEndText;
    }
  }

  pUndo = (struct __internal_undo_redo_buffer *)WBAlloc(cbLen + cbLen2 + 4 + sizeof(*pUndo));
  if(!pUndo)
  {
    // TODO:  walk the 'undo' chain and start removing stuff, and retry the alloc

    WB_ERROR_PRINT("ERROR - %s - unable to create undo buffer, errno=%d\n", __FUNCTION__, errno);
    return;
  }

  pUndo->iOperation = iOperation;
  pUndo->iSelMode = iSelMode;

  if(prctStartSel)
  {
    memcpy(&(pUndo->rctSelOld), prctStartSel, sizeof(WB_RECT));
  }
  else
  {
    memset(&(pUndo->rctSelOld), 0, sizeof(WB_RECT));
  }

  if(prctEndSel)
  {
    memcpy(&(pUndo->rctSelNew), prctEndSel, sizeof(WB_RECT));
  }
  else
  {
    memset(&(pUndo->rctSelNew), 0, sizeof(WB_RECT));
  }

  pUndo->nOld = cbLen;
  if(cbLen)
  {
    memcpy(pUndo->aData, pStartText, cbLen);
    pUndo->aData[cbLen++] = 0; // just because
  }

  pUndo->nOld = cbLen;

  if(cbLen2)
  {
    memcpy(pUndo->aData + cbLen, pEndText, cbLen2);
    pUndo->aData[cbLen + cbLen2++] = 0; // just because
  }

  pUndo->nNew = cbLen2;

  // insert undo buffer into the 'chain'

  pTU = pUndo->pNext = (struct __internal_undo_redo_buffer *)(pThis->pUndo);
  pThis->pUndo = pUndo;

  // NOW walk the chain and remove things past a certain point.  For now, UNDO_LIMIT
  // NOTE:  this is a compromise - the alternative is a double-link list and an 'end' pointer
  //        along with a running count of items.  If the number of undo/redo items becomes
  //        VERY large, that might be a better alternative. So for now I use a single-link list.

  if(pTU)
  {
    for(i1=1; i1 < UNDO_LIMIT && pTU->pNext; pTU = pTU->pNext, i1++) { }
    // on a modern CPU, this shouldn't take more than a few microseconds

    if(pTU->pNext) // will only be true if I have too many entries
    {
      // free and unhook the chain
      pTU2 = pTU->pNext;
      pTU->pNext = NULL; // generally safer THIS way

      __internal_free_undo_redo_buffer(pTU2); // NOW free what was once chained from here
    }
  }

  // whenever I add an 'undo' HERE, I screw up the 'redo' so blast it away if it exists
  if(pThis->pRedo)
  {
    pTU = pThis->pRedo;
    pThis->pRedo = NULL;

    __internal_free_undo_redo_buffer(pTU);
  }
}

static void __internal_add_redo(struct _text_object_ *pThis, struct __internal_undo_redo_buffer *pUndo)
{
struct __internal_undo_redo_buffer *pRedo;
int cbLen;


  if(!WBIsValidTextObject(pThis))
  {
    return;
  }

  // convert an 'undo' into a 'redo' and add it to the 'redo' chain
  // essentially 'just a copy'

  cbLen = pUndo->nOld + pUndo->nNew + sizeof(*pUndo);

  pRedo = (struct __internal_undo_redo_buffer *)WBAlloc(cbLen + 2);

  if(!pRedo)
  {
    // TODO:  walk the 'undo' and 'redo' chains and start removing stuff, and retry the alloc

    WB_ERROR_PRINT("ERROR - %s - unable to create redo buffer, errno=%d\n", __FUNCTION__, errno);
    return;
  }

  memcpy(pRedo, pUndo, cbLen);

  // now add it to the redo chain

  pRedo->pNext = (struct __internal_undo_redo_buffer *)(pThis->pRedo);
  pThis->pRedo = pRedo;
}

static void __internal_perform_undo(struct _text_object_ *pThis, struct __internal_undo_redo_buffer *pUndo)
{
struct __internal_undo_redo_buffer *pDo;
int iOldSel;


  if(!WBIsValidTextObject(pThis) || !pUndo)
  {
    return;
  }

  // first, make sure the selection mode is correct

  iOldSel = pThis->iSelMode;
  pThis->iSelMode = pUndo->iSelMode;

  if(pUndo->iOperation == UNDO_SELECT)
  {
  }
  else if(pUndo->iOperation == UNDO_DELETE)
  {
    // perform an insert of 'Old Text' data at the appropriate cursor spot
  }
  else if(pUndo->iOperation == UNDO_INSERT)
  {
    // perform a delete of 'new text' data at the appropriate cursor spot
  }
  else if(pUndo->iOperation == UNDO_REPLACE)
  {
    // replace 'new text' with 'old text' at the appropriate cursor spot
  }
  else if(pUndo->iOperation == UNDO_INDENT)
  {
    // indents a block of text
    // to indent, start col will be 0, end col will be the indent
    // to un-indent, start col will be > 0, end col will be 0
    // The start/end rows define the block of lines to be indented or un-indented

  }

  // re-select the old selection using the old select method


  // restore cursor to appropriate spot


//  // restore the current selection method if restored selection is empty
//  pThis->iSelMode = iOldSel;


  // add a redo buffer that's a copy of the undo operation
  __internal_add_redo(pThis, pUndo);
}

static void __internal_perform_redo(struct _text_object_ *pThis, struct __internal_undo_redo_buffer *pRedo)
{
struct __internal_undo_redo_buffer *pNewUndo;
int iOldSel, cbLen;


  if(!WBIsValidTextObject(pThis) || !pRedo)
  {
    return;
  }

  cbLen = pRedo->nOld + pRedo->nNew + sizeof(*pRedo);

  // first, make sure the selection mode is correct

  iOldSel = pThis->iSelMode;
  pThis->iSelMode = pRedo->iSelMode;

  if(pRedo->iOperation == UNDO_SELECT)
  {
  }
  else if(pRedo->iOperation == UNDO_DELETE)
  {
    // perform an insert of 'new Text' data at the appropriate cursor spot
  }
  else if(pRedo->iOperation == UNDO_INSERT)
  {
    // perform a delete of 'old text' data at the appropriate cursor spot
  }
  else if(pRedo->iOperation == UNDO_REPLACE)
  {
    // replace 'old text' with 'new text' at the appropriate cursor spot
  }
  else if(pRedo->iOperation == UNDO_INDENT)
  {
    // indents a block of text
    // to indent, start col will be 0, end col will be the indent
    // to un-indent, start col will be > 0, end col will be 0
    // The start/end rows define the block of lines to be indented or un-indented

  }

  // re-select the new selection using the applicable select method


  // restore cursor to appropriate spot


//  // restore the current selection method if restored selection is empty
//  pThis->iSelMode = iOldSel;


  // now I must add the 'redo' operation 'as-is' to the 'undo' chain, but NOT blast away the 'redo' chain
  // I'll make a copy of it first, since the caller will need to manage the undo/redo pointers

  pNewUndo = (struct __internal_undo_redo_buffer *)WBAlloc(cbLen + 2);

  if(!pNewUndo)
  {
    // TODO:  walk the 'undo' and 'redo' chains and start removing stuff, and retry the alloc

    WB_ERROR_PRINT("ERROR - %s - unable to create undo buffer from redo buffer, errno=%d\n", __FUNCTION__, errno);
    return;
  }

  memcpy(pNewUndo, pRedo, cbLen);

  // now add it to the undo chain so I can 'undo the re-do' if I want to

  pNewUndo->pNext = (struct __internal_undo_redo_buffer *)(pThis->pUndo);
  pThis->pUndo = pNewUndo;
}

// ---------------------------------------------------------------------------
// __internal_get_selected_text - arbitrary text retrieval (internal only)
//                                returns malloc'd string pointer
//
// iRow is the starting row position
// iCol is the starting column position
// iEndRow is the ending row position.  In modes OTHER than 'box mode', this may equal 'iCol'
// iEndCol is the ending column position.  In modes OTHER than 'box mode' this may be LESS than 'iCol'
static char * __internal_get_selected_text(const struct _text_object_ *pThis, int iRow, int iCol, int iEndRow, int iEndCol)
{
int i1, i2, i3, cb1, cbLF=0;
char *p1, *pRval = NULL;
const char *szLineFeed = NULL;
TEXT_BUFFER *pTB;
int iIsBoxMode, iIsLineMode;


  if(WBIsValidTextObject(pThis))
  {
    if(!pThis->pText)
    {
      return WBCopyString(""); // return a blank string
    }

    if(iRow < 0)
    {
      iRow = 0;
    }
    if(iCol < 0)
    {
      iCol = 0;
    }
    if(iEndRow < 0)
    {
      iEndRow = INT_MAX;
    }
    if(iEndCol < 0)
    {
      iEndCol = INT_MAX;
    }

    if(iRow == iEndRow)
    {
      iIsBoxMode = iIsLineMode = 0;
    }
    else
    {
      if(pThis->iSelMode == SelectMode_BOX)
      {
        iIsBoxMode = 1;
        iIsLineMode = 0;
      }
      else if(pThis->iSelMode == SelectMode_LINE)
      {
        iIsBoxMode = 0;
        iIsLineMode = 1;
      }
      else // char and default
      {
        iIsBoxMode = 0;
        iIsLineMode = 0;
      }
    }

    if(iRow > iEndRow                           // row exceeds ending row
       || (iRow == iEndRow && iCol >= iEndCol)  // single row with no 'width'
       /* || (box mode && iCol >= iEndCol) */)  // box mode requires iCol < iEndCol
    {
      return WBCopyString(""); // return a blank string
    }

    pTB = (TEXT_BUFFER *)(pThis->pText);

    // NOTE:  when iRow == iEndRow, both box mode and line mode revert to 'stream mode'
    //        and the 'iIsBoxMode' and 'iIsStreamMode' flags will both be zero

    if(iIsBoxMode)
    {
      cb1 = (iEndRow - iRow + 1) * (2 + iEndCol - iCol);
    }
    else
    {
      // FOR NOW just go through the TEXT_BUFFER array, determine the length (later cache it)

      for(i1=iRow, cb1=4; i1 < pTB->nEntries && i1 <= iEndRow; i1++)
      {
        i2 = strlen(pTB->aLines[i1]);

        // last line in 'normal' select mode limits width - 'iEndCol' may be 0
        if(i1 == iEndRow        // i.e. "the last line" in the selected area
           && !iIsLineMode)     // NOT 'line mode' (will be always false for single-row selects)
        {
          if(i2 > iEndCol) // trim the line accordingly
          {
            i2 = iEndCol;
          }
        }

        cb1 += i2 + 2; // do this regardless (it's only to count up max string length)
      }
    }

    // now build the string using the specified line ending and selection mode

    szLineFeed = __internal_get_line_ending_text(pThis->iLineFeed);

    if(!szLineFeed) // single-line
    {
      if(pTB->nEntries > 1)
      {
        szLineFeed = __internal_get_line_ending_text(LineFeed_DEFAULT); // fallback with multi-line data
      }
    }

    if(szLineFeed)
    {
      cbLF = strlen(szLineFeed);
    }

    pRval = malloc(cb1); // allocate the buffer

    if(pRval)
    {
      p1 = pRval;
      for(i1=iRow, p1 = pRval; i1 < pTB->nEntries && i1 <= iEndRow; i1++)
      {
        // TODO:  validate pRval + cb1 > p1 + length of "the stuff that follows"
        i2 = i3 = strlen(pTB->aLines[i1]);

        // TODO: for box mode limit the width on all lines and pad with white space as needed

        // TODO:  handle hard tab translation?  For now "leave it".  Later, I should use a character
        //        that prints as 'white space' but translates as a 'hard tab'.
        //        Example might be 0xA0, i.e. a ' ' + 80H, filling up spaces to the tab point.  Delete
        //        and insert would have to compensate for this.  This function ALSO would have to compensate,
        //        translating tabs to spaces for box mode, and to hard tabs for everything else when 'select all'
        //        is not in effect and tabs are preserved.
        //        For 'select all', hard tabs (when preserved) would be translated into a minimum number of
        //        tab characters; otherwise they would translate into spaces.  Also a hard tab should be displayed
        //        differently (when preserved), such as a greyed |--> or similar.
        //        When 'do not preserve tabs' is set, inserted tabs should automatically become spaces.  ONLY when
        //        the tabs are being preserved should the translation take place.
        //
        // CASE FOR USING 'A0' FOR HARD TAB
        // a) UTF8 does not use it as a marker for multi-byte character data - http://en.wikipedia.org/wiki/UTF-8
        // b) it's basically a ' ' with the high bit set
        // c) it's not used for anything significant in 8-bit ASCII other than "non-breaking space" (i.e. &nbsp;)
        // d) if it's imported, it will translate to actual spaces
        // e) if it's exported by accident, it probably won't matter (other than formatting)
        // f) a definition NOW exists - see HARD_TAB_CHAR (text_object.h)

        // last line in 'normal' select mode limits width - 'iEndCol' may be 0
        if(i1 == iEndRow        // i.e. "the last line" in the selected area
           || iIsBoxMode)       // box mode limits length differently on all lines
        {
          if(iIsBoxMode)
          {
            if(i2 >= iEndCol)
            {
              i2 = iEndCol - iCol;
            }
            else
            {
              i2 -= iCol;
            }
          }
          else if(!iIsLineMode || iEndCol == 0)
          {
            if(i2 >= iEndCol) // this will ALSO force i2 = 0 for line mode on last row with iEndCol == 0
            {
              i2 = iEndCol;
            }
          }
        }

        // check for stream mode on the first line, and start with 'iCol'
        if(!iIsBoxMode && !iIsLineMode && i1 == iRow) // on first line, start at 'iCol'
        {
          i2 -= iCol; // subtract starting column for total length
        }

        if(i2 > 0) // might be < 0 depending
        {
          if(iIsLineMode || i1 > iCol) // multi-line select NOT on first line, or line mode
          {
            memcpy(p1, pTB->aLines[i1], i2);
          }
          else
          {
            memcpy(p1, pTB->aLines[i1] + iCol, i2);
          }
          p1 += i2;
        }
        else
        {
          i2 = 0; // for box mode, mostly
        }

        if(iIsBoxMode) // iRow < iEndRow also
        {
          // for box mode, pad any 'remaining' length with space
          i2 = iEndCol - iCol - i2;  // I need THAT MANY white spaces
          if(i2 > 0)
          {
            memset(p1, ' ', i2);
            p1 += i2; // now the width should be exactly 'iEndCol - iCol'
          }
        }

        // don't add final line feed in 'stream' mode or in 'line' mode if it ends on column 0

        if(iIsBoxMode ||                    // box mode ALWAYS
           (iIsLineMode && iEndCol > 0) ||  // I'm in line mode and NOT ending on column 0 on the last line
           i1 < iEndRow)                    // not the last line
        {
          if(szLineFeed)
          {
            memcpy(p1, szLineFeed, cbLF);
            p1 += cbLF;
          }
        }
      }

      *p1 = 0;
    }
  }

  return pRval;
}

static void __internal_invalidate_cursor(const struct _text_object_ *pThis, int bPaintFlag)
{
WB_RECT rctCursor;

  if(WBIsValidTextObject(pThis) && pThis->wIDOwner != None)
  {
    rctCursor.left = pThis->iCursorX - 1;
    rctCursor.top = pThis->iCursorY - 1;
    rctCursor.bottom = rctCursor.top + pThis->iCursorHeight + 2;

    if(pThis->iInsMode == InsertMode_OVERWRITE)
    {
      rctCursor.right = rctCursor.left + pThis->iFontWidth;
    }
    else
    {
      rctCursor.right = rctCursor.left + 3;
    }

    WBInvalidateRect(pThis->wIDOwner, &rctCursor, bPaintFlag);
  }
}

static void __internal_invalidate_rect(const struct _text_object_ *pThis, WB_RECT *pRect, int bPaintFlag)
{
WB_RECT rctInvalid;

  if(WBIsValidTextObject(pThis) && pThis->wIDOwner != None)
  {
    if(!pRect)
    {
      WBInvalidateRect(pThis->wIDOwner, NULL, bPaintFlag);
      return;
    }

    memcpy(&rctInvalid, pRect, sizeof(*pRect));

    if(pThis->rctWinView.left - MIN_BORDER_SPACING > rctInvalid.left)
    {
      rctInvalid.left = pThis->rctWinView.left - MIN_BORDER_SPACING;
    }
    if(pThis->rctWinView.right + MIN_BORDER_SPACING < rctInvalid.right)
    {
      rctInvalid.right = pThis->rctWinView.right + MIN_BORDER_SPACING;
    }
    if(pThis->rctWinView.top - MIN_BORDER_SPACING > rctInvalid.top)
    {
      rctInvalid.top = pThis->rctWinView.top - MIN_BORDER_SPACING;
    }
    if(pThis->rctWinView.bottom + MIN_BORDER_SPACING < rctInvalid.bottom)
    {
      rctInvalid.bottom = pThis->rctWinView.bottom + MIN_BORDER_SPACING;
    }

    WBInvalidateRect(pThis->wIDOwner, &rctInvalid, bPaintFlag);
  }
}

// NOTE:  iStartRow and iStartCol may be 0 but not negative
//        iEndRow and iEndCol can be negative to indicate "all"
static void __internal_calc_rect(const struct _text_object_ *pThis, WB_RECT *pRect, int iStartRow, int iStartCol, int iEndRow, int iEndCol)
{
int iFontHeight;
TEXT_BUFFER *pBuf;

  if(!pRect || !WBIsValidTextObject(pThis))
  {
    if(pRect)
    {
      memset(pRect, 0, sizeof(*pRect));
    }

    return;
  }

  pBuf = (TEXT_BUFFER *)(pThis->pText);

  if(iEndRow < 0)
  {
    if(pBuf && pThis->iLineFeed != LineFeed_NONE)
    {
      iEndRow = pBuf->nEntries;
    }
    else
    {
      iEndRow = 0;
    }
  }

  // examine the viewpoint rect, font height, and other info

  iFontHeight = pThis->iAsc + pThis->iDesc;

  if(pThis->iLineFeed == LineFeed_NONE) // i.e. SINGLE LINE (ignore row)
  {
    // top of line will always be centered

    pRect->top = pThis->rctWinView.top
               + (pThis->rctWinView.bottom - pThis->rctWinView.top
                  - pThis->iAsc - pThis->iDesc)
               / 2;

    pRect->bottom = pRect->top + iFontHeight; // always

    pRect->left = pThis->rctWinView.left
                + pThis->iFontWidth * (iStartCol - pThis->rctView.left); // can be negative

    if(iEndCol < 0)
    {
      pRect->right = INT_MAX;
    }
    else
    {
      pRect->right = pThis->iFontWidth * (iEndCol - iStartCol + 1);
    }
  }
  else
  {
    pThis->rctWinView.top;

    if(iStartRow == iEndRow) // single row
    {
      pRect->left = pThis->rctWinView.left
                  + pThis->iFontWidth * (iStartCol - pThis->rctView.left); // can be negative

      if(iEndCol < 0)
      {
        pRect->right = INT_MAX;
      }
      else
      {
        pRect->right = pThis->iFontWidth * (iEndCol - iStartCol + 1);
      }

      pRect->top = pThis->rctWinView.top;
      pRect->bottom = pRect->top + iFontHeight; // always
    }
    else // multiple rows implies including the entire line unless ending column is 0 [in which case last line is excluded]
    {
      // ignore columns, use the entire viewport width
      pRect->left = pThis->rctWinView.left;
      pRect->right = INT_MAX; //pThis->rctWinView.right;

      // adjust font height to include line spacing (I'll use this to position the lines)
      if(pThis->iDesc > MIN_LINE_SPACING / 2)
      {
        iFontHeight += pThis->iDesc / 2; // line spacing is 1/2 of descent, or MIN_LINE_SPACING
      }
      else
      {
        iFontHeight += MIN_LINE_SPACING;
      }

      pRect->top = pThis->rctWinView.top
                 + iFontHeight * (iStartRow - pThis->rctView.top);

      if(iEndCol > 0)
      {
        pRect->bottom = pThis->rctWinView.top
                      + iFontHeight * (iEndRow + 1 - pThis->rctView.top);
      }
      else // nothing selected on last row
      {
        pRect->bottom = pThis->rctWinView.top
                       + iFontHeight * (iEndRow - pThis->rctView.top);
      }
    }
  }
}

static void __internal_merge_rect(const struct _text_object_ *pThis, WB_RECT *pRect, int iStartRow, int iStartCol, int iEndRow, int iEndCol)
{
WB_RECT rctMerge;

  if(!pRect || !WBIsValidTextObject(pThis))
  {
    if(pRect)
    {
      memset(pRect, 0, sizeof(*pRect));
    }

    return;
  }

  __internal_calc_rect(pThis, &rctMerge, iStartRow, iStartCol, iEndRow, iEndCol);

  if(rctMerge.left < pRect->left)
  {
    pRect->left = rctMerge.left;
  }
  if(rctMerge.top < pRect->top)
  {
    pRect->top = rctMerge.top;
  }
  if(rctMerge.right > pRect->right)
  {
    pRect->right = rctMerge.right;
  }
  if(rctMerge.bottom > pRect->bottom)
  {
    rctMerge.bottom = pRect->bottom;
  }
}


// ****************************
// TEXT OBJECT VTABLE FUNCTIONS
// ****************************

static void __internal_destroy(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    // TODO:  additional validation

    if(pThis->pText)
    {
      // TODO:  validate pointer
      WBFreeTextBuffer((TEXT_BUFFER *)pThis->pText);
      pThis->pText = NULL;
    }

    // now for the undo/redo buffers

    __internal_free_undo_redo_buffer(pThis->pUndo);
    pThis->pUndo = NULL;
    __internal_free_undo_redo_buffer(pThis->pRedo);
    pThis->pRedo = NULL;
  }
}
static void __internal_init(struct _text_object_ *pThis)
{
  pThis->wIDOwner = None;
  memset(&pThis->rctSel, 0, sizeof(pThis->rctSel));
  memset(&pThis->rctHighLight, 0, sizeof(pThis->rctHighLight));

  pThis->iFileType = 0;   // plain text
  pThis->iLineFeed = 0;   // '\n'
  pThis->iInsMode = 1;    // insert
  pThis->iSelMode = 0;    // normal
  pThis->iScrollMode = 0; // normal
  pThis->iRow = 0;
  pThis->iCol = 0;
  pThis->iPos = 0; // reserved
  memset(&pThis->rctView, 0, sizeof(pThis->rctView));
  pThis->pText = NULL;
  pThis->pUndo = NULL;
  pThis->pRedo = NULL;

  // TODO:  do I re-initialize the owner-maintained values?  for now, NO!
}

static void __internal_highlight_colors(struct _text_object_ *pThis, XColor clrHFG, XColor clrHBG)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->clrHFG = clrHFG;
    pThis->clrHBG = clrHBG;
  }
}

static char * __internal_get_text(struct _text_object_ *pThis)
{
  return __internal_get_selected_text(pThis, -1, -1, -1, -1);
}

static void __internal_set_text(struct _text_object_ *pThis, const char *szText, unsigned long cbLen)
{
TEXT_BUFFER *pTemp;

  if(WBIsValidTextObject(pThis))
  {
    // for now, allocate a NEW text buffer and replace the old one with it

    pTemp = WBAllocTextBuffer(szText, cbLen);

    if(pTemp)
    {
      if(pThis->pText)
      {
        WBFreeTextBuffer(pThis->pText);
      }

      pThis->pText = pTemp; // and I'm spent
    }
    else
    {
      WB_ERROR_PRINT("TEXT OBJECT:  %s - not enough memory for TEXT BUFFER errno=%d (no change)\n", __FUNCTION__, errno);
    }
  }
  else
  {
    WB_ERROR_PRINT("ERROR - %s - NOT a valid TEXT_OBJECT - %p\n", __FUNCTION__, pThis);
  }
}

static int __internal_get_rows(const struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;

  if(WBIsValidTextObject(pThis))
  {
    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(pBuf && pBuf->nEntries > 0) // only if NOT empty
    {
      if(pThis->iLineFeed == LineFeed_NONE ||
         !pBuf->aLines[0] || !strlen(pBuf->aLines[0])) // "blank line"
      {
        return 1;  // for multiline, even a blank line counts as '1'
      }

      return pBuf->nEntries + 1; // include the last line (a blank one) in the line count
    }
  }

  return 0; // assume blank
}
static int __internal_get_cols(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;
int i1;

  if(WBIsValidTextObject(pThis))
  {
    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(pBuf)
    {
      if(pBuf->nMinMaxCol > pBuf->nMaxCol || !pBuf->nMaxCol || !pBuf->nMinMaxCol)
      {
        // cache data not valid, so re-evaluate
        WBTextBufferRefreshCache(pBuf); // re-calculate
      }

      if(pBuf->nMaxCol)
      {
        if(pBuf->nMaxCol < pThis->iCol) // is my current column past the 'max' column?
        {
          i1 = pThis->iCol + DEFAULT_TAB_WIDTH; // use my current column position
        }
        else
        {
          i1 = pBuf->nMaxCol + DEFAULT_TAB_WIDTH; // use the 'max' column position
        }

        return i1 - (i1 % DEFAULT_TAB_WIDTH); // rounded off to 'DEFAULT_TAB_WIDTH'
        // so if DEFAULT_TAB_WIDTH is 8, then 1 becomes 8, 8 becomes 16, etc.
      }
    }
    else if(pThis->iCol > 0) // allow for 'scrolling without any actual data yet'
    {
      i1 = pThis->iCol + DEFAULT_TAB_WIDTH; // use my current column position
      return i1 - (i1 % DEFAULT_TAB_WIDTH); // rounded off to 'DEFAULT_TAB_WIDTH'
    }

    // all other conditions fall through and return 0
  }

  return 0; // assume blank
}

static int __internal_get_filetype(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iFileType;
  }
  return 0; // for now
}
static void __internal_set_filetype(struct _text_object_ *pThis, int iFileType)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iFileType = iFileType;
  }
}
static int __internal_get_linefeed(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return (int) pThis->iLineFeed;
  }
  return 0; // for now
}
static void __internal_set_linefeed(struct _text_object_ *pThis, int iLineFeed)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iLineFeed = (enum _LineFeed_)iLineFeed;
  }
}
static int __internal_get_insmode(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iInsMode;
  }
  return 0; // for now
}
static void __internal_set_insmode(struct _text_object_ *pThis, int iInsMode)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iInsMode = iInsMode;
  }
}
static int __internal_get_selmode(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iSelMode;
  }
  return 0; // for now
}
static void __internal_set_selmode(struct _text_object_ *pThis, int iSelMode)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iSelMode = iSelMode;
  }
}
static int __internal_get_tab(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iTab;
  }
  return 0; // for now
}
static void __internal_set_tab(struct _text_object_ *pThis, int iTab)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iTab = iTab;
  }
}
static int __internal_get_scrollmode(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iScrollMode;
  }
  return 0; // for now
}
static void __internal_set_scrollmode(struct _text_object_ *pThis, int iScrollMode)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iScrollMode = iScrollMode;
  }
}
static void __internal_get_select(const struct _text_object_ *pThis, WB_RECT *pRct)
{
  if(WBIsValidTextObject(pThis))
  {
    if(pRct)
    {
      if(SEL_RECT_ALL(pThis))
      {
        pRct->left = -1;   // 'normalize' 'select all' to return {-1,-1,-1,-1}
        pRct->right = -1;
        pRct->top = -1;
        pRct->bottom = -1;
      }
      else
      {
        memcpy(pRct, &(pThis->rctSel), sizeof(*pRct));

        if(!SEL_RECT_EMPTY(pThis))   // if not empty
        {
          NORMALIZE_SEL_RECT(*pRct); // normalize the results
        }
      }
    }
  }
}
static void __internal_set_select(struct _text_object_ *pThis, const WB_RECT *pRct)
{
  if(WBIsValidTextObject(pThis))
  {
    memcpy(&(pThis->rctSel), pRct, sizeof(*pRct));
  }
}
static int __internal_has_select(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return !SEL_RECT_EMPTY(pThis);
  }
  return 0;
}
static char* __internal_get_sel_text(const struct _text_object_ *pThis, const WB_RECT *pRct)
{
WB_RECT rctSel;

  if(WBIsValidTextObject(pThis))
  {
    if(SEL_RECT_EMPTY(pThis))
    {
      return NULL;
    }
    else if(SEL_RECT_ALL(pThis))
    {
      return __internal_get_selected_text(pThis, -1, -1, -1, -1);
    }

    memcpy(&rctSel, &(pThis->rctSel), sizeof(rctSel));

    NORMALIZE_SEL_RECT(rctSel);

    return __internal_get_selected_text(pThis, rctSel.top, rctSel.left,
                                        rctSel.bottom, rctSel.right);
  }
  return NULL; // for now
}
static int __internal_get_row(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iRow;
  }
  return 0; // for now
}
static void __internal_set_row(struct _text_object_ *pThis, int iRow)
{
  if(WBIsValidTextObject(pThis))
  {
    if(iRow < 0 || !pThis->pText)
    {
      iRow = 0;
    }
    else if(iRow > ((TEXT_BUFFER *)pThis->pText)->nEntries)
    {
      iRow = ((TEXT_BUFFER *)pThis->pText)->nEntries;
    }

    pThis->iRow = iRow;
  }
}
static int __internal_get_col(const struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    return pThis->iCol;
  }
  return 0; // for now
}
static void __internal_set_col(struct _text_object_ *pThis, int iCol)
{
int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

  if(WBIsValidTextObject(pThis))
  {
    pThis->iCol = iCol; // for now, assign "as-is"

    if(pThis->iLineFeed == LineFeed_NONE && // single-line, do auto-scrolling
       pThis->rctView.right > pThis->rctView.left) // in case the view area is empty
    {
      while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
      {
        iAutoScrollWidth >>= 1;
      }

      // scroll left/right to expose the cursor

      while(pThis->rctView.left > pThis->iCol)
      {
        pThis->rctView.left -= iAutoScrollWidth;
        pThis->rctView.right -= iAutoScrollWidth;
      }
      while(pThis->rctView.right <= pThis->iCol)
      {
        pThis->rctView.left += iAutoScrollWidth;
        pThis->rctView.right += iAutoScrollWidth;
      }
    }
  }
}
static void __internal_del_select(struct _text_object_ *pThis)
{
char *pTemp, *pL;
int iSelAll, iLen, i1, i2;
TEXT_BUFFER *pBuf;
WB_RECT rctSel;


  if(WBIsValidTextObject(pThis))
  {
    __internal_invalidate_cursor(pThis, 0);
    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    iSelAll = SEL_RECT_ALL(pThis); // identifies "select all"

    if(!iSelAll && SEL_RECT_EMPTY(pThis))
    {
      // no selection, do nothing
      return;
    }

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf || (pThis->rctSel.top >= pBuf->nEntries && pThis->rctSel.bottom >= pBuf->nEntries))
    {
      return;  // NO buffer, or select area is outside of buffer area
    }

    // for the undo buffer I will need a copy of the original text.
    // this function only returns NULL on error

    memcpy(&rctSel, &(pThis->rctSel), sizeof(rctSel));

    if(iSelAll)
    {
      pTemp = __internal_get_selected_text(pThis, -1, -1, -1, -1);
    }
    else
    {
      NORMALIZE_SEL_RECT(rctSel);

      pTemp = __internal_get_selected_text(pThis, rctSel.top, rctSel.left,
                                           rctSel.bottom, rctSel.right);
    }

    if(iSelAll)
    {
      // delete all
      if(pThis->pText)
      {
        WBFreeTextBuffer(pThis->pText);
        pThis->pText = NULL;
      }

      if(pTemp)
      {
        __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                            0, 0, &(pThis->rctSel), pTemp, -1,
                            pBuf->nEntries, 0, NULL, NULL, 0);
      }
    }
    else if(pThis->iLineFeed == LineFeed_NONE ||
            rctSel.top == rctSel.bottom) // single-line selection (all methods behave the same)
    {
      // delete from rctSel.left to rctSel.right (exclusive)

      pL = pBuf->aLines[rctSel.top];

      if(pL)
      {
        iLen = strlen(pL);
        if(iLen >= rctSel.left)
        {
          if(iLen <= rctSel.right)
          {
            pL[rctSel.left] = 0; // just truncate the string
          }
          else
          {
            strcpy(pL + rctSel.left, pL + rctSel.right);
          }
        }
      }

      if(pTemp)
      {
        __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                            rctSel.top, rctSel.left, &(pThis->rctSel),
                            pTemp, -1,
                            rctSel.bottom, rctSel.right, NULL, NULL, 0);
      }

      if(pThis->iLineFeed == LineFeed_NONE && // special case, auto-hscroll
         pThis->rctView.right > pThis->rctView.left)
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
        {
          iAutoScrollWidth >>= 1;
        }

        // scroll left/right to expose the cursor

        while(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.left -= iAutoScrollWidth;
          pThis->rctView.right -= iAutoScrollWidth;
        }
        while(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += iAutoScrollWidth;
          pThis->rctView.right += iAutoScrollWidth;
        }
      }
    }
    else if(pThis->iSelMode == SelectMode_BOX)
    {
    }
    else if(pThis->iSelMode == SelectMode_LINE)
    {
    }
    else // default 'char'
    {
      if(pBuf->aLines[rctSel.top] && rctSel.left > 0)
      {
        pL = pBuf->aLines[rctSel.top];

        if(pL)
        {
          iLen = strlen(pL);
          if(iLen > rctSel.left) // the "delete point"
          {
            pL[rctSel.left] = 0; // truncate the line here
          }
        }

        if(rctSel.right > 0) // merge bottom line with this one
        {
          pTemp = pBuf->aLines[rctSel.bottom];

          if(pTemp)
          {
            pL = WBReAlloc(pL, strlen(pL) + strlen(pTemp) + 2);
            if(pL)
            {
              pBuf->aLines[rctSel.top] = pL;
              strcat(pL, pTemp);
              WBFree(pTemp);
              pBuf->aLines[rctSel.bottom] = NULL; // so it's not re-used
            }
            else
            {
              WB_ERROR_PRINT("ERROR - %s - memory allocation error (partial delete performed) errno=%d\n", __FUNCTION__, errno);
              return; // no undo buffer when there's a memory error
            }
          }

          i2 = rctSel.bottom + 1; // start copying the NEXT line
        }
        else
        {
          i2 = rctSel.bottom; // start copying THIS line (since I'm not joining them)
        }

        for(i1=pThis->rctSel.top + 1; i2 < pBuf->nEntries; i1++, i2++)
        {
          if(pBuf->aLines[i1])
          {
            WBFree(pBuf->aLines[i1]);
          }
          pBuf->aLines[i1] = pBuf->aLines[i2];
          pBuf->aLines[i2] = NULL; // for now, to prevent accidental pointer re-use later
        }

        pBuf->nEntries = i1;
      }
      else
      {
        if(rctSel.right == 0) // an even number of lines is being deleted
        {
          for(i1=rctSel.top, i2=rctSel.bottom; i2 < pBuf->nEntries; i1++, i2++)
          {
            if(pBuf->aLines[i1])
            {
              WBFree(pBuf->aLines[i1]);
            }
            pBuf->aLines[i1] = pBuf->aLines[i2];
            pBuf->aLines[i2] = NULL; // for now, to prevent accidental pointer re-use later
          }

          pBuf->nEntries = i1;
        }
        else // uneven lines
        {
          // top line will become partial bottom line
          pL = pBuf->aLines[rctSel.bottom];

          if(pL)
          {
            strcpy(pL, pL + rctSel.right);
          }

          if(pBuf->aLines[rctSel.top])
          {
            WBFree(pBuf->aLines[rctSel.top]);
          }

          pBuf->aLines[rctSel.top] = pL;
          pBuf->aLines[rctSel.bottom] = NULL; // to prevent re-use of pointer

          for(i1=rctSel.top + 1, i2=rctSel.bottom + 1; i2 < pBuf->nEntries; i1++, i2++)
          {
            if(pBuf->aLines[i1])
            {
              WBFree(pBuf->aLines[i1]);
            }

            pBuf->aLines[i1] = pBuf->aLines[i2];
            pBuf->aLines[i2] = NULL; // for now, to prevent accidental pointer re-use later
          }

          pBuf->nEntries = i1;
        }
      }

      if(pTemp)
      {
        __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                            rctSel.top, rctSel.left, &(pThis->rctSel),
                            pTemp, -1,
                            rctSel.bottom, rctSel.right, NULL, NULL, 0);
      }
    }

    if(pTemp)
    {
      free(pTemp);
    }

    // once the selection has been deleted, select 'nothing' and re-paint all
    // and of course, iRow and iCol will be at the left/top of the selection

    // NOTE:  this assumes that the data is consistent

    pThis->rctSel.left = pThis->rctSel.top = pThis->rctSel.right = pThis->rctSel.bottom = 0;

    if(iSelAll)
    {
      pThis->iRow = pThis->iCol = 0;
    }
    else
    {
      pThis->iRow = rctSel.top;
      pThis->iCol = rctSel.left;
    }

    __internal_invalidate_rect(pThis, NULL, 1); // TODO:  optimize this
  }
}
static void __internal_replace_select(struct _text_object_ *pThis, const char *szText, unsigned long cbLen)
{
WB_RECT rctSel;
int iSelAll;

  if(WBIsValidTextObject(pThis))
  {
    int iOldRow, iOldCol, iOldIns;

    if(pThis->iRow < 0 || pThis->iCol< 0)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }

    iOldRow = pThis->iRow;
    iOldCol = pThis->iCol;
    iOldIns = pThis->iInsMode;

    iSelAll = SEL_RECT_ALL(pThis);

    memcpy(&rctSel, &(pThis->rctSel), sizeof(rctSel));

    if(iSelAll)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }
    else if(!SEL_RECT_EMPTY(pThis))
    {
      NORMALIZE_SEL_RECT(rctSel);

      pThis->iRow = rctSel.top;
      pThis->iCol = rctSel.left;
    }

    pThis->iInsMode = InsertMode_INSERT;

    // TODO:  if box mode, height/width may need to match.  for now, don't care

    if(!iSelAll && SEL_RECT_EMPTY(pThis)) // not 'ALL'
    {
      __internal_ins_chars(pThis, szText, cbLen); // just insert the text (no selection)

      // NOTE:  select rectangle remains empty
    }
    else
    {
      // for now delete the selection, then insert the new characters
      // this will take into consideration the select mode
      __internal_del_select(pThis);               // this also clears the selection

     // new selection starts at rctSel.top, rctSel.left

      __internal_ins_chars(pThis, szText, cbLen); // just insert the text (no selection)

      // new selection ends at iRow, iCol

      rctSel.right = pThis->iRow;
      rctSel.bottom = pThis->iCol;

      // assign the new select rectangle to become the text I just added.
      memcpy(&(pThis->rctSel), &rctSel, sizeof(pThis->rctSel));
    }

//    pThis->iRow = iOldRow;
//    pThis->iCol = iOldCol;
    pThis->iInsMode = iOldIns;

    // todo:  mark a NEW selection using the inserted text?  this might mean replicating code for
    //        __internal_del_select and __internal_ins_chars and processing undo here


    __internal_invalidate_rect(pThis, NULL, 1); // TODO:  optimize this
  }
}
static void __internal_del_chars(struct _text_object_ *pThis, int nChar)
{
TEXT_BUFFER *pBuf;
int i1, i2, iLen;
char *pL, *pL2, *pTemp;
WB_RECT rctInvalid;


  if(!nChar)
  {
    return; // does nothing
  }

  // NOTE: nChar < 0 deletes to the left (like a backspace), >0 deletes to the right like 'Del' normally would
  //       If the cursor is at the end of the line or the start of the line, an appropriate delete will
  //       merge the previous (or next) line.  Values of |nChar| greater than the number of characters remaining
  //       in the line (from the cursor) _STOP_ at the beginning/end of the line.  Only a delete with cursor
  //       AT the beginning or end of the line will merge.  Merge also considers the virtual cursor position.

  if(WBIsValidTextObject(pThis))
  {
    __internal_invalidate_cursor(pThis, 0);
    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    if(nChar > 0 || pThis->iCol == 0)
    {
      __internal_calc_rect(pThis, &rctInvalid, pThis->iRow, pThis->iCol, pThis->iRow, pThis->iCol + 1);
    }
    else if(pThis->iCol > 0)
    {
      __internal_calc_rect(pThis, &rctInvalid, pThis->iRow, pThis->iCol - 1, pThis->iRow, pThis->iCol);
    }

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf || !pBuf->nEntries || pThis->iRow > pBuf->nEntries ||
       (pThis->iRow == pBuf->nEntries && nChar > 0)) // ending row only allows a backspace from the 1st column
    {
      return;  // do nothing
    }

    pL = pBuf->aLines[pThis->iRow];
    if(!pL)
    {
      return; // do nothing (TODO:  error message?)
    }

    iLen = strlen(pL);

    // for the first delete, if it's at an edge, merge lines

    if(pThis->iRow > 0 && nChar < 0 && pThis->iCol == 0) // backspace while at the start of a line
    {
      pL2 = pBuf->aLines[pThis->iRow - 1];

      if(!pL2)
      {
        return; // do nothing (TODO:  error message?)
      }

      // allocate memory for merged line
      i2 = strlen(pL2); // also the new column position
      pTemp = WBReAlloc(pL2, i2 + iLen + 2);
      if(!pTemp)
      {
        return; // do nothing (TODO:  error message?)
      }

      pBuf->aLines[pThis->iRow - 1] = pTemp; // the new pointer

      strcpy(pTemp + i2, pL); // merge them

      for(i1=pThis->iRow; i1 < pBuf->nEntries; i1++)
      {
        pBuf->aLines[i1 - 1] = pBuf->aLines[i1];
      }

      pBuf->nEntries--;
      pBuf->aLines[pBuf->nEntries] = NULL; // so that pointers aren't accidentally re-used

      WBFree(pL); // free up memory for old line

      pThis->iRow--;
      pThis->iCol = i2;

      nChar++;

      __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                          pThis->iRow, i2, &(pThis->rctSel), "\n", 1,
                          pThis->iRow + 1, 0, NULL, NULL, 0);

      __internal_merge_rect(pThis, &rctInvalid, pThis->iRow, 0, -1, -1);
    }
    else if(pThis->iCol >= iLen && nChar > 0 && pThis->iRow < (pBuf->nEntries - 1))
    {
      pL2 = pBuf->aLines[pThis->iRow + 1];

      if(!pL2)
      {
        return; // do nothing (TODO:  error message?)
      }

      // allocate memory for merged line
      i2 = strlen(pL2);

      if(i2 > 0) // if it's empty we don't copy anything
      {
        pTemp = WBReAlloc(pL, i2 + pThis->iCol + 2);
           // note that 'iCol' is the point we'll be copying to, not 'iLen'
        if(!pTemp)
        {
          return; // do nothing (TODO:  error message?)
        }

        pBuf->aLines[pThis->iRow] = pTemp; // the new pointer

        if(iLen < pThis->iCol)
        {
          memset(pTemp + iLen, ' ', pThis->iCol - iLen); // fill with white space up to 'iCol'
        }

        strcpy(pTemp + pThis->iCol, pL); // merge them
      }

      pBuf->nEntries--;

      for(i1=pThis->iRow; i1 < pBuf->nEntries; i1++)
      {
        pBuf->aLines[i1] = pBuf->aLines[i1 + 1];
      }

      pBuf->aLines[pBuf->nEntries] = NULL; // so that pointers aren't accidentally re-used

      WBFree(pL2); // free up memory for old line

      nChar--;

      __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                          pThis->iRow, iLen, &(pThis->rctSel), "\n", 1,
                          pThis->iRow + 1, 0, NULL, NULL, 0);

      __internal_merge_rect(pThis, &rctInvalid, pThis->iRow, 0, pThis->iRow, -1); // invalidate entire row
    }

    // OK now that _THAT_ is done, delete "up to the end of the string if needed"
    // on either end, depending upon which direction we must travel

    pL = pBuf->aLines[pThis->iRow];

    if(!pL)
    {
      return; // do nothing (TODO:  error message?)
    }

    if(nChar < 0 && pThis->iCol > 0)
    {
      // TODO:  handle hard tab translation?  For now "leave it"

      nChar = -nChar;
      if(nChar > pThis->iCol)
      {
        nChar = pThis->iCol;
      }

      // create undo record first, before I actually delete things
      __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                          pThis->iRow, pThis->iCol - nChar, &(pThis->rctSel),
                          pL + pThis->iCol - nChar, nChar,
                          pThis->iRow, pThis->iCol, NULL, NULL, 0);

      strcpy(pL + pThis->iCol - nChar, pL + pThis->iCol); // delete things down

      pThis->iCol -= nChar;

      __internal_merge_rect(pThis, &rctInvalid, pThis->iRow, pThis->iCol, pThis->iRow, -1); // invalidate remainder of row
    }
    else if(nChar > 0 && iLen > pThis->iCol)
    {
      // TODO:  handle hard tab translation?  For now "leave it"

      if(nChar > iLen - pThis->iCol)
      {
        nChar = iLen - pThis->iCol;
      }

      // create undo record first, before I actually delete things
      __internal_add_undo(pThis, UNDO_DELETE, pThis->iSelMode,
                          pThis->iRow, pThis->iCol, &(pThis->rctSel),
                          pL + pThis->iCol, nChar,
                          pThis->iRow, pThis->iCol + nChar, NULL, NULL, 0);

      strcpy(pL + pThis->iCol, pL + pThis->iCol + nChar); // delete things down

      // NOTE:  column does not change
      __internal_merge_rect(pThis, &rctInvalid, pThis->iRow, pThis->iCol, pThis->iRow, -1); // invalidate remainder of row
    }

    // implement auto-hscroll while deleting

    if(pThis->rctView.right > pThis->rctView.left)
    {
      if(pThis->rctView.right <= pThis->iCol ||
         pThis->rctView.left > pThis->iCol)
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
        {
          iAutoScrollWidth >>= 1;
        }

        // scroll left/right to expose the cursor

        while(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.left -= iAutoScrollWidth;
          pThis->rctView.right -= iAutoScrollWidth;
        }
        while(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += iAutoScrollWidth;
          pThis->rctView.right += iAutoScrollWidth;
        }

        __internal_invalidate_rect(pThis, NULL, 1); // scrolling, so invalidate everything
      }
      else
      {
        __internal_invalidate_rect(pThis, &rctInvalid, 1); // invalidate bounding rectangle
      }
    }
    else
    {
      __internal_invalidate_rect(pThis, &rctInvalid, 1); // invalidate bounding rectangle
    }
  }
}
static void __internal_ins_chars(struct _text_object_ *pThis, const char *pChar, int nChar)
{
TEXT_BUFFER *pBuf;
const char *p1, *p2;
char *pL, *pTemp;
int i1, iLen=0, iMultiLine = 0;
WB_RECT rctInvalid;


  if(!pChar || !nChar)
  {
    return;
  }

  if(nChar < 0)
  {
    nChar = strlen(pChar);
  }

  p1 = pChar;
  p2 = pChar + nChar;


  // FIRST, see if the insert is single-line or multi-line and act accordingly

  while(p1 < p2)
  {
    if(*p1 == '\n' || *p1 == '\r')
    {
      iMultiLine = 1;
      break; // this will be used in single-line mode to mark "stop here"
    }

    p1++;
  }


  if(WBIsValidTextObject(pThis))
  {
    if(pThis->iRow < 0 || pThis->iCol< 0)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }

    __internal_invalidate_cursor(pThis, 0);
    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    __internal_calc_rect(pThis, &rctInvalid, pThis->iRow, pThis->iCol, pThis->iRow, -1); // always refresh entire line from 'iCol' forward

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(pThis->iLineFeed == LineFeed_NONE) // single line
    {
      if(iMultiLine)
      {
        iMultiLine = 0;
        p2 = p1;
      }
      p1 = pChar;

      // insert at 'iCol'

      if(!pBuf) // no buffer, so add text now
      {
        pThis->pText = WBAllocTextBuffer(p1, p2 - p1);

        pThis->iRow = 0; // always
        pThis->iCol = p2 - p1; // effectively, like pressing 'end'

        __internal_add_undo(pThis, UNDO_INSERT, pThis->iSelMode,
                            pThis->iRow, 0, &(pThis->rctSel), NULL, 0, // old col was 0, always
                            pThis->iRow, pThis->iCol, NULL,            // new col already assigned
                            p1, p2 - p1); // the new text
      }
      else if(p2 > p1) // adding text to existing buffer
      {
        if(pThis->iRow != 0)
        {
          pThis->iRow = 0; // force it
        }

        if(pBuf->nEntries <= 0)
        {
          pBuf->nEntries = 1;
          pL = pBuf->aLines[0] = WBAlloc(pThis->iCol + p2 - p1 + 2);
          if(pL)
          {
            iLen = strlen(pL);
          }
        }
        else if(!pBuf->aLines[0])
        {
          pL = pBuf->aLines[0] = WBAlloc(pThis->iCol + p2 - p1 + 2);
          if(pL)
          {
            iLen = strlen(pL);
          }
        }
        else
        {
          pTemp = pBuf->aLines[0];
          i1 = iLen = strlen(pTemp);
          if(iLen < pThis->iCol)
          {
            i1 = pThis->iCol;
          }

          if(pThis->iInsMode == InsertMode_OVERWRITE)
          {
            if(i1 < pThis->iCol + p2 - p1)
            {
              i1 = pThis->iCol + p2 - p1; // extent of the text I'm adding when I overwrite
            }
          }
          else
          {
            i1 += p2 - p1;
          }

          pL = WBReAlloc(pTemp, i1 + 2);

          if(pL)
          {
            pBuf->aLines[0] = pL;
          }
        }

        if(pL)
        {
          if(iLen < pThis->iCol)
          {
            memset(pL + iLen, ' ', pThis->iCol - iLen); // pad with space
            pL[pThis->iCol + p2 - p1] = 0;              // I need a terminating zero byte
          }
          else if(iLen > pThis->iCol &&                    // insert 'in the middle'
                  pThis->iInsMode != InsertMode_OVERWRITE) // NOT overwriting
          {
            // make room for text
            memmove(pL + pThis->iCol + (p2 - p1), pL + pThis->iCol, iLen - pThis->iCol + 1);
          }
          else if((p2 - p1) + pThis->iCol >= iLen)
          {
            pL[pThis->iCol + p2 - p1] = 0; // I need a terminating zero byte
          }

          __internal_add_undo(pThis, UNDO_INSERT, pThis->iSelMode,
                              pThis->iRow, pThis->iCol, &(pThis->rctSel),
                              (pThis->iInsMode == InsertMode_OVERWRITE && pThis->iCol < iLen ?
                               pL + pThis->iCol : NULL), // for overwrite, it's the original text
                              (pThis->iInsMode == InsertMode_OVERWRITE && pThis->iCol < iLen ?
                               p2 - p1 : 0),  // length of old text for overwrite
                              pThis->iRow, pThis->iCol + (p2 - p1), NULL,
                              p1, p2 - p1); // the new text

          memcpy(pL + pThis->iCol, p1, p2 - p1); // insert the data

          pThis->iCol += p2 - p1; // always advance the cursor to this point (overwrite OR insert)
        }
      }
    }
    else // multi-line text
    {

      // TODO: auto-vscroll while inserting text, make sure cursor position is visible

      __internal_invalidate_rect(pThis, NULL, 1); // so invalidate everything
    }

    // auto-hscroll while inserting text, make sure cursor position is visible

    if(pThis->rctView.right > pThis->rctView.left)
    {
      if(iMultiLine ||
         pThis->rctView.right <= pThis->iCol ||
         pThis->rctView.left > pThis->iCol)
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
        {
          iAutoScrollWidth >>= 1;
        }

        // scroll left/right to expose the cursor

        while(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.left -= iAutoScrollWidth;
          pThis->rctView.right -= iAutoScrollWidth;
        }
        while(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += iAutoScrollWidth;
          pThis->rctView.right += iAutoScrollWidth;
        }

        __internal_invalidate_rect(pThis, NULL, 1); // scrolling, so invalidate everything
      }
      else
      {
        __internal_invalidate_rect(pThis, &rctInvalid, 1); // invalidate bounding rectangle
      }
    }
    else
    {
      __internal_invalidate_rect(pThis, NULL, 1); // invalidate everything (confusion handler)
    }
  }
}
static void __internal_indent(struct _text_object_ *pThis, int nCol)
{
  if(WBIsValidTextObject(pThis))
  {
  }
}
static int __internal_can_undo(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
  }
  return 0; // for now
}
static void __internal_undo(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
  }
}
static int __internal_can_redo(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
  }
  return 0; // for now
}
static void __internal_redo(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
  }
}
static void __internal_get_view(const struct _text_object_ *pThis, WB_RECT *pRct)
{
  if(WBIsValidTextObject(pThis))
  {
  }
}
static void __internal_set_view(struct _text_object_ *pThis, const WB_RECT *pRct)
{
  if(WBIsValidTextObject(pThis))
  {
  }
}
static void __internal_begin_highlight(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iDragState = DragState_CURSOR;
  }
}
static void __internal_end_highlight(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iDragState = DragState_NONE;
  }
}
static void __internal_mouse_click(struct _text_object_ *pThis, int iMouseXDelta, int iMouseYDelta, int iType, int iACS)
{
TEXT_BUFFER *pBuf;
int iRow = -1, iCol = -1; // pre-assign error returns
int iFontHeight;
WB_RECT rctSel;

  // NOTE:  if this has never been painted, I can't respond to this request

  if(WBIsValidTextObject(pThis))
  {
    pBuf = (TEXT_BUFFER *)(pThis->pText);

    memset(&rctSel, 0, sizeof(rctSel));

    if(!(pThis->iDragState & DragState_MOUSE)) // not mouse-dragging at the moment
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    iFontHeight = pThis->iAsc + pThis->iDesc;

    if(iFontHeight && pThis->iFontWidth &&
       pThis->rctWinView.left < pThis->rctWinView.right &&
       pThis->rctWinView.top < pThis->rctWinView.bottom)
    {
      if(pThis->iLineFeed == LineFeed_NONE) // i.e. "single line"
      {
        iRow = 0; // always
      }
      else
      {
        if(pThis->iDesc > MIN_LINE_SPACING / 2)
        {
          iFontHeight += pThis->iDesc / 2; // line spacing is 1/2 of descent, or MIN_LINE_SPACING
        }
        else
        {
          iFontHeight += MIN_LINE_SPACING;
        }

        iRow = pThis->rctView.top
             + (iMouseYDelta + iFontHeight / 4 - pThis->rctWinView.top) / iFontHeight;

        if(iRow < 0 || !pBuf)
        {
          iRow = 0;
        }
        else if(iRow > pBuf->nEntries)
        {
          iRow = pBuf->nEntries;
        }
      }

      // column calculation is no different between single-line and multi-line
      iCol = pThis->rctView.left
           + (iMouseXDelta + pThis->iFontWidth / 4 - pThis->rctWinView.left) / pThis->iFontWidth;

      if(iCol < 0 || !pBuf || iRow >= pBuf->nEntries || !pBuf->aLines[iRow])
      {
        iCol = 0;  // for now also force column 0 if there's no buffer or a NULL entry for it or at end of document
      }
      else if(pThis->iLineFeed == LineFeed_NONE &&
              iCol > strlen(pBuf->aLines[iRow]))
      {
        iCol = strlen(pBuf->aLines[iRow]);  // don't select pos past end of line for single-line edit
      }
    }

    // if I am doing a mouse-drag, and the selection is empty, start a new selection.
    // if I am doing a cursor-drag, disable it.

    if(pThis->iDragState & DragState_CURSOR)
    {
      pThis->iDragState = DragState_NONE; // turn it off now.

      if(iType == WB_POINTER_BUTTON1 && iACS == 0) // only if left-click for now
      {
        pThis->iCol = iCol;
        pThis->iRow = iRow;
      }
    }
    else if(!(pThis->iDragState & DragState_MOUSE))
    {
      if(iType == WB_POINTER_BUTTON1 && iACS == 0) // only if left-click for now
      {
        pThis->iCol = iCol;
        pThis->iRow = iRow;
      }
      else
      {
        pThis->iDragState = DragState_NONE; // turn dragging off

        // TODO:  check for wheel buttons WB_POINTER_BUTTON4 and WB_POINTER_BUTTON5 ?
      }
    }
    else if(iType == 0 && iACS == 0) // a mouse motion message while dragging
    {
      // see if the select rectangle is empty.  If it is, then I
      // am just starting the drag and I need to anchor the cursor

      // NOTE:  cursor anchor is always (left,top) even if it's a negative distance

      if(SEL_RECT_EMPTY(pThis))
      {
        pThis->rctSel.top = pThis->iRow; // old row
        pThis->rctSel.left = pThis->iCol; // previous column
      }

      pThis->rctSel.bottom = iRow;     // new row
      pThis->rctSel.right = iCol;       // new column

      pThis->iCol = iCol;
      pThis->iRow = iRow;
    }
    else
    {
      // TODO:  cancel dragging?  or not... [maybe check for right-click or scroll]

      // TODO:  check for wheel buttons WB_POINTER_BUTTON4 and WB_POINTER_BUTTON5 ?
      //        for a mouse drag I may enable this, but probably should just shut off the drag
      //        maybe shift+wheel would select...? testing it shows that it scrolls the viewport

      pThis->iDragState = DragState_NONE; // turn dragging off, for now
    }

    // for now mouse-click invalidates the entire rectangle.  Later I fix this.

    __internal_invalidate_rect(pThis, NULL, 1); // POOBAH
  }
}
static void __internal_begin_mouse_drag(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
//    WB_ERROR_PRINT("TEMPORARY - %s\n", __FUNCTION__);
    pThis->iDragState = DragState_MOUSE;
  }
}
static void __internal_end_mouse_drag(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
//    WB_ERROR_PRINT("TEMPORARY - %s\n", __FUNCTION__);
    pThis->iDragState = DragState_NONE;
  }
}
static void __internal_cursor_up(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;
int iPageHeight;


  if(WBIsValidTextObject(pThis))
  {
    int iOldRow = pThis->iRow;

    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    if(pThis->iLineFeed == LineFeed_NONE) // single line
    {
      return; // do nothing
    }

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }
    else if(pBuf->nEntries < pThis->iRow)
    {
      pThis->iRow = pBuf->nEntries;
      pThis->iCol = 0;
    }
    else if(pThis->iRow > 0)
    {
      pThis->iRow--;
    }
    else
    {
      pThis->iRow = 0;
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        pThis->rctSel.left = pThis->iCol;
        pThis->rctSel.top = iOldRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(pThis->rctView.top > pThis->iRow ||
       pThis->rctView.bottom <= pThis->iRow)
    {
      __internal_invalidate_rect(pThis, NULL, 1); // scrolling invalidates all


      iPageHeight = pThis->rctView.bottom - pThis->rctView.top - 1;

      // scroll up/down to expose the cursor

      if(iPageHeight > 0)
      {
        while(pThis->rctView.top > pThis->iRow)
        {
          pThis->rctView.top -= iPageHeight;
          pThis->rctView.bottom -= iPageHeight;
        }

        while(pThis->rctView.bottom <= pThis->iRow)
        {
          pThis->rctView.top += iPageHeight;
          pThis->rctView.bottom += iPageHeight;
        }
      }
    }
    else // re-calculate cursor metrics
    {
      pThis->iCursorY += (pThis->iAsc + pThis->iDesc
                          + pThis->iDesc > MIN_LINE_SPACING * 2 ?
                            pThis->iDesc / 2 : MIN_LINE_SPACING)
                       * (pThis->iRow - iOldRow);

      __internal_invalidate_cursor(pThis, 1); // invalidate the NEW cursor rectangle
    }
  }
}
static void __internal_cursor_down(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;
int iPageHeight;


  if(WBIsValidTextObject(pThis))
  {
    int iOldRow = pThis->iRow;

    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    if(pThis->iLineFeed == LineFeed_NONE) // single line
    {
      return; // do nothing
    }

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }
    else if(pThis->iRow >= (pBuf->nEntries - 1))
    {
      pThis->iRow = pBuf->nEntries;
      pThis->iCol = 0;
    }
    else
    {
      pThis->iRow++;
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        pThis->rctSel.left = pThis->iCol;
        pThis->rctSel.top = iOldRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(pThis->rctView.top > pThis->iRow ||
       pThis->rctView.bottom <= pThis->iRow)
    {
      __internal_invalidate_rect(pThis, NULL, 1); // scrolling invalidates all


      iPageHeight = pThis->rctView.bottom - pThis->rctView.top - 1;

      // scroll up/down to expose the cursor

      if(iPageHeight > 0)
      {
        while(pThis->rctView.top > pThis->iRow)
        {
          pThis->rctView.top -= iPageHeight;
          pThis->rctView.bottom -= iPageHeight;
        }

        while(pThis->rctView.bottom <= pThis->iRow)
        {
          pThis->rctView.top += iPageHeight;
          pThis->rctView.bottom += iPageHeight;
        }
      }
    }
    else // re-calculate cursor metrics
    {
      pThis->iCursorY += (pThis->iAsc + pThis->iDesc
                          + pThis->iDesc > MIN_LINE_SPACING * 2 ?
                            pThis->iDesc / 2 : MIN_LINE_SPACING)
                       * (pThis->iRow - iOldRow);

      __internal_invalidate_cursor(pThis, 1); // invalidate the NEW cursor rectangle
    }
  }
}
static void __internal_cursor_left(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;


  if(WBIsValidTextObject(pThis))
  {
    int iOldCol = pThis->iCol;

    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }
    else if(pThis->iCol > 0)
    {
      pThis->iCol --;
    }
    else
    {
      pThis->iCol = 0;
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        pThis->rctSel.left = iOldCol;
        pThis->rctSel.top = pThis->iRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(pThis->rctView.right > pThis->rctView.left)
    {
      if(pThis->rctView.right <= pThis->iCol ||
         pThis->rctView.left > pThis->iCol)
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
        {
          iAutoScrollWidth >>= 1;
        }

        // scroll left/right to expose the cursor

        while(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.left -= iAutoScrollWidth;
          pThis->rctView.right -= iAutoScrollWidth;
        }
        while(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += iAutoScrollWidth;
          pThis->rctView.right += iAutoScrollWidth;
        }

        __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
      }
      else // re-calculate cursor metrics
      {
        pThis->iCursorX += (pThis->iCol - iOldCol) * pThis->iFontWidth;

        __internal_invalidate_cursor(pThis, 1); // invalidate the NEW cursor rectangle
      }
    }
    else
    {
      __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here (confusion point)
    }
  }
}
static void __internal_cursor_right(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;


  if(WBIsValidTextObject(pThis))
  {
    int iOldCol = pThis->iCol;

    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf)
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }
    else if(pThis->iCol < 0)
    {
      pThis->iCol = 0;
    }
    else if(pThis->iCol < INT_MAX)
    {
      if(pThis->iLineFeed == LineFeed_NONE) // single line
      {
        if(pBuf->nEntries <= 0 || !pBuf->aLines[0])
        {
          pThis->iCol = 0;
        }
        else
        {
          int iLen = strlen(pBuf->aLines[0]);

          if(pThis->iRow != 0)
          {
            pThis->iRow = 0; // force it
          }

          // no 'virtual space' for single-line but trailing white space OK

          if(pThis->iCol >= iLen)
          {
            pThis->iCol = iLen;
          }
          else
          {
            pThis->iCol++;
          }
        }
      }
      else
      {
        pThis->iCol ++;
      }
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        pThis->rctSel.left = iOldCol;
        pThis->rctSel.top = pThis->iRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(pThis->rctView.right > pThis->rctView.left)
    {
      if(pThis->rctView.right <= pThis->iCol ||
         pThis->rctView.left > pThis->iCol)
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
        {
          iAutoScrollWidth >>= 1;
        }

        // scroll left/right to expose the cursor

        while(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.left -= iAutoScrollWidth;
          pThis->rctView.right -= iAutoScrollWidth;
        }
        while(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += iAutoScrollWidth;
          pThis->rctView.right += iAutoScrollWidth;
        }

        __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
      }
      else // re-calculate cursor metrics
      {
        pThis->iCursorX += (pThis->iCol - iOldCol) * pThis->iFontWidth;

        __internal_invalidate_cursor(pThis, 1); // invalidate the NEW cursor rectangle
      }
    }
    else
    {
      __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here (confusion point)
    }
  }
}
static void __internal_page_up(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something


    __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
  }
}
static void __internal_page_down(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something


    __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
  }
}
static void __internal_page_left(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something


    __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
  }
}
static void __internal_page_right(struct _text_object_ *pThis)
{
  if(WBIsValidTextObject(pThis))
  {
    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something


    __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
  }
}

static void __internal_cursor_home(struct _text_object_ *pThis)
{
const char *pL, *p2;
TEXT_BUFFER *pBuf;


  if(WBIsValidTextObject(pThis))
  {
    int iOldCol = pThis->iCol;

    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf || pThis->iRow >= pBuf->nEntries || pThis->iCol > 0)
    {
      pThis->iCol = 0;
    }
    else
    {
      // find first non-white-space character and assign to THAT
      // TODO:  handle hard tab translation?  For now "leave it"

      pL = pBuf->aLines[pThis->iRow];

      if(pL)
      {
        p2 = pL;
        while(*p2 && *p2 <= ' ') // TODO:  adjust for 'hard tab' char which might be '\xa0'...
        {
          p2++;
        }

        if(*p2)
        {
          pThis->iCol = (int)(p2 - pL); // toggling 'beginning of line' and column 0
        }
      }
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        pThis->rctSel.left = iOldCol;
        pThis->rctSel.top = pThis->iRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(pThis->rctView.right > pThis->rctView.left)
    {
      if(pThis->rctView.right <= pThis->iCol ||
         pThis->rctView.left > pThis->iCol)
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
        {
          iAutoScrollWidth >>= 1;
        }

        // scroll left/right to expose the cursor

        while(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.left -= iAutoScrollWidth;
          pThis->rctView.right -= iAutoScrollWidth;
        }
        while(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += iAutoScrollWidth;
          pThis->rctView.right += iAutoScrollWidth;
        }

        __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
      }
      else // re-calculate cursor metrics
      {
        pThis->iCursorX += (pThis->iCol - iOldCol) * pThis->iFontWidth;

        __internal_invalidate_cursor(pThis, 1); // invalidate the NEW cursor rectangle
      }
    }
    else
    {
      __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here (confusion point)
    }
  }
}

static void __internal_cursor_end(struct _text_object_ *pThis)
{
const char *pL;
TEXT_BUFFER *pBuf;


  if(WBIsValidTextObject(pThis))
  {
    int iOldCol = pThis->iCol;

    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    __internal_invalidate_cursor(pThis, 0); // invalidate current cursor rectangle

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf || pThis->iRow >= pBuf->nEntries)
    {
      pThis->iCol = 0;
    }
    else
    {
      pL = pBuf->aLines[pThis->iRow];

      if(!pL)
      {
        pThis->iCol = 0;
      }
      else
      {
        pThis->iCol = strlen(pL);
      }
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        pThis->rctSel.left = iOldCol;
        pThis->rctSel.top = pThis->iRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    if(pThis->rctView.right > pThis->rctView.left)
    {
      if(pThis->rctView.right <= pThis->iCol ||
         pThis->rctView.left > pThis->iCol)
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
        {
          iAutoScrollWidth >>= 1;
        }

        // scroll left/right to expose the cursor

        while(pThis->rctView.left > pThis->iCol)
        {
          pThis->rctView.left -= iAutoScrollWidth;
          pThis->rctView.right -= iAutoScrollWidth;
        }
        while(pThis->rctView.right <= pThis->iCol)
        {
          pThis->rctView.left += iAutoScrollWidth;
          pThis->rctView.right += iAutoScrollWidth;
        }

        __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here
      }
      else // re-calculate cursor metrics
      {
        pThis->iCursorX += (pThis->iCol - iOldCol) * pThis->iFontWidth;

        __internal_invalidate_cursor(pThis, 1); // invalidate the NEW cursor rectangle
      }
    }
    else
    {
      __internal_invalidate_rect(pThis, NULL, 1); // invalidate entire screen if I'm here (confusion point)
    }
  }
}

static void __internal_cursor_top(struct _text_object_ *pThis)
{
int iPageHeight;

  if(WBIsValidTextObject(pThis))
  {
    int iOldRow = pThis->iRow;

    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    pThis->iRow = 0;
    pThis->iCol = 0;

    iPageHeight = pThis->rctView.bottom - pThis->rctView.top - 1;

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        pThis->rctSel.left = pThis->iCol;
        pThis->rctSel.top = iOldRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    // scroll up/down to expose the cursor

    if(iPageHeight > 0)
    {
      while(pThis->rctView.top > pThis->iRow)
      {
        pThis->rctView.top -= iPageHeight;
        pThis->rctView.bottom -= iPageHeight;
      }

      while(pThis->rctView.bottom <= pThis->iRow)
      {
        pThis->rctView.top += iPageHeight;
        pThis->rctView.bottom += iPageHeight;
      }
    }
  }
}

static void __internal_cursor_bottom(struct _text_object_ *pThis)
{
TEXT_BUFFER *pBuf;
int iPageHeight;

  if(WBIsValidTextObject(pThis))
  {
    int iOldRow = pThis->iRow;

    pThis->iBlinkState = 0; // this affects the cursor blink, basically resetting it whenever I edit something

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(pBuf)
    {
      pThis->iRow = pBuf->nEntries;  // last line, which has no text
      pThis->iCol = 0;
    }
    else
    {
      pThis->iRow = 0;
      pThis->iCol = 0;
    }

    if(pThis->iDragState & DragState_CURSOR)
    {
      if(SEL_RECT_EMPTY(pThis))
      {
        pThis->rctSel.left = pThis->iCol;
        pThis->rctSel.top = iOldRow;
      }

      pThis->rctSel.right = pThis->iCol;
      pThis->rctSel.bottom = pThis->iRow;
    }
    else
    {
      // clear the selection if there is one
      if(!SEL_RECT_EMPTY(pThis))
      {
        __internal_invalidate_rect(pThis, &(pThis->rctHighLight), 0); // invalidate the highlight rectangle
        memset(&(pThis->rctSel), 0, sizeof(pThis->rctSel));
        memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
      }
    }

    iPageHeight = pThis->rctView.bottom - pThis->rctView.top - 1;

    // scroll up/down to expose the cursor

    if(iPageHeight > 0)
    {
      while(pThis->rctView.top > pThis->iRow)
      {
        pThis->rctView.top -= iPageHeight;
        pThis->rctView.bottom -= iPageHeight;
      }

      while(pThis->rctView.bottom <= pThis->iRow)
      {
        pThis->rctView.top += iPageHeight;
        pThis->rctView.bottom += iPageHeight;
      }
    }
  }
}

static void __internal_do_expose(struct _text_object_ *pThis, Display *pDisplay, Window wID,
                                 GC gc, const WB_GEOM *pPaintGeom, const WB_GEOM *pViewGeom,
                                 XFontSet rFontSet)
{
TEXT_BUFFER *pBuf;
WB_GEOM geomV, geomP, geomC;
XFontStruct *pFont = NULL, **ppFonts = NULL;
char **ppNames, *pL;
int i1, iLen, iFontHeight, iFontWidth, nFonts, iAsc=0, iDesc=0, iX, iY, iW, iPX, iPY;
XFontSet fSet;
XFontSetExtents *pExt;
Pixmap pxTemp;
unsigned long clrFG, clrBG, clrHFG, clrHBG;
GC gc2 = None;


  if(pViewGeom)
  {
    memcpy(&geomV, pViewGeom, sizeof(geomV));
  }
  else
  {
    WBGetWindowGeom(wID, &geomV);

    geomV.y += MIN_BORDER_SPACING;           // need a minimum top/bottom border as well
    geomV.height -= MIN_BORDER_SPACING * 2;
  }

  // in all cases, make room on right/left edges for the cursor

  geomV.x += MIN_BORDER_SPACING; // required for cursor
  geomV.width -= MIN_BORDER_SPACING * 2;

  // TODO:  make use of geomV's "border" parameter??

  if(geomV.width <= MIN_BORDER_SPACING * 2 ||  // absolute minimum width
     geomV.height <= MIN_BORDER_SPACING * 2)   // absolute minimum height
  {
    return; // can't do window that's way too small
  }

  if(pPaintGeom)
  {
    memcpy(&geomP, pPaintGeom, sizeof(geomP));
  }
  else
  {
    memcpy(&geomP, &geomV, sizeof(geomV));
  }

  if(rFontSet == None) /* NULL? */
  {
    pFont = WBGetGCFont(pDisplay, gc);

    if(!pFont)
    {
      WB_ERROR_PRINT("%s - ERROR:  WBGetGCFont returns NULL\n", __FUNCTION__);

      return; // bad
    }

    fSet = WBFontSetFromFont(pDisplay, pFont); // convert font to font set

    XFreeFont(pDisplay, pFont); // free it now (important to do so)
    pFont = NULL;

    if(fSet == None)
    {
      WB_ERROR_PRINT("%s - ERROR:  WBFontSetFromFont returns None\n", __FUNCTION__);

      return; // bad
    }
  }
  else
  {
    fSet = rFontSet; // I must check for this before I free fSet later
  }

  // at this point I must use 'fSet' to do all of the font metrics + drawing

  pExt = XExtentsOfFontSet(fSet); // get extents for the font set (reserved)
  nFonts = XFontsOfFontSet(fSet, &ppFonts, &ppNames); // returns # of items (do NOT free resources!  They are owned by the font set)

  // TODO:  XFontStruct::direction indicates LTR RTL TTB or BTT for painting - for now _ONLY_ LTR_TTB will apply

  if(nFonts <= 0 || !ppFonts) // no fonts?
  {
    WB_ERROR_PRINT("%s - ERROR:  XFontsOfFontSet returns %d\n", __FUNCTION__, nFonts);

    goto the_end;
  }

  // to find the floor of the font, I'll need to determine max iAsc and iDesc

  for(i1=0; i1 < nFonts; i1++)
  {
    if(iAsc < ppFonts[i1]->ascent)
    {
      iAsc = ppFonts[i1]->ascent;
    }
    if(iDesc < ppFonts[i1]->descent)
    {
      iDesc = ppFonts[i1]->descent;
    }
  }

  // get the font width for a space

  iFontWidth = WB_TEXT_ESCAPEMENT(fSet, " ", 1);

  // get FG/BG color information

  clrFG = WBGetGCFGColor(pDisplay, gc);
  clrBG = WBGetGCBGColor(pDisplay, gc);

  // TODO:  compare clrHFG and clrHBG to a "NULL" XColor?
  if(!memcmp(&pThis->clrHFG, &pThis->clrHBG, sizeof(XColor))) // not assigned (they should never match)
  {
    clrHBG = clrFG;
    clrHFG = clrBG;
  }
  else
  {
    clrHBG = pThis->clrHBG.pixel;
    clrHFG = pThis->clrHFG.pixel;
  }

  // make a copy of the GC since I'm probably going to mess with it

  gc2 = XCreateGC(pDisplay, wID, 0, NULL);

  if(gc2 != None)
  {
    // NOTE:  docs wrong for XCopyGC, header correct - see WBBeginPaint()
    if(!XCopyGC(pDisplay, gc, GCAll, gc2))
    {
      XFreeGC(pDisplay, gc2);
      gc2 = None;
    }
  }

  // font metrics complete. Now THAT wasn't so bad, was it?  OK it was but only need to do it here

  if(WBIsValidTextObject(pThis))
  {
    // cache the window ID
    pThis->wIDOwner = wID;

    // cache the font metrics
    pThis->iAsc = iAsc;
    pThis->iDesc = iDesc;
    pThis->iFontWidth = iFontWidth;

    iFontHeight = iAsc + iDesc; // does not include interline spacing (that comes later for multi-line only)


    // keep track of the total viewport in window coordinates.
    // this will be used later for mouse translation

    pThis->rctWinView.left = geomV.x;
    pThis->rctWinView.top  = geomV.y;
    pThis->rctWinView.right = pThis->rctWinView.left + geomV.width;
    pThis->rctWinView.bottom = pThis->rctWinView.top + geomV.height;

    // convert selection rectangle into

    pBuf = (TEXT_BUFFER *)(pThis->pText);

    if(!pBuf || pBuf->nEntries <= 0)
    {
//      WB_ERROR_PRINT("TEMPORARY:  %s - no text\n", __FUNCTION__);
      goto the_end; // I use the goto so I can put cleanup code there - it's safer
    }

    // CALCULATING THE CORRECT VIEWPORT
    //
    // NOTE:  if the owning window has reset the viewport, the entire window SHOULD
    //        be invalid.  If not, it won't paint properly.

    if(pThis->iLineFeed == LineFeed_NONE) // SINGLE LINE
    {
      // AUTO-ASSIGN the viewport whenever right <= left (i.e. viewport is 'NULL' or 'empty')
      // or whenever the viewport is not properly assigned (window re-size re-paint)

      if(pThis->rctView.top || pThis->rctView.bottom ||
         pThis->rctView.right != pThis->rctView.left + geomV.width / iFontWidth) // not PROPERLY assigned
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        if(pThis->rctView.left < 0) // not already assigned
        {
          pThis->rctView.left = 0;
        }

        pThis->rctView.top = pThis->rctView.bottom = 0; // single line forces this (always)

        pThis->rctView.right = pThis->rctView.left + geomV.width / iFontWidth;

        if(pThis->rctView.right > pThis->rctView.left)
        {
          while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
          {
            iAutoScrollWidth >>= 1;
          }

          // scroll right to expose the cursor

          while(pThis->rctView.right <= pThis->iCol)
          {
            pThis->rctView.left += iAutoScrollWidth;
            pThis->rctView.right += iAutoScrollWidth;
          }
        }
        else
        {
          pThis->rctView.right = pThis->rctView.left = pThis->iCol; // desperate to have something there
        }
      }
    }
    else
    {
      int iWindowHeightInLines;

      // adjust font height to include line spacing (I'll use this to position the lines)

      if(iDesc > MIN_LINE_SPACING / 2)
      {
        iFontHeight += iDesc / 2; // line spacing is 1/2 of descent, or MIN_LINE_SPACING
      }
      else
      {
        iFontHeight += MIN_LINE_SPACING;
      }

      iWindowHeightInLines = geomV.height / iFontHeight; // window height (in lines)
      if(!iWindowHeightInLines)
      {
        iWindowHeightInLines = 1; // just in case so I don't divide by zero
      }

      // AUTO-ASSIGN the viewport whenever right <= left (i.e. viewport is 'NULL' or 'empty')
      // or whenever the viewport is not properly assigned (window re-size re-paint)

      if(pThis->rctView.right - pThis->rctView.left
            != geomV.width / iFontWidth                   // viewport needs re-calculation
         || pThis->rctView.bottom - pThis->rctView.top
            != iWindowHeightInLines                       // viewport needs re-calculation
         || pThis->rctView.top > pBuf->nEntries)          // top exceeds total # of lines
      {
        int iAutoScrollWidth = AUTO_HSCROLL_SIZE;

        if(pThis->rctView.left < 0) // not already assigned
        {
          pThis->rctView.left = 0;
        }

        if(pThis->rctView.top < 0 || pThis->rctView.top > pBuf->nEntries
           || (pThis->rctView.top && pBuf->nEntries < iWindowHeightInLines))
        {
          pThis->rctView.top = 0; // set viewport to top
        }

        if(pThis->rctView.bottom - pThis->rctView.top
            != iWindowHeightInLines)
        {
          pThis->rctView.bottom = pThis->rctView.top + iWindowHeightInLines;

          // always scroll row into view

          while(pThis->rctView.top > pThis->iCol)
          {
            pThis->rctView.top -= iWindowHeightInLines - 1;
            pThis->rctView.bottom -= iWindowHeightInLines - 1;
          }
          while(pThis->rctView.bottom <= pThis->iCol)
          {
            pThis->rctView.top += iWindowHeightInLines - 1;
            pThis->rctView.bottom += iWindowHeightInLines - 1;
          }
        }

        if(pThis->rctView.right - pThis->rctView.left != geomV.width / iFontWidth)
        {
          pThis->rctView.right = pThis->rctView.left + geomV.width / iFontWidth;

          if(pThis->rctView.right > pThis->rctView.left) // just in case, test it
          {
            while(iAutoScrollWidth > 1 && iAutoScrollWidth >= pThis->rctView.right - pThis->rctView.left)
            {
              iAutoScrollWidth >>= 1;
            }

            // scroll right to expose the cursor

            while(pThis->rctView.right <= pThis->iCol)
            {
              pThis->rctView.left += iAutoScrollWidth;
              pThis->rctView.right += iAutoScrollWidth;
            }
          }
          else
          {
            pThis->rctView.right = pThis->rctView.left = pThis->iCol; // desperate to have something there
          }
        }
      }
    }

    // convert the highlight rectangle into screen coordinates

    if(!SEL_RECT_EMPTY(pThis))
    {
      WB_RECT rctSel;

      if(SEL_RECT_ALL(pThis))
      {
        memcpy(&rctSel, &(pThis->rctView), sizeof(rctSel)); // use entire viewport for hightlight rect
        // TODO:  single-line, only select to end of string?
      }
      else
      {
        memcpy(&rctSel, &(pThis->rctSel), sizeof(rctSel));
        NORMALIZE_SEL_RECT(rctSel);
      }

      pThis->rctHighLight.left = pThis->rctWinView.left
                               + (rctSel.left - pThis->rctView.left) * iFontWidth;

      pThis->rctHighLight.top  = pThis->rctWinView.top
                               + (rctSel.top - pThis->rctView.top) * iFontHeight;

      if(pThis->iLineFeed == LineFeed_NONE)
      {
        pThis->rctHighLight.top += (geomV.height - iAsc - iDesc) / 2; // since single-line text is centered
      }

      pThis->rctHighLight.right = pThis->rctHighLight.left
                                + (rctSel.right - rctSel.left) * iFontWidth;

      pThis->rctHighLight.bottom = pThis->rctHighLight.top // NOTE add 1 to # of lines, always
                                + (rctSel.bottom - rctSel.top + 1) * iFontHeight;

      // NOTE:  this is independent of the selection method.  In the special case
      //        that a single line or an entire line is selected, I may have
      //        to handle this differently
    }
    else
    {
      memset(&(pThis->rctHighLight), 0, sizeof(pThis->rctHighLight));
    }


    // if it's a single-line object, center it within the window and display only ONE line

    if(pThis->iLineFeed == LineFeed_NONE) // i.e. SINGLE LINE
    {
      ///////////////////////
      // SINGLE LINE PAINTING
      ///////////////////////

      int iXDelta = 0, iYDelta = 0;

      iY = geomV.y + (geomV.height - iAsc - iDesc) / 2 + iAsc; // iY is now "the baseline" for the font
      iX = geomV.x;

      iW = 0;

      pL = pBuf->aLines[0];
      if(!pL)
      {
        goto the_end;
      }

      // pixmap (for speeding up the process)

      iPX = pThis->rctWinView.right - pThis->rctWinView.left + 2 * MIN_BORDER_SPACING;
      iPY = pThis->rctWinView.bottom - pThis->rctWinView.top + 2 * MIN_BORDER_SPACING;

      if(gc2 != None && iPX > 0 && iPY > 0)
      {
        pxTemp = XCreatePixmap(pDisplay, wID, iPX, iPY,
                               DefaultDepth(pDisplay, DefaultScreen(pDisplay)));
      }
      else
      {
        pxTemp = None;
      }

      if(pxTemp != None)
      {
        iXDelta = geomV.x - MIN_BORDER_SPACING;
        iYDelta = geomV.y - MIN_BORDER_SPACING;

        XSetClipOrigin(pDisplay, gc2, -iXDelta, -iYDelta);  // so that it matches the display's clipping in gc

        XSetForeground(pDisplay, gc2, clrBG);
        XFillRectangle(pDisplay, pxTemp, gc2, 0, 0, iPX, iPY);

        // if I have highlighted text, fill the rectangle in with the highlight color

        if(pThis->rctHighLight.right > pThis->rctHighLight.left &&
           WBRectOverlapped(pThis->rctHighLight, pThis->rctWinView))
        {
          XSetForeground(pDisplay, gc2, clrHBG); // highlight background color

          XFillRectangle(pDisplay, pxTemp, gc2,
                         pThis->rctHighLight.left - iXDelta,
                         pThis->rctHighLight.top - iYDelta,
                         pThis->rctHighLight.right - pThis->rctHighLight.left,
                         pThis->rctHighLight.bottom - pThis->rctHighLight.top);
        }

        XSetForeground(pDisplay, gc2, clrFG);
      }
      else // FALLBACK, if no pixmap, go to window directly
      {
        XSetForeground(pDisplay, gc, clrBG);
        XFillRectangle(pDisplay, wID, gc,
                       pThis->rctWinView.left,
                       pThis->rctWinView.top,
                       pThis->rctWinView.right - pThis->rctWinView.left,
                       pThis->rctWinView.bottom - pThis->rctWinView.top);

        // if I have highlighted text, fill the rectangle in with the highlight color

        if(pThis->rctHighLight.right > pThis->rctHighLight.left &&
           WBRectOverlapped(pThis->rctHighLight, pThis->rctWinView))
        {
          XSetForeground(pDisplay, gc, clrHBG); // highlight background color

          XFillRectangle(pDisplay, wID, gc,
                         pThis->rctHighLight.left,
                         pThis->rctHighLight.top,
                         pThis->rctHighLight.right - pThis->rctHighLight.left,
                         pThis->rctHighLight.bottom - pThis->rctHighLight.top);
        }

        XSetForeground(pDisplay, gc, clrFG);
      }

      // DRAW the text and the vertical cursor

      iLen = strlen(pL);

      pThis->iCursorX = pThis->iCursorY = pThis->iCursorHeight = 0; // to indicate "not drawn"

      for(i1=pThis->rctView.left; i1 < pThis->rctView.right; i1++, iX += iFontWidth)
      {
        WB_RECT rctChar, rctCursor;

        if(i1 == pThis->iCol) // display the cursor
        {
          pThis->iCursorX = iX - 1;

          if(pThis->iInsMode == InsertMode_OVERWRITE)
          {
            pThis->iCursorY = iY + iDesc + 1;
            pThis->iCursorHeight = 1;

            rctCursor.left = pThis->iCursorX - iXDelta;
            rctCursor.top = pThis->iCursorY - iYDelta;
            rctCursor.right = pThis->iCursorX + iFontWidth - iXDelta;
            rctCursor.bottom = pThis->iCursorY - iYDelta;
          }
          else // INSERT mode cursor
          {
            pThis->iCursorY = iY - iAsc - 1;
            pThis->iCursorHeight = iY + iDesc + 1 - pThis->iCursorY;

            rctCursor.left = pThis->iCursorX - iXDelta;
            rctCursor.top = pThis->iCursorY - iYDelta;
            rctCursor.right = pThis->iCursorX - iXDelta;
            rctCursor.bottom = pThis->iCursorY + pThis->iCursorHeight - iYDelta;
          }


          if(pThis->iBlinkState != 0) // horizontal cursor for overwrite
          {
            if(WBRectOverlapped(rctCursor, pThis->rctHighLight))
            {
              XSetForeground(pDisplay, gc2 != None ? gc2 : gc, clrHFG);
              XSetBackground(pDisplay, gc2 != None ? gc2 : gc, clrHBG);
            }
            else
            {
              XSetForeground(pDisplay, gc2 != None ? gc2 : gc, clrFG);
              XSetBackground(pDisplay, gc2 != None ? gc2 : gc, clrBG);
            }

            XDrawLine(pDisplay, pxTemp != None ? pxTemp : wID,
                      gc2 != None ? gc2 : gc,
                      rctCursor.left, rctCursor.top, rctCursor.right, rctCursor.bottom);
          }
        }

        rctChar.top = iY - iAsc;
        rctChar.bottom = iY + iDesc;
        rctChar.left = iX + 1;
        rctChar.right = iX + iFontWidth - 1; // since I'm checking overlap, make it a bit 'skinner'

        if(WBRectOverlapped(rctChar, pThis->rctHighLight))
        {
          XSetForeground(pDisplay, gc2 != None ? gc2 : gc, clrHFG);
          XSetBackground(pDisplay, gc2 != None ? gc2 : gc, clrHBG);
        }
        else
        {
          XSetForeground(pDisplay, gc2 != None ? gc2 : gc, clrFG);
          XSetBackground(pDisplay, gc2 != None ? gc2 : gc, clrBG);
        }

        // for NOW, draw one character at a time. But make sure it's within
        // the invalid region first...

        geomC.x = iX;
        geomC.y = iY; // TODO:  for single line, move this and the next 2 outside the loop?
        geomC.width = iFontWidth;
        geomC.height = iFontHeight;

        if(i1 < iLen)
        {
          if(WBGeomOverlapped(geomC, geomP)) // only if the character's geometry overlaps the paint geometry
          {
            WB_DRAW_STRING(pDisplay, pxTemp ? pxTemp : wID, fSet,
                           gc2 != None ? gc2 : gc,
                           iX - iXDelta, iY - iYDelta, &(pL[i1]), 1);
          }
        }
        else if(i1 > pThis->iCol)
        {
          break; // slight optimization
        }
      }

      if(pxTemp != None) // OPTIMIZATION (using pixmap)
      {
        int iX0=0, iY0=0, iW0=iPX, iH0=iPY;

        iX = pThis->rctWinView.left - MIN_BORDER_SPACING;
        iY = pThis->rctWinView.top - MIN_BORDER_SPACING;

        // only copy the invalid area (this should save some time)

        if(geomP.x > iX)
        {
          iX0 = geomP.x - iX;
          iW0 -= iX0;
          iX = geomP.x;
        }

        if(geomP.x + geomP.width < iX + iW0)
        {
          iW0 = geomP.x + geomP.width - iX;
        }

        if(geomP.y > iY)
        {
          iY0 = geomP.y - iY;
          iH0 -= iY0;
          iY = geomP.y;
        }

        if(geomP.y + geomP.height < iY + iH0)
        {
          iH0 = geomP.y + geomP.height - iY;
        }

        if(iH0 > 0 && iW0 > 0)
        {
          XCopyArea(pDisplay, pxTemp, wID, gc, // this time use GC to do the copy
                    iX0, iY0, iW0, iH0, iX, iY);
        }
#if 0
                  0, 0, iPX, iPY,
                  pThis->rctWinView.left - MIN_BORDER_SPACING,
                  pThis->rctWinView.top - MIN_BORDER_SPACING);
#endif // 0
        XFreePixmap(pDisplay, pxTemp);
      }
    }
    else // MULTI-LINE
    {
      //////////////////////
      // MULTI LINE PAINTING
      //////////////////////






      WB_ERROR_PRINT("TEMPORARY:  %s - MULTI-LINE NOT IMPLEMENTED\n", __FUNCTION__);
    }
  }

the_end:

  // mandatory resource free-up goes here, hence the 'goto' label

  if(gc2 != None)
  {
    XFreeGC(pDisplay, gc2);
  }

  if(rFontSet == None) // that is, I created one
  {
    XFreeFontSet(pDisplay, fSet);
  }
}

static void __internal_cursor_blink(struct _text_object_ *pThis, int bHasFocus)
{
  if(WBIsValidTextObject(pThis))
  {
    WB_RECT rctCursor;

    if(!bHasFocus)
    {
      if(pThis->iBlinkState)
      {
        pThis->iBlinkState = 0; // no cursor

        __internal_invalidate_cursor(pThis, 1);
      }
    }
    else
    {
      pThis->iBlinkState = (pThis->iBlinkState + 1) % 3;

      __internal_invalidate_cursor(pThis, pThis->iBlinkState == 0 || pThis->iBlinkState == 1);
    }
  }
}


