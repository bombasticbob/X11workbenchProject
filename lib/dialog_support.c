///////////////////////////////////////////////////////////////////////////////////////////////////////
//         _  _         _                                                            _               //
//      __| |(_)  __ _ | |  ___    __ _       ___  _   _  _ __   _ __    ___   _ __ | |_     ___     //
//     / _` || | / _` || | / _ \  / _` |     / __|| | | || '_ \ | '_ \  / _ \ | '__|| __|   / __|    //
//    | (_| || || (_| || || (_) || (_| |     \__ \| |_| || |_) || |_) || (_) || |   | |_  _| (__     //
//     \__,_||_| \__,_||_| \___/  \__, |_____|___/ \__,_|| .__/ | .__/  \___/ |_|    \__|(_)\___|    //
//                                |___/|_____|           |_|    |_|                                  //
//                                                                                                   //
//                                                                                                   //
//                                additional dialog control support                                  //
//      This file contains various support and functionality that is common to dialog controls       //
//                                                                                                   //
///////////////////////////////////////////////////////////////////////////////////////////////////////


/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2016 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.
               Any claims to alleged functionality or features should be
               considered 'preliminary', and might not function as advertised.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/


#ifdef linux /* needed for debian, possibly others */
#define _GNU_SOURCE /* in case features.h is involved on linux */
#define __USE_GNU /* this enables a few more things in the headers like 'qsort_r' */
// TODO:  consider making this a 'configure' thing
#endif // linux

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <signal.h>
#include <time.h>
#include <sys/stat.h>

#ifndef XK_Delete /* moslty for interix */
#define XK_MISCELLANY /* mostly for interix */
#include <X11/keysymdef.h> // some platforms don't automatically include this with X headers
#endif // XK_Delete

#define DIALOG_SUPPORT_C /* prevents me from including the various Atom definitions */

#include "window_helper.h"
#include "pixmap_helper.h"  // pixmap helpers, including pre-defined icons
#include "dialog_window.h"
#include "dialog_controls.h"
#include "dialog_support.h" // internal-only definitions
#include "conf_help.h"
#include "file_help.h"
#include "draw_text.h"
#include "text_object.h"
#include "window_dressing.h"

/** \file dialog_controls.c Dialog Control support, standard control implementation */

#define THIS_SUBSYSTEM DebugSubSystem_DialogCtrl




#define INIT_ATOM(X) if(a##X == None){ a##X = WBGetAtom(WBGetDefaultDisplay(),X##_STR); }
#define INIT_ATOM2(X,Y) if(X == None){ X = WBGetAtom(WBGetDefaultDisplay(),Y); }

#define DEFAULT_LISTINFO_MAX 16384 /* default initial max # of items in LISTINFO */



// atoms first
// TODO:  make this documentation a bit better.  for now the format is OK in doxygen, a little flakey here

/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aFRAME_CONTROL = None;             ///< Standard Dialog Control - transparent frame with optional text - see \ref FRAME_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aTEXT_CONTROL = None;              ///< Standard Dialog Control - static text (single or multi-line) - see \ref TEXT_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aICON_CONTROL = None;              ///< Standard Dialog Control - icon container (has a nice 3D border) - see \ref ICON_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aIMAGE_CONTROL = None;             ///< Standard Dialog Control - generic image/pixmap holder - see \ref IMAGE_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aEDIT_CONTROL = None;              ///< Standard Dialog Control - editable text (single or multi-line, scrollable, clipboard) - see \ref EDIT_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aPUSHBUTTON_CONTROL = None;        ///< Standard Dialog Control - Pushbutton control - see \ref PUSHBUTTON_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aDEFPUSHBUTTON_CONTROL = None;     ///< Standard Dialog Control - default Pushbutton control (has dark border, accepts &lt;ENTER&gt; as hotkey) - see \ref DEFPUSHBUTTON_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aCANCELBUTTON_CONTROL = None;      ///< Standard Dialog Control - cancel pushbutton control (accepts &lt;ESC&gt; as hotkey) - see \ref CANCELBUTTON_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aRADIOBUTTON_CONTROL = None;       ///< Standard Dialog Control - radio button - see \ref RADIOBUTTON_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aFIRSTRADIOBUTTON_CONTROL = None;  ///< Standard Dialog Control - 'first' radio button - defines start of radio button 'group' - see \ref FIRSTRADIOBUTTON_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aCHECKBUTTON_CONTROL = None;       ///< Standard Dialog Control - check[box] button - push-on/push-off with 'check mark' (or whatever) - see \ref CHECKBUTTON_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aTRISTATEBUTTON_CONTROL = None;    ///< Standard Dialog Control - tristate - like check, but with a third state - see \ref TRISTATEBUTTON_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aHSCROLL_CONTROL = None;           ///< Standard Dialog Control - horizontal scroll - see \ref HSCROLL_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aVSCROLL_CONTROL = None;           ///< Standard Dialog Control - vertical scroll - see \ref VSCROLL_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aSLIDER_CONTROL = None;            ///< Standard Dialog Control - volume control (slider bar) (h or v depending on geometry) - see \ref SLIDER_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aKNOB_CONTROL = None;              ///< Standard Dialog Control - "volume knob" (270 degrees of rotation, left to right) - see \ref KNOB_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aLIST_CONTROL = None;              ///< Standard Dialog Control - list - single, multi, extended select (h, v, multicol) - see \ref LIST_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aCOMBO_CONTROL = None;             ///< Standard Dialog Control - classic 'combo box' control - see \ref COMBO_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aTREE_CONTROL = None;              ///< Standard Dialog Control - class 'tree' control - see \ref TREE_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aCOMBOTREE_CONTROL = None;         ///< Standard Dialog Control - 'combo tree' (tree with interlocked edit/text box like combo box) - see \ref COMBOTREE_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aFILE_LIST_CONTROL = None;         ///< Standard Dialog Control - File List - see \ref FILE_LIST_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aFILE_COMBO_CONTROL = None;        ///< Standard Dialog Control - file combo control - see \ref FILE_COMBO_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aPATH_TREE_CONTROL = None;         ///< Standard Dialog Control - path tree - directory hierarchy - see \ref PATH_TREE_CONTROL_STR
/** \ingroup dlgctrl_atom
  * \hideinitializer */
Atom aTAB_CONTROL = None;               ///< Standard Dialog Control -'tab' container (auto enable/disable contents) - see \ref TAB_CONTROL_STR


// NOTE:  'xatoms' is in the CORE group - consider moving this into CORE
/** \ingroup xatoms
  * \hideinitializer
 Scroll notifications via ClientMessage
  *
  * MENU_COMMAND message format (relative to XEvent.xclient)\n
  * type == ClientMessage\n
  * message_type == aSCROLL_NOTIFY\n
  * format == 32 (always)\n
  * data.l[0] Identifies the bar (SCROLL_VERTICAL, SCROLL_HORIZONTAL, or SCROLL_DEFAULT)\n
  * data.l[1] Indicates the notification type, one of the following:\n
  * \li WB_SCROLL_KNOB    'knob track' - knob position will be in data.l[2]
  * \li WB_SCROLL_FORWARD  move down, or move right
  * \li WB_SCROLL_BACKWARD move up, or move left
  * \li WB_SCROLL_PAGEFWD  page down or page right
  * \li WB_SCROLL_PAGEBACK page up or page left
  * \li WB_SCROLL_FIRST    scroll to first entry, i.e. home or top
  * \li WB_SCROLL_LAST     scroll to last entry, i.e. bottom or end
  * \li WB_SCROLL_DBLCLICK double-click detection (no selection info in data.l[2])
  * \li WB_SCROLL_ABSOLUTE absolute scroll, to the absolute position in data.l[2]
  * \li WB_SCROLL_RELATIVE relative scroll, relative +/- position in data.l[2]
  * \li WB_SCROLL_NA       generic 'NA' or 'UNDEFINED' value
  *
  * data.l[2] Optional parameter, typically the absolute or relative scroll position
*/
Atom aSCROLL_NOTIFY = None; // specific notification for scrollbars

////Atom aCONTROL_NOTIFY = None; moved
/** \ingroup dlgctrl_notify
  * \hideinitializer
  * \brief CONTROL_NOTIFY ClientMessage for BUTTON_PRESS event
  *
  * BUTTON PRESS message format (relative to XEvent.xclient)\n
  * type == ClientMessage\n
  * message_type == aCONTROL_NOTIFY\n
  * format == 32 (always)\n
  * data.l[0] == aBUTTON_PRESS\n
  * data.l[1] == Control ID of originating conrol window\n
  * data.l[2] == truncated (32-bit) pointer to WBDialogControl structure\n
*/
Atom aBUTTON_PRESS = None;
/** \ingroup dlgctrl_notify
  * \hideinitializer
  * \brief CONTROL_NOTIFY ClientMessage for LIST_NOTIFY event
  *
  * LIST NOTIFY message format (relative to XEvent.xclient)\n
  * type == ClientMessage\n
  * message_type == aCONTROL_NOTIFY\n
  * format == 32 (always)\n
  * data.l[0] == aLIST_NOTIFY\n
  * data.l[1] == Control ID of originating conrol window\n
  * data.l[2] == notification code (one of WB_LIST_NONE, WB_LIST_SELCHANGE, or WB_LIST_DBLCLICK)\n
  * data.l[3] == currently highlighted (selected) item in list, -1 if none
*/
Atom aLIST_NOTIFY = None;
/** \ingroup dlgctrl_notify
  * \hideinitializer
  * \brief CONTROL_NOTIFY ClientMessage for TEXT_CHANGED event
  *
  * TEXT CHANGED message format (relative to XEvent.xclient)\n
  * type == ClientMessage\n
  * message_type == aCONTROL_NOTIFY\n
  * format == 32 (always)\n
  * data.l[0] == aTEXT_CHANGED\n
  * data.l[1] == Control ID of originating conrol window\n
  * data.l[2] == truncated (32-bit) pointer to WBDialogConrol structure
*/
Atom aTEXT_CHANGED = None;
/** \ingroup dlgctrl_notify
  * \hideinitializer
  * \brief CONTROL_NOTIFY ClientMessage for TEXTSELECT_CHANGE event
  *
  * TEXTSELECT CHANGE message format (relative to XEvent.xclient)\n
  * type == ClientMessage\n
  * message_type == aCONTROL_NOTIFY\n
  * format == 32 (always)\n
  * data.l[0] == aTEXTSELECT_CHANGE\n
  * data.l[1] == Control ID of originating conrol window\n
  * data.l[2] == reserved (TODO: implement)\n
  * data.l[3] == reserved (TODO: implement)\n
  * data.l[4] == reserved (TODO: implement)\n
*/
Atom aTEXTSELECT_CHANGE = None;
/** \ingroup dlgctrl_notify
  * \hideinitializer
  * \brief CONTROL_NOTIFY ClientMessage for GOTFOCUS event
  *
  * GOT FOCUS message format (relative to XEvent.xclient)\n
  * type == ClientMessage\n
  * message_type == aCONTROL_NOTIFY\n
  * format == 32 (always)\n
  * data.l[0] == aGOTFOCUS\n
  * data.l[1] == Control ID of originating conrol window\n
  * data.l[2] == truncated (32-bit) pointer to WBDialogConrol structure\n
*/
Atom aGOTFOCUS = None;
/** \ingroup dlgctrl_notify
  * \hideinitializer
  * \brief CONTROL_NOTIFY ClientMessage for LOSTFOCUS event
  *
  * LOST FOCUS message format (relative to XEvent.xclient)\n
  * type == ClientMessage\n
  * message_type == aCONTROL_NOTIFY\n
  * format == 32 (always)\n
  * data.l[0] == aLOSTFOCUS\n
  * data.l[1] == Control ID of originating conrol window\n
  * data.l[2] == truncated (32-bit) pointer to WBDialogConrol structure\n
*/
Atom aLOSTFOCUS = None;
/** \ingroup dlgctrl_notify
  * \hideinitializer
  * \brief CONTROL_NOTIFY ClientMessage for MOUSE_DOWN event
  *
  * MOUSE DOWN message format (relative to XEvent.xclient)\n
  * type == ClientMessage\n
  * message_type == aCONTROL_NOTIFY\n
  * format == 32 (always)\n
  * data.l[0] == aMOUSE_DOWN\n
  * data.l[1] == Control ID of originating conrol window\n
  * data.l[2] == reserved (TODO:  implement or remove?)
*/
Atom aMOUSE_DOWN = None;
/** \ingroup dlgctrl_notify
  * \hideinitializer
  * \brief CONTROL_NOTIFY ClientMessage for MOUSE_UP event
  *
  * MOUSE UP message format (relative to XEvent.xclient)\n
  * type == ClientMessage\n
  * message_type == aCONTROL_NOTIFY\n
  * format == 32 (always)\n
  * data.l[0] == aMOUSE_UP\n
  * data.l[1] == Control ID of originating conrol window\n
  * data.l[2] == reserved (TODO:  implement or remove?)
*/
Atom aMOUSE_UP = None;
/** \ingroup dlgctrl_notify
  * \hideinitializer
  * \brief CONTROL_NOTIFY ClientMessage for MOUSE_DRAG event
  *
  * MOUSE DRAG message format (relative to XEvent.xclient)\n
  * type == ClientMessage\n
  * message_type == aCONTROL_NOTIFY\n
  * format == 32 (always)\n
  * data.l[0] == aMOUSE_DRAG\n
  * data.l[1] == Control ID of originating conrol window\n
  * data.l[2] == reserved (TODO:  implement or remove?)
*/
Atom aMOUSE_DRAG = None;
/** \ingroup dlgctrl_notify
  * \hideinitializer
  * \brief CONTROL_NOTIFY ClientMessage for KEY_DOWN event
  *
  * KEY DOWN message format (relative to XEvent.xclient)\n
  * type == ClientMessage\n
  * message_type == aCONTROL_NOTIFY\n
  * format == 32 (always)\n
  * data.l[0] == aKEY_DOWN\n
  * data.l[1] == Control ID of originating conrol window\n
  * data.l[2] == reserved (TODO:  implement or remove?)
*/
Atom aKEY_DOWN = None;
/** \ingroup dlgctrl_notify
  * \hideinitializer
  * \brief CONTROL_NOTIFY ClientMessage for KEY_UP event
  *
  * KEY UP message format (relative to XEvent.xclient)\n
  * type == ClientMessage\n
  * message_type == aCONTROL_NOTIFY\n
  * format == 32 (always)\n
  * data.l[0] == aKEY_UP\n
  * data.l[1] == Control ID of originating conrol window\n
  * data.l[2] == reserved (TODO:  implement or remove?)
*/
Atom aKEY_UP = None;
/** \ingroup dlgctrl_notify
  * \hideinitializer
  * \brief CONTROL_NOTIFY ClientMessage for KEYSTROKE event
  *
  * KEYSTROKE message format (relative to XEvent.xclient)\n
  * type == ClientMessage\n
  * message_type == aCONTROL_NOTIFY\n
  * format == 32 (always)\n
  * data.l[0] == aKEYSTROKE\n
  * data.l[1] == Control ID of originating conrol window\n
  * data.l[2] == reserved (TODO:  implement or remove?)
*/
Atom aKEYSTROKE = None;

/** \ingroup dlgatom
  * \hideinitializer
  * \brief DIALOG_INIT ClientMessage, sent to dialog window callback on frame create
  *
  * DIALOG_INIT message format (relative to XEvent.xclient)\n
  * type == ClientMessage\n
  * message_type == aDIALOG_INIT\n
  * format == 32 (always)\n
*/
Atom aDIALOG_INIT = None;

/** \ingroup dlgatom
  * \hideinitializer
  * \brief DLGC_PROP_NOTIFY ClientMessage, notify control of property change
  *
  * DLGC_PROP_NOTIFY message format (relative to XEvent.xclient)\n
  * type == ClientMessage\n
  * message_type == aDLGC_PROP_NOTIFY\n
  * format == 32 (always)\n
  * data.l[0] == Atom of property that changed\n
*/
Atom aDLGC_PROP_NOTIFY = None;

/** \ingroup dlgctrl_notify
  * \hideinitializer
  * \brief LIST_SELCHANGE ClientMessage, notify self of list selection change
  *
  * LIST_SELCHANGE message format (relative to XEvent.xclient)\n
  * type == ClientMessage\n
  * message_type == aLIST_SELCHANGE\n
  * format == 32 (always)\n
  * data.l[0] == New selection index\n
  * data.l[1] == Old selection index\n
*/
Atom aLIST_SELCHANGE = None;  // list selection has changed (send to self)

// internal-only properties (still have global scope for inline functions, etc.)
/** \ingroup dlgctrl
  * \hideinitializer
  * \brief dialog control TEXT property - see WBDialogControlGetText()
  *
  * This is used internally and should not be invoked directly
*/
Atom aDLGC_TEXT = None;  // dialog control 'text' property, i.e. 'GetText'
/** \ingroup dlgctrl
  * \hideinitializer
  * \brief dialog control CAPTION property - see WBDialogControlGetCaption()
*/
Atom aDLGC_CAPTION = None;  // dialog control 'caption' property, i.e. 'GetCaption' (not an actual property, notification only)
/** \ingroup dlgctrl
  * \hideinitializer
  * \brief dialog control FONT property - reserved
  *
  * This is used internally and should not be invoked directly
*/
Atom aDLGC_FONT = None;
/** \ingroup dlgctrl
  * \hideinitializer
  * \brief dialog control SCROLLINFO property - see \ref WB_SCROLLINFO structure
  *
  * Property contains the WB_SCROLLINFO structure, to be maintained by APIs only.
  *
  * This is used internally and should not be invoked directly
*/
Atom aDLGC_SCROLLINFO = None;  // scrollbar info structure (horizontal AND vertical)
                               // (scrollbars, listboxes, combo boxes, multi-line edit)
/** \ingroup dlgctrl
  * \hideinitializer
  * \brief dialog control LISTINFO property - see DLGInitControlListInfo() etc.
  *
  * Contains the listbox 'info' structure, to be maintained by APIs only
  *
  * This is used internally and should not be invoked directly
*/
Atom aDLGC_LISTINFO = None;    // listbox info structure

/** \ingroup dlgctrl
  * \hideinitializer
  * \brief dialog control PATH property, for file and directory controls
  *
  * Text property identifying a directory name, standard for file and directory controls.
  * Can be maintained and queried directly using property API functions.
  *
  * This is used internally and should not be invoked directly
*/
Atom aDLGC_PATH = None;


void WBDialogControlsInit(void)
{
  INIT_ATOM(FRAME_CONTROL);
  INIT_ATOM(TEXT_CONTROL);
  INIT_ATOM(ICON_CONTROL);
  INIT_ATOM(IMAGE_CONTROL);
  INIT_ATOM(EDIT_CONTROL);
  INIT_ATOM(PUSHBUTTON_CONTROL);
  INIT_ATOM(DEFPUSHBUTTON_CONTROL);
  INIT_ATOM(CANCELBUTTON_CONTROL);
  INIT_ATOM(RADIOBUTTON_CONTROL);
  INIT_ATOM(FIRSTRADIOBUTTON_CONTROL);
  INIT_ATOM(CHECKBUTTON_CONTROL);
  INIT_ATOM(TRISTATEBUTTON_CONTROL);
  INIT_ATOM(HSCROLL_CONTROL);
  INIT_ATOM(VSCROLL_CONTROL);
  INIT_ATOM(SLIDER_CONTROL);
  INIT_ATOM(KNOB_CONTROL);
  INIT_ATOM(LIST_CONTROL);
  INIT_ATOM(COMBO_CONTROL);
  INIT_ATOM(TREE_CONTROL);
  INIT_ATOM(COMBOTREE_CONTROL);
  INIT_ATOM(FILE_LIST_CONTROL);
  INIT_ATOM(FILE_COMBO_CONTROL);
  INIT_ATOM(PATH_TREE_CONTROL);
  INIT_ATOM(TAB_CONTROL);

//  INIT_ATOM2(aCONTROL_NOTIFY,"ControlNotify");
  INIT_ATOM2(aSCROLL_NOTIFY,"ScrollNotify");
  INIT_ATOM2(aBUTTON_PRESS,"ButtonPress");
  INIT_ATOM2(aLIST_NOTIFY,"ListNotify");
  INIT_ATOM2(aTEXT_CHANGED,"TextChanged");
  INIT_ATOM2(aTEXTSELECT_CHANGE,"TextSelectChange");
  INIT_ATOM2(aGOTFOCUS,"GotFocus");
  INIT_ATOM2(aLOSTFOCUS,"LostFocus");
  INIT_ATOM2(aMOUSE_DOWN,"MouseDown");
  INIT_ATOM2(aMOUSE_UP,"MouseUp");
  INIT_ATOM2(aMOUSE_DRAG,"MouseDrag");
  INIT_ATOM2(aKEY_DOWN,"KeyDown");
  INIT_ATOM2(aKEY_UP,"KeyUp");
  INIT_ATOM2(aKEYSTROKE,"Keystroke");

  INIT_ATOM2(aDLGC_TEXT, "DLGC_TEXT");
  INIT_ATOM2(aDLGC_CAPTION, "DLGC_CAPTION");
  INIT_ATOM2(aDLGC_FONT, "DLGC_FONT");
  INIT_ATOM2(aDLGC_SCROLLINFO, "DLGC_SCROLLINFO");
  INIT_ATOM2(aDLGC_LISTINFO, "DLGC_LISTINFO");
  INIT_ATOM2(aDLGC_PATH, "DLGC_PATH");


  // other dialog-related messages
  INIT_ATOM2(aDIALOG_INIT,"DialogInit");
//  INIT_ATOM2(aDIALOG_SETFOCUS,"DialogSetFocus");
  INIT_ATOM2(aDLGC_PROP_NOTIFY, "DLGCPropNotify");
  INIT_ATOM2(aLIST_SELCHANGE, "LIST_SELCHANGE");

}


/////////////////////////////////////////////////////
// D I A L O G   C O N T R O L   P R O P E R T I E S
/////////////////////////////////////////////////////


void WBDialogControlSetCaption(WBDialogControl *pCtrl, const char *szCaption)
{
char *szOldCaption = pCtrl->pCaption;

  pCtrl->pCaption = WBCopyString(szCaption);

  if(szOldCaption)
  {
    WBFree(szOldCaption);
  }

  WBInvalidateGeom(pCtrl->wID, NULL, 0);
  WBUpdateWindow(pCtrl->wID); // schedule update (not immediate)

  DLGNotifySelf(pCtrl, aDLGC_PROP_NOTIFY, aDLGC_CAPTION, 0, 0, 0, 0);
}

const char *WBDialogControlGetCaption(WBDialogControl *pCtrl)
{
  if(!pCtrl->pCaption)
  {
    return "";
  }

  return pCtrl->pCaption;
}

void WBDialogControlSetPixmap(WBDialogControl *pCtrl, Pixmap pixmap)
{
Display *pDisplay = NULL;

  if(!pCtrl ||
     (pCtrl->aClass != aICON_CONTROL && pCtrl->aClass != aIMAGE_CONTROL
      && pCtrl->aClass != aPUSHBUTTON_CONTROL && pCtrl->aClass != aDEFPUSHBUTTON_CONTROL
      && pCtrl->aClass != aCANCELBUTTON_CONTROL))
  {
    return;
  }

  pDisplay = WBGetWindowDisplay(pCtrl->wID);

  if(!pDisplay)
  {
    pDisplay = WBGetDefaultDisplay();
  }

  if(pCtrl->aClass == aICON_CONTROL ||
     pCtrl->aClass == aIMAGE_CONTROL)
  {
    Pixmap pxOld = ((struct _WB_IMAGE_CONTROL_ *)pCtrl)->pixmap;
    Pixmap pxOld2 = ((struct _WB_IMAGE_CONTROL_ *)pCtrl)->pixmap2;

    ((struct _WB_IMAGE_CONTROL_ *)pCtrl)->pixmap = pixmap;
    ((struct _WB_IMAGE_CONTROL_ *)pCtrl)->pixmap2 = None;

    BEGIN_XCALL_DEBUG_WRAPPER
    if(pxOld != None)
    {
      XFreePixmap(pDisplay, pxOld);
    }
    if(pxOld2 != None)
    {
      XFreePixmap(pDisplay, pxOld2);
    }
    END_XCALL_DEBUG_WRAPPER
  }

  if(pCtrl->aClass == aPUSHBUTTON_CONTROL || pCtrl->aClass == aDEFPUSHBUTTON_CONTROL
     || pCtrl->aClass == aCANCELBUTTON_CONTROL)
  {
    Pixmap pxOld = ((struct _WB_PUSHBUTTON_CONTROL_ *)pCtrl)->pixmap;
    Pixmap pxOld2 = ((struct _WB_PUSHBUTTON_CONTROL_ *)pCtrl)->pixmap2;

    ((struct _WB_PUSHBUTTON_CONTROL_ *)pCtrl)->pixmap = pixmap;
    ((struct _WB_PUSHBUTTON_CONTROL_ *)pCtrl)->pixmap2 = None;

    BEGIN_XCALL_DEBUG_WRAPPER
    if(pxOld != None)
    {
      XFreePixmap(pDisplay, pxOld);
    }
    if(pxOld2 != None)
    {
      XFreePixmap(pDisplay, pxOld2);
    }
    END_XCALL_DEBUG_WRAPPER
  }
}

Pixmap WBDialogControlGetPixmap(WBDialogControl *pCtrl)
{
  if(!pCtrl)
  {
    return None;
  }

  if(pCtrl->aClass == aICON_CONTROL ||
     pCtrl->aClass == aIMAGE_CONTROL)
  {
    return ((struct _WB_IMAGE_CONTROL_ *)pCtrl)->pixmap;
  }

  if(pCtrl->aClass == aPUSHBUTTON_CONTROL || pCtrl->aClass == aDEFPUSHBUTTON_CONTROL
     || pCtrl->aClass == aCANCELBUTTON_CONTROL)
  {
    return ((struct _WB_PUSHBUTTON_CONTROL_ *)pCtrl)->pixmap;
  }

  return None;
}

void WBDialogControlSetIconPixmap(WBDialogControl *pCtrl, Pixmap pixmap, Pixmap pixmap2)
{
Display *pDisplay = NULL;

  if(!pCtrl ||
     (pCtrl->aClass != aICON_CONTROL && pCtrl->aClass != aIMAGE_CONTROL
      && pCtrl->aClass != aPUSHBUTTON_CONTROL && pCtrl->aClass != aDEFPUSHBUTTON_CONTROL
      && pCtrl->aClass != aCANCELBUTTON_CONTROL))
  {
    return;
  }

  pDisplay = WBGetWindowDisplay(pCtrl->wID);

  if(!pDisplay)
  {
    pDisplay = WBGetDefaultDisplay();
  }

  if(pCtrl->aClass == aICON_CONTROL ||
     pCtrl->aClass == aIMAGE_CONTROL)
  {
    Pixmap pxOld = ((struct _WB_IMAGE_CONTROL_ *)pCtrl)->pixmap;
    Pixmap pxOld2 = ((struct _WB_IMAGE_CONTROL_ *)pCtrl)->pixmap2;

    ((struct _WB_IMAGE_CONTROL_ *)pCtrl)->pixmap = pixmap;
    ((struct _WB_IMAGE_CONTROL_ *)pCtrl)->pixmap2 = pixmap2;

    BEGIN_XCALL_DEBUG_WRAPPER
    if(pxOld != None)
    {
      XFreePixmap(pDisplay, pxOld);
    }
    if(pxOld2 != None)
    {
      XFreePixmap(pDisplay, pxOld2);
    }
    END_XCALL_DEBUG_WRAPPER
  }

  if(pCtrl->aClass == aPUSHBUTTON_CONTROL || pCtrl->aClass == aDEFPUSHBUTTON_CONTROL
     || pCtrl->aClass == aCANCELBUTTON_CONTROL)
  {
    Pixmap pxOld = ((struct _WB_PUSHBUTTON_CONTROL_ *)pCtrl)->pixmap;
    Pixmap pxOld2 = ((struct _WB_PUSHBUTTON_CONTROL_ *)pCtrl)->pixmap2;

    ((struct _WB_PUSHBUTTON_CONTROL_ *)pCtrl)->pixmap = pixmap;
    ((struct _WB_PUSHBUTTON_CONTROL_ *)pCtrl)->pixmap2 = pixmap2;

    BEGIN_XCALL_DEBUG_WRAPPER
    if(pxOld != None)
    {
      XFreePixmap(pDisplay, pxOld);
    }
    if(pxOld2 != None)
    {
      XFreePixmap(pDisplay, pxOld2);
    }
    END_XCALL_DEBUG_WRAPPER
  }
}

Pixmap WBDialogControlGetIconPixmap(WBDialogControl *pCtrl, Pixmap *pPixmap2)
{
  if(!pCtrl)
  {
    return None;
  }

  if(pCtrl->aClass == aICON_CONTROL ||
     pCtrl->aClass == aIMAGE_CONTROL)
  {
    if(pPixmap2)
    {
      *pPixmap2 = ((struct _WB_PUSHBUTTON_CONTROL_ *)pCtrl)->pixmap2;
    }

    return ((struct _WB_IMAGE_CONTROL_ *)pCtrl)->pixmap;
  }

  if(pCtrl->aClass == aPUSHBUTTON_CONTROL || pCtrl->aClass == aDEFPUSHBUTTON_CONTROL
     || pCtrl->aClass == aCANCELBUTTON_CONTROL)
  {
    if(pPixmap2)
    {
      *pPixmap2 = ((struct _WB_PUSHBUTTON_CONTROL_ *)pCtrl)->pixmap2;
    }

    return ((struct _WB_PUSHBUTTON_CONTROL_ *)pCtrl)->pixmap;
  }

  return None;
}


int WBDialogControlSetPropList(WBDialogControl *pCtrl, const char *szPropList)
{
// property<tab>value<newline>

  return 0; // for now (not being used yet)
}

int WBDialogControlSetProperty(WBDialogControl *pCtrl, Atom aPropName, const char *szPropVal)
{
  WB_DIALOG_PROP p;

  p.aProp = aPropName;
  p.lVal = 0;
  p.pVal = WBCopyString(szPropVal);

  if(!p.pVal)
  {
    return -1;
  }

  WBDialogControlSetDialogProp(pCtrl, &p);
  return 0;
}

void WBDialogControlSetProperty2(WBDialogControl *pCtrl, Atom aPropName, void *pPropVal)
{
  WB_DIALOG_PROP p;

  p.aProp = aPropName;
  p.lVal = 0;
  p.pVal = pPropVal;

  WBDialogControlSetDialogProp(pCtrl, &p);
}

const char *WBDialogControlGetProperty(WBDialogControl *pCtrl, Atom aPropName)
{
const WB_DIALOG_PROP *pP = WBDialogControlGetDialogProp(pCtrl, aPropName);

  if(pP)
  {
    return pP->pVal;  // TODO:  if NULL, lVal as a string?
  }

  return "";  // so it's not NULL
}

void *WBDialogControlGetProperty2(WBDialogControl *pCtrl, Atom aPropName)
{
const WB_DIALOG_PROP *pP = WBDialogControlGetDialogProp(pCtrl, aPropName);

  if(pP)
  {
    return (void *)(pP->pVal);  // TODO:  if NULL, lVal as a string?
  }

  return NULL;
}



#define INITIAL_PROPERTY_MAX 64

static WBDialogPropList * __ConstructPropList(void)
{
  int iInitialSize = sizeof(WBDialogPropList) + INITIAL_PROPERTY_MAX * sizeof(WB_DIALOG_PROP);
  WBDialogPropList *pRval = (WBDialogPropList *)WBAlloc(iInitialSize);

  if(pRval)
  {
    pRval->nProps = 0;
    pRval->nMaxProps = INITIAL_PROPERTY_MAX;
    WB_WARN_PRINT("TEMPORARY:  WBDialogPropList constructor %p %d, %d\n", pRval, pRval->nProps, pRval->nMaxProps);
  }
  else
  {
    WB_ERROR_PRINT("%s - not enough memory\n", __FUNCTION__);
  }

  return pRval;
}

int WBDialogControlSetDialogProp(WBDialogControl *pCtrl, WB_DIALOG_PROP *pPropVal)
{
int i1;
WBDialogPropList *pPropList;
WB_DIALOG_PROP *pProp = NULL;
Atom aProp;

  if(!pCtrl || !pPropVal)
  {
    WB_ERROR_PRINT("%s - pCtrl %p or pPropVal %p\n", __FUNCTION__,
                   pCtrl, pPropVal);

    return -1;
  }

  if(!pCtrl->pPropList)
  {
    if(!(pCtrl->pPropList = __ConstructPropList()))
    {
      WB_ERROR_PRINT("%s - unable to allocate property list for window %d (%08xH)\n",
                      __FUNCTION__, (int)pCtrl->wID, (int)pCtrl->wID);

      return -2;
    }
  }

  pPropList = pCtrl->pPropList;
  aProp = pPropVal->aProp;

  for(i1=0; i1 < pPropList->nProps; i1++)
  {
    register WB_DIALOG_PROP *pProp0 = &(pPropList->aDlgProp[i1]);

    if(pProp0 && pProp0->aProp == aProp)
    {
      pProp = pProp0;
      break;
    }
  }

  if(!pProp)
  {
    if((pPropList->nProps + 1) >= pPropList->nMaxProps)
    {
      int iNewSize = (pPropList->nMaxProps + INITIAL_PROPERTY_MAX / 2)
                   * sizeof(pPropList->aDlgProp[0])
                   + sizeof(*pPropList);

      pPropList = (WBDialogPropList *)WBReAlloc(pPropList, iNewSize);
      if(!pPropList)
      {
        WB_ERROR_PRINT("%s - unable to RE-allocate property list for window %d (%08xH)\n",
                        __FUNCTION__, (int)pCtrl->wID, (int)pCtrl->wID);

        return -3;
      }

      pCtrl->pPropList = pPropList;
      pPropList->nMaxProps += INITIAL_PROPERTY_MAX / 2;

      if(pPropList->nProps >= pPropList->nMaxProps)
      {
        WB_ERROR_PRINT("%s - internal inconsistency, nProps=%d, nMaxProps=%d\n",
                       __FUNCTION__, pPropList->nProps, pPropList->nMaxProps);
        return -4;
      }
    }

    pProp = &(pPropList->aDlgProp[pPropList->nProps]);
    pPropList->nProps++;

    pProp->aProp = aProp;
    pProp->lVal = 0;
    pProp->pVal = NULL;
  }

  pProp->lVal = pPropVal->lVal;  // just copy the lVal

  if(pProp->pVal != pPropVal->pVal) // if it changes... and ONLY if it changes
  {
    if(pProp->pVal)
    {
      if(pProp->aProp == aDLGC_LISTINFO)
      {
        DLGCListInfoDestructor((LISTINFO *)(pProp->pVal));
      }
      else
      {
        WBFree(pProp->pVal);
      }
    }

    pProp->pVal = pPropVal->pVal;
  }

  // last but not least, tell the dialog control its properties were altered
  // by directly calling its callback function with the 'property change' event

  WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_DialogCtrl | DebugSubSystem_Dialog,
                 "%s - DLGC_PROP_NOTIFY (set) for window %d (%08xH)\n",
                  __FUNCTION__, (int)pCtrl->wID, (int)pCtrl->wID);

  DLGNotifySelf(pCtrl, aDLGC_PROP_NOTIFY, pPropVal->aProp, 0, 0, 0, 0);

  return 0;  // success
}

void WBDialogControlDelDialogProp(WBDialogControl *pCtrl, Atom aProp)
{
int i1, bNotify = 0;
WBDialogPropList *pPropList = pCtrl ? pCtrl->pPropList : NULL;
//WB_DIALOG_PROP *pProp2 = NULL;
WB_DIALOG_PROP sProp;


  if(!pPropList)
  {
    return;
  }

  for(i1=0; i1 < pPropList->nProps; i1++)
  {
    register WB_DIALOG_PROP *pProp = &(pPropList->aDlgProp[i1]);

    if(pProp && pProp->aProp == aProp)
    {
      if(pProp->pVal) // pointer?
      {
        if(pProp->aProp == aDLGC_LISTINFO)
        {
          DLGCListInfoDestructor((LISTINFO *)(pProp->pVal));
        }
        else
        {
          WBFree(pProp->pVal);
        }

        pProp->pVal = NULL;  // necessary, for the next step
      }

      memcpy(&sProp, pProp, sizeof(WB_DIALOG_PROP)); // make a copy of the thing
      bNotify = 1;

      // must remove this entry now
      for(i1++; i1 < pPropList->nProps; i1++)
      {
        pPropList->aDlgProp[i1 - 1] = pPropList->aDlgProp[i1];
      }

      pPropList->nProps--;
      bzero(&(pPropList->aDlgProp[pPropList->nProps]), sizeof(pPropList->aDlgProp[pPropList->nProps]));

      break;
    }
  }

 // last but not least, tell the dialog control its properties were altered
 // by directly calling its callback function with the 'property change' event

//  if(pProp2)  NO NO NO!  but this is how 'set' does it, since 'pProp2' is still valid
//  {
//    DLGNotifySelf(pCtrl, aDLGC_PROP_NOTIFY, pProp2->aProp, 0, 0, 0, 0);
//  }

  // TODO:  find a better way to notify for a property that was deleted.
  //        for now I copied the prop structure

  if(bNotify)
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_DialogCtrl | DebugSubSystem_Dialog,
                   "%s - DLGC_PROP_NOTIFY (del) for window %d (%08xH)\n",
                    __FUNCTION__, (int)pCtrl->wID, (int)pCtrl->wID);

    DLGNotifySelf(pCtrl, aDLGC_PROP_NOTIFY, sProp.aProp, 0, 0, 0, 0);
  }

}

const WB_DIALOG_PROP *WBDialogControlGetDialogProp(WBDialogControl *pCtrl, Atom aProp)
{
int i1;
WBDialogPropList *pPropList = pCtrl ? pCtrl->pPropList : NULL;

  if(!pPropList)
  {
    return NULL; // for NULL 'pCtrl' will always be the case
  }

  for(i1=0; i1 < pPropList->nProps; i1++)
  {
    register WB_DIALOG_PROP *pProp = &(pPropList->aDlgProp[i1]);

    if(pProp && pProp->aProp == aProp)
    {
      return pProp;
    }
  }

  return NULL;  // not found
}

void DLGCDestroyProperties(WBDialogPropList *pPropList)
{
int i1;

  if(!pPropList)
  {
    return;
  }

  for(i1=0; i1 < pPropList->nProps; i1++)
  {
    /*register*/ WB_DIALOG_PROP *pProp = &(pPropList->aDlgProp[i1]);

    if(pProp->pVal) // pointer?
    {
      if(pProp->aProp == aDLGC_LISTINFO)
      {
        DLGCListInfoDestructor((LISTINFO *)(pProp->pVal));
      }
      else
      {
        WBFree(pProp->pVal);
      }

#if 0
      { // debug code to prevent re-free problems with b0rked list
        int i2;

        for(i2=i1+1; i2 < pPropList->nProps; i2++)
        {
          register WB_DIALOG_PROP *pProp2 = &(pPropList->aDlgProp[i2]);

          if(pProp->pVal == pProp2->pVal)
          {
            if(pProp->aProp == pProp2->aProp)
            {
              WB_DEBUG_PRINT(DebugLevel_ERROR | DebugSubSystem_DialogCtrl | DebugSubSystem_Dialog,
                             "%s - %d %d matching property name %d and value %p detected\n",
                              __FUNCTION__, i1, i2, (int)(pProp->aProp), pProp->pVal);
            }

            pProp2->pVal = NULL;
            pProp2->aProp = 0;  // for now set this to zero as well
          }
        }
      }
#endif // 0
    }

    bzero(pProp, sizeof(*pProp));  // zero out whatever used to be there (as a matter of course)
  }

  pPropList->nProps = 0; // matter of course

  WBFree(pPropList); // caller must ensure no duplicate destruction happens
}



////////////////////////////////////////
// L I S T   I N F O   H A N D L E R S
////////////////////////////////////////

void * DLGCDefaultListInfoAllocator(const void *pData, int cbData)
{
  void *pRval;

  if(cbData < 0)
  {
    if(pData)
    {
      cbData = strlen((const char *)pData) + 1;
    }
    else
    {
      return NULL;
    }
  }

  pRval = WBAlloc(cbData + 1);

  if(pRval)
  {
    if(cbData)
    {
      if(pData)
      {
        memcpy(pRval, pData, cbData);
      }
      else
      {
        bzero(pRval, cbData);
      }
    }

    ((char *)pRval)[cbData] = 0;  // there will always be at least that one extra byte for the zero
  }

  return pRval;
}

int DLGInitControlListInfo(WBDialogControl *pCtrl, int nFlags,
                           void *(*pfnAllocator)(const void *,int), void (*pfnDestructor)(void *),
                           void (*pfnDisplay)(WBDialogControl *, void *, int, GC, WB_GEOM *, XFontSet),
                           int (*pfnSort)(const void *, const void *))
{
WB_DIALOG_PROP propTemp;
int i1;

  if(!pfnDisplay)
  {
    pfnDisplay = DLGCDefaultListControlDisplayProc;
  }

  propTemp.aProp = aDLGC_LISTINFO;
  propTemp.lVal = 0;
  propTemp.pVal = DLGCListInfoConstructor(pCtrl->wID, DEFAULT_LISTINFO_MAX, nFlags,
                                          pfnAllocator, pfnDestructor, pfnDisplay, NULL);

  if(!propTemp.pVal)
  {
    WB_ERROR_PRINT("%s - DLGCListInfoConstructor returns NULL\n", __FUNCTION__);
    return -2;
  }

  i1 = WBDialogControlSetDialogProp(pCtrl, &propTemp);

  if(i1)
  {
    WB_ERROR_PRINT("%s - WBDialogControlSetDialogProp returns %d\n", __FUNCTION__, i1);
    DLGCListInfoDestructor(propTemp.pVal);
  }

  return i1;  // 0 means 'success'
}

int DLGModifyControlListInfo(WBDialogControl *pCtrl, int bFlags, int nFlags,
                             int bAllocator, void *(*pfnAllocator)(const void *,int),
                             int bDestructor, void (*pfnDestructor)(void *),
                             int bDisplay, void (*pfnDisplay)(WBDialogControl *, void *, int, GC, WB_GEOM *, XFontSet),
                             int bSort, int (*pfnSort)(const void *, const void *))
{
WB_DIALOG_PROP propTemp;
const WB_DIALOG_PROP *pProp;
LISTINFO *pLI;
//int i1;


  pProp = WBDialogControlGetDialogProp(pCtrl, aDLGC_LISTINFO);

  if(!pProp)
  {
    // see DLGInitControlListInfoDefault for canonical default values (this should match it actually)

    return DLGInitControlListInfo(pCtrl, bFlags ? nFlags : ListInfoFlags_SORTED,
                                  bAllocator ? pfnAllocator : DLGCDefaultListInfoAllocator,
                                  bDestructor ? pfnDestructor : WBFree,
                                  bDisplay ? pfnDisplay : NULL,
                                  bSort ? pfnSort : NULL);
  }

  memcpy(&propTemp, pProp, sizeof(propTemp));

  if(!propTemp.pVal)
  {
    WB_ERROR_PRINT("%s - DLGCListInfoConstructor returns NULL\n", __FUNCTION__);
    return -2;
  }

  pLI = (LISTINFO *)propTemp.pVal;

  // assuming it's ok, assign the various information as specified.

  if(bFlags)
  {
    pLI->nFlags = nFlags;
  }

  if(bAllocator)
  {
    pLI->pfnAllocator = pfnAllocator;
  }

  if(bDestructor)
  {
    pLI->pfnDestructor = pfnDestructor;
  }

  if(bDisplay)
  {
    if(pfnDisplay)
    {
      pLI->pfnDisplay = pfnDisplay;
    }
    else
    {
      pLI->pfnDisplay = DLGCDefaultListControlDisplayProc;
    }
  }

  if(bSort)
  {
    if(pfnSort)
    {
      pLI->pfnSort = pfnSort;
    }
    else
    {
      pLI->pfnSort = (int (*)(const void *,const void *))strcmp;
    }
  }

  return 0;
}

LISTINFO *DLGCListInfoConstructor(Window wOwner, int nMax, int nFlags,
                                  void *(*pfnAllocator)(const void *,int), void (*pfnDestructor)(void *),
                                  void (*pfnDisplay)(WBDialogControl *, void *, int, GC, WB_GEOM *, XFontSet),
                                  int (*pfnSort)(const void *, const void *))
{
LISTINFO *pRval = WBAlloc(sizeof(*pRval) + nMax * sizeof(const void *));

  if(pRval)
  {
    pRval->nItems = 0;
    pRval->nMaxItems = nMax;
    pRval->nPos = 0;     // current scroll position (initially zero)
    pRval->nTop = 0;     // index of top item that's visible
    pRval->nHeight = 0;  // height of viewport in 'items'
    pRval->nFlags = nFlags;
    pRval->wOwner = wOwner;
    pRval->pfnAllocator = pfnAllocator;
    pRval->pfnDestructor = pfnDestructor;
    if(pfnDisplay)
    {
      pRval->pfnDisplay = pfnDisplay;
    }
    else
    {
      pRval->pfnDisplay = DLGCDefaultListControlDisplayProc;
    }
    if(pfnSort)
    {
      pRval->pfnSort = pfnSort;
    }
    else
    {
      pRval->pfnSort = (int (*)(const void *,const void *))strcmp;
    }
  }

  return pRval;
}

void DLGCListInfoDestructor(LISTINFO *pListInfo)
{
int i1;
void **paData;

  if(!pListInfo)
  {
    return;
  }

  paData = pListInfo->aItems;

  WB_DEBUG_PRINT(DebugLevel_Verbose | DebugSubSystem_DialogCtrl | DebugSubSystem_Dialog,
                 "%s - destroying %d items using %p for %p\n",
                 __FUNCTION__, pListInfo->nItems, pListInfo->pfnDestructor, pListInfo->aItems);

  for(i1=0; i1 < pListInfo->nItems; i1++)
  {
    WB_DEBUG_PRINT(DebugLevel_Verbose | DebugSubSystem_DialogCtrl | DebugSubSystem_Dialog,
                  "%s - destroying item %d, value = %p\n",
                 __FUNCTION__, i1, paData[i1]);

    if(pListInfo->pfnDestructor)
    {
      pListInfo->pfnDestructor(paData[i1]);
    }
    else if(paData[i1])
    {
      WBFree(paData[i1]);
    }
  }

  WBFree(pListInfo);
}

//typedef struct __LISTINFO__
//{
//  int nItems, nMaxItems;              // size/max size of aItems (must re-alloc to increase nMaxItems)
//  int nFlags;                         // flags (sorted, etc.)
//  Window wOwner;                      // owning window [to be notified on change]
//  void *(*pfnAllocator)(void *, int); // copy constructor to call for each item that's added
//                                      // typically this will call 'WBAlloc' followed by 'memcpy'
//                                      // if NULL, the caller-supplied pointer is assigned to 'aItems' as-is
//  void (*pfnDestructor)(void *);      // destructor to call for each item that's removed
//                                      // typically this will point to 'WBFree'
//                                      // if NULL, the caller-supplied pointer is ignored
//
//  void (*pfnDisplay)(WBDialogControl *pControl, void *pData, int iSelected, GC gcPaint, WB_GEOM *pGeom);
//                                      // generic function to display contents of item within 'pGeom' using GC
//                                      // typically one of the listbox 'display item' functions
//
//  int (*pfnSort)(const void *, const void *); // sort proc (NULL implies strcmp)
//
//  void *aItems[1];                    // array of item data (remainder of struct)
//} LISTINFO;

const char * DLGGetControlListText(WBDialogControl *pCtrl, int iIndex)
{
  const LISTINFO *pListInfo;
  const WB_DIALOG_PROP *pProp = WBDialogControlGetDialogProp(pCtrl, aDLGC_LISTINFO);

  if(!pProp || !pProp->pVal)
  {
    return NULL;
  }

  pListInfo = (LISTINFO *)(pProp->pVal);

  if(iIndex == ControlListIndex_LAST)
  {
    iIndex = pListInfo->nItems - 1;
  }

  if(iIndex < 0 || iIndex >= pListInfo->nItems)
  {
    return NULL;
  }

  if(!(pListInfo->aItems[iIndex]))
  {
    return "";  // always a non-NULL return if the item exists
  }

  return (const char *)(pListInfo->aItems[iIndex]);
}

const void * DLGGetControlListData(WBDialogControl *pCtrl, int iIndex)
{
  const LISTINFO *pListInfo;
  const WB_DIALOG_PROP *pProp = WBDialogControlGetDialogProp(pCtrl, aDLGC_LISTINFO);

  if(!pProp || !pProp->pVal)
  {
    return NULL;
  }

  pListInfo = (LISTINFO *)(pProp->pVal);

  if(iIndex == ControlListIndex_LAST)
  {
    iIndex = pListInfo->nItems - 1;
  }

  if(iIndex < 0 || iIndex >= pListInfo->nItems)
  {
    return NULL;
  }

  return pListInfo->aItems[iIndex];
}

static DECLARE_SORT_FUNCTION(_actual_sort_proc,p0,p1,p2)
//static int _actual_sort_proc(void *p0, const void *p1, const void *p2)
{
  const void *p1a = *((const void * const *)p1);
  const void *p2a = *((const void * const *)p2);
  LISTINFO *pListInfo = (LISTINFO *)p0;

  if(pListInfo->pfnSort)
  {
    return pListInfo->pfnSort(p1a, p2a);
  }

  return strcmp(p1a, p2a);
}

int DLGAddControlListEntry(WBDialogControl *pCtrl, const char *pData, long cbData, int iIndex)
{
  LISTINFO *pListInfo, *pListInfo0;
  WB_DIALOG_PROP *pProp = (WB_DIALOG_PROP *)WBDialogControlGetDialogProp(pCtrl, aDLGC_LISTINFO);
  WB_DIALOG_PROP propTemp;
  int i1;
  void *pTemp;

  if(!pProp || !pProp->pVal)
  {
    if(!(pCtrl->ulFlags & CONTROL_SupportListInfo))
    {
      // check first for the property, then return an error if it's
      // not supported (you never know...)

      WB_ERROR_PRINT("%s - control does not support 'LISTINFO'\n", __FUNCTION__);
      return -3;
    }

    pListInfo0 = NULL;

    // use the default settings to initialize the LISTINFO
    propTemp.aProp = aDLGC_LISTINFO;
    propTemp.lVal = 0;
    propTemp.pVal = DLGCListInfoConstructor(pCtrl->wID, DEFAULT_LISTINFO_MAX, ListInfoFlags_SORTED,
                                            DLGCDefaultListInfoAllocator,
                                            WBFree,
                                            DLGCDefaultListControlDisplayProc,
                                            NULL);

    if(!propTemp.pVal)
    {
      WB_ERROR_PRINT("%s - unable to allocate 'LISTINFO'\n", __FUNCTION__);
      return -3;  // error (unable to allocate LISTINFO)
    }
  }
  else
  {
    propTemp.aProp = pProp->aProp;
    propTemp.lVal = pProp->lVal;
    propTemp.pVal = pProp->pVal;

    pListInfo0 = (LISTINFO *)propTemp.pVal;
  }

  pListInfo = (LISTINFO *)propTemp.pVal;

  if(iIndex == ControlListIndex_INSERT_FIRST)
  {
    iIndex = -1; // note - this should really have no effect at all
  }
  else if(iIndex == ControlListIndex_INSERT_LAST)
  {
    iIndex = pListInfo->nItems - 1;
  }
  else if(iIndex < 0 || iIndex >= pListInfo->nItems)
  {
    if(!pListInfo0)
    {
      DLGCListInfoDestructor(propTemp.pVal);
    }

    WB_ERROR_PRINT("%s - invalid index %d\n", __FUNCTION__, iIndex);

    return -2;
  }

  if((iIndex + 1) >= pListInfo->nMaxItems)
  {
    int nItems = pListInfo->nMaxItems;
    // time to re-allocate

    if(nItems <= 0x40000)
    {
      nItems *= 2;
    }
    else
    {
      nItems += 0x40000;
    }

    i1 = sizeof(*pListInfo)
       + nItems * sizeof(pListInfo->aItems[0]);

    propTemp.pVal = WBReAlloc(pListInfo, i1);

    if(!propTemp.pVal)
    {
      if(!pListInfo0) // extremely unlikely, if not impossible, extremely defensive code
      {
        WB_ERROR_PRINT("%s:%d %s - this should never happen\n", __FILE__, __LINE__, __FUNCTION__);
        DLGCListInfoDestructor(pListInfo); // destroy the one I just created
      }

      return -4;
    }

    pListInfo->nMaxItems = nItems;
    // now I must go to the property list entry itself and forcibly assign this new pointer

    if(pProp)
    {
      pProp->pVal = propTemp.pVal; // this prevents memory leaks in case of an error
    }

    pListInfo = (LISTINFO *)propTemp.pVal; // re-assign to new value
  }

  if(!cbData)
  {
//    WB_ERROR_PRINT("TEMPORARY:  %s:%s:%d NULL cbData\n", __FILE__, __FUNCTION__, __LINE__);
    pTemp = (void *)pData;
  }
  else if(pListInfo->pfnAllocator)
  {
    pTemp = pListInfo->pfnAllocator(pData, cbData);

//// TEMPORARY sanity test
//    if(pTemp == pData)
//    {
//      WB_ERROR_PRINT("%s:%s:%d pData == pTemp %p\n", __FILE__, __FUNCTION__, __LINE__, pTemp);
//    }
  }
  else
  {
    pTemp = NULL;
  }

  if(pListInfo->nFlags & ListInfoFlags_SORTED) // regardless of index, when sorted, do this
  {
    // add to the end to simplify the process, then qsort
    pListInfo->aItems[pListInfo->nItems] = (void *)pTemp;

    pListInfo->nItems++;

    // note:  QSORT_R macro needed because qsort_r differs between linux and BSD
    QSORT_R(pListInfo->aItems, pListInfo->nItems, sizeof(void *), pListInfo, _actual_sort_proc);
  }
  else
  {
    if(iIndex < pListInfo->nItems)
    {
      for(i1=pListInfo->nItems; i1 >= iIndex; i1--)
      {
        pListInfo->aItems[i1 + 1] = pListInfo->aItems[i1];
      }
    }

    pListInfo->aItems[iIndex] = (void *)pTemp;

    pListInfo->nItems++;
  }

  i1 = WBDialogControlSetDialogProp(pCtrl, &propTemp);

  if(i1)
  {
    if(!pListInfo0) // attempted to add new item and failed?
    {
      DLGCListInfoDestructor(propTemp.pVal);
    }

    return i1;
  }

//  WB_ERROR_PRINT("TEMPORARY:  %s:%s:%d\n", __FILE__, __FUNCTION__, __LINE__);
//  DEBUG_DUMP_LIST(pCtrl);

  return 0;  // meaning 'success'
}

void DLGDelControlListEntry(WBDialogControl *pCtrl, int iIndex)
{
  LISTINFO *pListInfo;
  WB_DIALOG_PROP *pProp = (WB_DIALOG_PROP *)WBDialogControlGetDialogProp(pCtrl, aDLGC_LISTINFO);
  int i1;

  if(!pProp || !pProp->pVal)
  {
    WB_WARN_PRINT("%s - unable to get LISTINFO for window %d (%08xH), pProp=%p\n", __FUNCTION__,
                  (int)pCtrl->wID, (int)pCtrl->wID, pProp);
    return;
  }

  pListInfo = (LISTINFO *)pProp->pVal;

  if(iIndex == ControlListIndex_LAST)
  {
    iIndex = pListInfo->nItems - 1;
  }
  else if(iIndex == ControlListIndex_DELETE_ALL)
  {
    if(pListInfo->pfnDestructor)
    {
      for(i1=0; i1 < pListInfo->nItems; i1++)
      {
        pListInfo->pfnDestructor(pListInfo->aItems[i1]);
      }
    }

    pListInfo->aItems[0] = NULL; // do this by convention
    pListInfo->nItems = 0;

    return;
  }
  else if(iIndex < 0 || iIndex >= pListInfo->nItems)
  {
    WB_ERROR_PRINT("%s - invalid index %d\n", __FUNCTION__, iIndex);
    return;
  }

  if(pListInfo->pfnDestructor)
  {
    pListInfo->pfnDestructor(pListInfo->aItems[iIndex]);
  }

  pListInfo->nItems--;

  for(i1=iIndex; i1 < pListInfo->nItems; i1++)
  {
    pListInfo->aItems[i1] = pListInfo->aItems[i1 + 1];
  }

  pListInfo->aItems[pListInfo->nItems] = NULL;  // by convention

//  WB_ERROR_PRINT("TEMPORARY:  %s:%s:%d\n", __FILE__, __FUNCTION__, __LINE__);
//  DEBUG_DUMP_LIST(pCtrl);
}


//typedef struct _WB_LIST_CURSEL_
//{
//  int iCurSel;      // current selection
//  int iTopIndex;    // index of item at top of window
//  int iHeight;      // calculated height of window in "entries" (see next member)
//  int iEntryHeight; // cached display height of each entry (calculated by Expose handler)
//} WBListCurSel; // intended to be member following WBDialogControl for "list" controls


// getting "extension" structures from dialog control structure
static WBListCurSel * __GetListCurSel(WBDialogControl *pCtrl)
{
WBListCurSel *pSel = (WBListCurSel *)(pCtrl + 1);

  if(!pCtrl || !(pCtrl->ulFlags & CONTROL_SupportListInfo)
     || (unsigned char *)(pSel + 1) > (((unsigned char *)pCtrl) + pCtrl->cbStructSize))
  {
    return NULL;
  }

  return pSel;
}


int DLGGetControlListSelection(WBDialogControl *pCtrl)
{
WB_DIALOG_PROP *pProp = (WB_DIALOG_PROP *)WBDialogControlGetDialogProp(pCtrl, aDLGC_LISTINFO);
WBListCurSel *pSel = __GetListCurSel(pCtrl);

  if(!pSel || !pProp || !pProp->pVal)
  {
    return ControlListIndex_NONE;  // "no selection"
  }

  return pSel->iCurSel;
}

void DLGSetControlListSelection(WBDialogControl *pCtrl, int iIndex)
{
WB_DIALOG_PROP *pProp = (WB_DIALOG_PROP *)WBDialogControlGetDialogProp(pCtrl, aDLGC_LISTINFO);
WBListCurSel *pSel = __GetListCurSel(pCtrl);
LISTINFO *pListInfo;
int iOldIndex;

  if(!pSel || !pProp || !pProp->pVal)
  {
    WB_WARN_PRINT("%s - unable to get LISTINFO or 'selection info' for window %d (%08xH), pSel=%p, pProp=%p\n", __FUNCTION__,
                  (int)pCtrl->wID, (int)pCtrl->wID, pSel, pProp);
    return;
  }

  pListInfo = (LISTINFO *)(pProp->pVal);

  iOldIndex = pSel->iCurSel;

  if(iIndex == ControlListIndex_LAST)
  {
    pSel->iCurSel = pListInfo->nItems - 1;
  }
  else if((iIndex >= 0 && iIndex < pListInfo->nItems)
          || iIndex == ControlListIndex_NONE)
  {
    pSel->iCurSel = iIndex;
  }
  else
  {
    WB_WARN_PRINT("%s - invalid index %d (nItems=%d)\n", __FUNCTION__, iIndex, pListInfo->nItems);
    return;
  }

  if(iOldIndex != pSel->iCurSel) // notify myself that something changed
  {
    DLGNotifySelf(pCtrl, aLIST_SELCHANGE, pSel->iCurSel, iOldIndex, 0, 0, 0);
  }
}

void DLGSetControlListSelectionValue(WBDialogControl *pCtrl, int iIndex, int iSelState)
{
}

int DLGGetControlListSelectionBits(WBDialogControl *pCtrl, unsigned int *piBits, int nSize)
{
  return 0;  // for now (warning avoidance)
}

char * DLGGetControlListSelectionText(WBDialogControl *pCtrl)
{
int iSel = DLGGetControlListSelection(pCtrl);

  if(iSel >= 0)
  {
    return WBCopyString(DLGGetControlListText(pCtrl, iSel));
  }

  // TODO:  multiple selections

  return NULL;
}



////////////////////////////////////////
// the default list control display proc
////////////////////////////////////////

void DLGCDefaultListControlDisplayProc(WBDialogControl *pList, void *pData, int iSelected, GC gc, WB_GEOM *pGeom, XFontSet fontSet)
{
int iHPos;
Window wID = pList->wID;
Display *pDisplay = WBGetWindowDisplay(wID);


  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                 "%s - Expose %d (%08xH) pData=%p\n", __FUNCTION__, (int)wID, (int)wID, pData);

  if(fontSet == None)
  {
    fontSet = WBGetWindowFontSet(wID);

    if(fontSet == None)
    {
      fontSet = WBGetDefaultFontSet(pDisplay);
    }
  }

  if(fontSet == None)
  {
    // TODO:  get font from dialog info
    WB_WARN_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);
    return;
  }

  iHPos = WBFontSetAvgCharWidth(pDisplay, fontSet);  // average character width is new horiz pos

  // font setup
  BEGIN_XCALL_DEBUG_WRAPPER
//  XClearWindow(pDisplay, wID);  // TODO:  rather than erase background, see if I need to
  XSetForeground(pDisplay, gc, iSelected ? pList->clrHBG.pixel : pList->clrBG.pixel);
  XFillRectangle(pDisplay, wID, gc, pGeom->x, pGeom->y, pGeom->width, pGeom->height);
  END_XCALL_DEBUG_WRAPPER

  if(iSelected)
  {
    WBDrawDashedRect(pDisplay, wID, gc, pGeom,  pList->clrBD2.pixel);
  }


    // vertically centered text
//  iVPos = pFont->max_bounds.ascent + pFont->max_bounds.descent;  // font height
//  iVPos = (pGeom->height - iVPos) >> 1;  // half of the difference - top of text
//  iVPos += pFont->max_bounds.ascent;

  // painting the window text

  if(pData)
  {
    const char *szText = (const char *)pData;
    WB_RECT rctBounds;

    rctBounds.left = pGeom->x + iHPos;
    rctBounds.right = pGeom->x + pGeom->width - iHPos; // equal border on right side, too
    rctBounds.top = pGeom->y;
    rctBounds.bottom = pGeom->y + pGeom->height;


    XSetForeground(pDisplay, gc, iSelected ? pList->clrHFG.pixel : pList->clrFG.pixel);
    XSetBackground(pDisplay, gc, iSelected ? pList->clrHBG.pixel : pList->clrBG.pixel);

    if(*szText)
    {
      DTDrawSingleLineText(fontSet, szText, pDisplay, gc, wID, 0, 0, &rctBounds,
                           DTAlignment_VCENTER | DTAlignment_HLEFT);
    }

    if(iSelected)  // selected item
    {
      XSetForeground(pDisplay, gc, pList->clrFG.pixel);
      XSetBackground(pDisplay, gc, pList->clrBG.pixel);
    }
  }

  // by convention, restore original objects/state

  BEGIN_XCALL_DEBUG_WRAPPER
  XSetForeground(pDisplay, gc, WBGetWindowFGColor(wID));  // restore it at the end
  END_XCALL_DEBUG_WRAPPER
}




//////////////////////////////////////
// S C R O L L B A R   H A N D L E R
//////////////////////////////////////

int DLGScrollBarHandler(Window wID, WBDialogControl *pCtrl, XEvent *pEvent)
{
int iX, iY, iDirection, iPosition;
WB_SCROLLINFO *pScrollInfo;


  if(pEvent->type != ClientMessage)
  {
    return 0;
  }

  // look for the following:
  // left-button click inside of scroll bar
  // left button click ON the knob
  // left button click above/below/right-of/left-of knob
  // left button click on top/bottom/left/right arrow

  if(pEvent->xclient.message_type == aWM_POINTER)
  {
    // pointer messages - cooked mousie clickie
    WB_ERROR_PRINT("TEMPORARY:  %s mouse message %d (%08xH) %d %d %d %d %d\n",
                   __FUNCTION__,
                   (int)pEvent->xclient.window, (int)pEvent->xclient.window,
                   (int)pEvent->xclient.data.l[0],
                   (int)pEvent->xclient.data.l[1],
                   (int)pEvent->xclient.data.l[2],
                   (int)pEvent->xclient.data.l[3],
                   (int)pEvent->xclient.data.l[4]);

    if(pEvent->xclient.data.l[0] == WB_POINTER_CLICK)
    {
      // TODO:  handle shift-click, ctrl-click, alt-click

      if(pEvent->xclient.data.l[1] == WB_POINTER_BUTTON1 && // left button
         !pEvent->xclient.data.l[2])
      {
        iX = pEvent->xclient.data.l[3];
        iY = pEvent->xclient.data.l[4];

        pScrollInfo = (WB_SCROLLINFO *)WBDialogControlGetProperty2(pCtrl, aDLGC_SCROLLINFO);

        if(WB_LIKELY(pScrollInfo != NULL))
        {
          iDirection = WB_SCROLL_NA;
          iPosition = 0;

          if(WBPointInGeom(iX, iY, pScrollInfo->geomVBar))
          {
            if(WBPointInGeom(iX, iY, pScrollInfo->geomVUp))
            {
              iDirection = WB_SCROLL_BACKWARD;
              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (up)\n", __FUNCTION__);
            }
            else if(WBPointInGeom(iX, iY, pScrollInfo->geomVDown))
            {
              iDirection = WB_SCROLL_FORWARD;
              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (down)\n", __FUNCTION__);
            }
            else if(WBPointInGeom(iX, iY, pScrollInfo->geomVKnob))
            {
              // ON THE KNOB - VScroll

              iDirection = WB_SCROLL_KNOB;
//              iPosition = pScrollInfo->iVMin; //pListInfo->nTop; // NO!
              iPosition = WBCalcVScrollDragPos(pScrollInfo, iY);

              if(iPosition < 0)
              {
                iPosition = pScrollInfo->iVMin; //pListInfo->nTop;
              }

              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (knob)\n", __FUNCTION__);

              // TODO:  determine position of knob
            }
            else if(iY >= pScrollInfo->geomVUp.y + pScrollInfo->geomVUp.height &&
                    iY < pScrollInfo->geomVKnob.y)
            {
              iDirection = WB_SCROLL_PAGEBACK;
              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (page up)\n", __FUNCTION__);
            }
            else if(iY >= pScrollInfo->geomVKnob.y + pScrollInfo->geomVKnob.height &&
                    iY < pScrollInfo->geomVDown.y)
            {
              iDirection = WB_SCROLL_PAGEFWD;
              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (page down)\n", __FUNCTION__);
            }
            else
            {
              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (unknown)\n", __FUNCTION__);
            }

            DLGNotifySelf(pCtrl, aSCROLL_NOTIFY, WB_SCROLL_VERTICAL, iDirection, iPosition, 0, 0);

            return 1;  // handled
          }
          else if(WBPointInGeom(iX, iY, pScrollInfo->geomHBar))
          {
            if(WBPointInGeom(iX, iY, pScrollInfo->geomHLeft))
            {
              iDirection = WB_SCROLL_BACKWARD;
              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (left)\n", __FUNCTION__);
            }
            else if(WBPointInGeom(iX, iY, pScrollInfo->geomHRight))
            {
              iDirection = WB_SCROLL_FORWARD;
              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (right)\n", __FUNCTION__);
            }
            else if(WBPointInGeom(iX, iY, pScrollInfo->geomHKnob))
            {
              // ON THE KNOB - HScroll

              iDirection = WB_SCROLL_KNOB;
//              iPosition = pScrollInfo->iHMin; // NO!
              iPosition = WBCalcHScrollDragPos(pScrollInfo, iY);

              if(iPosition < 0)
              {
                iPosition = pScrollInfo->iHMin; //pListInfo->nTop;
              }

              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (knob)\n", __FUNCTION__);

              // TODO:  determine position of knob
            }
            else if(iX >= pScrollInfo->geomHLeft.x + pScrollInfo->geomHLeft.width &&
                    iX < pScrollInfo->geomHKnob.x)
            {
              iDirection = WB_SCROLL_PAGEBACK;
              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (page left)\n", __FUNCTION__);
            }
            else if(iX >= pScrollInfo->geomHKnob.x + pScrollInfo->geomHKnob.width &&
                    iX < pScrollInfo->geomHRight.x)
            {
              iDirection = WB_SCROLL_PAGEFWD;
              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (page right)\n", __FUNCTION__);
            }
            else
            {
              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (unknown)\n", __FUNCTION__);
            }

            DLGNotifySelf(pCtrl, aSCROLL_NOTIFY, WB_SCROLL_HORIZONTAL, iDirection, iPosition, 0, 0);

            return 1;  // handled
          }
        }
      }
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_DBLCLICK)
    {
      if(pEvent->xclient.data.l[1] == WB_POINTER_BUTTON1 && // left button
         !pEvent->xclient.data.l[2])
      {
        iX = pEvent->xclient.data.l[3];
        iY = pEvent->xclient.data.l[4];
        // assume selection already done, so notify owner

        pScrollInfo = (WB_SCROLLINFO *)WBDialogControlGetProperty2(pCtrl, aDLGC_SCROLLINFO);

        if(WB_LIKELY(pScrollInfo != NULL))
        {
          if(WBPointInGeom(iX, iY, pScrollInfo->geomVBar))
          {
            // if not within knob, re-post to self as single-click
            if(!WBPointInGeom(iX, iY, pScrollInfo->geomVKnob))
            {
              XClientMessageEvent evt;
              memcpy(&evt, pEvent, sizeof(evt));
              evt.data.l[0] = WB_POINTER_CLICK;

              return DLGScrollBarHandler(wID, pCtrl, (XEvent *)&evt);
            }
          }
          else if(WBPointInGeom(iX, iY, pScrollInfo->geomHBar))
          {
            // if not within knob, re-post to self as single-click
            if(!WBPointInGeom(iX, iY, pScrollInfo->geomHKnob))
            {
              XClientMessageEvent evt;
              memcpy(&evt, pEvent, sizeof(evt));
              evt.data.l[0] = WB_POINTER_CLICK;

              return DLGScrollBarHandler(wID, pCtrl, (XEvent *)&evt);
            }
          }
        }
      }
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_CANCEL)
    {
      // canceling drag (as appropriate)

      pScrollInfo = (WB_SCROLLINFO *)WBDialogControlGetProperty2(pCtrl, aDLGC_SCROLLINFO);

//      if(pScrollInfo &&
//         pEvent->xclient.data.l[1] == WB_POINTER_BUTTON1 && // left button
//         !pEvent->xclient.data.l[2])
//      {
//        pScrollInfo->iScrollState &= ~WBScrollState_LDRAG;
//      }
      if((pScrollInfo->iScrollState & WBScrollState_LDRAG) ||
         (pScrollInfo->iScrollState & WBScrollState_MDRAG) ||
         (pScrollInfo->iScrollState & WBScrollState_RDRAG))
      {
        pScrollInfo->iScrollState &= ~(WBScrollState_LDRAG | WBScrollState_MDRAG | WBScrollState_RDRAG);

        return 1;  // "handled"
      }
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_DRAG ||
            pEvent->xclient.data.l[0] == WB_POINTER_MOVE)
    {
      if(pEvent->xclient.data.l[1] == WB_POINTER_BUTTON1 && // left button
         !pEvent->xclient.data.l[2])
      {
        iX = pEvent->xclient.data.l[3];
        iY = pEvent->xclient.data.l[4];

        WB_SCROLLINFO *pScrollInfo = (WB_SCROLLINFO *)WBDialogControlGetProperty2(pCtrl, aDLGC_SCROLLINFO);

        if(WB_LIKELY(pScrollInfo != NULL))
        {
          if(!WBPointInGeom(iX, iY, pScrollInfo->geomVBar) &&
             !WBPointInGeom(iX, iY, pScrollInfo->geomHBar) &&
             (!(pScrollInfo->iScrollState & WBScrollState_LDRAG) ||
              pEvent->xclient.data.l[0] == WB_POINTER_DRAG))
          {
            // TODO:  this is for multi-select listboxes, doing a drag-select

            pScrollInfo->iScrollState &= ~WBScrollState_LDRAG; // make sure

            return 0;  // "not handled" (allow drag-select to be handled by scrollbar owner)
          }
          else if(WBPointInGeom(iX, iY, pScrollInfo->geomVKnob) ||
                  WB_LIKELY(pEvent->xclient.data.l[0] == WB_POINTER_MOVE &&
                            (pScrollInfo->iScrollState & WBScrollState_LDRAG)))
          {
            if(pEvent->xclient.data.l[0] == WB_POINTER_DRAG) // begin drag, return window ID
            {
              WB_ERROR_PRINT("TEMPORARY - %s Mouse drag in scroll bar (knob)\n", __FUNCTION__);

              pScrollInfo->iScrollState |= WBScrollState_LDRAG;  // set the state bit for left-drag
              return((int)wID); // enabling the drag
            }

            iPosition = WBCalcVScrollDragPos(pScrollInfo, iY);

            if(iPosition < 0)
            {
              iPosition = pScrollInfo->iVMin; //pListInfo->nTop;
            }

            // track the mouse position along the center of the knob, if possible

            WB_ERROR_PRINT("TEMPORARY - %s Mouse motion in scroll bar (knob)\n", __FUNCTION__);

            DLGNotifySelf(pCtrl, aSCROLL_NOTIFY, WB_SCROLL_VERTICAL,
                          WB_SCROLL_KNOB, iPosition, 0, 0);
          }
          else if(WBPointInGeom(iX, iY, pScrollInfo->geomHKnob) ||
                  WB_LIKELY(pEvent->xclient.data.l[0] == WB_POINTER_MOVE &&
                            (pScrollInfo->iScrollState & WBScrollState_HLDRAG)))
          {
            if(pEvent->xclient.data.l[0] == WB_POINTER_DRAG) // begin drag, return window ID
            {
              WB_ERROR_PRINT("TEMPORARY - %s Mouse drag in scroll bar (knob)\n", __FUNCTION__);

              pScrollInfo->iScrollState |= WBScrollState_HLDRAG;  // set the state bit for left-drag
              return((int)wID); // enabling the drag
            }

            iPosition = WBCalcHScrollDragPos(pScrollInfo, iX);

            if(iPosition < 0)
            {
              iPosition = pScrollInfo->iHMin; // pListInfo->nTop;
            }

            // track the mouse position along the center of the knob, if possible

            WB_ERROR_PRINT("TEMPORARY - %s Mouse motion in scroll bar (knob)\n", __FUNCTION__);

            DLGNotifySelf(pCtrl, aSCROLL_NOTIFY, WB_SCROLL_VERTICAL,
                          WB_SCROLL_KNOB, iPosition, 0, 0);
          }
          else
          {
            WB_ERROR_PRINT("TEMPORARY - %s mouse motion in scroll bar outside of knob\n", __FUNCTION__);
          }
        }
      }
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_DROP)
    {
      WB_SCROLLINFO *pScrollInfo = (WB_SCROLLINFO *)WBDialogControlGetProperty2(pCtrl, aDLGC_SCROLLINFO);

      if(WB_LIKELY(pScrollInfo != NULL))
      {
        if((pScrollInfo->iScrollState & WBScrollState_LDRAG) ||
           (pScrollInfo->iScrollState & WBScrollState_MDRAG) ||
           (pScrollInfo->iScrollState & WBScrollState_RDRAG))
        {
          pScrollInfo->iScrollState &= ~(WBScrollState_LDRAG | WBScrollState_MDRAG | WBScrollState_RDRAG);

          return 1;  // "handled" (just a notification anyway)
        }
      }
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_SCROLLUP)
    {
      DLGNotifySelf(pCtrl, aSCROLL_NOTIFY, WB_SCROLL_VERTICAL, WB_SCROLL_BACKWARD, 0, 0, 0);
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_SCROLLDOWN)
    {
      DLGNotifySelf(pCtrl, aSCROLL_NOTIFY, WB_SCROLL_VERTICAL, WB_SCROLL_FORWARD, 0, 0, 0);
    }
  }
  else if(pEvent->xclient.message_type == aWM_CHAR)
  {
    // handle cursors only - up, down, left, right, home, end, page up, page down, etc.

    long lKey = pEvent->xclient.data.l[0];             // return from WBKeyEventProcessKey
    long lAltCtrlShift = pEvent->xclient.data.l[1];    // *piAltCtrlShift from WBKeyEventProcessKey
#ifndef NO_DEBUG
    int nChar = (int)pEvent->xclient.data.l[2];        // # of characters decoded into pBuf (below)
    char *pBuf = (char *)&(pEvent->xclient.data.l[3]); // decode buffer (at least 8 chars in length)
#endif // !NO_DEBUG


    WB_ERROR_PRINT("TEMPORARY:  %s char message %lx %ld %d %s\n", __FUNCTION__, lAltCtrlShift, lKey, nChar, pBuf);

    if(lAltCtrlShift & WB_KEYEVENT_KEYSYM) // symbol keys only for this part
    {
      pScrollInfo = (WB_SCROLLINFO *)WBDialogControlGetProperty2(pCtrl, aDLGC_SCROLLINFO);

      if(WB_LIKELY(pScrollInfo != NULL))
      {
        int iShift = lAltCtrlShift & WB_KEYEVENT_SHIFT;
        int iCtrl = lAltCtrlShift & WB_KEYEVENT_CTRL;
        int iAlt = lAltCtrlShift & WB_KEYEVENT_ALT;
        int iBar = WB_SCROLL_NA;
        int iDirection = WB_SCROLL_NA;

        switch(lKey)
        {
          case XK_Up:
            if(iShift || iCtrl || iAlt)
            {
              return 0;
            }

            iBar = WB_SCROLL_VERTICAL;
            iDirection = WB_SCROLL_BACKWARD;
            break;

          case XK_Down:
            if(iShift || iCtrl || iAlt)
            {
              return 0;
            }

            iBar = WB_SCROLL_VERTICAL;
            iDirection = WB_SCROLL_FORWARD;
            break;

          case XK_Left:
            if(iShift || iCtrl || iAlt)
            {
              return 0;
            }

            iBar = WB_SCROLL_HORIZONTAL;
            iDirection = WB_SCROLL_BACKWARD;
            break;

          case XK_Right:
            if(iShift || iCtrl || iAlt)
            {
              return 0;
            }

            iBar = WB_SCROLL_HORIZONTAL;
            iDirection = WB_SCROLL_FORWARD;
            break;

          case XK_Home:

            if(iShift || iAlt)
            {
              return 0;
            }

            if(iCtrl)
            {
              iBar = WB_SCROLL_VERTICAL;
            }
            else
            {
              iBar = WB_SCROLL_HORIZONTAL;
            }

            iDirection = WB_SCROLL_FIRST;
            break;

          case XK_End:

            if(iShift || iAlt)
            {
              return 0;
            }

            if(iCtrl)
            {
              iBar = WB_SCROLL_VERTICAL;
            }
            else
            {
              iBar = WB_SCROLL_HORIZONTAL;
            }

            iDirection = WB_SCROLL_LAST;
            break;

          case XK_Page_Up:

            if(iShift || iAlt)
            {
              return 0;
            }

            if(!iCtrl)
            {
              iBar = WB_SCROLL_VERTICAL;
            }
            else
            {
              iBar = WB_SCROLL_HORIZONTAL;
            }

            iDirection = WB_SCROLL_PAGEBACK;
            break;

          case XK_Page_Down:

            if(iShift || iAlt)
            {
              return 0;
            }

            if(!iCtrl)
            {
              iBar = WB_SCROLL_VERTICAL;
            }
            else
            {
              iBar = WB_SCROLL_HORIZONTAL;
            }

            iDirection = WB_SCROLL_PAGEFWD;
            break;

          default:
            return 0;
        }

        // see if the bar is actually visible first
        if(iBar == WB_SCROLL_HORIZONTAL)
        {
          if(pScrollInfo->geomHBar.width <= 0 || pScrollInfo->geomHBar.height <= 0)
          {
            return 0;  // no vertical scroll bar
          }
        }
        else // vertical
        {
          if(pScrollInfo->geomVBar.width <= 0 || pScrollInfo->geomVBar.height <= 0)
          {
            return 0;  // no vertical scroll bar
          }
        }

        DLGNotifySelf(pCtrl, aSCROLL_NOTIFY, iBar, iDirection, 0, 0, 0);
        return 1;  // keystroke eaten
      }
    }
  }

  return 0;  // NOT handled
}


#ifndef NO_DEBUG
void DEBUG_DUMP_LIST(WBDialogControl *pCtrl)
{
  LISTINFO *pListInfo;
  WB_DIALOG_PROP *pProp;
  int i1;
  const char *p1;


  if(WB_LIKELY((WBGetDebugLevel() & DebugLevel_MASK) < (DebugLevel_Light & DebugLevel_MASK)) ||
     ((WBGetDebugLevel() & DebugSubSystem_MASK) && !(DebugSubSystem_DialogCtrl & WBGetDebugLevel())))
  {
    return;
  }

  pProp = (WB_DIALOG_PROP *)WBDialogControlGetDialogProp(pCtrl, aDLGC_LISTINFO);

  if(!pProp || !pProp->pVal)
  {
    if(!(pCtrl->ulFlags & CONTROL_SupportListInfo))
    {
      WBDebugPrint("%s - control does not support 'LISTINFO'\n", __FUNCTION__);
    }
    else
    {
      WBDebugPrint("%s - 'LISTINFO' is empty\n", __FUNCTION__);
    }

    return;
  }

  pListInfo = (LISTINFO *)pProp->pVal;

  if(pListInfo->nFlags & ListInfoFlags_SORTED) // regardless of index, when sorted, do this
  {
    WBDebugPrint("%s - 'LISTINFO' is sorted\n", __FUNCTION__);
  }

  WBDebugPrint("%s - 'LISTINFO' %d items\n", __FUNCTION__, pListInfo->nItems);

  for(i1=0; i1 < pListInfo->nItems; i1++)
  {
    // for now assume string data
    WBDebugPrint("  %6d: %p %s\n", i1, pListInfo->aItems[i1], (char *)(pListInfo->aItems[i1]));
  }
}
#endif // NO_DEBUG


