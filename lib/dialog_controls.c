////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                            //
//      _  _         _                                       _                _               //
//   __| |(_)  __ _ | |  ___    __ _       ___  ___   _ __  | |_  _ __  ___  | | ___     ___  //
//  / _` || | / _` || | / _ \  / _` |     / __|/ _ \ | '_ \ | __|| '__|/ _ \ | |/ __|   / __| //
// | (_| || || (_| || || (_) || (_| |    | (__| (_) || | | || |_ | |  | (_) || |\__ \ _| (__  //
//  \__,_||_| \__,_||_| \___/  \__, |_____\___|\___/ |_| |_| \__||_|   \___/ |_||___/(_)\___| //
//                             |___/|_____|                                                   //
//                                                                                            //
//                                  dialog control support                                    //
//    construction, destruction, message handling, and expose handlers for dialog controls    //
//                                                                                            //
////////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2016 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.
               Any claims to alleged functionality or features should be
               considered 'preliminary', and might not function as advertised.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <signal.h>
#include <time.h>
#include <sys/stat.h>

#ifndef XK_Delete /* moslty for interix */
#define XK_MISCELLANY /* mostly for interix */
#include <X11/keysymdef.h> // some platforms don't automatically include this with X headers
#endif // XK_Delete

#include <X11/cursorfont.h> /* for special cursors */

#include "window_helper.h"
#include "pixmap_helper.h"  // pixmap helpers, including pre-defined icons
#include "dialog_window.h"
#include "dialog_controls.h"
#include "dialog_support.h" // internal stuff
#include "conf_help.h"
#include "text_object.h"
#include "file_help.h"
#include "draw_text.h"
#include "window_dressing.h"

/** \file dialog_controls.c Dialog Control support, standard control implementation */

#define THIS_SUBSYSTEM DebugSubSystem_DialogCtrl

#define KEYSYM_DEBUG_FLAG DebugLevel_Excessive/*DebugLevel_ERROR*/

#define DEFAULT_STATIC_TAB_WIDTH 4 /* for drawing static text */
#define DEFAULT_BUTTON_TAB_WIDTH 4 /* for drawing button text */


static void FileListControlDisplayProc(WBDialogControl *pList, void *pData, int iSelected, GC gc, WB_GEOM *pGeom, XFontSet fontSet);



#define DEFINE_CREATE_CONTROL(X) \
  static WBDialogControl * do_create_##X(WBDialogControl *pDialogControl, \
                                         int iX, int iY, int iWidth, int iHeight, \
                                         const char *szClassName, const char *szTitle);

#define IMPLEMENT_CREATE_CONTROL(X) \
  static WBDialogControl * do_create_##X(WBDialogControl *pDialogControl, \
                                         int iX, int iY, int iWidth, int iHeight, \
                                         const char *szClassName, const char *szTitle)

#define BEGIN_CREATE_CONTROL(X) Atom aThis = a##X; { aThis = aThis; }

DEFINE_CREATE_CONTROL(FRAME_CONTROL)
DEFINE_CREATE_CONTROL(TEXT_CONTROL)
DEFINE_CREATE_CONTROL(ICON_CONTROL)
DEFINE_CREATE_CONTROL(IMAGE_CONTROL)
DEFINE_CREATE_CONTROL(EDIT_CONTROL)
DEFINE_CREATE_CONTROL(PUSHBUTTON_CONTROL)
DEFINE_CREATE_CONTROL(DEFPUSHBUTTON_CONTROL)
DEFINE_CREATE_CONTROL(CANCELBUTTON_CONTROL)
DEFINE_CREATE_CONTROL(RADIOBUTTON_CONTROL)
DEFINE_CREATE_CONTROL(FIRSTRADIOBUTTON_CONTROL)
DEFINE_CREATE_CONTROL(CHECKBUTTON_CONTROL)
DEFINE_CREATE_CONTROL(TRISTATEBUTTON_CONTROL)
DEFINE_CREATE_CONTROL(HSCROLL_CONTROL)
DEFINE_CREATE_CONTROL(VSCROLL_CONTROL)
DEFINE_CREATE_CONTROL(SLIDER_CONTROL)
DEFINE_CREATE_CONTROL(KNOB_CONTROL)
DEFINE_CREATE_CONTROL(LIST_CONTROL)
DEFINE_CREATE_CONTROL(COMBO_CONTROL)
DEFINE_CREATE_CONTROL(TREE_CONTROL)
DEFINE_CREATE_CONTROL(COMBOTREE_CONTROL)
DEFINE_CREATE_CONTROL(FILE_LIST_CONTROL)
DEFINE_CREATE_CONTROL(FILE_COMBO_CONTROL)
DEFINE_CREATE_CONTROL(PATH_TREE_CONTROL)
DEFINE_CREATE_CONTROL(TAB_CONTROL)


static int GetWBDialogControlStructSize(Atom aClass)
{
  if(aClass == aICON_CONTROL ||
     aClass == aIMAGE_CONTROL)
  {
    return sizeof(struct _WB_IMAGE_CONTROL_);
  }

  if(aClass == aPUSHBUTTON_CONTROL ||
     aClass == aDEFPUSHBUTTON_CONTROL ||
     aClass == aCANCELBUTTON_CONTROL)
  {
    return sizeof(struct _WB_PUSHBUTTON_CONTROL_);
  }

  if(aClass == aEDIT_CONTROL)
  {
    return sizeof(struct _WB_EDIT_CONTROL_);
  }

  if(aClass == aCOMBO_CONTROL)
  {
    return sizeof(struct _WB_COMBO_CONTROL_);
  }

  if(aClass == aLIST_CONTROL ||
     aClass == aFILE_LIST_CONTROL)
  {
    return sizeof(struct _WB_LIST_CONTROL_);
  }

  if(aClass == aTREE_CONTROL ||
     aClass == aPATH_TREE_CONTROL)
  {
    return sizeof(struct _WB_TREE_CONTROL_);
  }

  return sizeof(WBDialogControl);
}

int DLGControlDefaultCallback(Window wID, XEvent *pEvent)
{
#ifndef NO_DEBUG
  Display *pDisplay = WBGetWindowDisplay(wID);
#endif // NO_DEBUG
  WBDialogControl *pDialogControl = DLGGetDialogControlStruct(wID);
  int iRval;

  if(!pDialogControl)
  {
    WB_ERROR_PRINT("%s - no dialog control struct for window %d (%08xH)\n",
                   __FUNCTION__, (int)wID, (int)wID);
    return 0;
  }

  // TODO:  message re-direction to children BEFORE 'pDLGCallback'

  switch(pEvent->type)
  {
    case ButtonPress:
      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Mouse | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                     "BUTTON PRESS - dialog control\n");

      // if this window does NOT have the focus, then I must switch focus
      // also make sure parent window is 'moved forward' so I can view it

      // TODO:  in cases where button presses need to be generically overridden
      //        I can do that here

      break;

    case ButtonRelease:
      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Mouse | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                     "BUTTON RELEASE - dialog control\n");

      // TODO:  in cases where button presses need to be generically overridden
      //        I can do that here

      break;

    case MotionNotify:
      WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_Mouse | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                     "MOTION NOTIFY - dialog control\n");

      // TODO:  in cases where mouse drags need to be generically overridden
      //        I can do that here

      break;

    case KeyPress:
    case KeyRelease:

      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Keyboard | DebugSubSystem_DialogCtrl,
                     "%s KEY PRESS/RELEASE - dialog control - check for hotkeys\n", __FUNCTION__);

      // TODO:  in cases where key presses need to be generically overridden
      //        I can do that here

      iRval = DLGProcessHotKey(pDialogControl->pOwner, pEvent);

      if(iRval)
      {
        return iRval;
      }

      break;

    case FocusIn:

//      WB_ERROR_PRINT("TEMPORARY:  %s - FocusIn for dialog control ID %d window %d (%08xH)\n", __FUNCTION__,
//                     (int)(pDialogControl->pDlgControlEntry ? pDialogControl->pDlgControlEntry->iID : -1),
//                     (int)wID, (int)wID);

      WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Mouse | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                     "FocusIn - dialog control\n");

      DLGNotifyOwner(pDialogControl, aGOTFOCUS,
                     (long)(pDialogControl->pDlgControlEntry ? pDialogControl->pDlgControlEntry->iID : pDialogControl->wID),
                     (unsigned long)pDialogControl->pDlgControlEntry, 0, 0, 0);

      // now update myself
      WBInvalidateGeom(wID, NULL, 1);

      break;

    case FocusOut:

      WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Mouse | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                     "FocusOut - dialog control\n");

      DLGNotifyOwner(pDialogControl, aLOSTFOCUS,
                     (long)(pDialogControl->pDlgControlEntry ? pDialogControl->pDlgControlEntry->iID : pDialogControl->wID),
                     (unsigned long)pDialogControl->pDlgControlEntry, 0, 0, 0);

      // now update myself
      WBInvalidateGeom(wID, NULL, 1);

      break;

  }


  if(pDialogControl->pDLGControlCallback)
  {
    // for most messages, if I handle it here, I don't do further processing

    int iRval = pDialogControl->pDLGControlCallback(wID, pEvent);

    if(iRval)
    {
      // check message types that I do *NOT* want to 'bail out' for

      switch(pEvent->type)
      {
        case DestroyNotify:
          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                         "%s - DestroyNotify and user callback returned %d\n", __FUNCTION__, iRval);

          break;;

        case Expose:
          return iRval;  // 'expose' event already handled

        default:
          return iRval;
      }
    }
  }

  // un-handled messages

  if(pEvent->type == ClientMessage &&
     pEvent->xclient.window == wID)
  {
      if(pEvent->xclient.message_type == aWM_PROTOCOLS && pEvent->xclient.window == wID)
      {
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                       "CLIENT MESSAGE - dialog control - WM_PROTOCOLS\n");

        return 0;  // "not handled"
      }
//      else if(pEvent->xclient.message_type == aCONTROL_NOTIFY) // 'control notification' messages
//      {
//      }
//      else if(pEvent->xclient.message_type == aDLG_FOCUS)  // dialog focus change message
//      {
//      }

#ifndef NO_DEBUG
      {
        char *p1 = WBGetAtomName(pDisplay, pEvent->xclient.message_type);
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                       "CLIENT MESSAGE - dialog control (NOT HANDLED) - %s\n", p1);
        if(p1)
        {
          WBFree(p1);
        }
      }
#endif // NO_DEBUG
      return 1;
  }

//  // special handling for 'destroy'
//  if(pEvent->type == DestroyNotify &&
//     pEvent->xdestroywindow.window == wID)
//  {
//    WBUnregisterWindowCallback(wID); // force this to happen, regardless

//////    int boolQuitFlag = (pDialogWindow->wbDLG.iFlags & WBDialogWindow_APP_WINDOW) != 0;
//////    int boolModal = (pDialogWindow->wbDLG.iFlags & WBDialogWindow_DOMODAL) != 0;
////
////      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
////                     "%s - DestroyNotify\n", __FUNCTION__);
////
////    WBSetWindowData(wID, 0, NULL);
////    WBFree(pDialogControl);
////
//    return 1;
//  }

  return 0;
}

void DLGRegisterControlCallback(WBDialogControl *pDialogControl, const char *szClassName, WBWinEvent pCallback)
{
  pDialogControl->pDLGControlCallback = pCallback;
  WBRegisterWindowCallback(pDialogControl->wID, DLGControlDefaultCallback);
  WBSetWindowClassName(pDialogControl->wID, szClassName);
}


WBDialogControl * WBDialogControlCreate(Atom aClass, WBDialogWindow *pOwner,
                                        WBDialogEntry *pDialogEntry, // pointer to the dialog entry I'll be using
                                        int iX, int iY, int iWidth, int iHeight,
                                        const char *szTitle, const char *szPropertyList)
{
WBDialogControl *pRval;
int i1;

#define DO_CREATE_CONTROL(X) if(aClass == a##X) \
  { return do_create_##X(pRval, iX, iY, iWidth, iHeight, #X, szTitle); }

  pRval = WBAlloc(i1 = GetWBDialogControlStructSize(aClass));
  if(!pRval)
  {
    return NULL;
  }

  memset(pRval, 0, i1);

  iX = DLGPixelWidth(pOwner, iX);
  iY = DLGPixelHeight(pOwner, iY);
  iWidth = DLGPixelWidth(pOwner, iWidth);
  iHeight = DLGPixelHeight(pOwner, iHeight);

  pRval->ulTag = DIALOG_CONTROL_TAG;
  pRval->wID = -1;  // initial value
  pRval->aClass = aClass;
  pRval->pOwner = pOwner;
  pRval->pDlgControlEntry = pDialogEntry;
  pRval->ulFlags = 0;
  pRval->pPropList = NULL;  // initial value
  pRval->cbStructSize = i1;  // keep track of how large the structure _REALLY_ is

  if(WBDialogControlSetPropList(pRval, szPropertyList))
  {
    WB_ERROR_PRINT("%s - Error return from WBDialogSetPropList\n", __FUNCTION__);
    WBFree(pRval);
    return NULL;
  }

  DO_CREATE_CONTROL(FRAME_CONTROL);  // NOTE:  if requested type matches FRAME_CONTROL it returns
  DO_CREATE_CONTROL(TEXT_CONTROL);
  DO_CREATE_CONTROL(ICON_CONTROL);
  DO_CREATE_CONTROL(IMAGE_CONTROL);
  DO_CREATE_CONTROL(EDIT_CONTROL);
  DO_CREATE_CONTROL(PUSHBUTTON_CONTROL);
  DO_CREATE_CONTROL(DEFPUSHBUTTON_CONTROL);
  DO_CREATE_CONTROL(CANCELBUTTON_CONTROL);
  DO_CREATE_CONTROL(RADIOBUTTON_CONTROL);
  DO_CREATE_CONTROL(FIRSTRADIOBUTTON_CONTROL);
  DO_CREATE_CONTROL(CHECKBUTTON_CONTROL);
  DO_CREATE_CONTROL(TRISTATEBUTTON_CONTROL);
  DO_CREATE_CONTROL(HSCROLL_CONTROL);
  DO_CREATE_CONTROL(VSCROLL_CONTROL);
  DO_CREATE_CONTROL(SLIDER_CONTROL);
  DO_CREATE_CONTROL(KNOB_CONTROL);
  DO_CREATE_CONTROL(LIST_CONTROL);
  DO_CREATE_CONTROL(COMBO_CONTROL);
  DO_CREATE_CONTROL(TREE_CONTROL);
  DO_CREATE_CONTROL(COMBOTREE_CONTROL);
  DO_CREATE_CONTROL(FILE_LIST_CONTROL);
  DO_CREATE_CONTROL(FILE_COMBO_CONTROL);
  DO_CREATE_CONTROL(PATH_TREE_CONTROL);
  DO_CREATE_CONTROL(TAB_CONTROL);


  // TODO:  user-registered controls


  // if I get here the control was unrecognized (would have returned if any of the above matched)

  WB_ERROR_PRINT("%s - Unrecognized control in WBDialogControlCreate\n", __FUNCTION__);

  // unrecognized control
  if(pRval->pPropList)
  {
    DLGCDestroyProperties(pRval->pPropList);
    pRval->pPropList = NULL; // as a matter of course
  }

  WBFree(pRval);

  return NULL;
}


#define LOAD_COLOR0(X,Y) if(CHGetResourceString(WBGetDefaultDisplay(), X, Y, sizeof(Y)) > 0) {  }
#define LOAD_COLOR(X,Y,Z) if(CHGetResourceString(WBGetDefaultDisplay(), X, Y, sizeof(Y)) <= 0){ WB_WARN_PRINT("%s - WARNING:  can't find color %s, using default value %s\n", __FUNCTION__, X, Z); strcpy(Y,Z); }

static void alloc_control_colors(WBDialogControl *pDialogControl,
                                 const char *szFGName, const char *szBGName,
                                 const char *szHFGName, const char *szHBGName,
                                 const char *szAFGName, const char *szABGName,
                                 const char *szBDName, int bUseStaticColors)
{
  static const char *szBorder2="#FFFFFF", *szBorder2W="#C8C6C0", *szBorder3="#9C9A94"; // for 3D borders
  static const char *szHFGDef="#E0E0E0", *szHBGDef="#0000A0";  // highlight FG/BG
  static const char *szAFGDef="#000000", *szABGDef="white";  // active FG/BG
  char szFG[18], szBG[18], szBD[18], szHFG[18], szHBG[18], szAFG[18], szABG[18];
  Colormap colormap = DefaultColormap(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));


  // TODO:  add some sanity to this, maybe an API for loading colors?  *MOST* of this is now obsolete
  //        and XSETTINGS uses completely different naming.

  LOAD_COLOR0(szFGName,szFG) else LOAD_COLOR0("*Dialog.foreground",szFG) else LOAD_COLOR0("*Form.foreground", szFG)
   else LOAD_COLOR0("*WmDialogShell.foreground",szFG) else LOAD_COLOR0("*WmForm.foreground", szFG)
   else LOAD_COLOR("*foreground", szFG, "#000000");
  if(bUseStaticColors)
  {
    LOAD_COLOR0(szBGName,szBG) else LOAD_COLOR0("*Dialog.background",szBG) else LOAD_COLOR0("*Form.background", szBG)
     else LOAD_COLOR0("*WmDialogShell.background",szBG)
     else LOAD_COLOR("*WmForm.background", szBG, "#dcdad5"); // default for gnome is dcdad5
  }
  else
  {
    LOAD_COLOR0(szBGName,szBG) else LOAD_COLOR0("*Window.background",szBG)
     else LOAD_COLOR("*background", szBG, "white");
  }
  LOAD_COLOR(szHFGName,szHFG,szHFGDef);
  LOAD_COLOR(szHBGName,szHBG,szHBGDef);
  if(bUseStaticColors)
  {
    LOAD_COLOR(szAFGName,szAFG,szAFGDef);
    LOAD_COLOR(szABGName,szABG,szABGDef);
  }
  else
  {
    LOAD_COLOR(szAFGName,szAFG,szFG);
    LOAD_COLOR(szABGName,szABG,szBG);
  }
  LOAD_COLOR0(szBDName,szBD) else LOAD_COLOR0("*Dialog.border",szBD) else LOAD_COLOR0("*Form.border", szBD)
   else LOAD_COLOR0("*WmDialogShell.border",szBD) else LOAD_COLOR0("*WmForm.border", szBD)
   else LOAD_COLOR0("*borderColor", szBD)
   else LOAD_COLOR("*border", szBD, "black"); // default for gnome


//  // TEMPORARILY DUMP COLOR MAPPING
//  WB_ERROR_PRINT("TEMPORARY:  %s - control colors:\n", __FUNCTION__);
//  WB_ERROR_PRINT("   %s=%s  default=%s\n", szFGName, szFG, "#000000");
//  WB_ERROR_PRINT("   %s=%s  default=%s\n", szBGName, szBG, "#dcdad5 or 'white'");
//  WB_ERROR_PRINT("   %s=%s  default=%s\n", szHFGName, szHFG, szHFGDef);
//  WB_ERROR_PRINT("   %s=%s  default=%s\n", szHBGName, szHBG, szHBGDef);
//  WB_ERROR_PRINT("   %s=%s  default=%s\n", szAFGName, szAFG, szAFGDef);
//  WB_ERROR_PRINT("   %s=%s  default=%s\n", szABGName, szABG, szABGDef);
//  WB_ERROR_PRINT("   %s=%s  default=%s\n", szBDName, szBD, "black");


  XParseColor(WBGetDefaultDisplay(), colormap, szFG, &(pDialogControl->clrFG));
  XAllocColor(WBGetDefaultDisplay(), colormap, &(pDialogControl->clrFG));
  XParseColor(WBGetDefaultDisplay(), colormap, szBG, &(pDialogControl->clrBG));
  XAllocColor(WBGetDefaultDisplay(), colormap, &(pDialogControl->clrBG));
  XParseColor(WBGetDefaultDisplay(), colormap, szAFG, &(pDialogControl->clrAFG));
  XAllocColor(WBGetDefaultDisplay(), colormap, &(pDialogControl->clrAFG));
  XParseColor(WBGetDefaultDisplay(), colormap, szABG, &(pDialogControl->clrABG));
  XAllocColor(WBGetDefaultDisplay(), colormap, &(pDialogControl->clrABG));
  XParseColor(WBGetDefaultDisplay(), colormap, szHFG, &(pDialogControl->clrHFG));
  XAllocColor(WBGetDefaultDisplay(), colormap, &(pDialogControl->clrHFG));
  XParseColor(WBGetDefaultDisplay(), colormap, szHBG, &(pDialogControl->clrHBG));
  XAllocColor(WBGetDefaultDisplay(), colormap, &(pDialogControl->clrHBG));
  XParseColor(WBGetDefaultDisplay(), colormap, szBD, &(pDialogControl->clrBD));

  // 3D border colors for now these are hard-coded - later derive them from FG and BG colors
  if(pDialogControl->clrBG.red >= 60000 && pDialogControl->clrBG.green >= 60000 &&
     pDialogControl->clrBG.blue >= 60000) // note see man page on XColor, values 0 through 65535 for RGB
  {
    XParseColor(WBGetDefaultDisplay(), colormap, szBorder2W, &(pDialogControl->clrBD2));
  }
  else
  {
    XParseColor(WBGetDefaultDisplay(), colormap, szBorder2, &(pDialogControl->clrBD2));
  }
  XAllocColor(WBGetDefaultDisplay(), colormap, &(pDialogControl->clrBD2));
  XParseColor(WBGetDefaultDisplay(), colormap, szBorder3, &(pDialogControl->clrBD3));
  XAllocColor(WBGetDefaultDisplay(), colormap, &(pDialogControl->clrBD3));
}

static Display *dialog_control_get_display(WBDialogControl *pDialogControl)
{
Display *pRval = NULL;

  if(pDialogControl && pDialogControl->pOwner)
  {
    pRval = WBGetWindowDisplay(pDialogControl->pOwner->wID);
  }

  if(!pRval)
  {
    pRval = WBGetDefaultDisplay();
  }

  return pRval;
}

static Window standard_do_create_control(WBDialogControl *pDialogControl,
                                         int iX, int iY, int iWidth, int iHeight, int iBorderWidth,
                                         const char *szClassName, const char *szTitle, WBWinEvent pCallback)
{
  XSetWindowAttributes xswa;  /* Temporary Set Window Attribute struct */
  Display *pDisplay = dialog_control_get_display(pDialogControl);

  bzero(&xswa, sizeof(xswa));

  xswa.border_pixel = pDialogControl->clrBD.pixel;
  xswa.background_pixel = pDialogControl->clrBG.pixel;
  xswa.colormap = DefaultColormap(pDisplay, DefaultScreen(pDisplay));
  xswa.bit_gravity = CenterGravity;

  pDialogControl->wID = XCreateWindow(pDisplay, pDialogControl->pOwner ? pDialogControl->pOwner->wID : 0,
                                      iX, iY, iWidth, iHeight,
                                      iBorderWidth,
                                      DefaultDepth(pDisplay, DefaultScreen(pDisplay)),
                                      InputOutput,
                                      DefaultVisual(pDisplay, DefaultScreen(pDisplay)),
                                      CWBorderPixel | CWBackPixel | CWColormap | CWBitGravity,
                                      &xswa);
  if(pDialogControl->wID <= 0 /* == None */)
  {
    return None;
  }

  // TODO:  standardize this a little better using WBCreateWindow

  DLGRegisterControlCallback(pDialogControl, szClassName, pCallback);  // adds it to the 'WB' window matrix
  WBSetParentWindow(pDialogControl->wID, pDialogControl->pOwner ? pDialogControl->pOwner->wID : None);

  // immediately identify this window using window data
  WBSetWindowData(pDialogControl->wID, 0, (void *)pDialogControl);

  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                 "%s - TEMPORARY: creating %s control with caption \"%s\"\n",
                 __FUNCTION__, szClassName, szTitle);

  pDialogControl->pCaption = WBCopyString(szTitle);
//  XSetStandardProperties(pDisplay, pDialogControl->wID, szTitle, szTitle, None,
//                         NULL, 0, NULL); // argv, argc, &xsh);
      // this has been superseded by XSetWMProperties() and should not be used any more

  WBCreateWindowDefaultGC(pDialogControl->wID, pDialogControl->clrFG.pixel, pDialogControl->clrBG.pixel);

  return pDialogControl->wID;
}

//  IMPLEMENT_CREATE_CONTROL
//  static WBDialogControl * do_create_##X(WBDialogControl *pDialogControl,
//                                         int iX, int iY, int iWidth, int iHeight,
//                                         const char *szClassName, const char *szTitle);

static int static_callback(Window wID, XEvent *pEvent);

IMPLEMENT_CREATE_CONTROL(FRAME_CONTROL)
{
BEGIN_CREATE_CONTROL(FRAME_CONTROL);

  Display *pDisplay = dialog_control_get_display(pDialogControl);
  int iBorderWidth = 1;

  aThis = aThis; // so BEGIN_CREATE_CONTROL does not cause warnings for unused variables

  pDialogControl->ulFlags &= ~STATIC_TYPEMASK;
  pDialogControl->ulFlags |= STATIC_Frame;

  // if 3D border
  {
    iBorderWidth = 0;
    pDialogControl->ulFlags |= STATIC_3DBorder;
  }

  // color information for border, foreground, background

  alloc_control_colors(pDialogControl, "*Dialog.foreground", "*Dialog.background",
                       "*Dialog.foreground", "*Dialog.background",
                       "*Dialog.foreground", "*Dialog.background",
                       "*Dialog.border", 1);

  if(standard_do_create_control(pDialogControl, iX, iY, iWidth, iHeight, iBorderWidth,
                                szClassName, szTitle, static_callback)
     == None)
  {
    if(pDialogControl->pPropList)
    {
      DLGCDestroyProperties(pDialogControl->pPropList);
      pDialogControl->pPropList = NULL; // as a matter of course
    }

    WBFree(pDialogControl);
    return NULL;
  }

  // now allow certain kinds of input messages (I should be able to handle messages at this point)
  XSelectInput(pDisplay, pDialogControl->wID, WB_STANDARD_INPUT_MASK);


  if(pDialogControl->pDlgControlEntry &&
     (pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_VISIBLE))
  {
    XMapWindow(pDisplay, pDialogControl->wID);
  }

  return pDialogControl;
}


IMPLEMENT_CREATE_CONTROL(TEXT_CONTROL)
{
BEGIN_CREATE_CONTROL(TEXT_CONTROL);

  Display *pDisplay = dialog_control_get_display(pDialogControl);
  int iBorderWidth = 1;

  aThis = aThis; // so BEGIN_CREATE_CONTROL does not cause warnings for unused variables

  pDialogControl->ulFlags &= ~STATIC_TYPEMASK;
  pDialogControl->ulFlags |= STATIC_Text;

  // if 3D border
  {
    iBorderWidth = 0;
    pDialogControl->ulFlags |= STATIC_3DBorder;
  }

//  // focus
//  pDialogControl->pDlgControlEntry->iFlags |= WBDialogEntry_CAN_HAVE_FOCUS;

  // color information for border, foreground, background

  alloc_control_colors(pDialogControl, "*Label.foreground", "*Label.background",
                       "*Label.highlightColor", "*Label.highlightBackground",
                       "*Labelframe.highlightColor", "*Labelframe.background",  // slightly different
                       "*Labelframe.foreground", 1);

  if(standard_do_create_control(pDialogControl, iX, iY, iWidth, iHeight, iBorderWidth,
                                szClassName, szTitle, static_callback)
     == None)
  {
    if(pDialogControl->pPropList)
    {
      DLGCDestroyProperties(pDialogControl->pPropList);
      pDialogControl->pPropList = NULL; // as a matter of course
    }

    WBFree(pDialogControl);
    return NULL;
  }

  // now allow certain kinds of input messages (I should be able to handle messages at this point)
  XSelectInput(pDisplay, pDialogControl->wID, WB_STANDARD_INPUT_MASK);


  if(pDialogControl->pDlgControlEntry &&
     (pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_VISIBLE))
  {
    XMapWindow(pDisplay, pDialogControl->wID);
  }

  return pDialogControl;
}


IMPLEMENT_CREATE_CONTROL(ICON_CONTROL)
{
BEGIN_CREATE_CONTROL(ICON_CONTROL);

  Display *pDisplay = dialog_control_get_display(pDialogControl);
  int iBorderWidth = 1;

  aThis = aThis; // so BEGIN_CREATE_CONTROL does not cause warnings for unused variables

  pDialogControl->ulFlags &= ~STATIC_TYPEMASK;
  pDialogControl->ulFlags |= STATIC_Icon;

  // if 3D border
  {
    iBorderWidth = 0;
    pDialogControl->ulFlags |= STATIC_3DBorder;
  }


  // color information for border, foreground, background

  alloc_control_colors(pDialogControl, "*Dialog.foreground", "*Dialog.background",
                       "*Dialog.foreground", "*Dialog.background",
                       "*Dialog.foreground", "*Dialog.background",
                       "*Dialog.border", 1);

  if(standard_do_create_control(pDialogControl, iX, iY, iWidth, iHeight, iBorderWidth,
                                szClassName, szTitle, static_callback)
     == None)
  {
    if(pDialogControl->pPropList)
    {
      DLGCDestroyProperties(pDialogControl->pPropList);
      pDialogControl->pPropList = NULL; // as a matter of course
    }

    WBFree(pDialogControl);
    return NULL;
  }

  // now allow certain kinds of input messages (I should be able to handle messages at this point)
  XSelectInput(pDisplay, pDialogControl->wID, WB_STANDARD_INPUT_MASK);


  // TODO:  scan properties for 'ICON' property, load icon, assign to
  //        ((struct _WB_IMAGE_CONTROL_ *)pDialogControl)->pixmap

  if(pDialogControl->pDlgControlEntry &&
     (pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_VISIBLE))
  {
    XMapWindow(pDisplay, pDialogControl->wID);
  }

  return pDialogControl;
}


IMPLEMENT_CREATE_CONTROL(IMAGE_CONTROL)
{
BEGIN_CREATE_CONTROL(IMAGE_CONTROL);

  Display *pDisplay = dialog_control_get_display(pDialogControl);
  int iBorderWidth = 1;

  aThis = aThis; // so BEGIN_CREATE_CONTROL does not cause warnings for unused variables

  pDialogControl->ulFlags &= ~STATIC_TYPEMASK;
  pDialogControl->ulFlags |= STATIC_Image;

  // if 3D border
  {
    iBorderWidth = 0;
    pDialogControl->ulFlags |= STATIC_3DBorder;
  }


  // color information for border, foreground, background

  alloc_control_colors(pDialogControl, "*Dialog.foreground", "*Dialog.background",
                       "*Dialog.foreground", "*Dialog.background",
                       "*Dialog.foreground", "*Dialog.background",
                       "*Dialog.border", 1);

  if(standard_do_create_control(pDialogControl, iX, iY, iWidth, iHeight, iBorderWidth,
                                szClassName, szTitle, static_callback)
     == None)
  {
    if(pDialogControl->pPropList)
    {
      DLGCDestroyProperties(pDialogControl->pPropList);
      pDialogControl->pPropList = NULL; // as a matter of course
    }

    WBFree(pDialogControl);
    return NULL;
  }

  // now allow certain kinds of input messages (I should be able to handle messages at this point)
  XSelectInput(pDisplay, pDialogControl->wID, WB_STANDARD_INPUT_MASK);


  if(pDialogControl->pDlgControlEntry &&
     (pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_VISIBLE))
  {
    XMapWindow(pDisplay, pDialogControl->wID);
  }

  return pDialogControl;
}


static int edit_callback(Window wID, XEvent *pEvent);

IMPLEMENT_CREATE_CONTROL(EDIT_CONTROL)
{
BEGIN_CREATE_CONTROL(EDIT_CONTROL);

  WBEditControl *pPrivate = (WBEditControl *)pDialogControl;
  Display *pDisplay = dialog_control_get_display(pDialogControl);

//  pDialogControl->ulFlags &= ~EDIT_TYPEMASK;
//  pDialogControl->ulFlags |= EDIT_Frame;


  // focus
  pDialogControl->pDlgControlEntry->iFlags |= WBDialogEntry_CAN_HAVE_FOCUS;

  // private member initialization
//  pPrivate->pState = NULL;  // nothing, yet (until text is assigned)
  WBInitializeInPlaceTextObject(&(pPrivate->xTextObject), None);

  // NOTE:  it's assumed that vtable will NOT be NULL after calling that...


  // TODO:  determine single/multi line behavior.  for now, SINGLE only
  pPrivate->xTextObject.vtable->set_linefeed(&(pPrivate->xTextObject), LineFeed_NONE); // single-line


  // color information for border, foreground, background

  alloc_control_colors(pDialogControl, "*Text.foreground", "*Text.background",
                       "*Text.selectForeground", "*Text.selectBackground",
                       "*Text.activeForeground", "*Text.activeBackground",
                       "*Text.border", 0);

//  WB_ERROR_PRINT("TEMPORARY:  EDIT colors FG=%lxH BG=%lxH HF=%lx HB=%lx AF=%lx AB=%lx\n",
//                 pDialogControl->clrFG.pixel,pDialogControl->clrBG.pixel,
//                 pDialogControl->clrHFG.pixel,pDialogControl->clrHBG.pixel,
//                 pDialogControl->clrAFG.pixel,pDialogControl->clrABG.pixel);

  // assign highlight colors to text object (other colors obtained from the GC)
  pPrivate->xTextObject.vtable->highlight_colors(&(pPrivate->xTextObject), pDialogControl->clrHFG, pDialogControl->clrHBG);

  if(standard_do_create_control(pDialogControl, iX, iY, iWidth, iHeight, 1, // border width is 1
                                szClassName, szTitle, edit_callback)
     == None)
  {
    if(pDialogControl->pPropList)
    {
      DLGCDestroyProperties(pDialogControl->pPropList);
      pDialogControl->pPropList = NULL; // as a matter of course
    }

    // destroy any allocated 'text object' stuff thus far
    WBDestroyInPlaceTextObject(&(pPrivate->xTextObject));

    WBFree(pDialogControl);
    return NULL;
  }

  pPrivate->xTextObject.wIDOwner = pDialogControl->wID; // TODO:  make assigning this an API function?

  // this one needs a special cursor
  WBSetWindowDefaultCursor(pDialogControl->wID, XC_xterm);//tcross);

  // assign colors to TEXT OBJECT

  // now allow certain kinds of input messages (I should be able to handle messages at this point)
  XSelectInput(pDisplay, pDialogControl->wID,
               WB_STANDARD_INPUT_MASK | WB_MOUSE_INPUT_MASK | WB_KEYBOARD_INPUT_MASK);

  if(pDialogControl->pDlgControlEntry &&
     (pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_VISIBLE))
  {
    XMapWindow(pDisplay, pDialogControl->wID);
  }

  // create timer for cursor blink
  CreateTimer(pDisplay, pDialogControl->wID, 333333, 1, 1); // TODO:  use #define for timer ID

  return pDialogControl;
}


static int button_callback(Window wID, XEvent *pEvent);

IMPLEMENT_CREATE_CONTROL(PUSHBUTTON_CONTROL)
{
BEGIN_CREATE_CONTROL(PUSHBUTTON_CONTROL);

XFontSet fsBold;


  Display *pDisplay = dialog_control_get_display(pDialogControl);

//  aThis = aThis; // so BEGIN_CREATE_CONTROL does not cause warnings for unused variables

  pDialogControl->ulFlags &= ~BUTTON_TYPEMASK;
  pDialogControl->ulFlags |= BUTTON_PushButton;


  // focus
  pDialogControl->pDlgControlEntry->iFlags |= WBDialogEntry_CAN_HAVE_FOCUS
                                            | WBDialogEntry_PUSHBUTTON; // override 'default' when I have focus

  // color information for border, foreground, background

  alloc_control_colors(pDialogControl, "*Button.foreground", "*Button.background",
                       "*Button.highlightForeground", "*Button.highlightBackground",
                       "*Button.activeForeground", "*Button.activeBackground",
                       "*Button.border", 1);

  if(standard_do_create_control(pDialogControl, iX, iY, iWidth, iHeight, 0, // border width is zero
                                szClassName, szTitle, button_callback)
     == None)
  {
    if(pDialogControl->pPropList)
    {
      DLGCDestroyProperties(pDialogControl->pPropList);
      pDialogControl->pPropList = NULL; // as a matter of course
    }

    WBFree(pDialogControl);
    return NULL;
  }

  // assign BOLD font to this one... (TODO:  query owner dialog box? get fonts from that?)

  fsBold = WBCopyModifyFontSet(pDisplay, WBGetDefaultFontSet(pDisplay),
                               0, WBFontFlag_WT_BOLD); // BOLD version

  if(fsBold != None)
  {
    WBSetWindowFontSet(pDialogControl->wID, fsBold);
  }

  // now allow certain kinds of input messages (I should be able to handle messages at this point)
  XSelectInput(pDisplay, pDialogControl->wID,
               WB_STANDARD_INPUT_MASK | WB_MOUSE_INPUT_MASK | WB_KEYBOARD_INPUT_MASK);


  if(pDialogControl->pDlgControlEntry &&
     (pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_VISIBLE))
  {
    XMapWindow(pDisplay, pDialogControl->wID);
  }

  return pDialogControl;
}


IMPLEMENT_CREATE_CONTROL(DEFPUSHBUTTON_CONTROL)
{
BEGIN_CREATE_CONTROL(DEFPUSHBUTTON_CONTROL);

XFontSet fsBold;


  Display *pDisplay = dialog_control_get_display(pDialogControl);

//  aThis = aThis; // so BEGIN_CREATE_CONTROL does not cause warnings for unused variables

  pDialogControl->ulFlags &= ~BUTTON_TYPEMASK;
  pDialogControl->ulFlags |= BUTTON_DefPushButton;


  // focus
  pDialogControl->pDlgControlEntry->iFlags |= WBDialogEntry_CAN_HAVE_FOCUS
                                            | WBDialogEntry_PUSHBUTTON  // override 'default' when I have focus (trivial here)
                                            | WBDialogEntry_DEFAULT;

  // color information for border, foreground, background

  alloc_control_colors(pDialogControl, "*Button.foreground", "*Button.background",
                       "*Button.highlightForeground", "*Button.highlightBackground",
                       "*Button.activeForeground", "*Button.activeBackground",
                       "*Button.border", 1);

  if(standard_do_create_control(pDialogControl, iX, iY, iWidth, iHeight, 0, // border width is zero
                                szClassName, szTitle, button_callback)
     == None)
  {
    if(pDialogControl->pPropList)
    {
      DLGCDestroyProperties(pDialogControl->pPropList);
      pDialogControl->pPropList = NULL; // as a matter of course
    }

    WBFree(pDialogControl);
    return NULL;
  }

  // assign BOLD font to this one... (TODO:  query owner dialog box? get fonts from that?)

  fsBold = WBCopyModifyFontSet(pDisplay, WBGetDefaultFontSet(pDisplay),
                               0, WBFontFlag_WT_BOLD); // BOLD version

  if(fsBold != None)
  {
    WBSetWindowFontSet(pDialogControl->wID, fsBold);
  }

  // now allow certain kinds of input messages (I should be able to handle messages at this point)
  XSelectInput(pDisplay, pDialogControl->wID,
               WB_STANDARD_INPUT_MASK | WB_MOUSE_INPUT_MASK | WB_KEYBOARD_INPUT_MASK);


  if(pDialogControl->pDlgControlEntry &&
     (pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_VISIBLE))
  {
    XMapWindow(pDisplay, pDialogControl->wID);
  }

  return pDialogControl;
}


IMPLEMENT_CREATE_CONTROL(CANCELBUTTON_CONTROL)
{
BEGIN_CREATE_CONTROL(CANCELBUTTON_CONTROL);

XFontSet fsBold;


  Display *pDisplay = dialog_control_get_display(pDialogControl);

//  aThis = aThis; // so BEGIN_CREATE_CONTROL does not cause warnings for unused variables

  pDialogControl->ulFlags &= ~BUTTON_TYPEMASK;
  pDialogControl->ulFlags |= BUTTON_CancelButton;


  // focus
  pDialogControl->pDlgControlEntry->iFlags |= WBDialogEntry_CAN_HAVE_FOCUS
                                            | WBDialogEntry_PUSHBUTTON; // override 'default' when I have focus

  // color information for border, foreground, background

  alloc_control_colors(pDialogControl, "*Button.foreground", "*Button.background",
                       "*Button.highlightForeground", "*Button.highlightBackground",
                       "*Button.activeForeground", "*Button.activeBackground",
                       "*Button.border", 1);

  if(standard_do_create_control(pDialogControl, iX, iY, iWidth, iHeight, 0, // border width is zero
                                szClassName, szTitle, button_callback)
     == None)
  {
    if(pDialogControl->pPropList)
    {
      DLGCDestroyProperties(pDialogControl->pPropList);
      pDialogControl->pPropList = NULL; // as a matter of course
    }

    WBFree(pDialogControl);
    return NULL;
  }

  // assign BOLD font to this one... (TODO:  query owner dialog box? get fonts from that?)

  fsBold = WBCopyModifyFontSet(pDisplay, WBGetDefaultFontSet(pDisplay),
                               0, WBFontFlag_WT_BOLD); // BOLD version

  if(fsBold != None)
  {
    WBSetWindowFontSet(pDialogControl->wID, fsBold);
  }

  // now allow certain kinds of input messages (I should be able to handle messages at this point)
  XSelectInput(pDisplay, pDialogControl->wID,
               WB_STANDARD_INPUT_MASK | WB_MOUSE_INPUT_MASK | WB_KEYBOARD_INPUT_MASK);


  if(pDialogControl->pDlgControlEntry &&
     (pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_VISIBLE))
  {
    XMapWindow(pDisplay, pDialogControl->wID);
  }

  return pDialogControl;
}


IMPLEMENT_CREATE_CONTROL(RADIOBUTTON_CONTROL)
{
BEGIN_CREATE_CONTROL(RADIOBUTTON_CONTROL);

  Display *pDisplay = dialog_control_get_display(pDialogControl);

//  aThis = aThis; // so BEGIN_CREATE_CONTROL does not cause warnings for unused variables

  pDialogControl->ulFlags &= ~BUTTON_TYPEMASK;
  pDialogControl->ulFlags |= BUTTON_RadioButton;


  // focus
  pDialogControl->pDlgControlEntry->iFlags |= WBDialogEntry_CAN_HAVE_FOCUS;

  // color information for border, foreground, background

  alloc_control_colors(pDialogControl, "*Radiobutton.foreground", "*Radiobutton.background",
                       "*Radiobutton.highlightForeground", "*Radiobutton.highlightBackground",
                       "*Radiobutton.activeForeground", "*RadioButton.activeBackground",
                       "*Radiobutton.border", 1);

  if(standard_do_create_control(pDialogControl, iX, iY, iWidth, iHeight, 0, // border width is zero
                                szClassName, szTitle, button_callback)
     == None)
  {
    if(pDialogControl->pPropList)
    {
      DLGCDestroyProperties(pDialogControl->pPropList);
      pDialogControl->pPropList = NULL; // as a matter of course
    }

    WBFree(pDialogControl);
    return NULL;
  }

  // now allow certain kinds of input messages (I should be able to handle messages at this point)
  XSelectInput(pDisplay, pDialogControl->wID,
               WB_STANDARD_INPUT_MASK | WB_MOUSE_INPUT_MASK | WB_KEYBOARD_INPUT_MASK);


  if(pDialogControl->pDlgControlEntry &&
     (pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_VISIBLE))
  {
    XMapWindow(pDisplay, pDialogControl->wID);
  }

  return pDialogControl;
}


IMPLEMENT_CREATE_CONTROL(FIRSTRADIOBUTTON_CONTROL)
{
BEGIN_CREATE_CONTROL(FIRSTRADIOBUTTON_CONTROL);

  Display *pDisplay = dialog_control_get_display(pDialogControl);

//  aThis = aThis; // so BEGIN_CREATE_CONTROL does not cause warnings for unused variables

  pDialogControl->ulFlags &= ~BUTTON_TYPEMASK;
  pDialogControl->ulFlags |= BUTTON_FirstRadioButton;


  // focus
  pDialogControl->pDlgControlEntry->iFlags |= WBDialogEntry_CAN_HAVE_FOCUS;

  // color information for border, foreground, background

  alloc_control_colors(pDialogControl, "*Radiobutton.foreground", "*Radiobutton.background",
                       "*Radiobutton.highlightForeground", "*Radiobutton.highlightBackground",
                       "*Radiobutton.activeForeground", "*RadioButton.activeBackground",
                       "*Radiobutton.border", 1);

  if(standard_do_create_control(pDialogControl, iX, iY, iWidth, iHeight, 0, // border width is zero
                                szClassName, szTitle, button_callback)
     == None)
  {
    if(pDialogControl->pPropList)
    {
      DLGCDestroyProperties(pDialogControl->pPropList);
      pDialogControl->pPropList = NULL; // as a matter of course
    }

    WBFree(pDialogControl);
    return NULL;
  }

  // now allow certain kinds of input messages (I should be able to handle messages at this point)
  XSelectInput(pDisplay, pDialogControl->wID,
               WB_STANDARD_INPUT_MASK | WB_MOUSE_INPUT_MASK | WB_KEYBOARD_INPUT_MASK);


  if(pDialogControl->pDlgControlEntry &&
     (pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_VISIBLE))
  {
    XMapWindow(pDisplay, pDialogControl->wID);
  }

  return pDialogControl;
}


IMPLEMENT_CREATE_CONTROL(CHECKBUTTON_CONTROL)
{
BEGIN_CREATE_CONTROL(CHECKBUTTON_CONTROL);


  Display *pDisplay = dialog_control_get_display(pDialogControl);

//  aThis = aThis; // so BEGIN_CREATE_CONTROL does not cause warnings for unused variables

  pDialogControl->ulFlags &= ~BUTTON_TYPEMASK;
  pDialogControl->ulFlags |= BUTTON_CheckButton;


  // focus
  pDialogControl->pDlgControlEntry->iFlags |= WBDialogEntry_CAN_HAVE_FOCUS;

  // color information for border, foreground, background

  alloc_control_colors(pDialogControl, "*Checkbutton.foreground", "*Checkbutton.background",
                       "*Checkbutton.highlightForeground", "*Checkbutton.highlightBackground",
                       "*Checkbutton.activeForeground", "*CheckButton.activeBackground",
                       "*Checkbutton.border", 1);

  if(standard_do_create_control(pDialogControl, iX, iY, iWidth, iHeight, 0, // border width is zero
                                szClassName, szTitle, button_callback)
     == None)
  {
    if(pDialogControl->pPropList)
    {
      DLGCDestroyProperties(pDialogControl->pPropList);
      pDialogControl->pPropList = NULL; // as a matter of course
    }

    WBFree(pDialogControl);
    return NULL;
  }

  // now allow certain kinds of input messages (I should be able to handle messages at this point)
  XSelectInput(pDisplay, pDialogControl->wID,
               WB_STANDARD_INPUT_MASK | WB_MOUSE_INPUT_MASK | WB_KEYBOARD_INPUT_MASK);


  if(pDialogControl->pDlgControlEntry &&
     (pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_VISIBLE))
  {
    XMapWindow(pDisplay, pDialogControl->wID);
  }

  return pDialogControl;
}


IMPLEMENT_CREATE_CONTROL(TRISTATEBUTTON_CONTROL)
{
BEGIN_CREATE_CONTROL(TRISTATEBUTTON_CONTROL);

  Display *pDisplay = dialog_control_get_display(pDialogControl);

//  aThis = aThis; // so BEGIN_CREATE_CONTROL does not cause warnings for unused variables

  pDialogControl->ulFlags &= ~BUTTON_TYPEMASK;
  pDialogControl->ulFlags |= BUTTON_TriStateButton;


  // focus
  pDialogControl->pDlgControlEntry->iFlags |= WBDialogEntry_CAN_HAVE_FOCUS;

  // color information for border, foreground, background

  alloc_control_colors(pDialogControl, "*Checkbutton.foreground", "*Checkbutton.background",
                       "*Checkbutton.highlightForeground", "*Checkbutton.highlightBackground",
                       "*Checkbutton.activeForeground", "*CheckButton.activeBackground",
                       "*Checkbutton.border", 1);

  if(standard_do_create_control(pDialogControl, iX, iY, iWidth, iHeight, 0, // border width is zero
                                szClassName, szTitle, button_callback)
     == None)
  {
    if(pDialogControl->pPropList)
    {
      DLGCDestroyProperties(pDialogControl->pPropList);
      pDialogControl->pPropList = NULL; // as a matter of course
    }

    WBFree(pDialogControl);
    return NULL;
  }

  // now allow certain kinds of input messages (I should be able to handle messages at this point)
  XSelectInput(pDisplay, pDialogControl->wID,
               WB_STANDARD_INPUT_MASK | WB_MOUSE_INPUT_MASK | WB_KEYBOARD_INPUT_MASK);


  if(pDialogControl->pDlgControlEntry &&
     (pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_VISIBLE))
  {
    XMapWindow(pDisplay, pDialogControl->wID);
  }

  return pDialogControl;
}


IMPLEMENT_CREATE_CONTROL(HSCROLL_CONTROL)
{
BEGIN_CREATE_CONTROL(HSCROLL_CONTROL);

//  aThis = aThis; // so BEGIN_CREATE_CONTROL does not cause warnings for unused variables


  return NULL;  // for now
}


IMPLEMENT_CREATE_CONTROL(VSCROLL_CONTROL)
{
BEGIN_CREATE_CONTROL(VSCROLL_CONTROL);

//  aThis = aThis; // so BEGIN_CREATE_CONTROL does not cause warnings for unused variables


  return NULL;  // for now
}


IMPLEMENT_CREATE_CONTROL(SLIDER_CONTROL)
{
BEGIN_CREATE_CONTROL(SLIDER_CONTROL);

//  aThis = aThis; // so BEGIN_CREATE_CONTROL does not cause warnings for unused variables


  return NULL;  // for now
}


IMPLEMENT_CREATE_CONTROL(KNOB_CONTROL)
{
BEGIN_CREATE_CONTROL(KNOB_CONTROL);

//  aThis = aThis; // so BEGIN_CREATE_CONTROL does not cause warnings for unused variables


  return NULL;  // for now
}


static int list_callback(Window wID, XEvent *pEvent);

IMPLEMENT_CREATE_CONTROL(LIST_CONTROL)
{
BEGIN_CREATE_CONTROL(LIST_CONTROL);

  Display *pDisplay = dialog_control_get_display(pDialogControl);

//  aThis = aThis; // so BEGIN_CREATE_CONTROL does not cause warnings for unused variables

  pDialogControl->ulFlags |= CONTROL_SupportListInfo;

  // focus
  pDialogControl->pDlgControlEntry->iFlags |= WBDialogEntry_CAN_HAVE_FOCUS; // override 'default' when I have focus


  // color information for border, foreground, background

  alloc_control_colors(pDialogControl, "*List.foreground", "*List.background",
                       "*List.highlightForeground", "*List.highlightBackground",
                       "*List.activeForeground", "*List.activeBackground",
                       "*List.border", 0);

  if(standard_do_create_control(pDialogControl, iX, iY, iWidth, iHeight, 0, // border width is zero
                                szClassName, szTitle, list_callback)
     == None)
  {
    if(pDialogControl->pPropList)
    {
      DLGCDestroyProperties(pDialogControl->pPropList);
      pDialogControl->pPropList = NULL; // as a matter of course
    }

    WBFree(pDialogControl);
    return NULL;
  }

  // initialize list element with default settings if not already initialized on window create
  if(DLGInitControlListInfoDefault(pDialogControl))
//     DLGInitControlListInfo(pDialogControl, ListInfoFlags_SORTED, DLGCDefaultListInfoAllocator, WBFree, NULL, NULL))
  {
    WB_ERROR_PRINT("%s - Unable to initialize list entry for control\n", __FUNCTION__);
    if(pDialogControl->pPropList)
    {
      DLGCDestroyProperties(pDialogControl->pPropList);
      pDialogControl->pPropList = NULL; // as a matter of course
    }

    WBSetWindowData(pDialogControl->wID, 0, NULL);
    WBFree(pDialogControl);
    return NULL;
  }

  ((WBListControl *)pDialogControl)->fsBold = None; // make sure


  // now allow certain kinds of input messages (I should be able to handle messages at this point)
  XSelectInput(pDisplay, pDialogControl->wID,
               WB_STANDARD_INPUT_MASK | WB_MOUSE_INPUT_MASK | WB_KEYBOARD_INPUT_MASK);


  if(pDialogControl->pDlgControlEntry &&
     (pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_VISIBLE))
  {
    XMapWindow(pDisplay, pDialogControl->wID);
  }

  return pDialogControl;
}


static int combo_callback(Window wID, XEvent *pEvent)
{
//  Display *pDisplay = WBGetWindowDisplay(wID);
  WBDialogControl *pDialogControl = DLGGetDialogControlStruct(wID);


  // special handling for 'destroy'
  if(pEvent->type == DestroyNotify &&
     pEvent->xdestroywindow.window == wID)
  {
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                   "%s - DestroyNotify\n", __FUNCTION__);

    WBSetWindowData(wID, 0, NULL);

    if(pDialogControl)
    {
      WBComboControl *pPrivate = (WBComboControl *)pDialogControl;

      if(pDialogControl->pCaption)
      {
        WBFree(pDialogControl->pCaption);
      }

      if(pDialogControl->pPropList)
      {
        DLGCDestroyProperties(pDialogControl->pPropList);
        pDialogControl->pPropList = NULL; // as a matter of course
      }

      // free up privately allocated stuff
      WBDestroyInPlaceTextObject(&(pPrivate->xTextObject));

      WBFree(pDialogControl);
    }

    return 1; // handled
  }

  return 0;  // temporary
}

IMPLEMENT_CREATE_CONTROL(COMBO_CONTROL)
{
BEGIN_CREATE_CONTROL(COMBO_CONTROL);

  WBComboControl *pPrivate = (WBComboControl *)pDialogControl;
  Display *pDisplay = dialog_control_get_display(pDialogControl);

//  aThis = aThis; // so BEGIN_CREATE_CONTROL does not cause warnings for unused variables

  pDialogControl->ulFlags |= CONTROL_SupportListInfo;

  // focus
  pDialogControl->pDlgControlEntry->iFlags |= WBDialogEntry_CAN_HAVE_FOCUS; // override 'default' when I have focus

  WBInitializeInPlaceTextObject(&(pPrivate->xTextObject), None);

  // TODO:  determine single/multi line behavior.  for now, SINGLE only
  pPrivate->xTextObject.vtable->set_linefeed(&(pPrivate->xTextObject), LineFeed_NONE); // single-line


  // color information for border, foreground, background

  alloc_control_colors(pDialogControl, "*Combo.foreground", "*Combo.background",
                       "*Combo.highlightForeground", "*Combo.highlightBackground",
                       "*Combo.activeForeground", "*Combo.activeBackground",
                       "*Combo.border", 0);

  if(standard_do_create_control(pDialogControl, iX, iY, iWidth, iHeight, 0, // border width is zero
                                szClassName, szTitle, combo_callback)
     == None)
  {
    if(pDialogControl->pPropList)
    {
      DLGCDestroyProperties(pDialogControl->pPropList);
      pDialogControl->pPropList = NULL; // as a matter of course
    }

    // destroy any allocated stuff thus far
    WBDestroyInPlaceTextObject(&(pPrivate->xTextObject)); // by convention

    WBFree(pDialogControl);
    return NULL;
  }

  pPrivate->xTextObject.wIDOwner = pDialogControl->wID; // TODO:  make assigning this an API function?


//  // initialize list element with default settings if not already initialized on window create
//  if(DLGInitControlListInfoDefault(pDialogControl))
////     DLGInitControlListInfo(pDialogControl, ListInfoFlags_SORTED, DLGCDefaultListInfoAllocator, WBFree, NULL, NULL))
//  {
//    WB_ERROR_PRINT("%s - Unable to initialize list entry for control\n", __FUNCTION__);
//    if(pDialogControl->pPropList)
//      DLGCDestroyProperties(pDialogControl->pPropList);
//
//    WBSetWindowData(wID, 0, NULL);
//    WBFree(pDialogControl);
//    return NULL;
//  }

  // now allow certain kinds of input messages (I should be able to handle messages at this point)
  XSelectInput(pDisplay, pDialogControl->wID,
               WB_STANDARD_INPUT_MASK | WB_MOUSE_INPUT_MASK | WB_KEYBOARD_INPUT_MASK);


  if(pDialogControl->pDlgControlEntry &&
     (pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_VISIBLE))
  {
    XMapWindow(pDisplay, pDialogControl->wID);
  }

  return pDialogControl;
}


static int tree_callback(Window wID, XEvent *pEvent);

IMPLEMENT_CREATE_CONTROL(TREE_CONTROL)
{
BEGIN_CREATE_CONTROL(TREE_CONTROL);

  Display *pDisplay = dialog_control_get_display(pDialogControl);

//  aThis = aThis; // so BEGIN_CREATE_CONTROL does not cause warnings for unused variables

  pDialogControl->ulFlags |= CONTROL_SupportListInfo;

  // focus
  pDialogControl->pDlgControlEntry->iFlags |= WBDialogEntry_CAN_HAVE_FOCUS; // override 'default' when I have focus


  // color information for border, foreground, background

  alloc_control_colors(pDialogControl, "*List.foreground", "*List.background",
                       "*List.highlightForeground", "*List.highlightBackground",
                       "*List.activeForeground", "*List.activeBackground",
                       "*List.border", 0);

  if(standard_do_create_control(pDialogControl, iX, iY, iWidth, iHeight, 0, // border width is zero
                                szClassName, szTitle, tree_callback)
     == None)
  {
    if(pDialogControl->pPropList)
    {
      DLGCDestroyProperties(pDialogControl->pPropList);
      pDialogControl->pPropList = NULL; // as a matter of course
    }

    WBFree(pDialogControl);
    return NULL;
  }

  // initialize list element with default settings if not already initialized on window create
  if(DLGInitControlListInfoDefault(pDialogControl))
//     DLGInitControlListInfo(pDialogControl, ListInfoFlags_SORTED, DLGCDefaultListInfoAllocator, WBFree, NULL, NULL))
  {
    if(pDialogControl->pPropList)
    {
      DLGCDestroyProperties(pDialogControl->pPropList);
    }

    WBSetWindowData(pDialogControl->wID, 0, NULL);
    WBFree(pDialogControl);
    return NULL;
  }

  ((WBTreeControl *)pDialogControl)->fsBold = None;

  // now allow certain kinds of input messages (I should be able to handle messages at this point)
  XSelectInput(pDisplay, pDialogControl->wID,
               WB_STANDARD_INPUT_MASK | WB_MOUSE_INPUT_MASK | WB_KEYBOARD_INPUT_MASK);


  if(pDialogControl->pDlgControlEntry &&
     (pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_VISIBLE))
  {
    XMapWindow(pDisplay, pDialogControl->wID);
  }

  return pDialogControl;
}


static int combo_tree_callback(Window wID, XEvent *pEvent)
{
  return 0;  // temporary
}

IMPLEMENT_CREATE_CONTROL(COMBOTREE_CONTROL)
{
BEGIN_CREATE_CONTROL(COMBOTREE_CONTROL);

//  aThis = aThis; // so BEGIN_CREATE_CONTROL does not cause warnings for unused variables

  int (*x)(Window wID, XEvent *pEvent) = NULL; // warning avoidance
  x = combo_tree_callback;                     // warning avoidance

  x = x; // more warning avoidance (linux gcc is picky)


  return NULL;  // for now
}


static int file_list_callback(Window wID, XEvent *pEvent);

IMPLEMENT_CREATE_CONTROL(FILE_LIST_CONTROL)
{
BEGIN_CREATE_CONTROL(FILE_LIST_CONTROL);

int iVisible = pDialogControl->pDlgControlEntry &&
              (pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_VISIBLE);

  if(iVisible)
  {
    pDialogControl->pDlgControlEntry->iFlags &= ~ WBDialogEntry_VISIBLE;  // turn off visibility first
  }

  pDialogControl = do_create_LIST_CONTROL(pDialogControl, iX, iY, iWidth, iHeight, szClassName, szTitle);
    // these are very similar so use the LIST CONTROL create method.  Initially, the 'list control'
    // callback is assigned.  I must immediately assign the correct proc (and class name) after it returns.

  if(pDialogControl)
  {
    pDialogControl->aClass = aThis;  // re-define the correct class
    DLGRegisterControlCallback(pDialogControl, szClassName, file_list_callback); // use this callback

    DLGModifyControlListInfo(pDialogControl, 0, 0, 0, 0, 0, 0,
                             1, FileListControlDisplayProc, // only modify the display proc
                             0, 0);

    if(iVisible)
    {
      pDialogControl->pDlgControlEntry->iFlags |= WBDialogEntry_VISIBLE;  // turn visibility back on
      XMapWindow(WBGetWindowDisplay(pDialogControl->wID), pDialogControl->wID); // now show it
    }
  }

  return pDialogControl;
}


static int file_combo_callback(Window wID, XEvent *pEvent)
{
//  return 0;  // temporary

  // for all unhandled messages, call the 'combo_callback'
  // this takes care of things that are common to both FILE COMBO and the COMBO handler

  return combo_callback(wID, pEvent);
}

IMPLEMENT_CREATE_CONTROL(FILE_COMBO_CONTROL)
{
BEGIN_CREATE_CONTROL(FILE_COMBO_CONTROL);

int iVisible = pDialogControl->pDlgControlEntry &&
              (pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_VISIBLE);

  if(iVisible)
  {
    pDialogControl->pDlgControlEntry->iFlags &= ~ WBDialogEntry_VISIBLE;  // turn off visibility first
  }

  pDialogControl = do_create_COMBO_CONTROL(pDialogControl, iX, iY, iWidth, iHeight, szClassName, szTitle);
    // these are very similar so use the COMBO CONTROL create method.  Initially, the 'combo control'
    // callback is assigned.  I must immediately assign the correct proc (and class name) after it returns.

  if(pDialogControl)
  {
    pDialogControl->aClass = aThis;  // re-define the correct class
    DLGRegisterControlCallback(pDialogControl, szClassName, file_combo_callback); // use this callback

    if(iVisible)
    {
      pDialogControl->pDlgControlEntry->iFlags |= WBDialogEntry_VISIBLE;  // turn visibility back on
      XMapWindow(WBGetWindowDisplay(pDialogControl->wID), pDialogControl->wID); // now show it
    }
  }

  return pDialogControl;
}


static int path_tree_callback(Window wID, XEvent *pEvent);

IMPLEMENT_CREATE_CONTROL(PATH_TREE_CONTROL)
{
BEGIN_CREATE_CONTROL(PATH_TREE_CONTROL);

int iVisible = pDialogControl->pDlgControlEntry &&
              (pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_VISIBLE);

  if(iVisible)
  {
    pDialogControl->pDlgControlEntry->iFlags &= ~ WBDialogEntry_VISIBLE;  // turn off visibility first
  }

  pDialogControl = do_create_TREE_CONTROL(pDialogControl, iX, iY, iWidth, iHeight, szClassName, szTitle);
    // these are very similar so use the TREE CONTROL create method.  Initially, the 'tree control'
    // callback is assigned.  I must immediately assign the correct proc (and class name) after it returns.

  if(pDialogControl)
  {
    pDialogControl->aClass = aThis;  // re-define the correct class
    DLGRegisterControlCallback(pDialogControl, szClassName, path_tree_callback); // use this callback

    if(iVisible)
    {
      pDialogControl->pDlgControlEntry->iFlags |= WBDialogEntry_VISIBLE;  // turn visibility back on
      XMapWindow(WBGetWindowDisplay(pDialogControl->wID), pDialogControl->wID); // now show it
    }
  }

  return pDialogControl;
}


IMPLEMENT_CREATE_CONTROL(TAB_CONTROL)
{
BEGIN_CREATE_CONTROL(TAB_CONTROL);

//  aThis = aThis; // so BEGIN_CREATE_CONTROL does not cause warnings for unused variables


  return NULL;  // for now
}



// callbacks

static int StaticDoExposeEvent(XExposeEvent *pEvent, Display *pDisplay,
                               Window wID, WBDialogControl *pSelf);

static int static_callback(Window wID, XEvent *pEvent)
{
  Display *pDisplay = WBGetWindowDisplay(wID);
  WBDialogControl *pDialogControl = DLGGetDialogControlStruct(wID);

  if(pDialogControl && pEvent->type == Expose)
  {
    return StaticDoExposeEvent(&(pEvent->xexpose), pDisplay, wID, pDialogControl);
  }

  // special handling for 'destroy'
  if(pEvent->type == DestroyNotify &&
     pEvent->xdestroywindow.window == wID)
  {
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                   "%s - DestroyNotify\n", __FUNCTION__);

    WBSetWindowData(wID, 0, NULL);

    if(pDialogControl)
    {
      if(pDialogControl->aClass == aICON_CONTROL ||
         pDialogControl->aClass == aIMAGE_CONTROL)
      {

        Pixmap pxOld = ((struct _WB_PUSHBUTTON_CONTROL_ *)pDialogControl)->pixmap;
        if(pxOld != None)
        {
          BEGIN_XCALL_DEBUG_WRAPPER
          if(!pDisplay)
          {
            XFreePixmap(WBGetDefaultDisplay(), pxOld);
          }
          else
          {
            XFreePixmap(pDisplay, pxOld);
          }
          END_XCALL_DEBUG_WRAPPER
        }
      }

      if(pDialogControl->pCaption)
      {
        WBFree(pDialogControl->pCaption);
      }

      if(pDialogControl->pPropList)
      {
        DLGCDestroyProperties(pDialogControl->pPropList);
        pDialogControl->pPropList = NULL; // as a matter of course
      }

      WBFree(pDialogControl);
    }

    return 1;
  }

  return 0;  // not handled
}


static int EditDoExposeEvent(XExposeEvent *pEvent, Display *pDisplay,
                             Window wID, WBDialogControl *pSelf);
static int EditDoCharEvent(XClientMessageEvent *pEvent, Display *pDisplay,
                           Window wID, WBDialogControl *pSelf);
static int EditDoPointerEvent(XClientMessageEvent *pEvent, Display *pDisplay,
                              Window wID, WBDialogControl *pSelf);

static int edit_callback(Window wID, XEvent *pEvent)
{
  int iRval = 0;
  Atom aNotification = None;
  Display *pDisplay = WBGetWindowDisplay(wID);
  WBDialogControl *pDialogControl = DLGGetDialogControlStruct(wID);
  WBEditControl *pPrivate = (WBEditControl *)pDialogControl;
//  char tbuf[32];
//  int nChar = sizeof(tbuf);


  if(pDialogControl && pEvent->type == Expose)
  {
    return EditDoExposeEvent(&(pEvent->xexpose), pDisplay, wID, pDialogControl);
  }

  // special handling for 'destroy'
  if(pEvent->type == DestroyNotify &&
     pEvent->xdestroywindow.window == wID)
  {
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                   "%s - DestroyNotify\n", __FUNCTION__);

    WBSetWindowData(wID, 0, NULL);

    if(pDialogControl)
    {
      WBEditControl *pPrivate = (WBEditControl *)pDialogControl;

      if(pDialogControl->pCaption)
      {
        WBFree(pDialogControl->pCaption);
      }

      if(pDialogControl->pPropList)
      {
        DLGCDestroyProperties(pDialogControl->pPropList);
        pDialogControl->pPropList = NULL; // as a matter of course
      }

      DeleteTimer(pDisplay, wID, 1); // TODO:  use #define for timer ID

      // free up privately allocated stuff
      WBDestroyInPlaceTextObject(&(pPrivate->xTextObject)); // destroy in-place text object

      WBFree(pDialogControl);
    }

    return 1; // handled
  }

  // MOUSE/KEYBOARD INPUT
  if(pEvent->type == ButtonPress ||
     pEvent->type == ButtonRelease ||
     pEvent->type == MotionNotify)
  {
    return 0; // not handled (use WM_POINTER messages generated by toolkit)
  }
  else if(pEvent->type == KeyPress || pEvent->type == KeyRelease)
  {
    return 0; // NOT handled (use WM_CHAR messages instead)
  }

  // CLIENT MESSAGE
  else if(pEvent->type == ClientMessage)
  {
    // ClientMessage events - I want WM_CHAR and WM_POINTER

    if(pEvent->xclient.message_type == aWM_CHAR)
    {
      iRval = EditDoCharEvent(&(pEvent->xclient), pDisplay, wID, pDialogControl);

      if(iRval > 0)
      {
        aNotification = aTEXT_CHANGED;
      }
      else if(iRval < 0) // key handled, text NOT changed
      {
        iRval = 1;  // to indicate that no further key processing is needed
      }
    }
    else if(pEvent->xclient.message_type == aWM_POINTER)
    {
      iRval = EditDoPointerEvent(&(pEvent->xclient), pDisplay, wID, pDialogControl);

      if(iRval) // "handled"
      {
        aNotification = aTEXT_CHANGED; // TODO:  is this necessary??
      }
    }
    // PROPERTY NOTIFICATIONS - special handling for 'CAPTION' assignments
    else if(pEvent->xclient.message_type == aDLGC_PROP_NOTIFY)
    {
      // if I change the 'caption' property I will need to update the xTextObject accordingly

      if(pEvent->xclient.data.l[0] == aDLGC_CAPTION)
      {
//        WB_ERROR_PRINT("TEMPORARY: %s - caption notification \"%s\"\n", __FUNCTION__, pDialogControl->pCaption);

        // mirror the text within the TEXT_OBJECT
        pPrivate->xTextObject.vtable->set_text(&(pPrivate->xTextObject), pDialogControl->pCaption, 0);

        // invalidate the entire window if not already done
        if(WBIsMapped(pDisplay, wID)) // if I'm visible...
        {
          WBInvalidateGeom(wID, NULL, 1); // paint it now
        }
        else
        {
          WBInvalidateGeom(wID, NULL, 0); // just invalidate it
        }
      }
    }
    else if(pEvent->xclient.message_type == aWM_TIMER)
    {
      int bHasFocus = pDialogControl->pDlgControlEntry
                    ? pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_HAS_FOCUS
                    : 0;

      pPrivate->xTextObject.vtable->cursor_blink(&(pPrivate->xTextObject), bHasFocus);

      iRval = 1; // handled
//      aNotification = None;
    }
    else
    {
      iRval = 0; // NOT handled
    }
  }
  else
  {
    iRval = 0; // not handled (default case)
  }


  // *********************
  // CONTROL NOTIFICATIONS
  // *********************

  if(iRval && aNotification != None &&
     pDialogControl->pOwner &&
     pDialogControl->pDlgControlEntry)
  {
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                   "%s:%d - Post Event: %08xH %08xH %08xH %pH\n", __FUNCTION__, __LINE__,
                   (int)aCONTROL_NOTIFY, (int)aNotification,
                   (int)pDialogControl->pDlgControlEntry->iID, pDialogControl);

    DLGNotifyOwnerAsync(pDialogControl, aCONTROL_NOTIFY, aNotification,
                        pDialogControl->pDlgControlEntry->iID,
                        (long)pDialogControl, 0, 0);
  }

  return iRval;  // 0 if not handled, 1 if handled
}


static int PushButtonDoExposeEvent(XExposeEvent *pEvent, Display *pDisplay,
                                   Window wID, WBDialogControl *pSelf);  // these are different
static int ButtonDoExposeEvent(XExposeEvent *pEvent, Display *pDisplay,
                               Window wID, WBDialogControl *pSelf);

static int button_callback(Window wID, XEvent *pEvent)
{
  Display *pDisplay = WBGetWindowDisplay(wID);
  WBDialogControl *pDialogControl = DLGGetDialogControlStruct(wID);

  if(pDialogControl && pEvent->type == Expose)
  {
    int iType = pDialogControl->ulFlags & BUTTON_TYPEMASK;

    if(iType == BUTTON_PushButton || iType == BUTTON_DefPushButton
       || iType == BUTTON_CancelButton)
    {
      // pushbuttons have their own appearance so they must be painted differently

      return PushButtonDoExposeEvent(&(pEvent->xexpose), pDisplay, wID, pDialogControl); // temporary
    }

    // other buttons are some kind of gadget plus text, so they paint with the same proc
    return ButtonDoExposeEvent(&(pEvent->xexpose), pDisplay, wID, pDialogControl); // temporary
  }

  // special handling for 'destroy'
  if(pEvent->type == DestroyNotify &&
     pEvent->xdestroywindow.window == wID)
  {
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                   "%s - DestroyNotify\n", __FUNCTION__);

    WBSetWindowData(wID, 0, NULL);

    if(pDialogControl)
    {
      if(pDialogControl->aClass == aPUSHBUTTON_CONTROL ||
         pDialogControl->aClass == aDEFPUSHBUTTON_CONTROL ||
         pDialogControl->aClass == aCANCELBUTTON_CONTROL)
      {
        Pixmap pxOld = ((struct _WB_PUSHBUTTON_CONTROL_ *)pDialogControl)->pixmap;

        if(pxOld != None)
        {
          BEGIN_XCALL_DEBUG_WRAPPER
          if(!pDisplay)
          {
            XFreePixmap(WBGetDefaultDisplay(), pxOld);
          }
          else
          {
            XFreePixmap(pDisplay, pxOld);
          }
          END_XCALL_DEBUG_WRAPPER
        }
      }

      if(pDialogControl->pCaption)
      {
        WBFree(pDialogControl->pCaption);
      }

      if(pDialogControl->pPropList)
      {
        DLGCDestroyProperties(pDialogControl->pPropList);
        pDialogControl->pPropList = NULL; // as a matter of course
      }

      WBFree(pDialogControl);
    }

    return 1;
  }

  // CONTROL NOTIFICATIONS

  if(pDialogControl->pOwner &&
     pDialogControl->pDlgControlEntry)
  {
    if(pEvent->type == ButtonPress)
    {
      // button press event - what kind of button am I?
      if((pDialogControl->aClass == aPUSHBUTTON_CONTROL ||
          pDialogControl->aClass == aDEFPUSHBUTTON_CONTROL ||
          pDialogControl->aClass == aCANCELBUTTON_CONTROL)
        && ((XButtonEvent *)pEvent)->button == 1) // left button only
      {
        // re-paint button "pressed"
        pDialogControl->pDlgControlEntry->iFlags |= WBDialogEntry_PRESSED;

        WB_ERROR_PRINT("TEMPORARY:  %s - button press\n", __FUNCTION__);

        WBInvalidateRect(wID, NULL, 0);
        WBUpdateWindowImmediately(wID); // make sure I paint it NOW

        return 0;  // not handled - button release will activate these buttons
      }
    }
    else if(pEvent->type == ButtonRelease)
    {
      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Mouse,
                    "%s - BUTTON RELEASE for BUTTON %d\n",
                    __FUNCTION__, ((XButtonEvent *)pEvent)->button);

      // for pushbuttons, kick an even notifier upstairs to the owning window/control
      if((pDialogControl->aClass == aPUSHBUTTON_CONTROL ||
          pDialogControl->aClass == aDEFPUSHBUTTON_CONTROL ||
          pDialogControl->aClass == aCANCELBUTTON_CONTROL)
        && ((XButtonEvent *)pEvent)->button == 1) // left button only
      {
        DLGNotifyOwnerAsync(pDialogControl, aCONTROL_NOTIFY, aBUTTON_PRESS,
                            pDialogControl->pDlgControlEntry->iID,
                            (long)pDialogControl, 0, 0);

        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                       "%s:%d - Post Event: %08xH %08xH %08xH %pH\n", __FUNCTION__, __LINE__,
                       (int)aCONTROL_NOTIFY, (int)aBUTTON_PRESS,
                       (int)pDialogControl->pDlgControlEntry->iID, pDialogControl);

//        WBEndModal(wID, pItem->iAction);

        if(pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_PRESSED)
        {
          pDialogControl->pDlgControlEntry->iFlags &= ~WBDialogEntry_PRESSED; // flip the bit back off

          WBInvalidateRect(wID, NULL, 0);
          WBUpdateWindowImmediately(wID); // make sure I paint it NOW
        }

        return 1;  // handled
      }
    }
    else if(pEvent->type == KeyPress)
    {
      // certain key press events SHOULD cause me to do something, like "press"
      // the button and give positive feedback.

      // TODO:  implement spacebar and enter key doing this

      if(pDialogControl->aClass == aPUSHBUTTON_CONTROL ||
         pDialogControl->aClass == aDEFPUSHBUTTON_CONTROL ||
         pDialogControl->aClass == aCANCELBUTTON_CONTROL)
      {
        int iACS = 0, iKey = WBKeyEventProcessKey((XKeyEvent *)pEvent, NULL, NULL, &iACS);

        WB_ERROR_PRINT("TEMPORARY:  %s- keydown event, %d iACS=%d\n", __FUNCTION__, iKey, iACS);

        if((iKey == ' ' || iKey == '\n' || iKey == '\r')
            && iACS == 0 && pDialogControl->pDlgControlEntry)
        {
          WB_ERROR_PRINT("TEMPORARY:  %s - key press\n", __FUNCTION__);

          pDialogControl->pDlgControlEntry->iFlags |= WBDialogEntry_PRESSED;

          WBInvalidateRect(wID, NULL, 0);
          WBUpdateWindowImmediately(wID); // make sure I paint it NOW

//          pDialogControl->pDlgControlEntry->iFlags &= ~WBDialogEntry_PRESSED; // flip the bit back off
        }

        return 1;  // handled
      }
    }
    else if(pEvent->type == KeyRelease)
    {
      // KeyRelease

      // KeyPress - space bar will toggle the button or press it (as required)
      int iACS = 0, iKey = WBKeyEventProcessKey((XKeyEvent *)pEvent, NULL, NULL, &iACS);

      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                    "%s - KEY RELEASE for KEY %d\n",
                    __FUNCTION__, ((XKeyEvent *)pEvent)->keycode);

      if((pDialogControl->aClass == aPUSHBUTTON_CONTROL ||
          pDialogControl->aClass == aDEFPUSHBUTTON_CONTROL ||
          pDialogControl->aClass == aCANCELBUTTON_CONTROL) &&
         iACS == 0 &&
         (iKey == ' ' || iKey == '\n' || iKey == '\r')) // space bar, enter, return
      {
        DLGNotifyOwnerAsync(pDialogControl, aCONTROL_NOTIFY, aBUTTON_PRESS,
                            pDialogControl->pDlgControlEntry->iID,
                            (long)pDialogControl, 0, 0);

        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                       "%s:%d - Post Event: %08xH %08xH %08xH %pH\n", __FUNCTION__, __LINE__,
                       (int)aCONTROL_NOTIFY, (int)aBUTTON_PRESS,
                       (int)pDialogControl->pDlgControlEntry->iID, pDialogControl);

        if(pDialogControl->pDlgControlEntry->iFlags & WBDialogEntry_PRESSED)
        {
          pDialogControl->pDlgControlEntry->iFlags &= ~WBDialogEntry_PRESSED; // flip the bit back off

          WBInvalidateRect(wID, NULL, 0);
          WBUpdateWindowImmediately(wID); // make sure I paint it NOW
        }

//        WBEndModal(wID, pItem->iAction);
        return 1;  // handled
      }
    }
  }

  return 0;  // not handled
}

static int ListDoExposeEvent(XExposeEvent *pEvent, Display *pDisplay,
                             Window wID, WBDialogControl *pSelf);

static int ListDoCharEvent(XClientMessageEvent *pEvent, Display *pDisplay,
                           Window wID, WBDialogControl *pSelf);

static int list_callback(Window wID, XEvent *pEvent)
{
  int i1, iRval = 0;
  Atom aNotification = None;
  Display *pDisplay = WBGetWindowDisplay(wID);
  WBDialogControl *pDialogControl = DLGGetDialogControlStruct(wID);
//  char tbuf[32];
//  int nChar = sizeof(tbuf);
  LISTINFO *pListInfo = NULL;
  WB_DIALOG_PROP *pProp;

  if(pDialogControl && pEvent->type == Expose)
  {
    return ListDoExposeEvent(&(pEvent->xexpose), pDisplay, wID, pDialogControl);
  }

  pProp = (WB_DIALOG_PROP *)WBDialogControlGetDialogProp(pDialogControl, aDLGC_LISTINFO);

  if(pProp)
  {
    pListInfo = (LISTINFO *)pProp->pVal;
  }


  // special handling for 'destroy'
  if(pEvent->type == DestroyNotify &&
     pEvent->xdestroywindow.window == wID)
  {
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                   "%s - DestroyNotify\n", __FUNCTION__);

    if(((WBListControl *)pDialogControl)->fsBold == None)
    {
      // free up the allocated font set, if there is one
      XFreeFontSet(pDisplay, ((WBListControl *)pDialogControl)->fsBold);

      ((WBListControl *)pDialogControl)->fsBold = None;
    }

    WBSetWindowData(wID, 0, NULL);

    if(pDialogControl)
    {
      if(pDialogControl->pCaption)
      {
        WBFree(pDialogControl->pCaption);
      }

      if(pDialogControl->pPropList)
      {
        DLGCDestroyProperties(pDialogControl->pPropList);
        pDialogControl->pPropList = NULL; // as a matter of course
      }

      WBFree(pDialogControl);
    }

    return 1;
  }

  // handle scroll bars (mousie-clickie and keystrokes)
  // this will generate 'scroll notify' events (as appropriate)
  i1 = DLGScrollBarHandler(wID, pDialogControl, pEvent);

  if(i1)
  {
    return i1;
  }

#if 0
  if(pEvent->type == KeyPress)
  {
#ifndef NO_DEBUG
    int iACS = 0, iKey = WBKeyEventProcessKey((XKeyEvent *)pEvent, tbuf, &nChar, &iACS);
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                   "%s KEY PRESS for KEY %d KEYCODE %d\n", __FUNCTION__, iKey, ((XKeyEvent *)pEvent)->keycode);

    // TODO: extended select modifier keys, toggles, 'auto-complete' select, etc.

#endif // NO_DEBUG
    iRval = 1;  // handled
  }
  else if(pEvent->type == KeyRelease)
  {
    // KeyRelease

    int iACS = 0, iKey = WBKeyEventProcessKey((XKeyEvent *)pEvent, tbuf, &nChar, &iACS);

    if(nChar > 0)
    {
      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                     "%s KEY RELEASE for KEY %d KEYCODE %d  MASK=%d (%xH)\n",
                     __FUNCTION__, iKey, ((XKeyEvent *)pEvent)->keycode,
                     ((XKeyEvent *)pEvent)->state, ((XKeyEvent *)pEvent)->state);

//      if(iKey == 8) // backspace
//      {
//        // TODO:  delete char before cursor or highlighted text
//        // for now just delete the LAST character
//
//        int iLen = strlen(pDialogControl->pCaption);
//        if(iLen > 0)
//        {
//          pDialogControl->pCaption[iLen - 1] = 0;
//        }
//
//        WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
//                       "%s - BACKSPACE key pressed\n", __FUNCTION__);
//      }
//      else
//      {
//        // TODO:  insert or concatenate?  for now concatenate
//        WBCatString(&(pDialogControl->pCaption), tbuf);
//      }
//
//      aNotification = aTEXT_CHANGED;
//      WBInvalidateGeom(wID, NULL, 1);
    }
    else
    {
      if(iACS & WB_KEYEVENT_KEYSYM)
      {
        // TODO:  international, 'dead' and other KEYSYM key assignments
#define KEYSYM_MATCH_CURSOR_NAME(X) (iKey == XK_##X || iKey == XK_KP_##X)
        if(KEYSYM_MATCH_CURSOR_NAME(Home))
        {
          WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                         "%s - Home key pressed\n", __FUNCTION__);
        }
        else if(KEYSYM_MATCH_CURSOR_NAME(End))
        {
          WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                         "%s - End key pressed\n", __FUNCTION__);
        }
        else if(KEYSYM_MATCH_CURSOR_NAME(Left)) // if HSCROLL enabled
        {
          WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                         "%s - Left key pressed\n", __FUNCTION__);
        }
        else if(KEYSYM_MATCH_CURSOR_NAME(Right)) // if HSCROLL enabled
        {
          WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                         "%s - Right key pressed\n", __FUNCTION__);
        }
        else if(KEYSYM_MATCH_CURSOR_NAME(Up))
        {
          WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                         "%s - Up key pressed\n", __FUNCTION__);
        }
        else if(KEYSYM_MATCH_CURSOR_NAME(Down))
        {
          WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                         "%s - Down key pressed\n", __FUNCTION__);
        }
        else if(KEYSYM_MATCH_CURSOR_NAME(Page_Up))
        {
          WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                         "%s - Page Up key pressed\n", __FUNCTION__);
        }
        else if(KEYSYM_MATCH_CURSOR_NAME(Page_Down))
        {
          WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                         "%s - Page Down key pressed\n", __FUNCTION__);
        }
        else if(KEYSYM_MATCH_CURSOR_NAME(Begin)) // beginning of current line
        {
          WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                         "%s - Beginning Of Line key pressed\n", __FUNCTION__);
        }
#undef KEYSYM_MATCH_CURSOR_NAME
        else
        {
          // is it a cursor key?  let's find out
          WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                         "%s - CURSOR KEY? %d (%08xH)  %d (%08xH)\n",
                         __FUNCTION__, iKey, iKey, iACS, iACS);
        }
      }
    }

    iRval = 1;
  }
#endif // 0

  // processing notifications sent to me

  if(pEvent->type == ClientMessage &&
     pEvent->xclient.message_type == aCONTROL_NOTIFY)
  {
    char *p1 = WBGetAtomName(pDisplay,(Atom)pEvent->xclient.data.l[0]);
    WB_DEBUG_PRINT(DebugLevel_Verbose | DebugSubSystem_DialogCtrl | DebugSubSystem_Dialog,
                   "%s - CONTROL_NOTIFY for window %d (%08xH) - %s %ld\n", __FUNCTION__,
                   (int)wID, (int)wID, p1, pEvent->xclient.data.l[1]);
    if(p1)
    {
      WBFree(p1);
    }
  }
  else if(pEvent->type == ClientMessage &&
          pEvent->xclient.message_type == aWM_CHAR)
  {
    iRval = ListDoCharEvent(&(pEvent->xclient), pDisplay, wID, pDialogControl);

    if(iRval > 0)
    {
// POOBAH
      DLGNotifyOwner(pDialogControl, aCONTROL_NOTIFY, aLIST_NOTIFY,
                     pDialogControl->pDlgControlEntry->iID,
                     WB_LIST_SELCHANGE, pListInfo->nPos, 0); // synchronous notification
      return 1; // "handled"
    }

    iRval = 0; // "not handled"
  }
  else if(pEvent->type == ClientMessage &&
          pEvent->xclient.message_type == aWM_POINTER)
  {
    if(pEvent->xclient.data.l[0] == WB_POINTER_CLICK)
    {
      // TODO:  handle shift-click, ctrl-click, alt-click

      if(pEvent->xclient.data.l[1] == WB_POINTER_BUTTON1 && // left button
         !pEvent->xclient.data.l[2])
      {
        int iX = pEvent->xclient.data.l[3];
        int iY = pEvent->xclient.data.l[4];

        WB_SCROLLINFO *pScrollInfo = (WB_SCROLLINFO *)WBDialogControlGetProperty2(pDialogControl, aDLGC_SCROLLINFO);

        if(WB_LIKELY(pScrollInfo != NULL) &&
           WB_UNLIKELY(WBPointInGeom(iX, iY, pScrollInfo->geomVBar) != 0))
        {
          // mouse click was INSIDE of the scroll bar area - this should have already been handled

          WB_ERROR_PRINT("UNHANDLED SCROLL BAR mouse message inside VBAR %d %d %d %d %d\n",
                          (int)pEvent->xclient.data.l[0],
                          (int)pEvent->xclient.data.l[1],
                          (int)pEvent->xclient.data.l[2],
                          (int)pEvent->xclient.data.l[3],
                          (int)pEvent->xclient.data.l[4]);

          return 0;
        }

        // use information about the list to determine where I clicked (which selected item or not)
        // TODO:  encapsulate item selection via message post

        if(pListInfo && pListInfo->nItemHeight > 0)
        {
          i1 = (iY - 1) / pListInfo->nItemHeight; // item number within list 'display area'

//          WB_ERROR_PRINT("TEMPORARY:  clicked on item %d, top item is %d\n", i1, pListInfo->nTop);

          if(i1 >= 0 && i1 <= pListInfo->nHeight)
          {
            i1 += pListInfo->nTop;  // actual index
          }
          else
          {
            i1 = -1;  // as a flag
          }
        }
        if(i1 >= 0 && i1 < pListInfo->nItems)
        {
          if(pListInfo->nPos != i1)
          {
            // set new selection
            pListInfo->nPos = i1;

            if(i1 < pListInfo->nTop) // adjust top if needed
            {
              pListInfo->nTop = i1;
            }
            else if(i1 >= pListInfo->nHeight + pListInfo->nTop)
            {
               pListInfo->nTop = i1 - pListInfo->nHeight + 1;
            }

            WBInvalidateGeom(wID, NULL, 0); // asynchronous re-paint
            WBUpdateWindow(wID);  // posts expose event

            DLGNotifyOwner(pDialogControl, aCONTROL_NOTIFY, aLIST_NOTIFY,
                           pDialogControl->pDlgControlEntry->iID,
                           WB_LIST_SELCHANGE, pListInfo->nPos, 0); // synchronous notification
          }
        }

        return 1;  // handled
      }
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_DBLCLICK)
    {
      if(pEvent->xclient.data.l[1] == WB_POINTER_BUTTON1 && // left button
         !pEvent->xclient.data.l[2])
      {
        int iX = pEvent->xclient.data.l[3];
        int iY = pEvent->xclient.data.l[4];

        // NOTE:  no need to notify selection (would have already been done)

        WB_SCROLLINFO *pScrollInfo = (WB_SCROLLINFO *)WBDialogControlGetProperty2(pDialogControl, aDLGC_SCROLLINFO);

        if(WB_LIKELY(pScrollInfo != NULL) &&
           WB_UNLIKELY(WBPointInGeom(iX, iY, pScrollInfo->geomVBar) != 0))
        {
          WB_ERROR_PRINT("UNHANDLED SCROLL BAR mouse message %d %d %d %d %d\n",
                          (int)pEvent->xclient.data.l[0],
                          (int)pEvent->xclient.data.l[1],
                          (int)pEvent->xclient.data.l[2],
                          (int)pEvent->xclient.data.l[3],
                          (int)pEvent->xclient.data.l[4]);

          return 0;
        }

        // for now assume selection hasn't changed, and post a double-click notification
        // back to the list control's owner so that appropriate action will be taken

        DLGNotifyOwner(pDialogControl, aCONTROL_NOTIFY, aLIST_NOTIFY,
                       pDialogControl->pDlgControlEntry->iID,
                       WB_LIST_DBLCLICK, pListInfo->nPos, 0); // synchronous notification

        return 1;
      }

      return 0;  // so no further processing happens
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_CANCEL)
    {
      // canceling drag (as appropriate)

      WB_SCROLLINFO *pScrollInfo = (WB_SCROLLINFO *)WBDialogControlGetProperty2(pDialogControl, aDLGC_SCROLLINFO);

      if(pScrollInfo &&
         pEvent->xclient.data.l[1] == WB_POINTER_BUTTON1 && // left button
         !pEvent->xclient.data.l[2])
      {
        WB_ERROR_PRINT("UNHANDLED SCROLL BAR mouse message %d %d %d %d %d\n",
                        (int)pEvent->xclient.data.l[0],
                        (int)pEvent->xclient.data.l[1],
                        (int)pEvent->xclient.data.l[2],
                        (int)pEvent->xclient.data.l[3],
                        (int)pEvent->xclient.data.l[4]);

        pScrollInfo->iScrollState &= ~WBScrollState_LDRAG;
      }

      return 1;
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_DRAG ||
            pEvent->xclient.data.l[0] == WB_POINTER_MOVE)
    {
      if(pEvent->xclient.data.l[1] == WB_POINTER_BUTTON1 && // left button
         !pEvent->xclient.data.l[2])
      {
        int iX = pEvent->xclient.data.l[3];
        int iY = pEvent->xclient.data.l[4];

        WB_SCROLLINFO *pScrollInfo = (WB_SCROLLINFO *)WBDialogControlGetProperty2(pDialogControl, aDLGC_SCROLLINFO);

        if(WB_LIKELY(pScrollInfo != NULL) &&
           WB_UNLIKELY(WBPointInGeom(iX, iY, pScrollInfo->geomVBar) != 0))
        {
          WB_ERROR_PRINT("UNHANDLED SCROLL BAR mouse message %d %d %d %d %d\n",
                          (int)pEvent->xclient.data.l[0],
                          (int)pEvent->xclient.data.l[1],
                          (int)pEvent->xclient.data.l[2],
                          (int)pEvent->xclient.data.l[3],
                          (int)pEvent->xclient.data.l[4]);
        }
      }

      return 0;  // for now (to enforce 'NOT HANDLED')
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_DROP)
    {
      return 1;  // "handled" (just a notification anyway)
    }
  }
  else if(pEvent->type == ClientMessage &&
          pEvent->xclient.message_type == aSCROLL_NOTIFY)
  {
    WB_DEBUG_PRINT(DebugLevel_Verbose | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Dialog,
                   "%s - SCROLL_NOTIFY for window %d (%08xH) - %ld %ld %ld\n", __FUNCTION__,
                   (int)wID, (int)wID, pEvent->xclient.data.l[0],
                   pEvent->xclient.data.l[1], pEvent->xclient.data.l[2]);

    if(pEvent->xclient.data.l[0] == WB_SCROLL_VERTICAL)
    {
      int iOldTop = pListInfo->nTop;
      int iOldPos = pListInfo->nPos;

      switch(pEvent->xclient.data.l[1])
      {
        case WB_SCROLL_FORWARD:
          pListInfo->nPos ++;
          break;
        case WB_SCROLL_BACKWARD:
          pListInfo->nPos --;
          break;
        case WB_SCROLL_PAGEFWD:
          pListInfo->nPos += pListInfo->nHeight;
          break;
        case WB_SCROLL_PAGEBACK:
          pListInfo->nPos -= pListInfo->nHeight;
          break;
        case WB_SCROLL_FIRST:
          pListInfo->nPos = 0;
          break;
        case WB_SCROLL_LAST:
          pListInfo->nPos = pListInfo->nItems - 1;
          break;
        case WB_SCROLL_KNOB:
          pListInfo->nTop = pEvent->xclient.data.l[2];
          pListInfo->nPos += pListInfo->nTop - iOldTop;
          break;
        case WB_SCROLL_RELATIVE:
          pListInfo->nPos += pEvent->xclient.data.l[2];
          break;
        case WB_SCROLL_ABSOLUTE:
          pListInfo->nPos = pEvent->xclient.data.l[2];
          break;
      }

      if(iOldTop != pListInfo->nTop || iOldPos != pListInfo->nPos)
      {
        if(pListInfo->nPos < 0)
        {
          pListInfo->nPos = 0;
        }
        else if(pListInfo->nPos >= pListInfo->nItems)
        {
          pListInfo->nPos = pListInfo->nItems - 1;
        }
        if(pListInfo->nTop > pListInfo->nPos)
        {
          pListInfo->nTop = pListInfo->nPos;
        }
        else if(pListInfo->nTop + pListInfo->nHeight <= pListInfo->nPos)
        {
          pListInfo->nTop = pListInfo->nPos - pListInfo->nHeight + 1;
        }

        if(iOldTop != pListInfo->nTop || iOldPos != pListInfo->nPos)
        {
          WBInvalidateGeom(wID, NULL, 0);

          if(pEvent->xclient.data.l[1] == WB_SCROLL_KNOB)
          {
            WBUpdateWindowImmediately(wID);
          }
          else
          {
            WBUpdateWindow(wID);
          }
        }
      }

      return 1;
    }

    return 1;
  }



  // CONTROL NOTIFICATIONS to OWNER

  if(iRval && aNotification != None &&
     pDialogControl->pOwner &&
     pDialogControl->pDlgControlEntry)
  {
    DLGNotifyOwnerAsync(pDialogControl, aCONTROL_NOTIFY, aNotification,
                        pDialogControl->pDlgControlEntry->iID,
                        (long)pDialogControl, 0, 0);

    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                   "%s:%d - Post Event: %08xH %08xH %08xH %pH\n", __FUNCTION__, __LINE__,
                   (int)aCONTROL_NOTIFY, (int)aNotification,
                   (int)pDialogControl->pDlgControlEntry->iID, pDialogControl);
  }

  return iRval;  // 0 if not handled, 1 if handled
}


static int file_list_callback(Window wID, XEvent *pEvent)
{
//Display *pDisplay = WBGetWindowDisplay(wID);
WBDialogControl *pDialogControl = DLGGetDialogControlStruct(wID);
char *p1;
const char *p2;
void *pV;
unsigned long dw1;
char tbuf[NAME_MAX + 4];


//  WB_ERROR_PRINT("TEMPORARY: %s\n", __FUNCTION__);

  if(pEvent->type == ClientMessage &&
     pEvent->xclient.message_type == aDLGC_PROP_NOTIFY)
  {
    WB_DEBUG_PRINT(DebugLevel_Verbose | DebugSubSystem_DialogCtrl | DebugSubSystem_Dialog,
                   "%s - DLGC_PROP_NOTIFY for window %d (%08xH)\n", __FUNCTION__,
                   (int)wID, (int)wID);

    if(pEvent->xclient.data.l[0] == aDLGC_PATH) // TODO:  include a 'DLGC_FILTER' property as well
    {
      if(pDialogControl->pOwner)
      {
        WBBeginWaitCursor(pDialogControl->pOwner->wID);
      }
      else
      {
        WBBeginWaitCursor(wID);
      }

      WB_DEBUG_PRINT(DebugLevel_Verbose | DebugSubSystem_DialogCtrl | DebugSubSystem_Dialog,
                     "%s - DLGC_PROP_NOTIFY DLGC_PATH for window %d (%08xH)\n", __FUNCTION__,
                     (int)wID, (int)wID);

      // property change notification for aPATH must refresh contents
      DLGDelControlListEntry(pDialogControl, ControlListIndex_DELETE_ALL);  // delete all

      p2 = WBDialogControlGetProperty(pDialogControl, aDLGC_PATH); // original path info

      p1 = WBCopyString(p2); // working copy
      if(!p1 || !*p1)
      {
        // TODO:  get current working directory?

        // empty path implies empty list
        goto restore_cursor; // this will also re-paint
      }
      if(p1[strlen(p1) - 1] != '/')
      {
        WBCatString(&p1, "/*");
      }
      else
      {
        WBCatString(&p1, "*");
      }

      if(!p1 || !*p1) // in case of error
      {
        WB_ERROR_PRINT("%s - Memory allocation failure\n", __FUNCTION__);

        goto restore_cursor;
      }

      pV = WBAllocDirectoryList(p1);

      if(!pV) // in case of error
      {
        WB_ERROR_PRINT("%s - unable to get directory list for \"%s\"\n", __FUNCTION__, p1);
        WBFree(p1);

        goto restore_cursor;
      }

      WBFree(p1);
      p1 = NULL;

      // always add the '..' first, unless the path is '/'
      if(!p2 || p2[0] != '/' || p2[1])
      {
        strcpy(tbuf, "@.."); // directory '..'
        DLGAddControlListEntry(pDialogControl, tbuf, -1, ControlListIndex_INSERT_FIRST);
      }

      WB_DEBUG_PRINT(DebugLevel_Verbose | DebugSubSystem_DialogCtrl | DebugSubSystem_Dialog,
                     "%s - enumerating directory\n", __FUNCTION__);

      while(!WBNextDirectoryEntry(pV, tbuf + 1, sizeof(tbuf) - 1, &dw1))
      {
        if(S_ISDIR(dw1))
        {
          tbuf[0] = '@';
        }
        else if(S_ISLNK(dw1))
        {
          // TODO:  determine what link's type is
          if(WBGetDirectoryListFileStat(pV, tbuf, &dw1))
          {
            tbuf[0] = '^'; // can't 'stat' so mark as 'symlink' (for now, maybe reject it?)
          }
          else if(S_ISDIR(dw1))
          {
            tbuf[0] = '@'; // treat symlink as a directory since it points to one
          }
          else
          {
            tbuf[0] = '~'; // assume it's a regular file
          }
        }
        else
        {
          tbuf[0] = '~';
        }

//        WB_WARN_PRINT("TEMPORARY - %s %d (%08xH)\n", tbuf, (int)dw1, (int)dw1);

        // TODO:  directories are excluded
        DLGAddControlListEntry(pDialogControl, tbuf, -1, ControlListIndex_INSERT_LAST);
      }

//      WB_WARN_PRINT("TEMPORARY - DONE enumerating directory\n");

      WBDestroyDirectoryList(pV);
      DEBUG_DUMP_LIST(pDialogControl);

restore_cursor:

      WBInvalidateGeom(wID, NULL, 1); // invalidate and generate expose message (always)

      if(pDialogControl->pOwner)
      {
        WBEndWaitCursor(pDialogControl->pOwner->wID);
      }
      else
      {
        WBEndWaitCursor(wID);
      }

      return 1;
    }

    // TODO:  other stuff?

    // return 1;  do this when it's handled by THIS proc
  }

  return list_callback(wID, pEvent);  // allow base control class to handle it
}


static int tree_callback(Window wID, XEvent *pEvent)
{
  int iRval = 0;
  Atom aNotification = None;
  Display *pDisplay = WBGetWindowDisplay(wID);
  WBDialogControl *pDialogControl = DLGGetDialogControlStruct(wID);
//  char tbuf[32];
//  int nChar = sizeof(tbuf);


  if(pDialogControl && pEvent->type == Expose)
  {
    return ListDoExposeEvent(&(pEvent->xexpose), pDisplay, wID, pDialogControl);
  }

  // special handling for 'destroy'
  if(pEvent->type == DestroyNotify &&
     pEvent->xdestroywindow.window == wID)
  {
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                   "%s - DestroyNotify\n", __FUNCTION__);

    WBSetWindowData(wID, 0, NULL);

    if(pDialogControl)
    {
      if(pDialogControl->pCaption)
      {
        WBFree(pDialogControl->pCaption);
      }

      if(pDialogControl->pPropList)
      {
        DLGCDestroyProperties(pDialogControl->pPropList);
        pDialogControl->pPropList = NULL; // as a matter of course
      }

      WBFree(pDialogControl);
    }

    return 1;
  }

  if(pEvent->type == FocusIn)
  {
    WB_ERROR_PRINT("TEMPORARY:  %s - FocusIn should not be handled here\n", __FUNCTION__);
  }


  // TREE and LIST are similar

  // TODO:  keystroke handling via WM_CHAR


  // CONTROL NOTIFICATIONS

  if(iRval && aNotification != None &&
     pDialogControl->pOwner &&
     pDialogControl->pDlgControlEntry)
  {
    DLGNotifyOwnerAsync(pDialogControl, aCONTROL_NOTIFY, aNotification,
                        pDialogControl->pDlgControlEntry->iID,
                        (long)pDialogControl, 0, 0);

    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                   "%s:%d - Post Event: %08xH %08xH %08xH %pH\n", __FUNCTION__, __LINE__,
                   (int)aCONTROL_NOTIFY, (int)aNotification,
                   (int)pDialogControl->pDlgControlEntry->iID, pDialogControl);
  }

  return iRval;  // 0 if not handled, 1 if handled
}

static int path_tree_callback(Window wID, XEvent *pEvent)
{
//Display *pDisplay = WBGetWindowDisplay(wID);
WBDialogControl *pDialogControl = DLGGetDialogControlStruct(wID);
char *p1;
void *pV;
unsigned long dw1;
char tbuf[NAME_MAX + 4];


  if(pEvent->type == ClientMessage &&
     pEvent->xclient.type == aDLGC_PROP_NOTIFY)
  {
    WB_DEBUG_PRINT(DebugLevel_Verbose | DebugSubSystem_DialogCtrl | DebugSubSystem_Dialog,
                   "%s - DLGC_PROP_NOTIFY for window %d (%08xH)\n", __FUNCTION__,
                   (int)wID, (int)wID);

    if(pEvent->xclient.data.l[0] == aDLGC_PATH) // TODO:  include a 'DLGC_FILTER' property as well
    {
      WB_DEBUG_PRINT(DebugLevel_Verbose | DebugSubSystem_DialogCtrl | DebugSubSystem_Dialog,
                     "%s - DLGC_PROP_NOTIFY DLGC_PATH for window %d (%08xH)\n", __FUNCTION__,
                     (int)wID, (int)wID);

      // property change notification for aPATH must refresh contents
      DLGDelControlListEntry(pDialogControl, ControlListIndex_DELETE_ALL);  // delete all

      p1 = WBCopyString(WBDialogControlGetProperty(pDialogControl, aDLGC_PATH));
      if(!p1 || !*p1)
      {
        return 1;  // empty path implies empty list
      }
      if(p1[strlen(p1) - 1] != '/')
      {
        WBCatString(&p1, "/*");
      }
      else
      {
        WBCatString(&p1, "*");
      }

      if(!p1 || !*p1) // in case of error
      {
        WB_ERROR_PRINT("%s - Memory allocation failure\n", __FUNCTION__);
        return 1;
      }

      pV = WBAllocDirectoryList(p1);
      WBFree(p1);
      p1 = NULL;

      if(!pV) // in case of error
      {
        WB_ERROR_PRINT("%s - unable to get directory list\n", __FUNCTION__);
        return 1;
      }

//      WB_WARN_PRINT("TEMPORARY - enumerating directory\n");

      while(!WBNextDirectoryEntry(pV, tbuf, sizeof(tbuf), &dw1))
      {
        if(S_ISDIR(dw1))
        {
        }
        else if(S_ISLNK(dw1))
        {
          // TODO:  determine what link's type is

          if(WBStat(tbuf, &dw1) || !S_ISDIR(dw1))
          {
            continue;
          }
        }
        else
        {
          continue; // ignore regular files
        }

//        WB_WARN_PRINT("TEMPORARY - %s %d (%08xH)\n", tbuf, (int)dw1, (int)dw1);

        DLGAddControlListEntry(pDialogControl, tbuf, -1, ControlListIndex_INSERT_LAST);
      }

//      WB_WARN_PRINT("TEMPORARY - DONE enumerating directory\n");

      WBDestroyDirectoryList(pV);
      DEBUG_DUMP_LIST(pDialogControl);

      return 1;
    }
  }

  return tree_callback(wID, pEvent);  // allow base control class to handle it
}




//*****************************
// I N P U T   H A N D L I N G
//*****************************


// NOTE:  returns non-zero if text changes

static int EditDoCharEvent(XClientMessageEvent *pEvent, Display *pDisplay,
                           Window wID, WBDialogControl *pSelf)
{
WBEditControl *pPrivate = (WBEditControl *)pSelf;
int iRval = 0, iACS, iKey, nChar;//, iLen;
char *pBuf, *pData;
WB_RECT rctTemp;


  iKey = pEvent->data.l[0];  // result from WBKeyEventProcessKey()
  iACS = pEvent->data.l[1];
  nChar = pEvent->data.l[2];
  pBuf = (char *)&(pEvent->data.l[3]);

  if(nChar > 0) // normal ASCII characters
  { // DebugLevel_Heavy
    WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                   "%s KEY RELEASE for KEY %d KEYCODE %d  MASK=%d (%xH)\n",
                   __FUNCTION__, iKey, ((XKeyEvent *)pEvent)->keycode,
                   ((XKeyEvent *)pEvent)->state, ((XKeyEvent *)pEvent)->state);

    if(iKey == 8) // backspace
    {
      WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                     "%s - BACKSPACE key pressed, iACS=%d (%xH)\n", __FUNCTION__, iACS, iACS);

      if(pPrivate->xTextObject.vtable->has_select(&(pPrivate->xTextObject)))
      {
        pPrivate->xTextObject.vtable->del_select(&(pPrivate->xTextObject)); // delete selection
      }
      else
      {
        pPrivate->xTextObject.vtable->del_chars(&(pPrivate->xTextObject), -1); // delete the character to the left
      }

      // re-assign caption
      if(pSelf->pCaption)
      {
        WBFree(pSelf->pCaption);
      }

      pSelf->pCaption = pPrivate->xTextObject.vtable->get_text(&(pPrivate->xTextObject));

      iRval = 1; // text changed
    }
    else if(iKey == 13 || iKey == 10 // CR or LF (TODO:  check flags to see if I should accept this)
            || iKey == 9)            // tab (TODO:  check flags to see if I should accept this)
    {
      // TODO:  check for multi-line control, add line feeds as needed

      return 0; // LF may trigger default button, allow default handling
      // since the text was not changed return 0 _NOW_ so that WM_CHAR handling happens in default processing
    }
    else if(iKey == 1)  // CTRL+A
    {
      WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                     "%s - CTRL+A key pressed, iACS=%d (%xH)\n", __FUNCTION__, iACS, iACS);

      if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL)       // control key will always be pressed, but no shift
      {
        rctTemp.left = rctTemp.top = 0;
        rctTemp.right = rctTemp.bottom = INT_MAX;

        pPrivate->xTextObject.vtable->set_select(&(pPrivate->xTextObject), &rctTemp);
      }

      iRval = -1; // text NOT changed
    }
    else if(iKey == 3)  // CTRL+C
    {
      if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL)       // control key will always be pressed, but no shift
      {
        if(pPrivate->xTextObject.vtable->has_select(&(pPrivate->xTextObject)))
        {
          WB_DEBUG_PRINT(/*KEYSYM_DEBUG_FLAG*/DebugLevel_ERROR | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                         "%s - CTRL+C key pressed, iACS=%d (%xH)\n", __FUNCTION__, iACS, iACS);

          pData = pPrivate->xTextObject.vtable->get_sel_text(&(pPrivate->xTextObject), NULL);

          if(pData)
          {
            if(aUTF8_STRING != None)
            {
              WBSetClipboardData(pDisplay, aUTF8_STRING, 8, pData, strlen(pData) + 1);
            }
            else
            {
              WBSetClipboardData(pDisplay, aSTRING, 8, pData, strlen(pData) + 1);
            }
            WBFree(pData);
            pData = NULL; // by convention
          }
          else
          {
            XBell(pDisplay, -100);
            WB_ERROR_PRINT("TEMPORARY:  NULL returned from get_sel_text()\n");
          }
        }
        else
        {
          XBell(pDisplay, -100);
          WB_ERROR_PRINT("TEMPORARY - %s - no selection, can't 'COPY'\n", __FUNCTION__);
        }
      }

      iRval = -1; // text NOT changed
    }
    else if(iKey == 22) // CTRL+V
    {
      WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                     "%s - CTRL+V key pressed, iACS=%d (%xH)\n", __FUNCTION__, iACS, iACS);

      if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL)       // control key will always be pressed, but no shift
      {
        Atom aType = aUTF8_STRING;
        int iFormat = 8;
        unsigned long nData = 0;

        if(aType == None)
        {
          aType = aSTRING;
        }

        WB_ERROR_PRINT("TEMPORARY %s - CTRL+V key pressed\n", __FUNCTION__);

//        pData = (char *)CHGetSelectionData(pDisplay, aCLIPBOARD, aUTF8_STRING, aUTF8_STRING, //aCLIPBOARD, aC_STRING, aSTRING,
//                                           &aType, &iFormat, &nData);
        pData = (char *)WBGetClipboardData(pDisplay, &aType, &iFormat, &nData);

        if(!pData || !nData)
        {
          if(pData)
          {
            WBFree(pData);
          }

          aType = aSTRING;
          pData = (char *)WBGetClipboardData(pDisplay, &aType, &iFormat, &nData);
        }

        if(pData && nData > 0)
        {
          if(!pData[nData])
          {
            nData--;
          }
        }

        if(pData)
        {
          // TODO:  convert to correct format (ASCII)
          if(iFormat != 8)
          {
            if(iFormat == 8 * sizeof(wchar_t))
            {
              char *pNew = WBAlloc(sizeof(wchar_t) * (nData + 2));
              if(pNew)
              {
                memset(pNew, 0, sizeof(wchar_t) * (nData + 2));
                wcstombs(pNew, (const wchar_t *)pData, sizeof(wchar_t) * (nData + 2));
              }

              WBFree(pData);
              pData = pNew;
            }
            else
            {
              XBell(pDisplay, -100);
              WB_ERROR_PRINT("TEMPORARY - %s - clipboard format %d, can't 'PASTE'\n", __FUNCTION__, iFormat);

              WBFree(pData);
              pData = NULL;
            }
          }

          if(pData)
          {
            if(pPrivate->xTextObject.vtable->has_select(&(pPrivate->xTextObject)))
            {
              pPrivate->xTextObject.vtable->replace_select(&(pPrivate->xTextObject), pData, nData);
            }
            else
            {
              pPrivate->xTextObject.vtable->ins_chars(&(pPrivate->xTextObject), pData, nData);
            }

            WBFree(pData);
            pData = NULL; // by convention
          }
          else
          {
            XBell(pDisplay, -100);
            WB_ERROR_PRINT("TEMPORARY - %s - NULL pData, can't 'PASTE'\n", __FUNCTION__);
          }
        }
        else
        {
          XBell(pDisplay, -100);
          WB_ERROR_PRINT("TEMPORARY:  NULL returned from WBGetClipboardData()\n");
        }
      }

      iRval = 1; // text changed
    }
    else if(iKey == 24) // CTRL+X
    {
      WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                     "%s - CTRL+X key pressed, iACS=%d (%xH)\n", __FUNCTION__, iACS, iACS);

      if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL)       // control key will always be pressed, but no shift
      {
        if(pPrivate->xTextObject.vtable->has_select(&(pPrivate->xTextObject)))
        {
          WB_DEBUG_PRINT(/*KEYSYM_DEBUG_FLAG*/DebugLevel_ERROR | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                         "%s - CTRL+C key pressed, iACS=%d (%xH)\n", __FUNCTION__, iACS, iACS);

          pData = pPrivate->xTextObject.vtable->get_sel_text(&(pPrivate->xTextObject), NULL);

          if(pData)
          {
            if(aUTF8_STRING != None)
            {
              WBSetClipboardData(pDisplay, aUTF8_STRING, 8, pData, strlen(pData) + 1);
            }
            else
            {
              WBSetClipboardData(pDisplay, aSTRING, 8, pData, strlen(pData) + 1);
            }

            WBFree(pData);
            pData = NULL; // by convention

            pPrivate->xTextObject.vtable->del_select(&(pPrivate->xTextObject)); // delete selection
          }
          else
          {
            XBell(pDisplay, -100);
            WB_ERROR_PRINT("TEMPORARY:  NULL returned from get_sel_text()\n");
          }
        }
        else
        {
          XBell(pDisplay, -100);
          WB_ERROR_PRINT("TEMPORARY - %s - no selection, can't 'CUT'\n", __FUNCTION__);
        }
      }

      iRval = 1; // text changed
    }
    else if(iKey == 26) // ctrl+Z
    {
      WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                     "%s - CTRL+Z key pressed, iACS=%d (%xH)\n", __FUNCTION__, iACS, iACS);

      if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL)       // control key will always be pressed, but no shift
      {
        if(pPrivate->xTextObject.vtable->can_undo(&(pPrivate->xTextObject)))
        {
          pPrivate->xTextObject.vtable->undo(&(pPrivate->xTextObject));
        }
        else
        {
          XBell(pDisplay, -100);
        }
      }
      else if((iACS & WB_KEYEVENT_ACSMASK) == (WB_KEYEVENT_CTRL | WB_KEYEVENT_SHIFT)) // shift, no alt
      {
        if(pPrivate->xTextObject.vtable->can_redo(&(pPrivate->xTextObject)))
        {
          pPrivate->xTextObject.vtable->redo(&(pPrivate->xTextObject));
        }
        else
        {
          XBell(pDisplay, -100);
        }
      }

      iRval = 1; // text changed
    }
    else if(iKey == '\x1b') // ESC
    {
      WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                     "%s - ESC key pressed, iACS=%d (%xH)\n", __FUNCTION__, iACS, iACS);

      return 0; // not processed
    }
    else
    {
      if(pPrivate->xTextObject.vtable->has_select(&(pPrivate->xTextObject)))
      {
        pPrivate->xTextObject.vtable->replace_select(&(pPrivate->xTextObject), pBuf, nChar); // replace
      }
      else
      {
        // insert one or more ASCII characters
        pPrivate->xTextObject.vtable->ins_chars(&(pPrivate->xTextObject), pBuf, nChar);
      }

      // re-assign caption
      if(pSelf->pCaption)
      {
        WBFree(pSelf->pCaption);
      }

      pSelf->pCaption = pPrivate->xTextObject.vtable->get_text(&(pPrivate->xTextObject));
    }

    // update 'pCaption' with the complete text (cached value)

    if(pSelf->pCaption)
    {
      WBFree(pSelf->pCaption); // cached text
    }

    pSelf->pCaption = pPrivate->xTextObject.vtable->get_text(&(pPrivate->xTextObject));

    iRval = 1; // text changed
  }
  else
  {
    iRval = -1; // text normally doesn't change with these, but change to '1' if it does

    if(iACS & WB_KEYEVENT_KEYSYM)
    {
      // TODO:  international, 'dead' and other KEYSYM key assignments
#define KEYSYM_MATCH_CURSOR_NAME(X) (iKey == XK_##X || iKey == XK_KP_##X)

      if(KEYSYM_MATCH_CURSOR_NAME(Home))
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Home key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift
        {
          pPrivate->xTextObject.vtable->begin_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->cursor_home(&(pPrivate->xTextObject));
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == (WB_KEYEVENT_CTRL | WB_KEYEVENT_SHIFT)) // shift+ctrl
        {
          pPrivate->xTextObject.vtable->begin_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->cursor_top(&(pPrivate->xTextObject));
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == 0) // normal
        {
          pPrivate->xTextObject.vtable->cursor_home(&(pPrivate->xTextObject));
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL) // ctrl+home
        {
          pPrivate->xTextObject.vtable->cursor_top(&(pPrivate->xTextObject));
        }
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(End))
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - End key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift
        {
          pPrivate->xTextObject.vtable->begin_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->cursor_end(&(pPrivate->xTextObject));
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == (WB_KEYEVENT_CTRL | WB_KEYEVENT_SHIFT)) // shift+ctrl
        {
          pPrivate->xTextObject.vtable->begin_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->cursor_bottom(&(pPrivate->xTextObject));
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == 0) // normal
        {
          pPrivate->xTextObject.vtable->end_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->cursor_end(&(pPrivate->xTextObject));
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL) // ctrl+end
        {
          pPrivate->xTextObject.vtable->end_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->cursor_bottom(&(pPrivate->xTextObject));
        }
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Left))
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Left key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift
        {
          pPrivate->xTextObject.vtable->begin_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->cursor_left(&(pPrivate->xTextObject));
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == (WB_KEYEVENT_CTRL | WB_KEYEVENT_SHIFT)) // shift+ctrl
        {
          // TODO:  alter selection via selection method
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == 0) // normal
        {
          pPrivate->xTextObject.vtable->end_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->cursor_left(&(pPrivate->xTextObject));
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL) // ctrl+left
        {
          // TODO:  previous word
        }
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Right))
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Right key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift
        {
          pPrivate->xTextObject.vtable->begin_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->cursor_right(&(pPrivate->xTextObject));
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == (WB_KEYEVENT_CTRL | WB_KEYEVENT_SHIFT)) // shift+ctrl
        {
          // TODO:  alter selection via selection method
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == 0) // normal
        {
          pPrivate->xTextObject.vtable->end_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->cursor_right(&(pPrivate->xTextObject));
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL) // ctrl+right
        {
          // TODO:  next word
        }
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Up))
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Up key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift
        {
          pPrivate->xTextObject.vtable->begin_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->cursor_up(&(pPrivate->xTextObject));
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == (WB_KEYEVENT_CTRL | WB_KEYEVENT_SHIFT)) // shift+ctrl
        {
          // TODO:  alter selection via selection method
          XBell(pDisplay, -100);
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == 0) // normal
        {
          pPrivate->xTextObject.vtable->end_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->cursor_up(&(pPrivate->xTextObject));
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL) // ctrl+up
        {
          // TODO:  what should this do?
          XBell(pDisplay, -100);
        }
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Down))
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Down key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift
        {
          pPrivate->xTextObject.vtable->begin_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->cursor_down(&(pPrivate->xTextObject));
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == (WB_KEYEVENT_CTRL | WB_KEYEVENT_SHIFT)) // shift+ctrl
        {
          // TODO:  alter selection via selection method
          XBell(pDisplay, -100);
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == 0) // normal
        {
          pPrivate->xTextObject.vtable->end_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->cursor_down(&(pPrivate->xTextObject));
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL) // ctrl+down
        {
          // TODO:  what should this do?
          XBell(pDisplay, -100);
        }
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Page_Up))
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Page Up key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift
        {
          pPrivate->xTextObject.vtable->begin_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->page_up(&(pPrivate->xTextObject));
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == (WB_KEYEVENT_CTRL | WB_KEYEVENT_SHIFT)) // shift+ctrl
        {
          pPrivate->xTextObject.vtable->begin_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->page_left(&(pPrivate->xTextObject));
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == 0) // normal
        {
          pPrivate->xTextObject.vtable->end_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->page_up(&(pPrivate->xTextObject));
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL) // ctrl+PgUp
        {
          pPrivate->xTextObject.vtable->end_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->page_left(&(pPrivate->xTextObject));
        }
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Page_Down))
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Page Down key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift
        {
          pPrivate->xTextObject.vtable->begin_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->page_down(&(pPrivate->xTextObject));
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == (WB_KEYEVENT_CTRL | WB_KEYEVENT_SHIFT)) // shift+ctrl
        {
          pPrivate->xTextObject.vtable->begin_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->page_right(&(pPrivate->xTextObject));
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == 0) // normal
        {
          pPrivate->xTextObject.vtable->end_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->page_down(&(pPrivate->xTextObject));
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL) // ctrl+PgDown
        {
          pPrivate->xTextObject.vtable->end_highlight(&(pPrivate->xTextObject));
          pPrivate->xTextObject.vtable->page_right(&(pPrivate->xTextObject));
        }
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Begin)) // beginning of current line
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Beginning Of Line key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift
        {
          pPrivate->xTextObject.vtable->begin_highlight(&(pPrivate->xTextObject));
          if(pPrivate->xTextObject.vtable->get_col(&(pPrivate->xTextObject)))
          {
            pPrivate->xTextObject.vtable->cursor_home(&(pPrivate->xTextObject));
          }
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == 0) // normal
        {
          pPrivate->xTextObject.vtable->end_highlight(&(pPrivate->xTextObject));
          if(pPrivate->xTextObject.vtable->get_col(&(pPrivate->xTextObject)))
          {
            pPrivate->xTextObject.vtable->cursor_home(&(pPrivate->xTextObject));
          }
        }
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Insert)) // toggle 'insert' mode
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Insert key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if((iACS & WB_KEYEVENT_ACSMASK) == 0) // normal
        {
          if(pPrivate->xTextObject.vtable->get_insmode(&(pPrivate->xTextObject))
             == InsertMode_OVERWRITE)
          {
            pPrivate->xTextObject.vtable->set_insmode(&(pPrivate->xTextObject), InsertMode_INSERT);
          }
          else
          {
            pPrivate->xTextObject.vtable->set_insmode(&(pPrivate->xTextObject), InsertMode_OVERWRITE);
          }
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // SHIFT+insert (paste)
        {
          Atom aType = aUTF8_STRING;
          int iFormat = 8;
          unsigned long nData = 0;

          if(aType == None)
          {
            aType = aSTRING;
          }

          WB_ERROR_PRINT("TEMPORARY %s - SHIFT+insert key pressed\n", __FUNCTION__);

//          pData = (char *)CHGetSelectionData(pDisplay, aCLIPBOARD, aC_STRING, aC_STRING,
//                                             &aType, &iFormat, &nData);
          pData = (char *)WBGetClipboardData(pDisplay, &aType, &iFormat, &nData);

          if(pData && nData > 0)
          {
            if(!pData[nData])
            {
              nData--;
            }
          }

          if(pData)
          {
            // TODO:  convert to correct format (ASCII)
            if(iFormat != 8)
            {
              if(iFormat == 8 * sizeof(wchar_t))
              {
                char *pNew = WBAlloc(sizeof(wchar_t) * (nData + 2));
                if(pNew)
                {
                  memset(pNew, 0, sizeof(wchar_t) * (nData + 2));
                  wcstombs(pNew, (const wchar_t *)pData, sizeof(wchar_t) * (nData + 2));
                }

                WBFree(pData);
                pData = pNew;
              }
              else
              {
                XBell(pDisplay, -100);
                WB_ERROR_PRINT("TEMPORARY - %s - clipboard format %d, can't 'PASTE'\n", __FUNCTION__, iFormat);

                WBFree(pData);
                pData = NULL;
              }
            }

            if(pData)
            {
              if(pPrivate->xTextObject.vtable->has_select(&(pPrivate->xTextObject)))
              {
                pPrivate->xTextObject.vtable->replace_select(&(pPrivate->xTextObject), pData, nData);
              }
              else
              {
                pPrivate->xTextObject.vtable->ins_chars(&(pPrivate->xTextObject), pData, nData);
              }

              WBFree(pData);
              pData = NULL; // by convention
            }
            else
            {
              XBell(pDisplay, -100);
              WB_ERROR_PRINT("TEMPORARY - %s - NULL pData, can't 'PASTE'\n", __FUNCTION__);
            }
          }
          else
          {
            XBell(pDisplay, -100);
            WB_ERROR_PRINT("TEMPORARY:  NULL returned from WBGetClipboardData()\n");
          }
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL) // CTRL+insert (copy)
        {
          char *pData = pPrivate->xTextObject.vtable->get_sel_text(&(pPrivate->xTextObject), NULL);

          if(pData)
          {
            if(aUTF8_STRING != None)
            {
              WBSetClipboardData(pDisplay, aUTF8_STRING, 8, pData, strlen(pData) + 1);
            }
            else
            {
              WBSetClipboardData(pDisplay, aSTRING, 8, pData, strlen(pData) + 1);
            }

            WBFree(pData);
          }
          else
          {
            WB_ERROR_PRINT("TEMPORARY:  NULL returned from get_sel_text()\n");
          }
        }
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Delete)) // delete key (keypad may use this)
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Delete key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift+del (cut)
        {
          // perform 'CUT'
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == 0) // normal
        {
          if(pPrivate->xTextObject.vtable->has_select(&(pPrivate->xTextObject)))
          {
            pPrivate->xTextObject.vtable->del_select(&(pPrivate->xTextObject)); // delete selection
          }
          else
          {
            pPrivate->xTextObject.vtable->del_chars(&(pPrivate->xTextObject), 1); // delete the character to the right
          }
        }

        iRval = 1; // text changed

        // re-assign caption
        if(pSelf->pCaption)
        {
          WBFree(pSelf->pCaption);
        }

        pSelf->pCaption = pPrivate->xTextObject.vtable->get_text(&(pPrivate->xTextObject));

        iRval = 1; // text changed
      }
#undef KEYSYM_MATCH_CURSOR_NAME
      else
      {
        // is it a cursor key?  let's find out
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - CURSOR KEY? %d (%08xH)  %d (%08xH)\n",
                       __FUNCTION__, iKey, iKey, iACS, iACS);

        iRval = 0; // force this for unknown key combinations
      }
    }
  }

  return iRval;
}

static int EditDoPointerEvent(XClientMessageEvent *pEvent, Display *pDisplay,
                              Window wID, WBDialogControl *pSelf)
{
WBEditControl *pPrivate = (WBEditControl *)pSelf;
int iACS;
int iX, iY;


  if(pEvent->type != ClientMessage ||
     pEvent->message_type != aWM_POINTER)
  {
    return 0; // sanity check (temporary, remove later?)
  }


  // left-click - position cursor, cancel selection
  // shift-left-click - select from cursor to THIS point
  // (other modifiers, ignore the modifier key)
  // right-click - drop-down edit menu
  // middle click - select word? paste?
  // scroll wheel up/down - should be handled by scrollbar thingy
  // left-drag - select from starting position
  // right-drag - drag/drop?
  // middle-drag - ?

  // TODO:  check which button I clicked - it's data.l[1] - WB_POINTER_BUTTON1 through WB_POINTER_BUTTON5 (bitmask)

  iACS = pEvent->data.l[2];

  iX = pEvent->data.l[3];
  iY = pEvent->data.l[4];

  switch(pEvent->data.l[0])
  {
    case WB_POINTER_CLICK:
//      WB_ERROR_PRINT("TEMPORARY - %s - WB_POINTER_CLICK\n", __FUNCTION__);
      pPrivate->xTextObject.vtable->mouse_click(&(pPrivate->xTextObject), iX, iY, pEvent->data.l[1], iACS);
      break;

    case WB_POINTER_DBLCLICK:
      WB_ERROR_PRINT("TEMPORARY - %s - WB_POINTER_DBLCLICK\n", __FUNCTION__);
      break;

    case WB_POINTER_DRAG:
//      WB_ERROR_PRINT("TEMPORARY - %s - WB_POINTER_DRAG\n", __FUNCTION__);
      pPrivate->xTextObject.vtable->begin_mouse_drag(&(pPrivate->xTextObject));
      return wID; // do this to support pointer drag

    case WB_POINTER_DROP:
//      WB_ERROR_PRINT("TEMPORARY - %s - WB_POINTER_DROP\n", __FUNCTION__);
      pPrivate->xTextObject.vtable->end_mouse_drag(&(pPrivate->xTextObject));
      break;

    case WB_POINTER_MOVE:
//      WB_ERROR_PRINT("TEMPORARY - %s - WB_POINTER_MOVE\n", __FUNCTION__);
      pPrivate->xTextObject.vtable->mouse_click(&(pPrivate->xTextObject), iX, iY, 0, 0); // mouse motion only
      break;

    case WB_POINTER_CANCEL:
      WB_ERROR_PRINT("TEMPORARY - %s - WB_POINTER_CANCEL\n", __FUNCTION__);
      break;
    case WB_POINTER_SCROLLUP:
      WB_ERROR_PRINT("TEMPORARY - %s - WB_POINTER_SCROLLUP\n", __FUNCTION__);
      break;
    case WB_POINTER_SCROLLDOWN:
      WB_ERROR_PRINT("TEMPORARY - %s - WB_POINTER_SCROLLDOWN\n", __FUNCTION__);
      break;


    default:

      WB_ERROR_PRINT("TEMPORARY - %s - unhandled mousie message\n", __FUNCTION__);
      break;
  }

  return 0; // for now (necessary to avoid warnings, and NOT do bad stuff)
}


static int ListDoCharEvent(XClientMessageEvent *pEvent, Display *pDisplay,
                           Window wID, WBDialogControl *pSelf)
{
int iRval = 0, iACS, iKey, nChar;//, iLen;
//char *pBuf;


  iKey = pEvent->data.l[0];  // result from WBKeyEventProcessKey()
  iACS = pEvent->data.l[1];
  nChar = pEvent->data.l[2];
//  pBuf = (char *)&(pEvent->data.l[3]);

  if(nChar > 0) // normal ASCII characters
  {
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                   "%s KEY RELEASE for KEY %d KEYCODE %d  MASK=%d (%xH)\n",
                   __FUNCTION__, iKey, ((XKeyEvent *)pEvent)->keycode,
                   ((XKeyEvent *)pEvent)->state, ((XKeyEvent *)pEvent)->state);

    return 0; // for now
#if 0
    if(iKey == 8) // backspace
    {
      // TODO:  delete char before cursor or highlighted text
      // for now just delete the LAST character

      iLen = strlen(pSelf->pCaption);

      if(iLen > 0)
      {
        pSelf->pCaption[iLen - 1] = 0;
      }

      WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                     "%s - BACKSPACE key pressed\n", __FUNCTION__);
    }
    else if(iKey == 13 || iKey == 10 // CR or LF (TODO:  check flags to see if I should accept this)
            || iKey == 9) // tab (TODO:  check flags to see if I should accept this)
    {
      // TODO:  check for multi-line control, add line feeds as needed

      return 0; // LF may trigger default button, allow default handling
      // since the text was not changed return 0 _NOW_ so that WM_CHAR handling happens in default processing
    }
    else
    {
      // TODO:  insert or concatenate?  for now concatenate
      WBCatString(&(pSelf->pCaption), pBuf);
    }

    iRval = 1; // text changed
#endif // 0
  }
  else
  {
    if(iACS & WB_KEYEVENT_KEYSYM)
    {
      // TODO:  international, 'dead' and other KEYSYM key assignments
#define KEYSYM_MATCH_CURSOR_NAME(X) (iKey == XK_##X || iKey == XK_KP_##X)

      if(KEYSYM_MATCH_CURSOR_NAME(Home))
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Home key pressed\n", __FUNCTION__);
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(End))
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - End key pressed\n", __FUNCTION__);
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Left))
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Left key pressed\n", __FUNCTION__);
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Right))
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Right key pressed\n", __FUNCTION__);
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Up))
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Up key pressed\n", __FUNCTION__);
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Down))
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Down key pressed\n", __FUNCTION__);
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Page_Up))
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Page Up key pressed\n", __FUNCTION__);
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Page_Down))
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Page Down key pressed\n", __FUNCTION__);
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Begin)) // beginning of current line
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Beginning Of Line key pressed\n", __FUNCTION__);
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Insert)) // toggle 'insert' mode
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Insert key pressed\n", __FUNCTION__);
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Delete)) // delete key (keypad may use this)
      {
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Delete key pressed\n", __FUNCTION__);

        // TODO:  delete character under cursor

//        iRval = 1; // text changed
        iRval = 0; // for now...
      }
#undef KEYSYM_MATCH_CURSOR_NAME
      else
      {
        // is it a cursor key?  let's find out
        WB_DEBUG_PRINT(KEYSYM_DEBUG_FLAG | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - CURSOR KEY? %d (%08xH)  %d (%08xH)\n",
                       __FUNCTION__, iKey, iKey, iACS, iACS);

        iRval = 0; // force this for unknown key combinations
      }
    }
  }

  return iRval;
}





//*************
// E X P O S E
//*************


static int StaticDoExposeEvent(XExposeEvent *pEvent, Display *pDisplay,
                               Window wID, WBDialogControl *pSelf)
{
int iHPos, iVPos, iType;
XWindowAttributes xwa;      /* Temp Get Window Attribute struct */
XFontSet fontSet;
XCharStruct xBounds;
GC gc; // = WBGetWindowDefaultGC(wID);
WB_GEOM geomPaint, geomBorder;


  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                 "%s - Expose %d (%08xH)\n", __FUNCTION__, (int)wID, (int)wID);

  if (XGetWindowAttributes(pDisplay, wID, &xwa) == 0)
  {
    WB_WARN_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);
    return 0;
  }

  fontSet = WBGetWindowFontSet(wID);

  if(fontSet == None)
  {
    // TODO:  get font from dialog info
    WB_WARN_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);
    return 0;
  }

  iHPos = WBFontSetAvgCharWidth(pDisplay, fontSet);  // average char width for text border (TODO:  RTL text ??)
  xBounds = WBFontSetMaxBounds(pDisplay, fontSet);


  // get graphics context copy and begin painting
  gc = WBBeginPaint(wID, pEvent, &geomPaint);
  if(!gc)
  {
    WB_WARN_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);
    return 0;
  }

  iType = pSelf->ulFlags & STATIC_TYPEMASK;  // different types paint differently

  //------------------
  // ERASE BACKGROUND
  //------------------

  WBClearWindow(wID, gc);

  // 3D border
  if(iType == STATIC_Frame)
  {
    geomBorder.x = 0;
    geomBorder.y = xBounds.ascent + xBounds.descent + 2;
    geomBorder.width = xwa.width - geomBorder.x;
    geomBorder.height = xwa.height - geomBorder.y;

    // this text will apear in the upper left corner (sort of) of the border rectangle

    iVPos = xwa.border_width;  // top of text at top of window
    iVPos += xBounds.ascent;   // base of text
  }
  else
  {
    geomBorder.x = 0;
    geomBorder.y = 0;
    geomBorder.width = xwa.width - geomBorder.x;
    geomBorder.height = xwa.height - geomBorder.y;

    // vertically centered text (includes if it has a 3D border, below)
    iVPos = xBounds.ascent + xBounds.descent;  // font height
    iVPos = (xwa.height - iVPos) >> 1;  // half of the difference, now the top of text
    iVPos += xBounds.ascent;            // add ascent back (base of text)
  }

  if(pSelf->ulFlags & STATIC_3DBorder)
  {
    if(pSelf->pDlgControlEntry->iFlags & WBDialogEntry_HAS_FOCUS)
    {
      WBDrawBorderRect(pDisplay, wID, gc, &geomBorder,
                       BlackPixel(pDisplay, DefaultScreen(pDisplay)));

      geomBorder.x++;
      geomBorder.y++;
      geomBorder.height -= 2;
      geomBorder.width -= 2;
    }

    WBDraw3DBorderRect(pDisplay, wID, gc, &geomBorder,
                       pSelf->clrBD2.pixel, pSelf->clrBD3.pixel);

  }

  // painting the window text

  XSetForeground(pDisplay, gc, pSelf->clrFG.pixel);

  // where I put the text matters based on the control type (see iHPos, iVPos)
  if(iType == STATIC_Icon || iType == STATIC_Image)
  {
    Pixmap pixmap = ((struct _WB_PUSHBUTTON_CONTROL_ *)pSelf)->pixmap;
    Pixmap pixmap2 = ((struct _WB_PUSHBUTTON_CONTROL_ *)pSelf)->pixmap2;

    // TODO:  get the image's geometry so I can properly center it (etc.)

    if(pixmap != None)  // for now assume 36x36 icon only
    {
      if(pixmap2 != None) // an icon mask exists
      {
        GC gc2 = WBGetWindowCopyGC2(wID, gc);

        if(gc2 == None)
        {
          gc2 = WBGetWindowCopyGC(wID);
        }

        if(gc2 != None)  // painting the icon the way I think it should be...
        {
          XSetClipOrigin(pDisplay, gc2, geomBorder.x + 2, geomBorder.y + 2);
          XSetClipMask(pDisplay, gc2, pixmap2);
          XCopyArea(pDisplay, pixmap, wID, gc2, 0, 0, 36, 36, geomBorder.x + 2, geomBorder.y + 2);
          XFreeGC(pDisplay, gc2);
        }
        else
        {
          WB_WARN_PRINT("%s - WARNING:  unable to create GC copy to use bitmask to paint icon\n", __FUNCTION__);
          XCopyArea(pDisplay, pixmap, wID, gc, 0, 0, 36, 36, geomBorder.x + 2, geomBorder.y + 2);
        }
      }
      else
      {
        XCopyArea(pDisplay, pixmap, wID, gc, 0, 0, 36, 36, geomBorder.x + 2, geomBorder.y + 2);
      }
    }
  }
  else if(pSelf->pCaption)
  {
    WB_RECT rctText;

    rctText.left = geomBorder.x + iHPos;
    rctText.right = rctText.left + geomBorder.width - 2 * iHPos;
    rctText.top = geomBorder.y + xBounds.ascent / 2;
    rctText.bottom = rctText.top + geomBorder.height - xBounds.ascent;

    DTDrawMultiLineText(fontSet, pSelf->pCaption, pDisplay, gc, wID, DEFAULT_STATIC_TAB_WIDTH, 0,
                        &rctText, DTAlignment_UNDERSCORE | DTAlignment_VCENTER);
  }

  // by convention, restore original objects/state

  BEGIN_XCALL_DEBUG_WRAPPER
  XSetForeground(pDisplay, gc, WBGetWindowFGColor(wID));  // restore it at the end
  END_XCALL_DEBUG_WRAPPER

  WBEndPaint(wID, gc);

  return 1;  // processed
}


static int EditDoExposeEvent(XExposeEvent *pEvent, Display *pDisplay,
                             Window wID, WBDialogControl *pSelf)
{
WBEditControl *pPrivate = (WBEditControl *)pSelf;
XWindowAttributes xwa;      /* Temp Get Window Attribute struct */
XFontSet fontSet;
GC gc; // = WBGetWindowDefaultGC(wID);
WB_GEOM geomPaint, geomBorder;


  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                 "%s - Expose %d (%08xH)\n", __FUNCTION__, (int)wID, (int)wID);

  if (XGetWindowAttributes(pDisplay, wID, &xwa) == 0)
  {
    WB_WARN_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);
    return 0;
  }

  fontSet = WBGetWindowFontSet(wID);

  if(fontSet == None)
  {
    // TODO:  get font from dialog info
    WB_WARN_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);
    return 0;
  }


  // get graphics context copy and begin painting
  gc = WBBeginPaint(wID, pEvent, &geomPaint);
  if(!gc)
  {
    WB_WARN_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);
    return 0;
  }

  // font setup
  WBClearWindow(wID, gc);

  geomBorder.x = 0;
  geomBorder.y = 0;
  geomBorder.width = xwa.width - geomBorder.x;
  geomBorder.height = xwa.height - geomBorder.y;

  // TODO:  scrollbars, 'display window' scroll position within physical display

// TODO:  uncomment these when iVPos needs to be used - linux gcc warning avoidance
//  // vertically centered text (for single-line version)
//  iVPos = pFont->max_bounds.ascent + pFont->max_bounds.descent;  // font height
//  iVPos = (xwa.height - iVPos) >> 1;  // half of the difference - top of text
//  iVPos += pFont->max_bounds.ascent;

  if(pSelf->pOwner && pSelf->pDlgControlEntry)       //pSelf->ulFlags & STATIC_3DBorder)
  {
    if(pSelf->pDlgControlEntry->iFlags & WBDialogEntry_HAS_FOCUS)
    {
      WBDraw3DBorderRect(pDisplay, wID, gc, &geomBorder,
                         pSelf->clrBD2.pixel, pSelf->clrBD3.pixel);
    }
    else // draw a thin, 2D border
    {
      WBDrawBorderRect(pDisplay, wID, gc, &geomBorder,
                       pSelf->clrBG.pixel);
    }
  }

//  WB_ERROR_PRINT("TEMPORARY:  %s - caption is \"%s\"\n", __FUNCTION__, pSelf->pCaption);

  geomBorder.x += 4;
  geomBorder.y += 4;
  geomBorder.width -= 8;
  geomBorder.height -= 8;

  XSetForeground(pDisplay, gc, pSelf->clrFG.pixel);

  pPrivate->xTextObject.vtable->do_expose(&(pPrivate->xTextObject), pDisplay, wID,
                                          gc, &geomPaint, &geomBorder, fontSet);


#if 0

  // painting the window text

  XSetForeground(pDisplay, gc, pSelf->clrFG.pixel);

  if(pSelf->pCaption) // use TEXT not caption
  {
    const char *szText = pSelf->pCaption;
    int iU1=0, iU2=0;

//    if(i1 == pSelf->iSelected)  // text selection
//    {
//      XSetForeground(pDisplay, gc, pSelf->clrABG.pixel);
//      XSetBackground(pDisplay, gc, pSelf->clrABG.pixel);
//
//      XFillRectangle(pDisplay, wID, gc, pItem->iPosition, pSelf->iY, pItem->iTextWidth, pSelf->iHeight + 2);
//
//      XSetForeground(pDisplay, gc, pSelf->clrAFG.pixel);
//    }

#if 0
    if(strchr(szText, '_'))  // underline in text?  TODO:  use this info to set hotkey
    {
      char *p1;
      strcpy(tbuf, szText);
      p1 = tbuf;
      while(*p1)
      {
        if(*p1 == '_')
        {
          *p1 = 0;

          if(p1 == tbuf)
            iU1 = 0;
          else
            iU1 = XTextWidth(pFont, tbuf, p1 - tbuf);

          if(p1[1])
          {
            iU2 = XTextWidth(pFont, p1, 1);
            strcpy(p1, p1 + 1);
          }
          else
            iU2 = iU1;  // shouldn't happen
        }
        p1++;
      }

      szText = tbuf;
    }
#endif // 0

    // TODO:  use DTDrawSingleLineText or DTDrawMultiLineText instead

    if(*szText)
    {
      XDrawString(pDisplay, wID, gc, iHPos, iVPos, szText, strlen(szText));
    }

//    if(i1 == pSelf->iSelected)  // selected item
//    {
//      XSetForeground(pDisplay, gc, clrMenuFG.pixel);
//      XSetBackground(pDisplay, gc, clrMenuBG.pixel);
//    }
  }

#endif // 0

  // by convention, restore original objects/state

  BEGIN_XCALL_DEBUG_WRAPPER
  XSetForeground(pDisplay, gc, WBGetWindowFGColor(wID));  // restore it at the end
  END_XCALL_DEBUG_WRAPPER

  WBEndPaint(wID, gc);

  return 1;  // processed
}


static int ButtonDoExposeEvent(XExposeEvent *pEvent, Display *pDisplay,
                               Window wID, WBDialogControl *pSelf)
{
int i2, iHPos;
XWindowAttributes xwa;      /* Temp Get Window Attribute struct */
XFontSet fontSet;
XCharStruct xBounds;
GC gc; // = WBGetWindowDefaultGC(wID);
WB_GEOM geomPaint, geomBorder;


  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                 "%s - Expose %d (%08xH)\n", __FUNCTION__, (int)wID, (int)wID);

  if (XGetWindowAttributes(pDisplay, wID, &xwa) == 0)
  {
    WB_WARN_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);
    return 0;
  }

  fontSet = WBGetWindowFontSet(wID);

  if(fontSet == None)
  {
    // TODO:  get font from dialog info
    WB_WARN_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);
    return 0;
  }

  xBounds = WBFontSetMaxBounds(pDisplay, fontSet);

  // get graphics context copy and begin painting
  gc = WBBeginPaint(wID, pEvent, &geomPaint);
  if(!gc)
  {
    WB_WARN_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);
    return 0;
  }

  WBClearWindow(wID, gc);

  // paint the 3D-looking border

  geomBorder.x = xwa.border_width;
  geomBorder.y = xwa.border_width;
  geomBorder.width = xwa.width - xwa.border_width;
  geomBorder.height = xwa.height - xwa.border_width;

  if(pSelf->pDlgControlEntry->iFlags & WBDialogEntry_HAS_FOCUS)
  {
    WBDrawBorderRect(pDisplay, wID, gc, &geomBorder,
                     BlackPixel(pDisplay, DefaultScreen(pDisplay)));
    geomBorder.x++;
    geomBorder.y++;
    geomBorder.height -= 2;
    geomBorder.width -= 2;
  }

  // note - if a button is 'pressed' I draw the colors inverted

  if(pSelf->pDlgControlEntry->iFlags & WBDialogEntry_PRESSED)
  {
    WBDraw3DBorderRect(pDisplay, wID, gc, &geomBorder,
                       pSelf->clrBD3.pixel, pSelf->clrBD2.pixel);
  }
  else
  {
    WBDraw3DBorderRect(pDisplay, wID, gc, &geomBorder,
                       pSelf->clrBD2.pixel, pSelf->clrBD3.pixel);
  }

  // painting the window text
  i2 = WBFontSetAvgCharWidth(pDisplay, fontSet);  // average char width for text border (TODO:  RTL text ??)
  iHPos = xwa.border_width + i2;  // position of beginning of text (left side + space)

#if 0
  iVPos = pFont->max_bounds.ascent + pFont->max_bounds.descent;  // font height
  iVPos = (xwa.height - iVPos) >> 1;  // half of the difference - top of text
  iVPos += pFont->max_bounds.ascent;
#endif // 0

  XSetForeground(pDisplay, gc, pSelf->clrFG.pixel);

  if(pSelf->pCaption)
  {
    WB_RECT rctText;
    const char *szText = pSelf->pCaption;

    XSetBackground(pDisplay, gc, pSelf->clrABG.pixel);
    XSetForeground(pDisplay, gc, pSelf->clrAFG.pixel);

    rctText.left = geomBorder.x + iHPos;
    rctText.right = rctText.left + geomBorder.width - 2 * iHPos;
    rctText.top = geomBorder.y + xBounds.ascent / 2
                - xBounds.descent / 2; // better centering
    rctText.bottom = rctText.top + geomBorder.height - xBounds.ascent;

    DTDrawMultiLineText(fontSet, szText, pDisplay, gc, wID, DEFAULT_BUTTON_TAB_WIDTH, 0,
                        &rctText, DTAlignment_UNDERSCORE | DTAlignment_VCENTER | DTAlignment_HCENTER);
  }

  // by convention, restore original objects/state

  BEGIN_XCALL_DEBUG_WRAPPER
  XSetForeground(pDisplay, gc, WBGetWindowFGColor(wID));  // restore it at the end
  END_XCALL_DEBUG_WRAPPER

  WBEndPaint(wID, gc);

  return 1;  // processed
}


static int PushButtonDoExposeEvent(XExposeEvent *pEvent, Display *pDisplay,
                                   Window wID, WBDialogControl *pSelf)
{
int i2, iHPos;
XWindowAttributes xwa;      /* Temp Get Window Attribute struct */
XFontSet fontSet;
XCharStruct xBounds;
GC gc; // = WBGetWindowDefaultGC(wID);
WB_GEOM geomPaint, geomBorder;


  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                 "%s - Expose %d (%08xH)\n", __FUNCTION__, (int)wID, (int)wID);

  if(XGetWindowAttributes(pDisplay, wID, &xwa) == 0)
  {
    WB_WARN_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);
    return 0;
  }

  fontSet = WBGetWindowFontSet(wID); // I assigned the "bold font" to this on create

  if(fontSet == None)
  {
    // TODO:  get font from dialog info
    WB_ERROR_PRINT("%s - NO FONT, line %d\n", __FUNCTION__, __LINE__);
    return 0;
  }

  xBounds = WBFontSetMaxBounds(pDisplay, fontSet);

  // get graphics context copy and begin painting
  gc = WBBeginPaint(wID, pEvent, &geomPaint);

  if(!gc)
  {
    WB_WARN_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);

    return 0;
  }

  WBClearWindow(wID, gc);

  // paint the 3D-looking border

  geomBorder.x = xwa.border_width;
  geomBorder.y = xwa.border_width;
  geomBorder.width = xwa.width - xwa.border_width;
  geomBorder.height = xwa.height - xwa.border_width;

  if(pSelf->pDlgControlEntry->iFlags & WBDialogEntry_DEFAULT) // I am the default pushbutton
  {
    WBDrawBorderRect(pDisplay, wID, gc, &geomBorder,
                     pSelf->clrBD3.pixel);

    geomBorder.x++;
    geomBorder.y++;
    geomBorder.height -= 2;
    geomBorder.width -= 2;
  }

  if(pSelf->pDlgControlEntry->iFlags & WBDialogEntry_HAS_FOCUS)
  {
    WBDrawBorderRect(pDisplay, wID, gc, &geomBorder,
                     BlackPixel(pDisplay, DefaultScreen(pDisplay)));

    geomBorder.x++;
    geomBorder.y++;
    geomBorder.height -= 2;
    geomBorder.width -= 2;
  }

  // note - if a button is 'pressed' I draw the colors inverted

  if(pSelf->pDlgControlEntry->iFlags & WBDialogEntry_PRESSED)
  {
    WBDraw3DBorderRect(pDisplay, wID, gc, &geomBorder,
                       pSelf->clrBD3.pixel, pSelf->clrBD2.pixel);
  }
  else
  {
    WBDraw3DBorderRect(pDisplay, wID, gc, &geomBorder,
                       pSelf->clrBD2.pixel, pSelf->clrBD3.pixel);
  }

  // painting the window text

  i2 = WBFontSetAvgCharWidth(pDisplay, fontSet);  // average char width for text border (TODO:  RTL text ??)
  iHPos = xwa.border_width + i2;  // position of beginning of text (left side + space)
#if 0
  iVPos = pFont->max_bounds.ascent + pFont->max_bounds.descent;  // font height
  iVPos = (xwa.height - iVPos) >> 1;  // half of the difference - top of text
  iVPos += pFont->max_bounds.ascent;
#endif // 0

  XSetForeground(pDisplay, gc, pSelf->clrFG.pixel);

  // TODO:  icon button (rather than text) or combination icon/text

  if(pSelf->pCaption)
  {
    WB_RECT rctText;
    const char *szText = pSelf->pCaption;

    XSetBackground(pDisplay, gc, pSelf->clrABG.pixel);
    XSetForeground(pDisplay, gc, pSelf->clrAFG.pixel);

    rctText.left = geomBorder.x + iHPos;
    rctText.right = rctText.left + geomBorder.width - 2 * iHPos;
    rctText.top = geomBorder.y + xBounds.ascent / 2
                - xBounds.descent / 2; // better centering
    rctText.bottom = rctText.top + geomBorder.height - xBounds.ascent;

    DTDrawMultiLineText(fontSet, szText, pDisplay, gc, wID, DEFAULT_BUTTON_TAB_WIDTH, 0, &rctText,
                        DTAlignment_UNDERSCORE | DTAlignment_VCENTER | DTAlignment_HCENTER);
  }

  // by convention, restore original objects/state

  BEGIN_XCALL_DEBUG_WRAPPER
  XSetForeground(pDisplay, gc, WBGetWindowFGColor(wID));  // restore it at the end
  END_XCALL_DEBUG_WRAPPER

  WBEndPaint(wID, gc);

  return 1;  // processed
}


static int ListDoExposeEvent(XExposeEvent *pEvent, Display *pDisplay,
                             Window wID, WBDialogControl *pSelf)
{
int i1, iVScrollWidth, iHScrollHeight;
int nHeight, nItemHeight;
XWindowAttributes xwa;      /* Temp Get Window Attribute struct */
XFontSet fontSet;
XCharStruct xBounds;
GC gc;
Region rgnTemp;
WB_GEOM geomPaint, geomBorder;
WB_SCROLLINFO *pScrollInfo;
LISTINFO *pListInfo;
WB_DIALOG_PROP *pProp;


  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                 "%s - Expose %d (%08xH)\n", __FUNCTION__, (int)wID, (int)wID);

  if(XGetWindowAttributes(pDisplay, wID, &xwa) == 0)
  {
    WB_WARN_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);
    return 0;
  }

  fontSet = WBGetWindowFontSet(wID);

  if(fontSet == None)
  {
    // TODO:  get font from dialog info
    WB_WARN_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);
    return 0;
  }

  xBounds = WBFontSetMaxBounds(pDisplay, fontSet);

  // get graphics context copy and begin painting
  gc = WBBeginPaint(wID, pEvent, &geomPaint);
  if(!gc)
  {
    WB_WARN_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);
    return 0;
  }


  geomBorder.x = 0;
  geomBorder.y = 0;
  geomBorder.width = xwa.width - geomBorder.x;
  geomBorder.height = xwa.height - geomBorder.y;

  if(pSelf->pDlgControlEntry->iFlags & WBDialogEntry_HAS_FOCUS)
  {
    WBDrawBorderRect(pDisplay, wID, gc, &geomBorder,
                     BlackPixel(pDisplay, DefaultScreen(pDisplay)));
  }
  else
  {
    // use the background color for the dialog window itself
    WBDrawBorderRect(pDisplay, wID, gc, &geomBorder,
                     pSelf->pOwner ? pSelf->pOwner->clrBG.pixel : pSelf->clrABG.pixel);
  }

  geomBorder.x++;
  geomBorder.y++;
  geomBorder.height -= 2;
  geomBorder.width -= 2;

  // calculate a few things

  iVScrollWidth = WBTextWidth(fontSet, "X", 1) * 2 + 4; // width of vertical scrollbar
  iHScrollHeight = xBounds.ascent + xBounds.descent + 4;

  pProp = (WB_DIALOG_PROP *)WBDialogControlGetDialogProp(pSelf, aDLGC_LISTINFO);

  if(pProp)
  {
    pListInfo = (LISTINFO *)pProp->pVal;
  }
  else
  {
    pListInfo = NULL;

    WBClearWindow(wID, gc);
//    XClearWindow(pDisplay, wID);  // only necessary when there's no list info
  }

  // border
  WBDraw3DBorderRect(pDisplay, wID, gc, &geomBorder,
                     pSelf->clrBD2.pixel, pSelf->clrBD3.pixel);

  // again reduce the size of the border rectangle by 1 pixel on all sides
  geomBorder.x++;
  geomBorder.y++;
  geomBorder.height -= 2;
  geomBorder.width -= 2;

  // painting the scrollbar (assume vertical only)

  pScrollInfo = (WB_SCROLLINFO *)WBDialogControlGetProperty2(pSelf, aDLGC_SCROLLINFO);
  if(!pScrollInfo)
  {
    pScrollInfo = (WB_SCROLLINFO *)WBAlloc(sizeof(*pScrollInfo));
    if(!pScrollInfo)
    {
      WB_ERROR_PRINT("%s:%d Out Of Memory\n", __FUNCTION__, __LINE__);
      return -1;
    }

    bzero(pScrollInfo, sizeof(*pScrollInfo));
  }

  // what is the height of the dialog box in 'items'?  For now an item's height is
  // equal to pFont->max_bounds.ascent + pFont->max_bounds.descent + 6;

  nItemHeight = xBounds.ascent + xBounds.descent + 6;
  nHeight = (geomBorder.height - 4) / nItemHeight; // assume no horizontal scrollbar

  if(!pListInfo || pListInfo->nItems <= nHeight)
  {
    WBCalcVScrollBar(pScrollInfo, &geomBorder, iVScrollWidth, iHScrollHeight, 0, -1);

    if(pListInfo) // TODO:  allocate empty list info
    {
      pListInfo->nTop = 0;
      pListInfo->nPos = -1;  // "N/A"
    }
  }
  else
  {
    WBCalcVScrollBar(pScrollInfo, &geomBorder, iVScrollWidth, iHScrollHeight,
                     pListInfo->nItems - nHeight + 1, pListInfo->nTop);
    if(pListInfo->nPos < 0)
    {
      pListInfo->nPos = pListInfo->nTop;
    }
  }

  if(pListInfo)
  {
    pListInfo->nHeight = nHeight;        // cache this
    pListInfo->nItemHeight = nItemHeight;
  }

  WBDialogControlSetProperty2(pSelf, aDLGC_SCROLLINFO, pScrollInfo); // store updated scroll info (in case it changed)

  WBPaintVScrollBar(pScrollInfo, pDisplay, wID, gc, &geomBorder); // for now use 'border' geometry, later fix?

  // set the border rectangle so that it excludes scrollbar
  geomBorder.width = pScrollInfo->geomVBar.x
                   - pScrollInfo->geomVBar.border
                   - geomBorder.x;

  // painting the window text
  // FIRST, make sure that the bounding rectangle for painting
  // does NOT exceed geomBorder by setting the new clip region

  rgnTemp = WBGetPaintRegion(wID); // current paint region

  if(rgnTemp != None)
  {
    Region rgnTemp2 = WBGeomToRegion(&geomBorder);
    if(rgnTemp2 != None)
    {
      XIntersectRegion(rgnTemp2, rgnTemp, rgnTemp);
      XDestroyRegion(rgnTemp2);

      XSetRegion(pDisplay, gc, rgnTemp); // my new clipping region
    }

    XDestroyRegion(rgnTemp); // must destroy now
  }

  XSetForeground(pDisplay, gc, pSelf->clrFG.pixel);

  if(pListInfo) // use TEXT not caption
  {
    for(i1=pListInfo->nTop; i1 <= pListInfo->nTop + nHeight; i1++)
    {
      WB_GEOM geomItem;

      geomItem.x = geomBorder.x + 1;
      geomItem.width = geomBorder.width - 2;
      geomItem.y = geomBorder.y + nItemHeight * (i1 - pListInfo->nTop);
      geomItem.height = nItemHeight;

//      if(i1 == pListInfo->nPos) // the currently selected item
//      {
//        WB_ERROR_PRINT("TEMPORARY - drawing selected item %d\n", i1);
//      }
//      else
//      {
//        WB_ERROR_PRINT("TEMPORARY - NOT drawing selected item %d (%d)\n", i1, pListInfo->nPos);
//
//      }

      if(i1 < pListInfo->nItems)
      {
        if(pListInfo->pfnDisplay)//  void (*pfnDisplay)(WBDialogControl *pControl, void *pData, int iSelected, GC gcPaint, WB_GEOM *pGeom);
        {
          pListInfo->pfnDisplay(pSelf, pListInfo->aItems[i1], i1 == pListInfo->nPos, gc, &geomItem, fontSet);
        }
        else
        {
          DLGCDefaultListControlDisplayProc(pSelf, pListInfo->aItems[i1], i1 == pListInfo->nPos, gc, &geomItem, fontSet);
        }
      }
      else
      {
        if(pListInfo->pfnDisplay)//  void (*pfnDisplay)(WBDialogControl *pControl, void *pData, int iSelected, GC gcPaint, WB_GEOM *pGeom);
        {
          pListInfo->pfnDisplay(pSelf, NULL, 0, gc, &geomItem, fontSet);
        }
        else
        {
          DLGCDefaultListControlDisplayProc(pSelf, NULL, 0, gc, &geomItem, fontSet);
        }
      }
    }
  }

  // by convention, restore original objects/state

  BEGIN_XCALL_DEBUG_WRAPPER
  XSetForeground(pDisplay, gc, WBGetWindowFGColor(wID));  // restore it at the end
  END_XCALL_DEBUG_WRAPPER

  WBEndPaint(wID, gc);

  return 1;  // processed
}




// supporting functions

static void FileListControlDisplayProc(WBDialogControl *pList, void *pData, int iSelected, GC gc, WB_GEOM *pGeom, XFontSet fontSet)
{
int iHPos;
XCharStruct xBounds;
Window wID = pList->wID;
Display *pDisplay = WBGetWindowDisplay(wID);


  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                 "%s - Expose %d (%08xH) pData=%p\n", __FUNCTION__, (int)wID, (int)wID, pData);

  if(fontSet == None)
  {
    fontSet = WBGetWindowFontSet(wID);
    if(fontSet == None)
    {
      fontSet = WBGetDefaultFontSet(pDisplay);
      if(fontSet == None)
      {
        WB_ERROR_PRINT("%s - NO FONT, line %d\n", __FUNCTION__, __LINE__);
        return;
      }
    }
  }

  if(pData && *(char *)pData == '@') // it's a directory
  {
    // get the BOLD version of the same font for directories

    if(((WBListControl *)pList)->fsBold != None)
    {
      fontSet = ((WBListControl *)pList)->fsBold;
    }
    else
    {
      ((WBListControl *)pList)->fsBold = WBCopyModifyFontSet(pDisplay, fontSet, 0, WBFontFlag_WT_BOLD); // BOLD version
      if(((WBListControl *)pList)->fsBold == None)
      {
        // TODO:  make a copy without the 'bold' ???  (this should already have happened)
        WB_ERROR_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);

        return;
      }
      else
      {
        fontSet = ((WBListControl *)pList)->fsBold;
      }
    }
  }

  xBounds = WBFontSetMaxBounds(pDisplay, fontSet);
  iHPos = WBFontSetAvgCharWidth(pDisplay, fontSet);  // average character width for hpos

  // font setup
  BEGIN_XCALL_DEBUG_WRAPPER
//  XClearWindow(pDisplay, wID);  // TODO:  rather than erase background, see if I need to
  XSetForeground(pDisplay, gc, iSelected ? pList->clrHBG.pixel : pList->clrBG.pixel);
  XFillRectangle(pDisplay, wID, gc, pGeom->x, pGeom->y, pGeom->width, pGeom->height);
  END_XCALL_DEBUG_WRAPPER

  if(iSelected)
  {
    WBDrawDashedRect(pDisplay, wID, gc, pGeom,  pList->clrBD2.pixel);
  }


//    // vertically centered text
//  iVPos = xBounds.ascent + xBounds.descent;  // font height
//  iVPos = (pGeom->height - iVPos) >> 1;  // half of the difference - top of text
//  iVPos += xBounds.ascent; // base of the text

  // painting the window text

  if(pData)
  {
    if(((const char *)pData)[0] == '@' &&
       ((const char *)pData)[1] == '.' &&
       ((const char *)pData)[2] == '.' &&
       !((const char *)pData)[3])
    {
      XPoint aPoints[4];
//      int i1;
      // draw a left arrow using the highlight color

      XSetForeground(pDisplay, gc, iSelected ? pList->clrBG.pixel : pList->clrHBG.pixel);

      XFillRectangle(pDisplay, wID, gc,
                     pGeom->x + iHPos + xBounds.ascent / 2,
                     pGeom->y + pGeom->height / 2 - xBounds.ascent / 4, // half-way - ascent / 4
                     iHPos * 2 - xBounds.ascent / 2,
                     xBounds.ascent / 2); // half height of text

      // now make an 'arrow' (TODO: 3D-looking? I would need more colors...)

      aPoints[0].x = pGeom->x + iHPos;
      aPoints[0].y = pGeom->y + pGeom->height / 2;
      aPoints[1].x = aPoints[0].x + xBounds.ascent;
      aPoints[1].y = aPoints[0].y + xBounds.ascent * 2 / 3 - 1;
      aPoints[2].x = aPoints[1].x;
      aPoints[2].y = aPoints[0].y - xBounds.ascent * 2 / 3 + 1;
      aPoints[3].x = aPoints[0].x;
      aPoints[3].y = aPoints[0].y;

      XFillPolygon(pDisplay, wID, gc, aPoints, 4, Nonconvex, CoordModeOrigin);

      // 3D highlights for arrow
      XSetForeground(pDisplay, gc, iSelected ? pList->clrBD3.pixel : pList->clrBD2.pixel);
      XDrawLine(pDisplay, wID, gc, aPoints[0].x, aPoints[0].y, aPoints[1].x - 1, aPoints[1].y);
      XDrawLine(pDisplay, wID, gc, aPoints[1].x + 1, pGeom->y + pGeom->height / 2 - xBounds.ascent / 4,
                pGeom->x + iHPos * 3, pGeom->y + pGeom->height / 2 - xBounds.ascent / 4);
      XDrawLine(pDisplay, wID, gc, pGeom->x + iHPos * 3, pGeom->y + pGeom->height / 2 - xBounds.ascent / 4 + 1,
                pGeom->x + iHPos * 3, pGeom->y + pGeom->height / 2 + xBounds.ascent / 4 - 1);

      XSetForeground(pDisplay, gc, iSelected ? pList->clrBD2.pixel : pList->clrBD3.pixel);
      XDrawLine(pDisplay, wID, gc, aPoints[0].x, aPoints[0].y, aPoints[2].x - 1, aPoints[2].y);
      XDrawLine(pDisplay, wID, gc, aPoints[1].x + 1, pGeom->y + pGeom->height / 2 + xBounds.ascent / 4,
                pGeom->x + iHPos * 3, pGeom->y + pGeom->height / 2 + xBounds.ascent / 4);
    }
    else
    {
      const char *szText = (const char *)pData + 1;

      if(*(const char *)pData == '^') // symlink
      {
        XSetForeground(pDisplay, gc, iSelected ? pList->clrBG.pixel : pList->clrHBG.pixel);
      }
      else // regular file
      {
        XSetForeground(pDisplay, gc, iSelected ? pList->clrHFG.pixel : pList->clrFG.pixel);
      }

      XSetBackground(pDisplay, gc, iSelected ? pList->clrHBG.pixel : pList->clrBG.pixel);

      if(*szText)
      {
        WB_RECT rctBounds;

        rctBounds.top = pGeom->y;
        rctBounds.bottom = pGeom->y + pGeom->height;
        rctBounds.left = pGeom->x + iHPos;
        rctBounds.right = pGeom->x + pGeom->width - iHPos;

//        XDrawString(pDisplay, wID, gc, pGeom->x + iHPos, pGeom->y + iVPos, szText, strlen(szText));
        DTDrawSingleLineText(fontSet, szText, pDisplay, gc, wID, 0, 0, &rctBounds,
                             DTAlignment_VCENTER | DTAlignment_HLEFT);
      }

      if(iSelected)  // selected item
      {
        XSetForeground(pDisplay, gc, pList->clrFG.pixel);
        XSetBackground(pDisplay, gc, pList->clrBG.pixel);
      }
    }
  }

  // by convention, restore original objects/state

  BEGIN_XCALL_DEBUG_WRAPPER
  XSetForeground(pDisplay, gc, WBGetWindowFGColor(wID));  // restore it at the end
  END_XCALL_DEBUG_WRAPPER
}







