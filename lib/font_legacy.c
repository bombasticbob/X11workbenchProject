/////////////////////////////////////////////////////////////////////////////////
//                                                                             //
//    __                _         _                                            //
//   / _|  ___   _ __  | |_      | |  ___   __ _   __ _   ___  _   _     ___   //
//  | |_  / _ \ | '_ \ | __|     | | / _ \ / _` | / _` | / __|| | | |   / __|  //
//  |  _|| (_) || | | || |_      | ||  __/| (_| || (_| || (__ | |_| | _| (__   //
//  |_|   \___/ |_| |_| \__|_____|_| \___| \__, | \__,_| \___| \__, |(_)\___|  //
//                         |_____|         |___/               |___/           //
//                                                                             //
/////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2019 by Bob Frazier (aka 'Big Bad Bombastic Bob')


  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.
               Any claims to alleged functionality or features should be
               considered 'preliminary', and might not function as advertised.

  MIT-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  MIT-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

/** \file font_legacy.c
  * \brief Implementation file for LEGACY font helper functions
  *
  * This is the implementation file for LEGACY font helper functions
*/



#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <signal.h>
#include <time.h>
#include <X11/cursorfont.h>

#include <locale.h>

#include "window_helper.h" // for debug output; also includes platform.h and font_helper.h
#include "draw_text.h"

#define FONT_DUMP_DEBUG_LEVEL DebugLevel_Heavy

//#define USE_FONT_LIST_FOR_FONT_SET /* define this to make a list of matching names for a font list */


static char *InternalCheckSetLocale(void);



static XFontStruct *WBGetDefaultFontStruct()
{
  WB_FONTC pFont = WBGetDefaultFont();

  if(pFont)
  {
    return pFont->pFontStruct;
  }

  return None;
}


static XFontSet WBGetDefaultFontSet(Display *pDisplay)
{
  WB_FONTC pFont = WBGetDefaultFont();

  if(pFont)
  {
    return pFont->fsFont;
  }

  return None;
}


XFontStruct *WBCopyFontX(XFontStruct *pOldFont)
{
unsigned long lName;
XFontStruct *pRval;

  if(!pOldFont)
    return NULL;

  if(XGetFontProperty(pOldFont, XA_FONT, &lName))
  {
    char *pName = WBGetAtomName(WBGetDefaultDisplay(), (Atom)lName);

    if(pName)
    {
      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Font,
                     "%s(%s)\n", __FUNCTION__, pName);

      pRval = XLoadQueryFont(WBGetDefaultDisplay(), pName);

      WBFree(pName);

      return pRval;
    }
    else
    {
      WB_WARN_PRINT("%s - WARNING:  %d not an atom\n", __FUNCTION__, (int)lName);
    }
  }
#ifndef NO_DEBUG /* assign this to disable debugging - most likely a -D in Makefile */
  else if((WBGetDebugLevel() & DebugLevel_MASK) >= FONT_DUMP_DEBUG_LEVEL ||
          (WBGetDebugLevel() & DebugSubSystem_Font))
  {
    WBDumpFontStruct(pOldFont);
  }
#endif // NO_DEBUG

  // this is a fallback so debug output is 'light' category, like warnings

  WB_DEBUG_PRINT(DebugLevel_WARN | DebugSubSystem_Font,
                 "%s - call to XQueryFont for %d (%08xH)\n", __FUNCTION__, (int)pOldFont->fid, (int)pOldFont->fid);

  // NOTE:  XQueryFont needs to have XFreeFontList free it.  If I call XFreeFont
  //        it will unload the font and cause a bunch of errors if "other things"
  //        are using it.  NORMALLY I do not get to this point, so I'll return NULL
  //        if I _DO_ in order to flag the error rather than create a time bomb.

  return NULL; // XQueryFont(WBGetDefaultDisplay(), pOldFont->fid);
}

//---------------------
// LEGACY FONT LOADING
//---------------------

void WBFontNameFromAlias(const char *szFontName, char *szDest, int cbDest)
{
XFontStruct *pFSInfo=NULL;
char **ppNames=NULL;
int iCount=0;


  ppNames = XListFontsWithInfo(WBGetDefaultDisplay(), szFontName, 2, &iCount, &pFSInfo);
    // TODO:  if iCount > 0 is this a bad thing?  can I simply pick the 1st one anyway?

  bzero(szDest, cbDest);

  if(ppNames && iCount > 0) //== 1)
  {
    if(iCount > 1)
    {
      WB_WARN_PRINT("%s - WARNING:  WBFontNameFromAlias returns iCount > 1\n", __FUNCTION__);
    }

    strncpy(szDest, ppNames[0], cbDest);
  }

  XFreeFontInfo(ppNames, pFSInfo, iCount);
}

WB_FONT_INFO *WBParseFontName(const char *szFontName)
{
WB_FONT_INFO *pRval = NULL;
char tbuf[256], tbuf2[64];
char *p1, /* *p2,*/ *p3;

  if(!szFontName || !*szFontName)
    return NULL;

  if(szFontName[0] != '-')
  {
    // get the alias
    WBFontNameFromAlias(szFontName, tbuf, sizeof(tbuf));
    if(!*tbuf)
    {
      strcpy(tbuf, "-*-");
      strcat(tbuf, szFontName);
    }
    szFontName = tbuf;
  }

  if(szFontName[0] != '-')
  {
    WB_WARN_PRINT("%s - * BUG * font name doesn't start with a '-' \"%s\"\n", __FUNCTION__, szFontName);
    return NULL;  // should never happen
  }

  pRval = WBAlloc(sizeof(WB_FONT_INFO) + strlen(szFontName));
  // -foundry-family-weight-slant-sWidth-adstyle-pixelsize-pointsize-resX-resY-spacing-avgwidth-registry-encoding

  if(!pRval)
    return NULL;

  bzero(pRval, sizeof(WB_FONT_INFO) + strlen(szFontName));

  p1 = (char *)(pRval->data);
  strcpy(p1, szFontName + 1);  // copy everything past the leading '-'

#define DO_FONT_PARSE_THING(X) pRval->X=p1; while(*p1 && *p1 != '-') p1++; if(*p1 == '-') *(p1++) = 0
#define DO_FONT_PARSE_THING1() bzero(tbuf2,sizeof(tbuf2)); p3=tbuf2; \
  while(*p1 && *p1 != '-' && p3 < (tbuf2 + sizeof(tbuf2) - 2)) *(p3++)=*(p1++); \
  while(*p1 && *p1 != '-') p1++; if(*p1 == '-') *(p1++) = 0
#define DO_FONT_PARSE_THING2(X) DO_FONT_PARSE_THING1(); \
  if(!tbuf2[0] || tbuf2[0]=='*') pRval->X = -1; else pRval->X = atoi(tbuf2)

  DO_FONT_PARSE_THING(szFoundry);
  DO_FONT_PARSE_THING(szFamily);
  DO_FONT_PARSE_THING1();
  if(!strcasecmp(tbuf2,"regular"))
    pRval->iWeight = 1;
  else if(!strcasecmp(tbuf2,"medium"))
    pRval->iWeight = 2;
  else if(!strcasecmp(tbuf2,"demibold"))
    pRval->iWeight = 3;
  else if(!strcasecmp(tbuf2,"bold"))
    pRval->iWeight = 4;
  else if(tbuf2[0] == '*')
    pRval->iWeight = -1;
  else
    pRval->iWeight = 0;

  DO_FONT_PARSE_THING1();
  if(tbuf2[0] == 'r')
    pRval->iSlant = 1;
  else if(tbuf2[0] == 'o')
    pRval->iSlant = 2;
  else if(tbuf2[0] == 'i')
    pRval->iSlant = 3;
  else if(tbuf2[0] == '*')
    pRval->iSlant = -1;
  else
    pRval->iSlant = 0;

  DO_FONT_PARSE_THING1();
  if(!strcasecmp(tbuf2,"normal"))
    pRval->iWidth = 1;
  else if(!strcasecmp(tbuf2,"semicondensed"))
    pRval->iWidth = 2;
  else if(!strcasecmp(tbuf2,"condensed"))
    pRval->iWidth = 3;  // not sure but it's here anyway
  else if(tbuf2[0] == '*')
    pRval->iWidth = -1;
  else
    pRval->iWidth = 0;

  DO_FONT_PARSE_THING(szAdStyle);
  DO_FONT_PARSE_THING2(iPixelSize);
  DO_FONT_PARSE_THING2(iPointSize);
  DO_FONT_PARSE_THING2(iResX);
  DO_FONT_PARSE_THING2(iResY);
  DO_FONT_PARSE_THING1();
  if(tbuf2[0] == 'c')
    pRval->iSpacing = 1;
  else if(tbuf2[0] == 'm')
    pRval->iSpacing = 2;
  else if(tbuf2[0] == 'p')
    pRval->iSpacing = 7;  // proportional (so it's WAY different than the others numerically)
  else if(tbuf2[0] == '*')
    pRval->iSpacing = -1;
  else
    pRval->iSpacing = 0;

  DO_FONT_PARSE_THING2(iAvgWidth);
  DO_FONT_PARSE_THING(szRegistry);
  DO_FONT_PARSE_THING(szEncoding);

// TEMPORARY - when I parse a font make sure it comes out the way I want it to
//  fprintf(stderr, "TEMPORARY:  parsing font %s\n", szFontName);
//  fprintf(stderr, "    szFoundry=%s szFamily=%s iWeight=%d iSlant=%d iWidth=%d szAdStyle=%s\n"
//                  "    iPixelSize=%d iPointSize=%d iResX=%d iResY=%d iSpacing=%d iAvgWidth=%d\n"
//                  "    szRegistry=%s szEncoding=%s\n",
//          pRval->szFoundry, pRval->szFamily, pRval->iWeight, pRval->iSlant,
//          pRval->iWidth, pRval->szAdStyle, pRval->iPixelSize, pRval->iPointSize,
//          pRval->iResX, pRval->iResY, pRval->iSpacing, pRval->iAvgWidth,
//          pRval->szRegistry, pRval->szEncoding);

#undef DO_FONT_PARSE_THING2
#undef DO_FONT_PARSE_THING1
#undef DO_FONT_PARSE_THING

  return pRval;
}

#define FUZZY_FONT_EXACT_MATCH (3 + 10 + 5 + 5 + 2 + 4 + 3 + 3 + 1 + 5 + 4 + 4)

static int InternalFontMatch(const WB_FONT_INFO *p1, const WB_FONT_INFO *p2)
{
  int iRval = 0;

  if(!strcasecmp(p1->szFoundry, p2->szFoundry) ||
     p1->szFoundry[0] == '*' || p2->szFoundry[0] == '*' ||
     !p1->szFoundry[0] || !p2->szFoundry[0])
  {
    iRval += 3;  // score 3 if the foundry matches
  }

  if(!strcasecmp(p1->szFamily, p2->szFamily) ||
     p1->szFamily[0] == '*' || p2->szFamily[0] == '*')
  {
    iRval += 10;  // score 10 for font name match
  }

  if(p1->iWeight == -1 || p2->iWeight == -1 || p1->iWeight == p2->iWeight)
    iRval += 5;  // score 5 for matching weight
  else
    iRval += 3 - abs(p1->iWeight - p2->iWeight);  // sort of fuzzy matching

  if(p1->iSlant == -1 || p2->iSlant == -1 || p1->iSlant == p2->iSlant)
    iRval += 5;  // score 5 for matching Slant
  else
    iRval += 3 - abs(p1->iSlant - p2->iSlant);  // sort of fuzzy matching

  if(p1->iWidth == -1 || p2->iWidth == -1 || p1->iWidth == p2->iWidth)
    iRval += 2;  // score 2 for matching Width

  // for 'szAdStyle' match, it's 'sans' 'ja' 'ko' or blank
  // since blank may match any of them (or none) it's a 2 point delta for 'sans', 1 otherwise

  if(!strcasecmp(p1->szAdStyle,p2->szAdStyle) ||
     p1->szAdStyle[0] == '*' || p2->szAdStyle[0] == '*')
  {
    iRval += 4;  // score 4 for matching style (sans, ko, ja, blank)
  }
  else if((!p1->szAdStyle[0] || !p1->szAdStyle[1]) &&
          (!strcasecmp(p1->szAdStyle,"sans") || !strcasecmp(p2->szAdStyle,"sans")))
  {
    iRval += 2;  // score 2 for 'sort of matching' (blank vs sans)
  }
  else if(!p1->szAdStyle[0] || !p1->szAdStyle[1])
  {
    iRval ++;  // score 1 for 'sort of matching' (blank vs something other than sans)
  }
  else
  {
    iRval -= 2;  // subtract 2 if there's any other combination
  }

  if(p1->iPixelSize == -1 || p2->iPixelSize == -1 || p1->iPixelSize == p2->iPixelSize)
    iRval += 3;  // score 3 for matching PixelSize
  else
    iRval += 2 - abs(p1->iPixelSize - p2->iPixelSize);  // sort of fuzzy matching

  if(p1->iPointSize == -1 || p2->iPointSize == -1 || p1->iPointSize == p2->iPointSize)
    iRval += 3;  // score 3 for matching PointSize
  else
    iRval += 2 - abs(p1->iPointSize - p2->iPointSize) / 10;  // sort of fuzzy matching

  if((p1->iResX == p2->iResX && p1->iResY == p2->iResY) ||
     (p1->iResX == -1 && p1->iResY == -1) ||
     (p2->iResX == -1 && p2->iResY == -1))
  {
    iRval++;  // 1 point for resolution (exact match only)
  }

  if(p1->iSpacing == -1 || p2->iSpacing == -1 || p1->iSpacing == p2->iSpacing)
    iRval += 5;  // 5 points if spacing matches
  else if(p1->iSpacing == 0 || p2->iSpacing == 0)
    iRval += 3;  // 3 points if either is unspecified but not wildcard
  else
    iRval += 3 - abs(p1->iSpacing - p2->iSpacing) / 5;  // 1/5 of the delta (somewhat relative to point sizes)

  if(!strcasecmp(p1->szRegistry,p2->szRegistry) ||
     !p1->szRegistry[0] || !p2->szRegistry[0] ||
     p1->szRegistry[0] == '*' || p2->szRegistry[0] == '*')
  {
    iRval += 4;  // score 4 for matching registry (iso8859 etc.)
  }

  if(!strcasecmp(p1->szEncoding,p2->szEncoding) ||
     !p1->szEncoding[0] || !p2->szEncoding[0] ||
     p1->szEncoding[0] == '*' || p2->szEncoding[0] == '*')
  {
    iRval += 4;  // score 4 for matching character encoding
  }

  return iRval;
}

static int InternalFontMatch2(const char *p1, const char *p2)
{
  int iRval = -1;
  WB_FONT_INFO *pfi1 = p1 ? WBParseFontName(p1) : NULL;
  WB_FONT_INFO *pfi2 = p2 ? WBParseFontName(p2) : NULL;

  if(pfi1 && pfi2)
  {
    iRval = InternalFontMatch(pfi1, pfi2);
  }

  if(pfi1)
  {
    WBFree(pfi1);
  }

  if(pfi2)
  {
    WBFree(pfi2);
  }

  return iRval;
}

static __inline__ int __string_valid_check(const char *pString) { return pString && *pString; }

static void InternalBuildFontString(const char *szFontName, int iSize, int iFlags,
                                    char *pBuf, int cbBuf, int bForceWildcard)
{
  char *p1, /* *p2,*/ *pEnd;
  char tbuf[64];
  int iAvgWidth;
  WB_FONT_INFO *pFI = WBParseFontName(szFontName);

  if(!pFI)
  {
    strncpy(pBuf, szFontName, cbBuf);
    return;
  }

  p1 = pBuf;
  pEnd = pBuf + cbBuf;

  // build the string using 'pFI' and iFlags

#define DO_FONT_BUILD_THING(X) if((p1 + 2) >= pEnd) return; *(p1++) = '-'; \
  if(__string_valid_check(X)) { strncpy(p1, X, (pEnd - p1)); p1 += strlen(p1); } else *(p1++) = '*'; \
  *p1 = 0; if((p1 + 1) >= pEnd) return

  DO_FONT_BUILD_THING(pFI->szFoundry);
  DO_FONT_BUILD_THING(pFI->szFamily);

  *tbuf = 0;
  switch(pFI->iWeight)
  {
    case 1:
      strcpy(tbuf, "regular");
      break;
    case 2:
      strcpy(tbuf, "medium");
      break;
    case 3:
      strcpy(tbuf, "demibold");
      break;
    case 4:
      strcpy(tbuf, "bold");
      break;
    case -1:
      strcpy(tbuf, "*");
      break;
    default:
      *tbuf = 0;
  }

  switch(iFlags & WBFontFlag_WT_MASK)  // iFlags overrides
  {
    case WBFontFlag_WT_REGULAR:
      strcpy(tbuf, "regular");
      break;
    case WBFontFlag_WT_MEDIUM:
      strcpy(tbuf, "medium");
      break;
    case WBFontFlag_WT_DEMIBOLD:
      strcpy(tbuf, "demibold");
      break;
    case WBFontFlag_WT_BOLD:
      strcpy(tbuf, "bold");
      break;
    case WBFontFlag_WT_ANY:
      if(bForceWildcard || !*tbuf)
        strcpy(tbuf, "*");
      break;
  }

  DO_FONT_BUILD_THING(tbuf);  // commit what I just did

  *tbuf = 0;
  switch(pFI->iSlant)
  {
    case 1:
      strcpy(tbuf, "r");
      break;
    case 2:
      strcpy(tbuf, "o");
      break;
    case 3:
      strcpy(tbuf, "i");
      break;
    case -1:
      strcpy(tbuf, "*");
      break;
    default:
      *tbuf = 0;
  }

  switch(iFlags & WBFontFlag_SLANT_MASK)  // iFlags overrides
  {
    case WBFontFlag_SLANT_REGULAR:
      strcpy(tbuf, "r");
      break;
    case WBFontFlag_SLANT_OBLIQUE:
      strcpy(tbuf, "o");
      break;
    case WBFontFlag_SLANT_ITALIC:
      strcpy(tbuf, "i");
      break;
    case WBFontFlag_SLANT_ANY:
      if(bForceWildcard || !*tbuf)
        strcpy(tbuf, "*");
      break;
  }

  DO_FONT_BUILD_THING(tbuf);  // commit what I just did

  *tbuf = 0;
  switch(pFI->iWidth)
  {
    case 1:
      strcpy(tbuf, "normal");
      break;
    case 2:
      strcpy(tbuf, "semicondensed");
      break;
    case 3:                        // RESERVED (may not matter)
      strcpy(tbuf, "condensed");  // for now I have it here anyway
      break;
    case -1:
      strcpy(tbuf, "*");
      break;
    default:
      *tbuf = 0;
  }

  switch(iFlags & WBFontFlag_WIDTH_MASK)
  {
    case WBFontFlag_WIDTH_NORMAL:
      strcpy(tbuf, "normal");
      break;
    case WBFontFlag_WIDTH_SEMICOND:
      strcpy(tbuf, "semicondensed");
      break;
    case WBFontFlag_WIDTH_ANY:
      if(bForceWildcard || !*tbuf)
        strcpy(tbuf, "*");
      break;
  }

  DO_FONT_BUILD_THING(tbuf);  // commit what I just did

  strncpy(tbuf, pFI->szAdStyle, sizeof(tbuf));

  // if I'm insisting on serif then this must be blank
  switch(iFlags & WBFontFlag_STYLE_MASK)
  {
    case WBFontFlag_STYLE_SANS:
      strcpy(tbuf, "sans");
      break;
    case WBFontFlag_STYLE_SERIF:
      *tbuf = 0;
      break;
    case WBFontFlag_STYLE_ANY:
      if(bForceWildcard)
        strcpy(tbuf, "*");
      break;
  }

  DO_FONT_BUILD_THING(tbuf);

  // NOTE:  if I specify pixel size, then point size must be a wildcard
  //        unless the pixel size is <= 0 (and vice versa)

  iAvgWidth = pFI->iAvgWidth;

  if((iFlags & WBFontFlag_SIZE_MASK) == WBFontFlag_SIZE_PIXELS)
  {
    if(pFI->iPixelSize > 0 && iSize < 0 && !bForceWildcard)
      sprintf(tbuf, "%d", pFI->iPixelSize);
    else if(iSize > 0)
    {
      if(pFI->iPixelSize != iSize)
        iAvgWidth = -1;  // force this to be a wildcard
      sprintf(tbuf, "%d", iSize);
    }
    else
      strcpy(tbuf, "*");

    DO_FONT_BUILD_THING(tbuf);

    if(pFI->iPointSize > 0 && !bForceWildcard)
    {
      if(iSize <= 0 || iSize == pFI->iPixelSize)
        sprintf(tbuf, "%d", pFI->iPointSize);
      else
        sprintf(tbuf, "%d", ((pFI->iPointSize * 2 * iSize / pFI->iPixelSize) + 1) / 2);
    }
    else
      strcpy(tbuf, "*");

    DO_FONT_BUILD_THING(tbuf);
  }
  else if((iFlags & WBFontFlag_SIZE_MASK) == WBFontFlag_SIZE_POINTS ||
          (iFlags & WBFontFlag_SIZE_MASK) == WBFontFlag_SIZE_TWIPS)
  {
    if(pFI->iPointSize > 0 && !bForceWildcard)
    {
      if(iSize < 0 ||
         ((iFlags & WBFontFlag_SIZE_MASK) == WBFontFlag_SIZE_POINTS
          && iSize * 10 == pFI->iPointSize) ||
         ((iFlags & WBFontFlag_SIZE_MASK) == WBFontFlag_SIZE_TWIPS
          && iSize / 2 == pFI->iPointSize))
      {
        sprintf(tbuf, "%d", pFI->iPixelSize);
      }
      else if(!iSize)
      {
        strcpy(tbuf, "*");
      }
      else if((iFlags & WBFontFlag_SIZE_MASK) == WBFontFlag_SIZE_POINTS)
      {
        sprintf(tbuf, "%d", ((pFI->iPixelSize * 20 * iSize / pFI->iPointSize) + 1) / 2);
      }
      else
      {
        sprintf(tbuf, "%d", ((pFI->iPixelSize * iSize / pFI->iPointSize) + 1) / 2);
      }
    }
    else
      strcpy(tbuf, "*");

    DO_FONT_BUILD_THING(tbuf);

    if(pFI->iPointSize > 0 && iSize < 0 && !bForceWildcard)
      sprintf(tbuf, "%d", pFI->iPointSize);
    else if(iSize > 0)
    {
      if((iFlags & WBFontFlag_SIZE_MASK) == WBFontFlag_SIZE_POINTS)
      {
        sprintf(tbuf, "%d", iSize * 10);
        if(pFI->iPointSize != iSize * 10)
          iAvgWidth = -1;  // force this to be a wildcard
      }
      else
      {
        sprintf(tbuf, "%d", iSize / 2);
        if(pFI->iPointSize != iSize / 2)
          iAvgWidth = -1;  // force this to be a wildcard
      }
    }
    else
      strcpy(tbuf, "*");

    DO_FONT_BUILD_THING(tbuf);
  }
  else // a 'just in case' catchall
  {
    if(pFI->iPixelSize > 0 && !bForceWildcard)
      sprintf(tbuf, "%d", pFI->iPixelSize);
    else
      strcpy(tbuf, "*");

    DO_FONT_BUILD_THING(tbuf);

    if(pFI->iPointSize > 0 && !bForceWildcard)
      sprintf(tbuf, "%d", pFI->iPointSize);
    else
      strcpy(tbuf, "*");

    DO_FONT_BUILD_THING(tbuf);
  }

  if(!bForceWildcard && pFI->iResX > 0)  // for now wildcard applies to resX
    sprintf(tbuf, "%d", pFI->iResX);
  else
    strcpy(tbuf, "*");

  DO_FONT_BUILD_THING(tbuf);

  if(!bForceWildcard && pFI->iResY > 0)  // for now wildcard applies to resY
    sprintf(tbuf, "%d", pFI->iResY);
  else
    strcpy(tbuf, "*");

  DO_FONT_BUILD_THING(tbuf);

  *tbuf = 0;
  switch(pFI->iSpacing)
  {
    case 1:
      strcpy(tbuf, "c");
      break;
    case 2:
      strcpy(tbuf, "m");
      break;
    case 7:
      strcpy(tbuf, "p");
      break;
    case -1:
      strcpy(tbuf, "*");
      break;
  }

  switch(iFlags & WBFontFlag_PITCH_MASK)
  {
    case WBFontFlag_PITCH_FIXED:
      strcpy(tbuf, "m");
      break;
    case WBFontFlag_PITCH_CONDENSED:
      strcpy(tbuf, "c");
      break;
    case WBFontFlag_PITCH_VARIABLE:
      strcpy(tbuf, "p");
      break;
    case WBFontFlag_PITCH_ANY:
      if(!*tbuf || bForceWildcard)
        strcpy(tbuf, "*");
      break;
  }

  DO_FONT_BUILD_THING(tbuf);

  // average width (with forced wildcard, ALWAYS make it a wildcard; else actual value)
  if(bForceWildcard || iAvgWidth <= 0) // cached from above
    strcpy(tbuf, "*");
  else
    sprintf(tbuf, "%d", pFI->iAvgWidth);

  DO_FONT_BUILD_THING(tbuf);

  // registry + encoding

  if(!bForceWildcard || pFI->szRegistry[0]) // wildcard for a blank implies '*'
    strcpy(tbuf, pFI->szRegistry);
  else
    strcpy(tbuf, "*");

  // TODO:  the effect of 'iFlags' on these two

  DO_FONT_BUILD_THING(tbuf);

  if(!bForceWildcard || pFI->szEncoding[0]) // wildcard for a blank implies '*'
    strcpy(tbuf, pFI->szEncoding);
  else
    strcpy(tbuf, "*");

  DO_FONT_BUILD_THING(tbuf);
}


XFontStruct *WBLoadFontX(Display *pDisplay, const char *szFontName,
                         int iFontSize, int iFlags)
{
XFontStruct *pRval=NULL, *pFSInfo=NULL;
char **ppNames;
int i1, i2, i3, iBest, iCount = 0;
//int iWildcardFlag = 0;
char tbuf[512], tbuf2[512], tbuf3[512];

// font names follow one of these patterns...
//
// AliasName (not preceded by a '-')
//
//   or
//
// -foundry-family-weight-slant-sWidth-adstyle-pixelsize-pointsize-resX-resY-spacing-avgwidth-registry-encoding
//
// foundry = adoby, b&h, xfree86, misc, etc.
// family = lucida, terminal, courier, etc.
// weight = bold, demibold, medium, regular
// slant = i, o, r (italic, oblique, roman) - sometimes combinations like ro, ri
// sWidth = normal, semicondensed, condensed, narrow, double-width
// adstyle = (blank), sans, ja, ko, ???
// pixelsize = height in pixels
// pointsize = width in 10*points
// resX, resY = resolution?
// spacing = c, m, p (character, monospace, proportional)
// avgWidth (in tenths of a pixel)
// registry (i.e. 'iso8859' etc.)
// encoding (the '-' value following the registry, such as '1' for 'iso8859-1')


//#ifndef NO_DEBUG
//  {
//  static int iOnce = 0;
//    if(!iOnce) // note this is SLOW and locks up the X server while it does it's thang
//    {
//      iOnce = 1;
//
//      WBDumpMatchingFontNames(pDisplay, "-*-*-*-*-*-*-*-*-*-*-C-*-*-*");
//    }
//  }
//#endif // NO_DEBUG


  // step 1:  if it's a font alias, get the REAL font info.  I'll need to do this if I'm requesting
  //          a bold or italic version of an aliased font, or even a different size.

  if(szFontName && *szFontName && !strchr(szFontName, '*') && !strchr(szFontName,'-'))
  {
    // get the alias name
    WBFontNameFromAlias(szFontName, tbuf, sizeof(tbuf));

    if(!*tbuf)
    {
      strcpy(tbuf, "-*-");
      strncpy(tbuf + 3, szFontName, sizeof(tbuf) - 3);
    }
  }
  else
  {
//    iWildcardFlag = 1;  // additional information (TODO:  use this?)

    strncpy(tbuf, szFontName, sizeof(tbuf));
  }

  // at this point 'tbuf' is assumed to be a properly formatted font string

  if(iFlags || iFontSize)
  {
    InternalBuildFontString(tbuf, iFontSize, iFlags, tbuf2, sizeof(tbuf2), FALSE);
  }
  else
  {
    strncpy(tbuf2, tbuf, sizeof(tbuf2));
  }

  ppNames = XListFontsWithInfo(pDisplay, tbuf2, 2, &iCount, &pFSInfo);

  // in this case if I only have one font returned, and there are no overrides in iFlags,
  // then that's the one I use.  This is the simplest form of font mapping

  if(iCount == 1 && ppNames)  // there is only a single match
    pRval = XLoadQueryFont(pDisplay, *ppNames);

  if(ppNames)
  {
    XFreeFontInfo(ppNames, pFSInfo, iCount);
    ppNames = NULL;
    pFSInfo = NULL;
    iCount = 0;
  }

  if(pRval)
    return pRval;

  // no match or multi-match - use wildcards, pick "the best one"

  InternalBuildFontString(tbuf, iFontSize, iFlags, tbuf3, sizeof(tbuf3), TRUE);
//  fprintf(stderr, "TEMPORARY:  font string 2 %s\n", tbuf3);

  ppNames = XListFontsWithInfo(pDisplay, tbuf3, 8192, &iCount, &pFSInfo);

  if(ppNames && iCount == 1)
  {
    pRval = XLoadQueryFont(pDisplay, *ppNames);
  }
  else if(ppNames && iCount > 1)
  {
    iBest = -1;
    for(i1 = 0, i2 = -1; i1 < iCount; i1++)
    {
      i3 = InternalFontMatch2(ppNames[i1], tbuf2);  // compare with non-forced-wildcard version
      if(i3 > iBest)
      {
        iBest = i3;
        i2 = i1;
      }
    }

    if(i2 >= 0)
    {
      pRval = XLoadQueryFont(pDisplay, ppNames[i2]);
//      fprintf(stderr, "TEMPORARY 3:  best match %s\n", ppNames[i2]);
    }
  }

  if(ppNames)
  {
    XFreeFontInfo(ppNames, pFSInfo, iCount);
    ppNames = NULL;
    pFSInfo = NULL;
    iCount = 0;
  }

  // TODO:  other forms of 'fuzzy' matching?

  return pRval;
}

int WBFontAvgCharWidthX(Display *pDisplay, const XFontStruct *pFont)
{
unsigned long lName, lPoints;
char *pName = NULL;
WB_FONT_INFO *pFI;
int iRval = 0;


  // step 1:  generate font string from XFontStruct

  if(!pFont)
  {
    return 0;
  }

//  WBDumpFontStruct(pFont);

  // calculate from 'AVERAGE_WIDTH' (in pixels) using font height and point info

  if(XGetFontProperty((XFontStruct *)pFont, aAVERAGE_WIDTH, &lName) &&
     XGetFontProperty((XFontStruct *)pFont, XA_POINT_SIZE, &lPoints) &&
     lPoints && lName)
  {
    iRval = (pFont->ascent + pFont->descent) * lName / lPoints;

//    WB_ERROR_PRINT("TEMPORARY:  %s - avg font width=%d\n", __FUNCTION__, iRval);

    return iRval; // this will be the width [fastest method]
  }

  if(XGetFontProperty((XFontStruct *)pFont, XA_QUAD_WIDTH, &lName) && lName)
  {
    return (int)lName; // 'QUAD_WIDTH' value
  }

  // if i didn't have an average character width property, do it the *HARD* way

  if(XGetFontProperty((XFontStruct *)pFont, XA_FONT, &lName))
  {
    pName = WBGetAtomName(pDisplay ? pDisplay : WBGetDefaultDisplay(), (Atom)lName);

    if(!pName && pDisplay)
    {
      pName = WBGetAtomName(WBGetDefaultDisplay(), (Atom)lName);
    }
  }

  if(pName)
  {

    // if the user specified 'iFontSize' of zero, and did NOT include any
    // font size flags, make sure I duplicate the correct font size

    pFI = WBParseFontName(pName);

    if(pFI)
    {
      if(pFI->iAvgWidth)
      {
        iRval = (pFI->iAvgWidth * pFI->iPixelSize) / pFI->iPointSize;
      }
      else
      {
        iRval = pFI->iWidth; // assuming this is right
      }

      if(!iRval)
      {
        iRval = pFI->iWidth;
      }

//      WB_ERROR_PRINT("TEMPORARY:  %s - width=%d, avg=%d, rval=%d\n", __FUNCTION__, pFI->iWidth, pFI->iAvgWidth, iRval);
      WBFree(pFI);

      if(iRval)
      {
        return iRval;
      }
    }

    WBFree(pName);
    pName = NULL; // by convention to prevent re-use
  }

  iRval = XTextWidth((XFontStruct *)pFont, " ", 1); // return the width of the 'space' character as a last resort

  if(!iRval)
  {
    iRval = (pFont->ascent + pFont->descent) / 2; // desperate measure, return half the height

    WB_ERROR_PRINT("TEMPORARY:  %s - desperately returning 'half-height' avg font width %d\n", __FUNCTION__, iRval);
  }

  return iRval;
}

int WBFontSetDescent(Display *pDisplay, XFontSet fontSet)
{
XFontStruct **ppFontStruct = NULL;
char **ppFontNames = NULL;
int i1, i2, iN, iMax;


  if(fontSet == None)
  {
    fontSet = WBGetDefaultFontSet(pDisplay);

    if(fontSet == None)
    {
      WB_ERROR_PRINT("ERROR:  %s - no default font set available\n", __FUNCTION__);
      return 0;
    }
  }

  iN = XFontsOfFontSet(fontSet, &ppFontStruct, &ppFontNames); // (do NOT free resources!  They are owned by the font set)

  // obtain the max descent of the ENTIRE font set

  for(iMax=0, i1=0; i1 < iN; i1++)
  {
    if(!ppFontStruct[i1])
    {
      continue;
    }

    i2 = ppFontStruct[i1]->descent;

    if(i2 > iMax)
    {
      iMax = i2;
    }

//    WBDebugPrint("TEMPORARY:  %s - %4d: %2d  %s\n", __FUNCTION__, i1, i2, ppFontNames[i1]);
  }

  return iMax;
}

int WBFontSetAscent(Display *pDisplay, XFontSet fontSet)
{
XFontStruct **ppFontStruct = NULL;
char **ppFontNames = NULL;
int i1, i2, iN, iMax;


  if(fontSet == None)
  {
    fontSet = WBGetDefaultFontSet(pDisplay);

    if(fontSet == None)
    {
      WB_ERROR_PRINT("ERROR:  %s - no default font set available\n", __FUNCTION__);
      return 0;
    }
  }

  iN = XFontsOfFontSet(fontSet, &ppFontStruct, &ppFontNames); // (do NOT free resources!  They are owned by the font set)

  // obtain the max ascent of the ENTIRE font set

  for(iMax=0, i1=0; i1 < iN; i1++)
  {
    if(!ppFontStruct[i1])
    {
      continue;
    }

    i2 = ppFontStruct[i1]->ascent;

    if(i2 > iMax)
    {
      iMax = i2;
    }

//    WBDebugPrint("TEMPORARY:  %s - %4d: %2d  %s\n", __FUNCTION__, i1, i2, ppFontNames[i1]);
  }

  return iMax;
}

int WBFontSetHeight(Display *pDisplay, XFontSet fontSet)
{
XFontStruct **ppFontStruct = NULL;
char **ppFontNames = NULL;
int i1, i2, iN, iMaxD, iMaxH;


  if(fontSet == None)
  {
    fontSet = WBGetDefaultFontSet(pDisplay);

    if(fontSet == None)
    {
      WB_ERROR_PRINT("ERROR:  %s - no default font set available\n", __FUNCTION__);
      return 0;
    }
  }

  iN = XFontsOfFontSet(fontSet, &ppFontStruct, &ppFontNames);

  // obtain the average character width of the ENTIRE font set

  for(iMaxD=0, iMaxH=0, i1=0; i1 < iN; i1++)
  {
    if(!ppFontStruct[i1])
    {
      continue;
    }

    i2 = ppFontStruct[i1]->descent;

    if(i2 > iMaxD)
    {
      iMaxD = i2;
    }

    i2 = ppFontStruct[i1]->ascent;

    if(i2 > iMaxH)
    {
      iMaxH = i2;
    }

//    WBDebugPrint("TEMPORARY:  %s - %4d: %2d  %s\n", __FUNCTION__, i1, i2, ppFontNames[i1]);
  }

  return iMaxD + iMaxH;
}

int WBFontSetAvgCharWidth(Display *pDisplay, XFontSet fontSet)
{
XFontStruct **ppFontStruct = NULL;
char **ppFontNames = NULL;
int i1, i2, iN, iTotal, iMax, iCount;


  if(fontSet == None)
  {
    fontSet = WBGetDefaultFontSet(pDisplay);

    if(fontSet == None)
    {
      WB_ERROR_PRINT("ERROR:  %s - no default font set available\n", __FUNCTION__);
      return 0;
    }
  }

  iN = XFontsOfFontSet(fontSet, &ppFontStruct, &ppFontNames);

  // obtain the average character width of the ENTIRE font set

  for(iCount=0, iMax=0, iTotal=0, i1=0; i1 < iN; i1++)
  {
    if(!ppFontStruct[i1])
    {
      continue;
    }

    iCount++;

    i2 = WBFontAvgCharWidthX(pDisplay, ppFontStruct[i1]);

    if(i2 > 0)
    {
      iTotal += i2;

      if(i2 > iMax)
      {
        iMax = i2;
      }
    }

//    WBDebugPrint("TEMPORARY:  %s - %4d: %2d  %s\n", __FUNCTION__, i1, i2, ppFontNames[i1]);
  }

  if(iCount)
  {
    iTotal += iCount >> 1; // rounding
    iTotal /= iCount;
  }

  if(iTotal > iMax)
  {
    iTotal = iMax; // sort of a safety valve, should not be a problem
  }

  return iTotal;
}

XCharStruct WBFontSetMaxBounds(Display *pDisplay, XFontSet fontSet)
{
XCharStruct rVal;
XFontStruct **ppFontStruct = NULL;
char **ppFontNames = NULL;
int i1, iN, iMax;


  bzero(&rVal, sizeof(rVal));

  if(fontSet == None)
  {
    fontSet = WBGetDefaultFontSet(pDisplay);

    if(fontSet == None)
    {
      WB_ERROR_PRINT("ERROR:  %s - no default font set available\n", __FUNCTION__);
      return rVal;
    }
  }

  iN = XFontsOfFontSet(fontSet, &ppFontStruct, &ppFontNames);

  // obtain the average character width of the ENTIRE font set

  for(iMax=0, i1=0; i1 < iN; i1++)
  {
    if(!ppFontStruct[i1])
    {
      continue;
    }

    if(rVal.lbearing < ppFontStruct[i1]->max_bounds.lbearing)
    {
      rVal.lbearing = ppFontStruct[i1]->max_bounds.lbearing;
    }

    if(rVal.rbearing < ppFontStruct[i1]->max_bounds.rbearing)
    {
      rVal.rbearing = ppFontStruct[i1]->max_bounds.rbearing;
    }

    if(rVal.width < ppFontStruct[i1]->max_bounds.width)
    {
      rVal.width = ppFontStruct[i1]->max_bounds.width;
    }

    if(rVal.ascent < ppFontStruct[i1]->max_bounds.ascent)
    {
      rVal.ascent = ppFontStruct[i1]->max_bounds.ascent;
    }

    if(rVal.descent < ppFontStruct[i1]->max_bounds.descent)
    {
      rVal.descent = ppFontStruct[i1]->max_bounds.descent;
    }

//    WBDebugPrint("TEMPORARY:  %s - %4d: %2d  %s\n", __FUNCTION__, i1, i2, ppFontNames[i1]);
  }

  return rVal;
}

XFontStruct *WBLoadModifyFontX(Display *pDisplay, const XFontStruct *pOriginal,
                               int iFontSize, int iFlags)
{
unsigned long lName;
char *pName = NULL;
XFontStruct *pRval;

    // step 1:  generate font string from XFontStruct

  if(!pOriginal)
    return NULL;

  if(XGetFontProperty((XFontStruct *)pOriginal, XA_FONT, &lName))
  {
    pName = WBGetAtomName(pDisplay ? pDisplay : WBGetDefaultDisplay(), (Atom)lName);

    if(!pName && pDisplay)
    {
      pName = WBGetAtomName(WBGetDefaultDisplay(), (Atom)lName); // desperately trying to succeed
    }
  }

  if(!pName)
  {
    return NULL;
  }

  // if the user specified 'iFontSize' of zero, and did NOT include any
  // font size flags, make sure I duplicate the correct font size

  if(!iFontSize)
  {
    WB_FONT_INFO *pFI = WBParseFontName(pName);

    iFlags &= ~WBFontFlag_SIZE_MASK; // reserved for the future

    if(pFI)
    {
      if(pFI->iPixelSize > 0)
      {
        iFontSize = pFI->iPixelSize;
        iFlags |= WBFontFlag_SIZE_PIXELS;
      }
      else if(pFI->iPointSize > 0)
      {
        iFontSize = pFI->iPointSize;
        iFlags |= WBFontFlag_SIZE_POINTS;
      }
      else
      {
        WBFree(pFI);
        pFI = NULL; // flag (see below)
      }
    }

    if(!pFI)
    {
      iFontSize = pOriginal->ascent + pOriginal->descent;
      iFlags |= WBFontFlag_SIZE_PIXELS;
    }
    else
    {
      WBFree(pFI);
    }
  }

  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Font,
                 "%s(%s)\n", __FUNCTION__, pName);

  pRval = WBLoadFontX(pDisplay, pName, iFontSize, iFlags);

  if(!pRval)
  {
    pRval = XLoadQueryFont(pDisplay, pName);  // a copy of the original
  }

  WBFree(pName); // required (no longer need XFree, using 'WBGetAtomName()'
  pName = NULL; // by convention to prevent re-use


#ifndef NO_DEBUG /* assign this to disable debugging - most likely a -D in Makefile */
  if((WBGetDebugLevel() & DebugLevel_MASK) >= FONT_DUMP_DEBUG_LEVEL ||
     (WBGetDebugLevel() & DebugSubSystem_Font))
  {
    WBDumpFontStruct(pRval);
  }
#endif // NO_DEBUG

  return pRval;  // the NEW font!
}

XFontSet WBCopyModifyFontSet(Display *pDisplay, XFontSet fsOrig, int iFontSize, int iFlags)
{
XFontSet fsRval = None;
char *p1, *pLocale, *pName, *pDef = NULL;
char **ppMissing = NULL;
int nMissing = 0;
char tbuf[512];


  if(fsOrig == None)
  {
    fsOrig = WBGetDefaultFontSet(pDisplay);

    if(fsOrig == None)
    {
      WB_ERROR_PRINT("ERROR:  %s - no default font set available\n", __FUNCTION__);
      return None;
    }
  }

  // grab the font name as a copy in 'pName'

  p1 = XBaseFontNameListOfFontSet(fsOrig);  // grab the base name.  this is NOT an allocated pointer
  if(!p1)
  {
    WB_ERROR_PRINT("ERROR:  %s - font set can't get base name\n", __FUNCTION__);
    return None;
  }

  pName = WBCopyString(p1);
  if(!pName)
  {
    WB_ERROR_PRINT("ERROR:  %s - no memory for copying base name\n", __FUNCTION__);
    return None;
  }

  p1 = strchr(pName, ','); // is there a comma?
  if(p1)
  {
    *p1 = 0; // terminate string (use ONLY the first one)
  }

  // use the string I created the font with to load a similar font, after I
  // modify the settings info.

  // if the user specified 'iFontSize' of zero, and did NOT include any
  // font size flags, make sure I duplicate the correct font size

  if(!iFontSize && iFlags) // only if I specify flags AND didn't specify a size...
  {
    WB_FONT_INFO *pFI = WBParseFontName(pName);

    iFlags &= ~WBFontFlag_SIZE_MASK; // reserved for the future

    if(pFI)
    {
      if(pFI->iPixelSize > 0)
      {
        iFontSize = pFI->iPixelSize;
        iFlags |= WBFontFlag_SIZE_PIXELS;
      }
      else if(pFI->iPointSize > 0)
      {
        iFontSize = pFI->iPointSize;
        iFlags |= WBFontFlag_SIZE_POINTS;
      }
      else
      {
        WBFree(pFI);
        pFI = NULL; // flag (see below)
      }
    }

    if(!pFI) // usually a big problem, but I'll work around it
    {
      iFontSize = WBFontSetHeight(pDisplay, fsOrig);    // just do this
      iFlags |= WBFontFlag_SIZE_PIXELS;
    }
    else
    {
      WBFree(pFI);
    }
  }

  // at this point pName is assumed to be a properly formatted font string
  // this is the same (more or less) as what WBLoadFont will grab, except that I'm
  // using what I had before.

  // TODO:  If I get "no font set" as my return, I'll need to attempt the original font set in its place

  if(iFlags || iFontSize) // specifying zero for both of these gives me a direct copy
  {
    tbuf[0] = 0;

    InternalBuildFontString(pName, iFontSize, iFlags, tbuf, sizeof(tbuf), FALSE);

    // TODO:  soft-match?  particularly for size.  see WBLoadModifyFont()
  }
  else
  {
    strncpy(tbuf, pName, sizeof(tbuf));
  }

  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Font,
                 "%s(%s)\n", __FUNCTION__, pName);


  // NOW we duplicate the process of creating the original font set

  pLocale = InternalCheckSetLocale(); // change to correct UTF-8 supporting font

  // OK - allocate 'tbuf' font first, and if that fails, use 'pName' again for a copy

  // NOTE:  'pDef' is owned by the font set.  do NOT XFree it or modify its contents

  fsRval = XCreateFontSet(pDisplay, tbuf, &ppMissing, &nMissing, &pDef); // 6-7 milliseconds!!! (don't do this a lot)

  if(fsRval == None && // try again with original string
     strcmp(tbuf, pName)) // they're not identical so it's worth trying this
  {
    fsRval = XCreateFontSet(pDisplay, pName, &ppMissing, &nMissing, &pDef);
  }

//  WB_ERROR_PRINT("TEMPORARY:  %s - setting locale back to \"%s\"\n", __FUNCTION__, pLocale);

  if(pLocale)
  {
    setlocale(LC_ALL, pLocale);
    WBFree(pLocale);
    pLocale = NULL;
  }
  else
  {
    setlocale(LC_ALL, "C"); // will set things back to "the default" I hope
  }


  // TODO:  dump info?


  if(ppMissing || nMissing > 0)
  {
    if(ppMissing)
    {
      XFreeStringList(ppMissing);
    }
    else
    {
      WB_ERROR_PRINT("*BUG*  %s - nMissing is %d\n", __FUNCTION__, nMissing);
    }
  }


  WBFree(pName);
  pName = NULL; // by convention to prevent re-use


#ifndef NO_DEBUG /* assign this to disable debugging - most likely a -D in Makefile */
//  if((WBGetDebugLevel() & DebugLevel_MASK) >= FONT_DUMP_DEBUG_LEVEL ||
//     (WBGetDebugLevel() & DebugSubSystem_Font))
  WB_IF_DEBUG_LEVEL(FONT_DUMP_DEBUG_LEVEL | DebugSubSystem_Font)
  {
    WBDumpFontSet(pDisplay, fsRval);
  }
#endif // NO_DEBUG


  return fsRval;  // the NEW font set!
}



#ifdef USE_FONT_LIST_FOR_FONT_SET

static char * InternalGetMatchingFontNameList(Display *pDisplay, const char *szFontName)
{
char *pRval, *p1;
char **ppNames;
int i1, iCount, iLen;
XFontStruct *pFSInfo;

  pRval = NULL;

  ppNames = XListFontsWithInfo(pDisplay, szFontName, 8192, &iCount, &pFSInfo);

  if(ppNames)
  {
    for(i1=0, iLen=1; i1 < iCount; i1++)
    {
      iLen += strlen(ppNames[i1]) + 1;
    }

    pRval = WBAlloc(iLen + 1);

    if(pRval)
    {
      for(i1=0, p1=pRval; i1 < iCount; i1++)
      {
        if(i1 > 0)
        {
          *(p1++) = ','; // comma-separated font name list
        }

        strcpy(p1, ppNames[i1]);
        p1 += strlen(p1);
      }
    }

    XFreeFontInfo(ppNames, pFSInfo, iCount);
  }

  if(!pRval) // fallback, try desperately to make this work
  {
    pRval = WBCopyString(szFontName);
  }

  return pRval;
}

#endif // USE_FONT_LIST_FOR_FONT_SET


XFontSet WBFontSetFromFont(Display *pDisplay, const XFontStruct *pFont)
{
unsigned long lName;
char *pName = NULL, *pDef = NULL;
XFontSet rVal = None;
char **ppMissing = NULL;
int nMissing = 0;
char *p1, *pLocale;
static const char szISO[]="-ISO8859-";
//#ifndef NO_DEBUG
//unsigned long long ullTemp;
//#endif // NO_DEBUG

  // step 1:  generate font string from XFontStruct

  if(!pFont)
  {
    pFont = WBGetDefaultFontStruct();
    if(!pFont)
    {
      WB_ERROR_PRINT("%s - no font, returning NULL\n", __FUNCTION__);
      return NULL;
    }
  }

  // WARNING:  do NOT free 'pFont', it's a shared resource

  if(XGetFontProperty((XFontStruct *)pFont, XA_FONT, &lName))
  {
    pName = WBGetAtomName(pDisplay ? pDisplay : WBGetDefaultDisplay(), (Atom)lName);

    if(!pName && pDisplay)
    {
      pName = WBGetAtomName(WBGetDefaultDisplay(), (Atom)lName);
        // NOTE:  'pName' is an editable WBAlloc'd pointer that's a copy of the atom name
    }
  }

  if(!pName)
  {
    WB_ERROR_PRINT("%s - no font name, returning NULL\n", __FUNCTION__);
    return NULL;
  }

  p1 = WBReAlloc(pName, strlen(pName) * 2 + 64); // make sure it's big enough to edit it

  if(!p1)
  {
    WBFree(pName);

    WB_ERROR_PRINT("%s - no memory to update font name, returning NULL\n", __FUNCTION__);
    return NULL;
  }

  pName = p1; // now big enough to be edited


  // font name is an alias name, or starts with a '-' and is of the form:
  // -foundry-family-weight-slant-sWidth-adstyle-pixelsize-pointsize-resX-resY-spacing-avgwidth-registry-encoding
  //
  // foundry = adoby, b&h, xfree86, misc, etc.
  // family = lucida, terminal, courier, etc.
  // weight = bold, demibold, medium, regular
  // slant = i, o, r (italic, oblique, roman) - sometimes combinations like ro, ri
  // sWidth = normal, semicondensed, condensed, narrow, double-width
  // adstyle = (blank), sans, ja, ko, ???
  // pixelsize = height in pixels
  // pointsize = width in 10*points
  // resX, resY = resolution?
  // spacing = c, m, p (character, monospace, proportional)
  // avgWidth (in tenths of a pixel)
  // registry (i.e. 'iso8859' etc.)
  // encoding (the '-' value following the registry, such as '1' for 'iso8859-1')


  // using the font's name string, create a single entry font set for it
  // if the final entry is ISO8859-# change it to *-*
  // ( TODO:  check for other language-dependent things, or maybe just do the last 2 '-'s ? )


//  // if the starting string is "-Misc-", change to "-*-" to allow ALL
//
//  if(!strncasecmp(pName, "-Misc-", 6))
//  {
//    strcpy(pName, "-*-");
//    strcpy(pName + 3, pName + 6);
//  }

  p1 = pName + strlen(pName) - sizeof(szISO);

  while(p1 > pName && strncasecmp(p1, szISO, sizeof(szISO)-1)) // note must be case INsensitive compare...
  {
    p1--;
  }

  if(p1 > pName) // found
  {
    strcpy(p1, "-*-*"); // this allows all of the code sets to be included (fastest method)
  }

//#ifndef NO_DEBUG
//  ullTemp = WBGetTimeIndex();
//#endif // NO_DEBUG

  pLocale = InternalCheckSetLocale();

//#ifndef NO_DEBUG
//  WB_ERROR_PRINT("TEMPORARY:  %s - setlocale took %ld micros\n", __FUNCTION__, (long)(WBGetTimeIndex() - ullTemp));
//  ullTemp = WBGetTimeIndex();
//#endif // NO_DEBUG

  // NOTE:  'pDef' is owned by the font set.  do NOT XFree it or modify its contents

  rVal = XCreateFontSet(pDisplay, pName, &ppMissing, &nMissing, &pDef); // 6-7 milliseconds!!!

//#ifndef NO_DEBUG
//  WB_ERROR_PRINT("TEMPORARY:  %s - XCreateFontSet took %ld micros\n", __FUNCTION__, (long)(WBGetTimeIndex() - ullTemp));
//  ullTemp = WBGetTimeIndex();
//#endif // NO_DEBUG

  if(pLocale)
  {
//    WB_ERROR_PRINT("TEMPORARY:  %s - setting locale back to \"%s\"\n", __FUNCTION__, pLocale);

    setlocale(LC_CTYPE, pLocale);

    WBFree(pLocale);
    pLocale = NULL;
  }
//  else
//  {
//    setlocale(LC_CTYPE, "C"); // will set things back to "the default" I hope
//  }


  // TODO:  dump info?


  if(ppMissing || nMissing > 0)
  {
    if(ppMissing)
    {
  //    int i1;
  //
  //    WB_ERROR_PRINT("TEMPORARY:  %s\n", __FUNCTION__);
  //
  //    for(i1=0; i1 < nMissing; i1++)
  //    {
  //      WB_ERROR_PRINT("  %d : %s\n", i1, ppMissing[i1]);
  //    }

      XFreeStringList(ppMissing);
    }
    else
    {
      WB_ERROR_PRINT("*BUG*  %s - nMissing is %d\n", __FUNCTION__, nMissing);
    }
  }

  WBFree(pName);
  pName = NULL; // by convention to prevent re-use

  if(!rVal)
  {
    WB_ERROR_PRINT("%s - no result, returning NULL\n", __FUNCTION__);
  }
//#ifndef NO_DEBUG
//  else
//  {
//    WBDumpFontSet(pDisplay, rVal);
//  }
//#endif // NO_DEBUG

  return rVal;
}


XFontSet WBFontSetFromFontSingle(Display *pDisplay, const XFontStruct *pFont)
{
unsigned long lName;
char *pName = NULL, *pDef = NULL;
XFontSet rVal = None;
char **ppMissing = NULL;
int nMissing = 0;
char *p1, *pLocale;

  // step 1:  generate font string from XFontStruct

  if(!pFont)
  {
    pFont = WBGetDefaultFontStruct();
    if(!pFont)
    {
      WB_ERROR_PRINT("%s - no font, returning NULL\n", __FUNCTION__);
      return NULL;
    }
  }

  // WARNING:  do NOT free 'pFont', it's a shared resource

  if(XGetFontProperty((XFontStruct *)pFont, XA_FONT, &lName))
  {
    pName = WBGetAtomName(pDisplay ? pDisplay : WBGetDefaultDisplay(), (Atom)lName);

    if(!pName && pDisplay)
    {
      pName = WBGetAtomName(WBGetDefaultDisplay(), (Atom)lName);
        // NOTE:  'pName' is an editable WBAlloc'd pointer that's a copy of the atom name
    }
  }

  if(!pName)
  {
    WB_ERROR_PRINT("%s - no font name, returning NULL\n", __FUNCTION__);
    return NULL;
  }

  p1 = setlocale(LC_CTYPE, NULL); // get the current locale

  if(p1)
  {
    pLocale = WBCopyString(p1);
  }
  else
  {
    pLocale = NULL;
  }

  setlocale(LC_CTYPE, "C"); // set to 'C' locale, which gives me a single font set only that matches THIS one

  // NOTE:  'pDef' is owned by the font set.  do NOT XFree it or modify its contents

  rVal = XCreateFontSet(pDisplay, pName, &ppMissing, &nMissing, &pDef); // 6-7 milliseconds!!!

  WB_ERROR_PRINT("TEMPORARY:  %s - setting locale back to \"%s\"\n", __FUNCTION__, pLocale);

  if(pLocale)
  {
    setlocale(LC_CTYPE, pLocale);
    WBFree(pLocale);
    pLocale = NULL;
  }
//  else
//  {
//    setlocale(LC_ALL, "C"); // will set things back to "the default" I hope
//  }


  // TODO:  dump info?


  if(ppMissing || nMissing > 0)
  {
    if(ppMissing)
    {
      XFreeStringList(ppMissing);
    }
    else
    {
      WB_ERROR_PRINT("*BUG*  %s - nMissing is %d\n", __FUNCTION__, nMissing);
    }
  }

  WBFree(pName);
  pName = NULL; // by convention to prevent re-use

  if(!rVal)
  {
    WB_ERROR_PRINT("%s - no result, returning NULL\n", __FUNCTION__);
  }
#ifndef NO_DEBUG
  else
  {
    WBDumpFontSet(pDisplay, rVal);
  }
#endif // NO_DEBUG

  return rVal;
}


XFontStruct * WBFontFromFontSet(Display *pDisplay, XFontSet fontSet)
{
XFontStruct **ppFontStruct = NULL;
char **ppFontNames = NULL;
int i1, iN;
XFontStruct *pRval = NULL;


  if(fontSet == None)
  {
    fontSet = WBGetDefaultFontSet(pDisplay);

    if(fontSet == None)
    {
      WB_ERROR_PRINT("ERROR:  %s - no default font set available\n", __FUNCTION__);
      return 0;
    }
  }

  iN = XFontsOfFontSet(fontSet, &ppFontStruct, &ppFontNames);

  // get the first valid font struct and make a copy

  for(i1=0; i1 < iN; i1++)
  {
    if(ppFontStruct[i1])
    {
      pRval = WBCopyFontX(ppFontStruct[i1]);  // first one that's valid is my bail-out point

      if(pRval) // bail if it worked
      {
        break;
      }
    }
  }

  return pRval;
}


int WBTextWidthX(XFontSet fontSet, const char *szText, int cbText)
{
int iLen, iRval;


  if(fontSet == None || !cbText || !szText || (cbText < 0 && !*szText))
  {
    WB_ERROR_PRINT("TEMPORARY:  %s - returning zero (bad parameter)\n", __FUNCTION__);
    return 0;
  }
  else if(cbText < 0)
  {
    iLen = strlen(szText);
  }
  else
  {
    iLen = cbText;
  }

  iRval = WB_TEXT_ESCAPEMENT(fontSet, szText, iLen);

//  WB_ERROR_PRINT("TEMPORARY:  %s - escapement for '%.*s' is %d\n", __FUNCTION__, iLen, szText, iRval);

//  if(iRval <= 0)
//  {
//    iLen = mblen(szUTF8, nLength); // width estimate
//    iLen = XTextWidth(pFont, " ", 1) * iLen;
//
//    WB_ERROR_PRINT("%s WOULD BE returning %d, NOW returning %d\n", __FUNCTION__, iRval, iLen);
//    iRval = iLen;
//  }

  return iRval;
}

void WBTextExtentX(XFontSet fontSet, const char *szText, int cbText, WB_EXTENT *pExtent)
{
XRectangle rct, rct2;
int iLen;


  if(fontSet == None || !cbText || !szText || (cbText < 0 && !*szText))
  {
    WB_ERROR_PRINT("TEMPORARY:  %s - returning zero (bad parameter)\n", __FUNCTION__);
    return;
  }
  else if(cbText < 0)
  {
    iLen = strlen(szText);
  }
  else
  {
    iLen = cbText;
  }

  memset(&rct2, 0, sizeof(rct2));

  BEGIN_XCALL_DEBUG_WRAPPER
  WB_TEXT_EXTENTS(fontSet, szText, iLen, &rct, &rct2);
  END_XCALL_DEBUG_WRAPPER

  pExtent->width = rct2.width;
  pExtent->height = rct2.height;
}



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                     _                        _                           //
//                    | |     ___    ___  __ _ | |  ___                     //
//                    | |    / _ \  / __|/ _` || | / _ \                    //
//                    | |___| (_) || (__| (_| || ||  __/                    //
//                    |_____|\___/  \___|\__,_||_| \___|                    //
//                                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


/*static*/ char *InternalCheckSetLocale(void)
{
char *p1, *pLocale, *pNewLocale;
static const char szUTF8[]=".UTF-8";


  p1 = setlocale(LC_CTYPE, NULL); // get the current locale

  if(p1)
  {
    pLocale = WBCopyString(p1);
  }
  else
  {
    WB_ERROR_PRINT("ERROR:  %s - not enough memory\n", __FUNCTION__);

    return NULL; // error (unable to copy string)
  }

  // TODO:  treat this section differently when UTF8 *NOT* supported by libX11
  // determine whether this is a UTF-8 locale
  if(!strcasecmp(pLocale + strlen(pLocale) - (sizeof(szUTF8)-1), szUTF8)) // already UTF-8 capable?
  {
//    WB_ERROR_PRINT("TEMPORARY:  %s - locale \"%s\" already supports UTF-8\n", __FUNCTION__, pLocale);

    WBFree(pLocale);
    pLocale = NULL;
  }
  else
  {
    pNewLocale = NULL;

    if(!strcasecmp(pLocale, "C") || // is it the 'C' locale or 'POSIX' locale?
       !strcasecmp(pLocale, "POSIX"))
    {
      pNewLocale = WBCopyString("en_US.UTF-8"); // use THIS one (should work)
    }
    else
    {
      pNewLocale = WBCopyString(pLocale);

      if(pNewLocale)
      {
        p1 = pNewLocale + strlen(pNewLocale);

        while(p1 > pNewLocale && *(--p1) != '.') { }

        if(p1 > pNewLocale)
        {
          *p1 = 0; // the '.' so I can use .UTF-8 as my suffix
        }

        WBCatString(&pNewLocale, szUTF8); // tack on the '.UTF-8' thing
      }
    }

    if(pNewLocale) // still valid
    {
      if(setlocale(LC_CTYPE, pNewLocale)) // not NULL
      {
//        WB_ERROR_PRINT("TEMPORARY:  %s - set locale to \"%s\"\n", __FUNCTION__, pNewLocale);
      }
      else
      {
//        WB_ERROR_PRINT("TEMPORARY:  %s - unable to set locale to \"%s\"\n", __FUNCTION__, pNewLocale);
        // TODO:  search for a locale that will work

        WBFree(pNewLocale);
        pNewLocale = NULL; // as a flag
      }
    }

    if(pNewLocale) // this is also a flag to say that I successfully changed the locale
    {
      WBFree(pNewLocale);
    }
    else
    {
      WB_ERROR_PRINT("TEMPORARY:  %s - fallback, set locale to \"en_US.UTF-8\"\n", __FUNCTION__);

      setlocale(LC_CTYPE, "en_US.UTF-8"); // as a fallback.  for now, hard-coded to simply allow UTF-8 characters
    }
  }

  return pLocale; // original locale I need to change back to
}




#ifndef NO_DEBUG


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                     ____         _                                       //
//                    |  _ \   ___ | |__   _   _   __ _                     //
//                    | | | | / _ \| '_ \ | | | | / _` |                    //
//                    | |_| ||  __/| |_) || |_| || (_| |                    //
//                    |____/  \___||_.__/  \__,_| \__, |                    //
//                                                |___/                     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

static void WBDumpFontStruct(const XFontStruct *pFont)
{
int i1;

  typedef struct {
      XExtData *ext_data;      /* hook for extension to hang data */
      Font fid;                /* Font id for this font */
      unsigned direction;      /* hint about the direction font is painted */
      unsigned min_char_or_byte2;/* first character */
      unsigned max_char_or_byte2;/* last character */
      unsigned min_byte1;      /* first row that exists */
      unsigned max_byte1;      /* last row that exists */
      Bool all_chars_exist;    /* flag if all characters have nonzero size */
      unsigned default_char;   /* char to print for undefined character */
      int n_properties;        /* how many properties there are */
      XFontProp *properties;   /* pointer to array of additional properties */
      XCharStruct min_bounds;  /* minimum bounds over all existing char */
      XCharStruct max_bounds;  /* maximum bounds over all existing char */
      XCharStruct *per_char;   /* first_char to last_char information */
      int ascent;              /* logical extent above baseline for spacing */
      int descent;             /* logical decent below baseline for spacing */
  } XFontStruct;


  WB_WARN_PRINT("WBDumpFontStruct(%pH)\n", pFont);
  WB_WARN_PRINT("    ext_data         = %pH\n"
                "    fid              = %d (%08xH)\n"
                "    direction        = %d\n"
                "    min_char_or_byte2= %d\n"
                "    max_char_or_byte2= %d\n"
                "    min_byte1        = %d\n"
                "    max_byte1        = %d\n"
                "    all_chars_exist  = %d\n"
                "    default_char     = %d\n"
                "    n_properties     = %d\n",
                pFont->ext_data,
                (int)pFont->fid, (int)pFont->fid,
                pFont->direction,
                pFont->min_char_or_byte2,
                pFont->max_char_or_byte2,
                pFont->min_byte1,
                pFont->max_byte1,
                pFont->all_chars_exist,
                pFont->default_char,
                pFont->n_properties);

  for(i1=0; i1 < pFont->n_properties; i1++)
  {
    char *p1 = WBGetAtomName(WBGetDefaultDisplay(), pFont->properties[i1].name);
    char *p2 = WBGetAtomName(WBGetDefaultDisplay(), (Atom)pFont->properties[i1].card32);

    WB_WARN_PRINT("      %5d %-20s = %ld (%08lxH) %s\n",
                  (int)pFont->properties[i1].name,p1,
                  pFont->properties[i1].card32,
                  pFont->properties[i1].card32, p2);

    if(p1)
    {
      WBFree(p1);
    }

    if(p2)
    {
      WBFree(p2);
    }
  }

  WB_WARN_PRINT("    ascent           = %d\n"
                "    descent          = %d\n",
                pFont->ascent,
                pFont->descent);
}

static void WBDumpMatchingFontNames(Display *pDisplay, const char *szFontName)
{
char **ppNames;
int i1, iCount;
XFontStruct *pFSInfo;

  ppNames = XListFontsWithInfo(pDisplay, szFontName, 8192, &iCount, &pFSInfo);

  if(ppNames)
  {
    WBDebugPrint("%s - fonts matching \"%s\"\n", __FUNCTION__, szFontName);

    for(i1=0; i1 < iCount; i1++)
    {
      WBDebugPrint(" %4d: %s\n", i1, ppNames[i1]);
    }
  }
  else
  {
    WBDebugPrint("%s - NO fonts match \"%s\"\n", __FUNCTION__, szFontName);

  }

  if(ppNames)
  {
    XFreeFontInfo(ppNames, pFSInfo, iCount);
  }
}

static void WBDumpFontSet(Display *pDisplay, XFontSet fontSet)
{
XFontStruct **ppFontStruct = NULL;
char **ppFontNames = NULL;
int i1, iN;

  iN = XFontsOfFontSet(fontSet, &ppFontStruct, &ppFontNames);

  WBDebugPrint("%s - font set contains %d fonts\n", __FUNCTION__, iN);
  WBDebugPrint("font set locale \"%s\"\n", XLocaleOfFontSet(fontSet));

  WBDebugPrint("base name:  \"%s\"\n\n", XBaseFontNameListOfFontSet(fontSet));

  for(i1=0; i1 < iN; i1++)
  {
    WBDebugPrint("  %4d: %s\n", i1, ppFontNames[i1]);
  }
}

// NOTE:  use   WB_IF_DEBUG_LEVEL( n ) macro to control output if you don't always want it

void WBDumpFontInfo(const char *szFontName)
{
XFontStruct *pFSInfo=NULL;
char **ppNames=NULL;
int i1, i2, iCount = 0;
char temp[1024];

  if(!szFontName || !*szFontName)
  {
    strcpy(temp, "*");
  }
  else if(szFontName[0] != '-')
  {
    strcpy(temp, "*-");
    strcat(temp, szFontName);
    strcat(temp, "-*");
  }
  else
  {
    strcpy(temp, "*");
    strcat(temp, szFontName);
    strcat(temp, "*");
  }

  if(szFontName && *szFontName)
  {
// use the first one when you anticipate a LOT of entries or you know that 'szFontName'
// isn't an alias.  Use the 2nd one for a font alias.
//    ppNames = XListFonts(WBGetDefaultDisplay(), szFontName, 0x7fffffff, &iCount);

    ppNames = XListFontsWithInfo(WBGetDefaultDisplay(), szFontName, 16384, &iCount, &pFSInfo);
  }

  if(!ppNames)
  {
//    fprintf(stderr, "TEMPORARY  listing fonts for %s\n", temp);
    ppNames = XListFonts(WBGetDefaultDisplay(), temp, 0x7fffffff, &iCount);
  }

  if(!ppNames)
  {
    WBDebugPrint("%s - no matching fonts\n", __FUNCTION__);
    return;
  }

  // use WBDebugPrint to make sure I dump all of the font into

  WBDebugPrint("%s", "\n** FONT LIST **\n");

  for(i1=0; i1 < iCount; i1++)
  {
// TEMPORARY - for debugginG purposes (remove ASAP)
//    void *pTemp = WBParseFontName(ppNames[i1]);
//    if(pTemp)
//      WBFree(pTemp);

    WBDebugPrint("  %s\n", ppNames[i1]);

    if(pFSInfo)
    {
      WBDebugPrint("    Font      %d (%08xH)\n"
                   "    direction %d\n"
                   "    ascent    %d\n"
                   "    descent   %d\n",
                   (int)pFSInfo[i1].fid, (int)pFSInfo[i1].fid, pFSInfo[i1].direction,
                   pFSInfo[i1].ascent, pFSInfo[i1].descent);

      for(i2=0; i2 < pFSInfo[i1].n_properties && pFSInfo[i1].properties; i2++)
      {
        XFontProp *pProp = pFSInfo[i1].properties + i2;
        char *pName = WBGetAtomName(WBGetDefaultDisplay(),pProp->name);

        if(pName)
        {
          strncpy(temp, pName, sizeof(temp));
          WBFree(pName);
        }
        else
        {
          sprintf(temp, "Atom %d (%08xH)", (int)pProp->name, (int)pProp->name);
        }

        WBDebugPrint("    %-16s  %ld (%08lxH)\n",
                     temp, pProp->card32, pProp->card32);
      }
    }
  }

  WBDebugPrint("%s", "\n***************\n");

  if(pFSInfo)
  {
    XFreeFontInfo(ppNames, pFSInfo, iCount);
  }
  else
  {
    XFreeFontNames(ppNames);
  }
}

#endif // NO_DEBUG

