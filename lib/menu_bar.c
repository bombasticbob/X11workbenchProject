//////////////////////////////////////////////////////////////////////////////////////////
//                                               _                                      //
//           _ __ ___    ___  _ __   _   _      | |__    __ _  _ __  ___                //
//          | '_ ` _ \  / _ \| '_ \ | | | |     | '_ \  / _` || '__|/ __|               //
//          | | | | | ||  __/| | | || |_| |     | |_) || (_| || | _| (__                //
//          |_| |_| |_| \___||_| |_| \__,_|_____|_.__/  \__,_||_|(_)\___|               //
//                                        |_____|                                       //
//                                                                                      //
//                        generic menu bar implementation                               //
//                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2019 by Bob Frazier (aka 'Big Bad Bombastic Bob')


  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.
               Any claims to alleged functionality or features should be
               considered 'preliminary', and might not function as advertised.

  MIT-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  MIT-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

/** \file menu_bar.c
  * \brief Implementation file for menu bar windows
  *
  * This is the implementation file for menus bars, which virtualize the
  * menu structure's contents and handle user interaction
*/



#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <signal.h>
#include <time.h>
#include <X11/cursorfont.h>

#include "window_helper.h"
#include "pixmap_helper.h"  // pixmap helpers, including pre-defined icons
#include "frame_window.h"
#include "menu_bar.h"
#include "menu_popup.h"
#include "conf_help.h"


// sample menu resource format
//
// 1\n
// _File\tpopup\t2\n
// \tseparator\n
// _Help\t100\n
//
// 2\tpopup\n
// _Open\t102\Open File\n
// _Save\t103\Save File\n
// \tseparator\n
// E_xit\t104\Close Application\n
//
// this describes 2 separate menu resource strings.  The first has ID 1, the 2nd has ID 2.
// The ID values are relative only to the menu itself.

// generic description of format:
// <menu ID>[<tab>popup]<newline>
// <menu text><tab>[separator|popup<tab><submenu ID>|<notify ID>]<newline>
// <menu text><tab>[separator|popup<tab><submenu ID>|<notify ID>]<newline>
// (etc.)
//

int MBMenuParentEvent(Window wIDMenu, XEvent *pEvent);  // callback for parent windows that attach this menu
int MBMenuWinEvent(Window wID, XEvent *pEvent);  // callback for menu events

// message handlers
static int MenuBarDoExposeEvent(XExposeEvent *pEvent, WBMenu *pMenu, Display *pDisplay,
                                Window wID, WBMenuBarWindow *pSelf);


#define BORDER  32 /* was 1 */
#define MENU_FONT    "fixed"
#define MENU_ALT_FONT "*-fixed-*"
#define MENU_FONT_SIZE 13

// global color definitions
XColor clrMenuFG, clrMenuBG, clrMenuActiveFG, clrMenuActiveBG, clrMenuBorder1, clrMenuBorder2, clrMenuBorder3,
       clrMenuDisabledFG, clrMenuActiveDisabledFG;

static int iInitColorFlag = 0;
static WB_FONT pDefaultMenuFont = NULL;  // default menu font

/** \ingroup menu_bar
  * \hideinitializer
  * \brief Internal Client Message Atom for 'RESIZE' notification (tells menu bar to resize itself)
  *
  * XCLientMessageEvent members:
  *   window = menu bar window ID
  *   message_type = aMENU_RESIZE
  *   format = 32
  *
  * (no data members)
**/
Atom aMENU_RESIZE = 0;

/** \ingroup menu_bar
  * \hideinitializer
  * \brief Internal Client Message Atom for 'ACTIVATE' notification
  *
  * XClientMessageEvent members:
  *   window = menu bar window ID
  *   message_type = aMENU_ACTIVATE
  *   format = 32
  *
  * To activate a specific menu item:
  *   data.l[0] = Hashed pointer to WBMenuItem - see WBGetPointerFromHash()
  *   data.l[1] = the index for menu item
  *
  * To move to the previous or next menu item in the list:
  *   data.l[0] = 0
  *   data.l[1] = 1 or -1; 1 moves 'next', -1 'previous', 0 'first'.  others undefined.
  *
**/
Atom aMENU_ACTIVATE = 0;

/** \ingroup menu_bar
  * \hideinitializer
  * \brief Internal Client Message Atom for 'DISPLAY POPUP' action
  *
  * XClientMessageEvent members:
  *   window = menu bar window ID
  *   message_type = aMENU_DISPLAY_POPUP
  *   format = 32
  *   data.l[0] = popup menu identifier
  *   data.l[1] = X coordinate for popup 'left' side
  *   data.l[2] = X coordinate for popup 'right' side (left side plus text extent)
  *
**/
Atom aMENU_DISPLAY_POPUP = 0;


// for release code, define DEBUG_VALIDATE(X) as X
#ifdef NO_DEBUG
#define DEBUG_VALIDATE(X) X
#else // NO_DEBUG
#define DEBUG_VALIDATE(X) if(!(X)) { WB_WARN_PRINT("%s:%d - %s\n", __FUNCTION__, __LINE__, "WARNING - " #X " failed!\n"); }
#endif // NO_DEBUG

//#define LOAD_COLOR(X,Y,Z) if(CHGetResourceString(WBGetDefaultDisplay(), X, Y, sizeof(Y)) <= 0){ WB_WARN_PRINT("%s - WARNING:  can't find color %s, using default value %s\n", __FUNCTION__, X, Z); strcpy(Y,Z); }

int MBInitGlobal(void)
{
  Colormap colormap;

  if(!pDefaultMenuFont)
  {
//    pDefaultMenuFont = XLoadQueryFont(WBGetDefaultDisplay(), MENU_FONT);
    pDefaultMenuFont = WBLoadFont(WBGetDefaultDisplay(), MENU_FONT, MENU_FONT_SIZE, WBFontFlag_WT_BOLD);
    if(!pDefaultMenuFont)
    {
      // sometimes there is no font alias, so try again
      pDefaultMenuFont = WBLoadFont(WBGetDefaultDisplay(), MENU_ALT_FONT, MENU_FONT_SIZE, WBFontFlag_WT_BOLD);

      if(!pDefaultMenuFont) // still nothing?
      {
        pDefaultMenuFont = WBLoadFont(WBGetDefaultDisplay(), "*", MENU_FONT_SIZE,
                                      WBFontFlag_WT_BOLD | WBFontFlag_PITCH_FIXED | WBFontFlag_STYLE_SANS);
        if(!pDefaultMenuFont) // still nothing?
        {
          pDefaultMenuFont = WBLoadFont(WBGetDefaultDisplay(), "*", MENU_FONT_SIZE,
                                        WBFontFlag_WT_BOLD | WBFontFlag_PITCH_FIXED);
          if(!pDefaultMenuFont) // still nothing?
          {
            pDefaultMenuFont = WBLoadFont(WBGetDefaultDisplay(), MENU_FONT, MENU_FONT_SIZE, 0); // "ANY" style

            if(!pDefaultMenuFont) // still nothing?
            {
              pDefaultMenuFont = WBLoadFont(WBGetDefaultDisplay(), "*", MENU_FONT_SIZE,
                                            WBFontFlag_PITCH_FIXED);
              if(!pDefaultMenuFont) // still nothing?  REALLY????
              {
                pDefaultMenuFont = WBLoadFont(WBGetDefaultDisplay(), "*", MENU_FONT_SIZE, 0); // just give me something THAT size
              }
            }
          }
        }
      }
    }
  }

  if(!pDefaultMenuFont)
  {
    pDefaultMenuFont = WBCopyFont(WBGetDefaultDisplay(), WBGetDefaultFont());

    if(!pDefaultMenuFont)
    {
      // MY give up.  ~facepalm~

      WB_ERROR_PRINT("%s - no font, MENU FONT is %s,%s %d (menus will not be displayed)\n", __FUNCTION__, MENU_FONT, MENU_ALT_FONT, 13);
      WBDumpFontInfo("*");

      return 0;
    }
  }

  if(!iInitColorFlag)
  {
    char szMenuFG[16], szMenuBG[16], szMenuActiveFG[16], szMenuActiveBG[16],
         szMenuBorder1[16], szMenuActiveDisabledFG[16], szMenuDisabledFG[16];
//    static const char*szMenuBorder2="#FFFFFF", *szMenuBorder3="#9C9A94";
    int iY, iU, iV, iR, iG, iB;

#define COPY_COLOR_NAME(X,Y,Z) {const char *pX = X(WBGetDefaultDisplay()); if(pX) strncpy(Y,pX,sizeof(Y)); else strncpy(Y,Z,sizeof(Y));}

    colormap = DefaultColormap(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));
    COPY_COLOR_NAME(CHGetTextColor, szMenuFG, "#000000");
    COPY_COLOR_NAME(CHGetStaticBackgroundColor, szMenuBG, "#DCDAD5");
    COPY_COLOR_NAME(CHGetHighlightForegroundColor, szMenuActiveFG, "#ffffff");
    COPY_COLOR_NAME(CHGetHighlightBackgroundColor, szMenuActiveBG, "#4B6983");
    COPY_COLOR_NAME(CHGetDisabledTextColor, szMenuDisabledFG, "#808080");
    COPY_COLOR_NAME(CHGetDisabledTextColor, szMenuActiveDisabledFG, "#808080");

#if 0
    LOAD_COLOR("*Menu.foreground",szMenuFG,"#000000");
    LOAD_COLOR("*Menu.background",szMenuBG,"#DCDAD5");
    LOAD_COLOR("*Menu.activeForeground",szMenuActiveFG,"#FFFFFF");
    LOAD_COLOR("*Menu.activeBackground",szMenuActiveBG,"#4B6983");
    LOAD_COLOR("*Menu.disabledForeground",szMenuDisabledFG,"#808080");  // TODO:  verify these Menu.xxx strings for DISABLED
    LOAD_COLOR("*Menu.disabledForeground",szMenuActiveDisabledFG,"#808080");
    LOAD_COLOR("*borderColor",szMenuBorder1,"#000000");
#endif // 0

    // NOTE:  'DEBUG_VALIDATE' (defined above) simply validates the return and prints a message if it failed.
    //        in a release build, the code is still executed, but no error checks are performed on the return value

    DEBUG_VALIDATE(XParseColor(WBGetDefaultDisplay(), colormap, szMenuFG, &clrMenuFG));
    DEBUG_VALIDATE(XAllocColor(WBGetDefaultDisplay(), colormap, &clrMenuFG));  // NOTE:  do I need 'XFreeColors' for these ?

    DEBUG_VALIDATE(XParseColor(WBGetDefaultDisplay(), colormap, szMenuBG, &clrMenuBG));
    DEBUG_VALIDATE(XAllocColor(WBGetDefaultDisplay(), colormap, &clrMenuBG));

    DEBUG_VALIDATE(XParseColor(WBGetDefaultDisplay(), colormap, szMenuActiveFG, &clrMenuActiveFG));
    DEBUG_VALIDATE(XAllocColor(WBGetDefaultDisplay(), colormap, &clrMenuActiveFG));  // NOTE:  do I need 'XFreeColors' for these ?

    DEBUG_VALIDATE(XParseColor(WBGetDefaultDisplay(), colormap, szMenuActiveBG, &clrMenuActiveBG));
    DEBUG_VALIDATE(XAllocColor(WBGetDefaultDisplay(), colormap, &clrMenuActiveBG));

    DEBUG_VALIDATE(XParseColor(WBGetDefaultDisplay(), colormap, szMenuDisabledFG, &clrMenuDisabledFG));
    DEBUG_VALIDATE(XAllocColor(WBGetDefaultDisplay(), colormap, &clrMenuDisabledFG));

    DEBUG_VALIDATE(XParseColor(WBGetDefaultDisplay(), colormap, szMenuActiveDisabledFG, &clrMenuActiveDisabledFG));
    DEBUG_VALIDATE(XAllocColor(WBGetDefaultDisplay(), colormap, &clrMenuActiveDisabledFG));

    DEBUG_VALIDATE(XParseColor(WBGetDefaultDisplay(), colormap, szMenuBorder1, &clrMenuBorder1));
    DEBUG_VALIDATE(XAllocColor(WBGetDefaultDisplay(), colormap, &clrMenuBorder1));


    if((clrMenuBG.flags & (DoRed | DoGreen | DoBlue)) != (DoRed | DoGreen | DoBlue))
    {
      PXM_PixelToRGB(PXM_StandardColormapFromColormap(NULL,colormap),
                     &(clrMenuBG)); // make sure RGB is correctly assigned
    }

    RGB255_FROM_XCOLOR(clrMenuBG, iR, iG, iB);

    PXM_RGBToYUV(iR, iG, iB, &iY, &iU, &iV);

    // the highlight color should be 1/3 of the way between the background color and white, using the same U and V

    PXM_YUVToRGB((2 * iY + 256) / 3, iU, iV, &iR, &iG, &iB);

    RGB255_TO_XCOLOR(iR, iG, iB, clrMenuBorder2); // assign new RGB values to the XColor struct
    PXM_RGBToPixel(PXM_StandardColormapFromColormap(NULL,colormap),
                   &(clrMenuBorder2)); // re-assign pixel element from RGB values

    // the shaded color should be 2/3 of the way between black and the background color, using the same U and V

    PXM_YUVToRGB((2 * iY) / 3, iU, iV, &iR, &iG, &iB);

    RGB255_TO_XCOLOR(iR, iG, iB, clrMenuBorder3); // assign new RGB values to the XColor struct
    PXM_RGBToPixel(PXM_StandardColormapFromColormap(NULL,colormap),
                  &(clrMenuBorder3)); // re-assign pixel element from RGB values


    DEBUG_VALIDATE(XAllocColor(WBGetDefaultDisplay(), colormap, &clrMenuBorder2));
    DEBUG_VALIDATE(XAllocColor(WBGetDefaultDisplay(), colormap, &clrMenuBorder3));


    // TODO:  make sure I was able to actually allocate these colors

    iInitColorFlag = 1;
  }

  if(aMENU_RESIZE == None)
  {
    aMENU_RESIZE = WBGetAtom(WBGetDefaultDisplay(), "WB_MENU_RESIZE");
  }

  if(aMENU_ACTIVATE == None)
  {
    aMENU_ACTIVATE = WBGetAtom(WBGetDefaultDisplay(), "WB_MENU_ACTIVATE");
  }

  if(aMENU_DISPLAY_POPUP == None)
  {
    aMENU_DISPLAY_POPUP = WBGetAtom(WBGetDefaultDisplay(), "WB_MENU_DISPLAY_POPUP");
  }

  return 1;
}

WB_FONTC MBGetDefaultMenuFont(void)
{
  return pDefaultMenuFont;
}

WBMenuBarWindow *MBCreateMenuBarWindow(Window wIDParent, const char *pszResource,
//                                       int iX, int iY, int *piWidth, int *piHeight,
                                       int iFlags)
{
  Display *pDisplay;
  WBMenuBarWindow *pRval = NULL;
  unsigned long fg, bg, bd;   /* Pixel values */
  XSetWindowAttributes xswa;  /* Temporary Set Window Attribute struct */
  XSizeHints  xsh;            /* Size hints for window manager - width of owner + 2 * height of font */
  XWMHints xwmh;
  WB_RECT rct;
  WB_FONTC pFS;


  // initialize global menu objects
  if(!MBInitGlobal())
      return NULL;

  if(wIDParent > 0)
    pDisplay = WBGetWindowDisplay(wIDParent);
  else
    pDisplay = WBGetDefaultDisplay();

  // step 1:  create the window

  bd = clrMenuBorder1.pixel; // BlackPixel(pDisplay, DefaultScreen(pDisplay));
  fg = clrMenuFG.pixel;// BlackPixel(pDisplay, DefaultScreen(pDisplay));  // black foreground for menus (always)
  bg = clrMenuBG.pixel;// WhitePixel(pDisplay, DefaultScreen(pDisplay));  // white background for menus (for now)

  WBGetClientRect(wIDParent, &rct);
  pFS = WBQueryWindowFont(wIDParent);

  if(!pDefaultMenuFont && !pFS)
  {
    WB_ERROR_PRINT("%s - * BUG * no font!\n", __FUNCTION__);
    return 0;
  }
  else if(pDefaultMenuFont)
  {
    pFS = pDefaultMenuFont;
  }

  // set size hints to match client area, upper left corner (always)
  xsh.flags = (PPosition | PSize);
  xsh.x = rct.left;
  xsh.y = rct.top;
  xsh.width = rct.right - rct.left;
  if(!pFS)
    xsh.height = 32;
  else
    xsh.height = 2 * WBFontAscent(pFS) + WBFontDescent(pFS);

  if(xsh.height > (rct.bottom - rct.top))
    xsh.height = rct.bottom - rct.top;

  memset(&xswa, 0, sizeof(xswa));

  xswa.border_pixel = bd;
  xswa.background_pixel = bg;
  xswa.colormap = DefaultColormap(pDisplay, DefaultScreen(pDisplay));
  xswa.bit_gravity = CenterGravity;

  pRval = (WBMenuBarWindow *)WBAlloc(sizeof(*pRval));

  if(!pRval)
    return NULL;

  pRval->ulTag = MENU_WINDOW_TAG;

  pRval->pMenu = MBCreateMenu(-1, 0, pszResource, WBMENU_RESERVE_DEFAULT);

  if(!pRval->pMenu)
  {
    WB_WARN_PRINT("%s - WARNING:  pMenu is NULL in WBMenuBarWindow object\n", __FUNCTION__);
  }

  pRval->wSelf = WBCreateWindow(pDisplay, wIDParent, MBMenuWinEvent, "MenuBar",
                                xsh.x, xsh.y, xsh.width, xsh.height, 0,
                                InputOutput,
                                CWBorderPixel | CWBackPixel | CWColormap | CWBitGravity,
                                &xswa);

  if(pRval->wSelf == -1)
  {
    WBFree(pRval);
    return NULL;
  }

  pRval->wOwner = wIDParent;
  pRval->iPrevSel = pRval->iSelected = -1;  // 'none'
  pRval->iFlags = iFlags;  // make a copy of them (for now)

  // calculate the initial position and height of the menu bar within the window
  pRval->iX = xsh.x + 4;
  pRval->iY = xsh.y + 4;
  pRval->iWidth = xsh.width - 8;
  pRval->iHeight = xsh.height - 8;

  // establish this window as NEVER getting the input focus
  bzero(&xwmh, sizeof(xwmh));
  xwmh.flags = InputHint;
  xwmh.input = 0;  // this represents 'None' (or 'Globally Active' if WM_TAKE_FOCUS is present)

  WBSetWMProperties(pRval->wSelf, NULL, NULL, &xwmh, NULL);

  WBSetWindowDefaultCursor(pRval->wSelf, XC_hand2); //XC_top_left_arrow);
  WBSetWindowData(pRval->wSelf, 0, pRval);  // a pointer back to me.  must do before next part...
  WBRegisterMenuCallback(pRval->wSelf, MBMenuParentEvent);

  WBCreateWindowDefaultGC(pRval->wSelf, fg, bg);
//  WBSetWindowFontStruct(pRval->wSelf, XLoadQueryFont(WBGetDefaultDisplay(), MENU_FONT));
  WBSetWindowFont(pRval->wSelf, pFS);

  // TODO:  should I _NOT_ do this if I clear the input focus flag?
  XSelectInput(pDisplay, pRval->wSelf,
               WB_STANDARD_INPUT_MASK | WB_KEYBOARD_INPUT_MASK | WB_MOUSE_INPUT_MASK);

  WBAddMenuWindow(wIDParent, pRval->wSelf);   // add this menu to this window
                                              // this handles menu hotkeys and resize events for me
//  {
//    Atom a1, a2;
//    a1 = XInternAtom(pDisplay, "_NET_WM_WINDOW_TYPE", False);
//    a2 = XInternAtom(pDisplay, "_NET_WM_WINDOW_TYPE_MENU", False);
//    XChangeProperty(pDisplay, pRval->wSelf, a1, XA_ATOM, 32, PropModeReplace, (unsigned char *)&a2, 1);
//    a1 = XInternAtom(pDisplay, "WM_TRANSIENT_FOR", False);
//    XChangeProperty(pDisplay, pRval->wSelf, a1, XA_WINDOW, 32, PropModeReplace, (unsigned char *)&wIDParent, 1);
//  }

  WBMapWindow(pDisplay, pRval->wSelf);  // make window visible


  // TODO: set up font, GS, callback, etc.


  return(pRval);
}

static int __FindMenuBarWindowCallback(Window wID, void *pData)
{
  WBMenuBarWindow *pMB = MBGetMenuBarWindowStruct(wID);

  if(pMB && (void *)(pMB->pMenu) == pData)
  {
    return 1;
  }

  return 0;
}

WBMenuBarWindow *MBFindMenuBarWindow(WBMenu *pMenu)  // find first (active) window that uses 'pMenu'
{
  Window wID = WBLocateWindow(__FindMenuBarWindowCallback, (void *)pMenu);

  if(wID)
  {
    return MBGetMenuBarWindowStruct(wID);
  }

  return NULL;
}

void MBReCalcMenuBarWindow(WBMenuBarWindow *pMenuBar /*, int iX, int iY, int *piWidth, int *piHeight*/)
{
  // TODO:  update structure's position/size cache?

  WBInvalidateGeom(pMenuBar->wSelf, NULL, 1); // force a re-paint
}

void MBDestroyMenuBarWindow(WBMenuBarWindow *pMenuBar)
{
  if(!pMenuBar || pMenuBar->ulTag != MENU_WINDOW_TAG)
  {
    return;
  }

  // TODO:  any special notifications??

  if(pMenuBar->pMenu)
  {
    MBDestroyMenu(pMenuBar->pMenu); // TODO:  make this do reference counting?
    pMenuBar->pMenu = NULL; // by convention, do this
  }

  WBDestroyWindow(pMenuBar->wSelf);
  WBFree(pMenuBar);
}

void MBSetMenuBarMenuResource(WBMenuBarWindow *pMenuBar, const char *pszResource)
{
WBMenu *pMenu;

  if(!pMenuBar || pMenuBar->ulTag != MENU_WINDOW_TAG)
  {
    return;
  }

  pMenu = MBCreateMenu(-1, 0, pszResource, WBMENU_RESERVE_DEFAULT);

  if(!pMenu)
  {
    WB_ERROR_PRINT("ERROR:  %s - unable to create menu\n", __FUNCTION__);
    return;
  }

  if(pMenuBar->pMenu)
  {
    MBDestroyMenu(pMenuBar->pMenu);
  }

  pMenuBar->pMenu = pMenu;

  pMenuBar->iSelected = -1;
  pMenuBar->iPrevSel = -1;

  MBReCalcMenuBarWindow(pMenuBar);
}


// this next callback is assigned via WBRegisterMenuCallback
int MBMenuParentEvent(Window wIDMenu, XEvent *pEvent)
{
  Display *pDisplay = WBGetWindowDisplay(wIDMenu);
  WBMenuBarWindow *pSelf = MBGetMenuBarWindowStruct(wIDMenu);

  if(!pSelf)
  {
    WB_ERROR_PRINT("%s - pSelf is NULL\n", __FUNCTION__);
    return 0;
  }

  if(pEvent->type == ConfigureNotify &&
     pSelf->wOwner == pEvent->xconfigure.window)
  {
    XWindowChanges chg;
    chg.width = pEvent->xconfigure.width;
    XConfigureWindow(pDisplay, wIDMenu, CWWidth, &chg);

    WBInvalidateGeom(wIDMenu, NULL, 0);

    return 0;
  }

  // TODO:  menu hot keys

  // TODO:  mouse motion ?

  return 0;  // not handled
}

static void MBMenuHandleMenuItem(Display *pDisplay, WBMenuBarWindow *pSelf, WBMenu *pMenu, WBMenuItem *pItem)
{
Window wID = pSelf->wSelf;

  if(pItem->iAction & WBMENU_POPUP_HIGH_BIT)
  {
    XClientMessageEvent evt;

    // post a high-priority message to myself to display the menu

    bzero(&evt, sizeof(evt));
    evt.type = ClientMessage;
    evt.display = pDisplay;
    evt.window = wID;
    evt.message_type = aMENU_DISPLAY_POPUP;
    evt.format = 32;
    evt.data.l[0] = pItem->iAction & WBMENU_POPUP_MASK;
    evt.data.l[1] = pItem->iPosition;                     // minimum extent
    evt.data.l[2] = pItem->iPosition + pItem->iTextWidth; // maximum extent

    WBPostPriorityEvent(wID, (XEvent *)&evt);

    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_Menu,
                    "%s - posting client event message to display popup menu\n", __FUNCTION__);
  }
  else
  {
    XClientMessageEvent evt;

    bzero(&evt, sizeof(evt));
    evt.type = ClientMessage;

    evt.display = pDisplay;
    evt.window = pSelf->wOwner;
    evt.message_type = aMENU_COMMAND;
    evt.format = 32;  // always
    evt.data.l[0] = pItem->iAction;  // menu command message ID
    evt.data.l[1] = WBCreatePointerHash(pMenu); // hash of pointer to menu object
    evt.data.l[2] = wID;             // window ID of menu bar

    WBPostEvent(pSelf->wOwner, (XEvent *)&evt);

    pSelf->iSelected = -1;  // after handling the message I de-select the menu item

    WB_DEBUG_PRINT(DebugLevel_WARN | DebugSubSystem_Menu | DebugSubSystem_Event,
                    "%s - Post Event: %08xH %08xH %pH %08xH\n", __FUNCTION__,
                    (int)aMENU_COMMAND, (int)pItem->iAction,
                    pMenu, (int)wID);

////    WBInvalidateGeom(pSelf->wID, NULL, TRUE);  // make sure I re-paint
  }
}

#if 0 /* currently not used, reserved, consider removing it if not needed */
static int MBMenuHandleMenuItemUI(Display *pDisplay, WBMenuBarWindow *pSelf, WBMenu *pMenu, WBMenuItem *pItem)
{
  XClientMessageEvent evt;
  int iRval;

  bzero(&evt, sizeof(evt));
  evt.type = ClientMessage;

  evt.display = pDisplay;
  evt.window = pSelf->wOwner;
  evt.message_type = aMENU_UI_COMMAND;
  evt.format = 32;  // always

  // sending pointer data - since this is internally 'sent' I don't have to
  // worry about async causing pointers to become invalid

  evt.data.l[0] = pItem->iAction;  // menu command message ID (needed to identify menu)

  evt.data.l[1] = WBCreatePointerHash(pMenu);
  evt.data.l[2] = WBCreatePointerHash(pItem);
  evt.data.l[3] = 0; // this is a sort of 'flag' saying I'm using a pointer hash
  evt.data.l[4] = 0;

  iRval = WBWindowDispatch(pSelf->wOwner, (XEvent *)&evt); // 'send event'

  WBDestroyPointerHash(pMenu);
  WBDestroyPointerHash(pItem); // clean them up as I'm done with them now

  return iRval;
}
#endif // 0


// this next callback is assigned via WBRegisterWindowCallback
int MBMenuWinEvent(Window wID, XEvent *pEvent)
{
Display *pDisplay = WBGetWindowDisplay(wID);
WBMenuBarWindow *pSelf = MBGetMenuBarWindowStruct(wID);
WBMenu *pMenu = pSelf ? pSelf->pMenu : NULL;
WBMenuItem *pItem;
WB_GEOM geom;
Window wIDParent;
XEvent xevt;
int i1; //, iHPos, iVPos;


  if(pSelf && pEvent->type == Expose)
  {
    return MenuBarDoExposeEvent((XExposeEvent *)pEvent, pMenu, pDisplay, wID, pSelf);
  }

  if(pSelf && pEvent->type == ClientMessage && pEvent->xclient.message_type == aMENU_RESIZE)
  {
    WB_RECT rct;
    XWindowAttributes xswa;

    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Menu | DebugSubSystem_Window | DebugSubSystem_Event,
                   "%s - Resize Request Message for %d (%08xH)\n", __FUNCTION__, (int)wID, (int)wID);

    WBGetClientRect(pSelf->wOwner, &rct);

    XGetWindowAttributes(pDisplay, wID, &xswa);
    xswa.width = rct.right - rct.left - xswa.border_width;
    // assume height doesn't change

    WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Menu | DebugSubSystem_Window | DebugSubSystem_Event,
                   "%s - perform resize request for %d (%08xH) %d, %d\n",
                   __FUNCTION__, (int)wID, (int)wID, xswa.width, xswa.height);

    XResizeWindow(pDisplay, wID, xswa.width, xswa.height);
    return 0;  // still requesting default handling on this one
  }

  // process 'destroy' events
  if(pSelf && pEvent->type == DestroyNotify)
  {
    if(pEvent->xdestroywindow.window == wID) // destroying myself?
    {
      WBRemoveMenuWindow(-1, wID);  // removes from ALL windows
      return 1;  // processed
    }
  }


  wIDParent = WBGetParentWindow(wID); // grab the parent window's ID

  if(pSelf &&
     (pEvent->type == KeyPress ||
      pEvent->type == KeyRelease))
  {
    WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Menu | DebugSubSystem_Window | DebugSubSystem_Event,
                   "%s - keypress/release in menu_bar\n", __FUNCTION__);

    if(pEvent->type == KeyPress)
    {
      // see if this is a hotkey for a menu item
//      if(pEvent->xkey.
    }

    // send to parent window for processing

    memcpy(&xevt, pEvent, sizeof(*pEvent));
    xevt.xkey.window = wIDParent;

    WBWindowDispatch(wIDParent, &xevt); // have the parent process it

    // NEXT, post a 'set focus' request to the parent so it gets the other events

    bzero(&xevt, sizeof(xevt));
    xevt.type = ClientMessage;

    xevt.xclient.display = pDisplay;
    xevt.xclient.window = wIDParent;
    xevt.xclient.message_type = aSET_FOCUS;
    xevt.xclient.format = 32;  // always
    xevt.xclient.data.l[0] = 0; // default

    WBPostEvent(wIDParent, &xevt); // post this (parent should fix it now, asynchronously)
  }

  if(pSelf &&
     (pEvent->type == ButtonPress ||
      pEvent->type == ButtonRelease ||
      pEvent->type == MotionNotify))
  {
    int iX, iY; // mousie coordinates (when needed)

    // mousie clickie - yay!

    if(pEvent->type == MotionNotify)
    {
      WBXlatCoordPoint(pEvent->xmotion.window, pEvent->xmotion.x, pEvent->xmotion.y,
                       wID, &iX, &iY);
      if(pEvent->xmotion.state & Button1Mask) // left drag?
      {
        // todo - highlight selections by simulating button press, drop into a popup, etc.
      }
      else if(!(pEvent->xmotion.state & (Button2Mask | Button3Mask | Button4Mask | Button5Mask
                                         | ShiftMask | LockMask | ControlMask)))
      {
        // mouse hover within menu bar

#if 0 // for reference in case I want to handle this here
        if(pSelf->iSelected >= 0) // I have a selected item
        {
          // just hovering, so see if I need to do highlight a different menu and switch popups...

          WBXlatCoordPoint(pEvent->xbutton.window, pEvent->xbutton.x, pEvent->xbutton.y,
                           wID, &iX, &iY);

          for(i1=0; pMenu->ppItems && i1 < pMenu->nItems; i1++)
          {
            WBMenuItem *pItem = pMenu->ppItems[i1];
            if(!pItem)
              continue;

            if(pItem->iPosition <= iX && pItem->iTextWidth + pItem->iPosition >= iX)  // between them
            {
              if(i1 != pSelf->iSelected && // already selected?
                 pItem->iAction != -1)     // don't do anything with this menu item
              {
                // if I am doing this here, then it's likely to be within
                // a modal loop, and I'm recursing.  The trick now is to cause
                // the current menu to go away and a new one take its place.

                WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Menu | DebugSubSystem_Window | DebugSubSystem_Event,
                               "%s.%d - mouse hover in menu bar, different menu item - %d, %d\n",
                               __FUNCTION__, __LINE__, pSelf->iSelected, i1);

                //POOBAH
                MBMenuHandleMenuItem(pDisplay, pSelf, pMenu, pItem);
              }

              return 1;
            }
          }

          return 0; // _NOT_ handled
        }
#endif // 0
      }
    }
    else if(pEvent->type == ButtonPress && pMenu)
    {
      WBXlatCoordPoint(pEvent->xbutton.window, pEvent->xbutton.x, pEvent->xbutton.y,
                       wID, &iX, &iY);
      if(pEvent->xbutton.state & (Button2Mask | Button3Mask | Button4Mask | Button5Mask
                                  | ShiftMask | LockMask | ControlMask))
      {
        // this click I ignore (for now)
      }
      else if(iY >= pSelf->iY && iY <= (pSelf->iY + pSelf->iHeight))
      {
        for(i1=0; pMenu->ppItems && i1 < pMenu->nItems; i1++)
        {
          WBMenuItem *pItem = pMenu->ppItems[i1];
          if(!pItem)
            continue;

          if(pItem->iPosition <= iX && pItem->iTextWidth + pItem->iPosition >= iX)  // between them
          {
            WB_GEOM geom;

            pSelf->iPrevSel = pSelf->iSelected = i1;  // indicate the item that's selected

            geom.x = pItem->iPosition;
            geom.y = pSelf->iY;
            geom.width = pItem->iTextWidth;
            geom.height = pSelf->iHeight;
            geom.border = 0;

            WBInvalidateGeom(wID, &geom, TRUE);  // force a re-paint (at some point in time)

            return 1;
          }
        }

        WB_DEBUG_PRINT(DebugLevel_WARN | DebugSubSystem_Menu | DebugSubSystem_Mouse,
                       "%s - couldn't find the menu item - mouse at %d, %d\n", __FUNCTION__, iX, iY);

let_parent_process_it:

        // mouse outside of menu means parent should re-take the focus
        // So, post a 'set focus' request to the parent so it gets the other events

        bzero(&xevt, sizeof(xevt));
        xevt.type = ClientMessage;

        xevt.xclient.display = pDisplay;
        xevt.xclient.window = wIDParent;
        xevt.xclient.message_type = aSET_FOCUS;
        xevt.xclient.format = 32;  // always
        xevt.xclient.data.l[0] = 0; // default

        WBPostEvent(wIDParent, &xevt); // post this (parent should fix it now, asynchronously)
      }
      else
      {
        WB_DEBUG_PRINT(DebugLevel_WARN | DebugSubSystem_Menu | DebugSubSystem_Mouse,
                       "%s - Mouse pointer is out of range - %d, %d, %d, %d, %d, %d\n",
                       __FUNCTION__, iX, iY, pSelf->iX, pSelf->iY, pSelf->iWidth, pSelf->iHeight);

        goto let_parent_process_it;
      }
    }
    else // if(pEvent->type == ButtonRelease)
    {
      i1 = pSelf->iSelected;

      if(i1 < 0 || i1 >= pMenu->nItems)
      {
        pSelf->iSelected = -1;
        WBInvalidateGeom(wID, NULL, TRUE);
        return 0;  // nothing selected
      }

      pItem = pMenu->ppItems[i1];
      if(!pItem)
      {
        pSelf->iSelected = -1;
        WBInvalidateGeom(wID, NULL, TRUE);
        return 0;
      }

      geom.x = pItem->iPosition;
      geom.y = pSelf->iY;
      geom.width = pItem->iTextWidth;
      geom.height = pSelf->iHeight;
      geom.border = 0;

      WBInvalidateGeom(wID, &geom, TRUE);  // force a re-paint (at some point in time)

      // determine what the correct action for this menu item is...
      if(pItem->iAction == -1)
      {
        pSelf->iSelected = -1;
        WBInvalidateGeom(wID, NULL, TRUE);
        return 0;  // "not handled"
      }

      MBMenuHandleMenuItem(pDisplay, pSelf, pMenu, pItem);

      WBInvalidateGeom(wID, &geom, TRUE);  // force re-paint AGAIN

      return 1;
    }
  }

  if(pEvent && pEvent->type == ClientMessage)
  {
    if(((XClientMessageEvent *)pEvent)->message_type == aMENU_ACTIVATE)
    {
      int iMenuItemIndex = ((XClientMessageEvent *)pEvent)->data.l[1]; // index, prev, or next

      /////////////////////////////////////////////
      // TODO:  deal with dynamic menu elements
      /////////////////////////////////////////////

      pItem = NULL;

      if(iMenuItemIndex >= 0 && iMenuItemIndex < pMenu->nItems &&
         ((XClientMessageEvent *)pEvent)->data.l[0]) // prev/next or 'absolute' indicator - *NOT* equal to 'NULL'
      {
        // select the menu item specified by the index in data.l[1]

        if(pSelf->iSelected != iMenuItemIndex &&
           pSelf->iSelected >= 0 && pSelf->iSelected < pMenu->nItems)
        {
          pItem = pMenu->ppItems[pSelf->iSelected];
          geom.x = pItem->iPosition;
          geom.y = pSelf->iY;
          geom.width = pItem->iTextWidth;
          geom.height = pSelf->iHeight;
          geom.border = 0;

          WBInvalidateGeom(wID, &geom, FALSE); // invalidate rect for currently selected menu item
        }

        pSelf->iSelected = iMenuItemIndex;
        pItem = pMenu->ppItems[pSelf->iSelected];

        // this next part is a 'self-check' which helps to validate the menu item pointer

        if(pItem == WBGetPointerFromHash((((XClientMessageEvent *)pEvent)->data.l[0])))
        {
          geom.x = pItem->iPosition;
          geom.y = pSelf->iY;
          geom.width = pItem->iTextWidth;
          geom.height = pSelf->iHeight;
          geom.border = 0;

          pSelf->iPrevSel = pSelf->iSelected;

          MBMenuHandleMenuItem(pDisplay, pSelf, pMenu, pItem);

          WBInvalidateGeom(wID, &geom, TRUE);  // force window update

          WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_Menu | DebugSubSystem_Keyboard,
                         "%s - MENU_ACTIVATE event, activate menu item, %d %p\n",
                         __FUNCTION__, iMenuItemIndex, pItem);

          return 1;  // handled
        }
        else
        {
          pSelf->iSelected = -1;
          WBInvalidateGeom(wID, NULL, TRUE);
        }

        WBDestroyPointerHash(((XClientMessageEvent *)pEvent)->data.l[0]);
      }
      else if(/*iMenuItemIndex &&*/ !((XClientMessageEvent *)pEvent)->data.l[0])
      {
        // select the PREVIOUS or the NEXT menu item

        int iOldSel = pSelf->iSelected;

        if(iOldSel < 0 || iOldSel >= pMenu->nItems)
        {
          iOldSel = pSelf->iPrevSel;
        }
        if(iOldSel >=0 && iOldSel < pMenu->nItems)
        {
          pSelf->iSelected = iOldSel;  // re-initialize

          pItem = NULL;  // initially

          if(iMenuItemIndex == 0)
          {
            if(pMenu->nItems > 0) // just in case
            {
              pSelf->iSelected = 0;

              goto try_select_next; // a simple way to implement this
            }

            pItem = NULL; // make sure
          }
          else if(iMenuItemIndex > 0)
          {
            while(pSelf->iSelected < (pMenu->nItems - 1))
            {
              pSelf->iSelected++;
try_select_next:
              pItem = pMenu->ppItems[pSelf->iSelected];

              if(pItem->iAction != WBMENU_SEPARATOR)
              {
                break;
              }

              pItem = NULL;
            }
          }
          else
          {
            while(pSelf->iSelected > 0)
            {
              pSelf->iSelected--;
              pItem = pMenu->ppItems[pSelf->iSelected];

              if(pItem->iAction != WBMENU_SEPARATOR)
              {
                break;
              }

              pItem = NULL;
            }
          }

          if(!pItem)
          {
            pSelf->iSelected = iOldSel;
            pItem = pMenu->ppItems[pSelf->iSelected];
          }

          pSelf->iPrevSel = pSelf->iSelected;
        }
        else
        {
          pSelf->iSelected = pSelf->iPrevSel = 0;
          while(pSelf->iSelected < pMenu->nItems)
          {
            pItem = pMenu->ppItems[pSelf->iSelected];
            if(pItem->iAction != WBMENU_SEPARATOR)
            {
              break;
            }
            pItem = NULL;
          }

          if(!pItem)
          {
            pSelf->iSelected = -1;  // fallback for bad menus
            // leave pItem set to NULL;
          }
          else
          {
            pSelf->iPrevSel = pSelf->iSelected;
          }
        }

        if(pItem)
        {
          MBMenuHandleMenuItem(pDisplay, pSelf, pMenu, pItem);
          WBInvalidateGeom(wID, NULL, FALSE); // re-paint, at some point in time

          WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_Menu | DebugSubSystem_Keyboard,
                         "%s - MENU_ACTIVATE event, select prev/next, %d %d\n",
                         __FUNCTION__, iMenuItemIndex, pSelf->iSelected);
          return 1;  // handled
        }
      }

      WB_WARN_PRINT("%s - MENU_ACTIVATE event, invalid menu information, %d %d %p %p\n",
                    __FUNCTION__, iMenuItemIndex, pMenu->nItems,
                    (void *)pItem, (void *)(((XClientMessageEvent *)pEvent)->data.l[0]));
    }
    else if(((XClientMessageEvent *)pEvent)->message_type == aMENU_DISPLAY_POPUP)
    {
      WBMenuPopupWindow *pPopup;
      int iMenuItem = ((XClientMessageEvent *)pEvent)->data.l[0];
      int iPosition = ((XClientMessageEvent *)pEvent)->data.l[1];
      int iRightPos = ((XClientMessageEvent *)pEvent)->data.l[2];

      for(i1=0; i1 < pMenu->nPopups; i1++)
      {
        WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_Menu,
                       "%s - popup menu id = %d\n", __FUNCTION__,
                       (pMenu->ppPopups[i1]->iMenuID & WBMENU_POPUP_MASK));

        if(pMenu->ppPopups[i1] &&
            (pMenu->ppPopups[i1]->iMenuID & WBMENU_POPUP_MASK) == iMenuItem)
        {
          // TODO:  before moving mouse, see if it's already within "the band"
          // move the mouse cursor to the center of the menu item (if it's in another window)
          BEGIN_XCALL_DEBUG_WRAPPER
          XWarpPointer(pDisplay, None, pSelf->wSelf, 0, 0, 0, 0,
                       (iPosition + iRightPos) / 2, pSelf->iY + pSelf->iHeight / 2);
          END_XCALL_DEBUG_WRAPPER

          pPopup = MBCreateMenuPopupWindow(pSelf->wSelf, pSelf->wOwner, pMenu->ppPopups[i1],
                                           iPosition, pSelf->iY + pSelf->iHeight, 0);

          if(pPopup)
          {
#ifndef NO_DEBUG
            int i2;
#endif // NO_DEBUG

            WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Menu,
                           "%s - Displaying popup menu id %d\n", __FUNCTION__, iMenuItem);

#ifndef NO_DEBUG
            i2 =
#endif // NO_DEBUG
            MBMenuDoModal(pPopup);

#ifndef NO_DEBUG
            WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Menu,
                           "%s - Done with popup menu id %d, return %d\n", __FUNCTION__, iMenuItem, i2);
#endif // NO_DEBUG
          }
          else
          {
            WB_WARN_PRINT("%s - Unable to create popup menu %d\n", __FUNCTION__, iMenuItem);
          }

          pSelf->iSelected = -1; // necessary after modality returns
          WBInvalidateGeom(pSelf->wSelf, NULL, 1);  // re-paint (sort of a bug fix)

          break;
        }
      }

      if(i1 >= pMenu->nPopups)
      {
        WB_WARN_PRINT("%s - Unable to locate popup menu %d\n", __FUNCTION__, iMenuItem);
      }
    }
  }


  return 0;  // not handled
}


static int MenuBarDoExposeEvent(XExposeEvent *pEvent, WBMenu *pMenu, Display *pDisplay,
                                Window wID, WBMenuBarWindow *pSelf)
{
  int i1, i2, iHPos, iVPos;
  XWindowAttributes xwa;      /* Temp Get Window Attribute struct */
  WB_FONTC pFont, pTempFont;
  WB_FONT pOldFont;
  XPoint xpt[3];
  WBGC gc; // = WBGetWindowDefaultGC(wID);
//  XGCValues xgc;
  WB_GEOM geomPaint;
  char tbuf[128];

//    // Remove any other pending Expose events from the queue to avoid multiple repaints.
//    // (I don't do this now since I'm already consolidating expose events)
//    while(!bQuitFlag && XCheckTypedWindowEvent(pDisplay, wID, Expose, pEvent))
//      ;

//  if(pEvent->xexpose.count != 0)
//  {
//
//  }

  if (XGetWindowAttributes(pDisplay, wID, &xwa) == 0)
  {
    WB_ERROR_PRINT("%s - * BUG * unable to get window attributes\n", __FUNCTION__);
    return 0;
  }

  pOldFont = NULL;
  pFont = WBQueryWindowFont(wID);

  if(!pFont)
  {
    if(!pDefaultMenuFont)
    {
      WB_ERROR_PRINT("%s - * BUG * no font!\n", __FUNCTION__);
      return 0;
    }
    else if(pDefaultMenuFont) // NOTE:  using this in lieu of window font when specified
    {
      pFont = pDefaultMenuFont;
    }
  }

  // get graphics context copy and begin painting
  gc = WBBeginPaint(wID, pEvent, &geomPaint);
  if(!gc)
  {
    WB_ERROR_PRINT("%s - * BUG * no graphics context!\n", __FUNCTION__);
    return 0;
  }

  WBClearWindow(wID, gc);

//  xgc.font = pFont->fid;
//  WBChangeGC(gc, GCFont, &xgc);
  pTempFont = WBQueryGCFont(gc); // gets un-copied font
  if(pTempFont)
  {
    pOldFont = WBCopyFont(pDisplay, pTempFont); // make a copy
    pTempFont = NULL; // so I don't accidentally re-use it
  }

  WBSetFont(gc, pFont);

  // paint the 3D-looking border
  WBSetForeground(gc, clrMenuBorder2.pixel);
  xpt[0].x=xwa.border_width;
  xpt[0].y=xwa.height-1-2*xwa.border_width - 1;  // exclude first point
  xpt[1].x=xwa.border_width;
  xpt[1].y=xwa.border_width;
  xpt[2].x=xwa.width-1-2*xwa.border_width - 1;   // exclude last point
  xpt[2].y=xwa.border_width;

  WBDrawLines(pDisplay, wID, gc, xpt, 3, CoordModeOrigin);

  WBSetForeground(gc, clrMenuBorder3.pixel);
  xpt[0].x=xwa.width-1-2*xwa.border_width;
  xpt[0].y=xwa.border_width + 1;              // exclude first point
  xpt[1].x=xwa.width-1-2*xwa.border_width;
  xpt[1].y=xwa.height-1-2*xwa.border_width;
  xpt[2].x=xwa.border_width + 1;              // exclude final point
  xpt[2].y=xwa.height-1-2*xwa.border_width;

  WBDrawLines(pDisplay, wID, gc, xpt, 3, CoordModeOrigin);

  // painting the menu items

  i2 = WBTextWidth(pFont, "  ", 2);  // width of 2 spaces
  iVPos = WBFontAscent(pFont) + WBFontDescent(pFont); // font height
  iVPos = (xwa.height - iVPos) >> 1;  // half of the difference - top of text
  iVPos += WBFontAscent(pFont);

  // update the width and height of the menu bar within the window
  pSelf->iX = i2;
  pSelf->iY = iVPos - (WBFontAscent(pFont) + 1);
  pSelf->iWidth = i2;  // initially
  pSelf->iHeight = WBFontAscent(pFont) + WBFontDescent(pFont) + 1;

  WBSetForeground(gc, clrMenuFG.pixel);

  for(i1=0, iHPos = i2; pMenu && pMenu->ppItems && i1 < pMenu->nItems; i1++)
  {
    WBMenuItem *pItem = pMenu->ppItems[i1];
    const char *szText;
    int iU1=0, iU2=0;

    if(!pItem)
      continue;

//    MBMenuHandleMenuItemUI(pDisplay, pSelf, pMenu, pItem); TODO - grey things maybe?

    if(i1 == pSelf->iSelected)  // selected item
    {
      WBSetForeground(gc, clrMenuActiveBG.pixel);
      WBSetBackground(gc, clrMenuActiveBG.pixel);

      WBFillRectangle(pDisplay, wID, gc, pItem->iPosition, pSelf->iY, pItem->iTextWidth, pSelf->iHeight + 2);

      WBSetForeground(gc, clrMenuActiveFG.pixel);
    }

    szText = pItem->data + pItem->iMenuItemText;

    if(strchr(szText, '_'))
    {
      char *p1;
      strcpy(tbuf, szText);
      p1 = tbuf;
      while(*p1)
      {
        if(*p1 == '_')
        {
          *p1 = 0;

          if(p1 == tbuf)
            iU1 = 0;
          else
            iU1 = WBTextWidth(pFont, tbuf, p1 - tbuf);

          if(p1[1])
          {
            iU2 = WBTextWidth(pFont, p1, 1);
            strcpy(p1, p1 + 1);
          }
          else
          {
            iU2 = iU1;  // shouldn't happen
            break;
          }
        }
        p1++;
      }

      szText = tbuf;
    }

    if(pItem->iPosition < 0)
        pItem->iPosition = iHPos;  // also needed for mousie/clickie
    if(pItem->iTextWidth < 0)
        pItem->iTextWidth = WBTextWidth(pFont, szText, strlen(szText));

    // TODO:  change string into a series of XTextItem structures and
    //        then call XDrawText to draw the array of 'XTextItem's
    // TODO:  Use a 'font set' instead, and DTDrawXXX

    if(*szText)
      WBDrawString(pDisplay, wID, gc, iHPos, iVPos, szText, strlen(szText));

    if(strlen(szText) < strlen(pItem->data + pItem->iMenuItemText))
    {
      xpt[0].x=iHPos + iU1 - 1;
      xpt[0].y=pSelf->iY + pSelf->iHeight - 1;
      xpt[1].x=iHPos + iU1 + iU2;
      xpt[1].y=xpt[0].y;

      WBDrawLines(pDisplay, wID, gc, xpt, 2, CoordModeOrigin);
    }

    if(i1 == pSelf->iSelected)  // selected item
    {
      WBSetForeground(gc, clrMenuFG.pixel);
      WBSetBackground(gc, clrMenuBG.pixel);
    }

    iHPos += pItem->iTextWidth + i2;
  }

  pSelf->iWidth = iHPos - i2;  // update the width of the menu bar

  // by convention, restore original objects/state

//  xgc.font = pOldFont->fid;
//  WBChangeGC(gc, GCFont, &xgc);
  WBSetFontNoCopy(gc, pOldFont); // now the gc owns it (no need to WBFreeFont now)

  WBSetForeground(gc, WBGetWindowFGColor(wID));  // restore it at the end

  WBEndPaint(wID, gc);

  return 1;  // processed
}


