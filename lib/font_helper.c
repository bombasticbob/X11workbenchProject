//////////////////////////////////////////////////////////////////////////////////////////
//          __                _         _            _                                  //
//         / _|  ___   _ __  | |_      | |__    ___ | | _ __    ___  _ __  ___          //
//        | |_  / _ \ | '_ \ | __|     | '_ \  / _ \| || '_ \  / _ \| '__|/ __|         //
//        |  _|| (_) || | | || |_      | | | ||  __/| || |_) ||  __/| | _| (__          //
//        |_|   \___/ |_| |_| \__|_____|_| |_| \___||_|| .__/  \___||_|(_)\___|         //
//                               |_____|               |_|                              //
//                       basic font enumeration and selection                           //
//                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2016 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no waranties, either implied or explicit.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

/** \file font_helper.c
  * \brief Implementation file for font helper functions
  *
  * This is the implementation file for font helper functions
*/



#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <signal.h>
#include <time.h>
#include <X11/cursorfont.h>

#include "window_helper.h" // for debug output; also includes platform.h and font_helper.h
#include "draw_text.h"

#define FONT_DUMP_DEBUG_LEVEL DebugLevel_Heavy

typedef struct WBFontInfo
{
  char *szFoundry, *szFamily;
  int iWeight, iSlant, iWidth;
  char *szAdStyle;
  int iPixelSize, iPointSize, iResX, iResY, iSpacing, iAvgWidth;
  char *szRegistry, *szEncoding;
  char data[8];
} WB_FONT_INFO;

#ifndef NO_DEBUG
static void WBDumpFontStruct(XFontStruct *pFont);
#endif // NO_DEBUG

XFontStruct *WBCopyFont(XFontStruct *pOldFont)
{
unsigned long lName;
XFontStruct *pRval;

  if(!pOldFont)
    return NULL;

  if(XGetFontProperty(pOldFont, XA_FONT, &lName))
  {
    char *pName = XGetAtomName(WBGetDefaultDisplay(), (Atom)lName);
    if(pName)
    {
      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Font,
                     "%s(%s)\n", __FUNCTION__, pName);

      pRval = XLoadQueryFont(WBGetDefaultDisplay(), pName);
      XFree(pName);
      return pRval;
    }
    else
    {
      WB_WARN_PRINT("%s - WARNING:  %d not an atom\n", __FUNCTION__, (int)lName);
    }
  }
#ifndef NO_DEBUG /* assign this to disable debugging - most likely a -D in Makefile */
  else if((WBGetDebugLevel() & DebugLevel_MASK) >= FONT_DUMP_DEBUG_LEVEL ||
          (WBGetDebugLevel() & DebugSubSystem_Font))
  {
    WBDumpFontStruct(pOldFont);
  }
#endif // NO_DEBUG

  // this is a fallback so debug output is 'light' category, like warnings

  WB_DEBUG_PRINT(DebugLevel_WARN | DebugSubSystem_Font,
                 "%s - call to XQueryFont for %d (%08xH)\n", __FUNCTION__, (int)pOldFont->fid, (int)pOldFont->fid);

  // NOTE:  XQueryFont needs to have XFreeFontList free it.  If I call XFreeFont
  //        it will unload the font and cause a bunch of errors if "other things"
  //        are using it.  NORMALLY I do not get to this point, so I'll return NULL
  //        if I _DO_ in order to flag the error rather than create a time bomb.

  return NULL; // XQueryFont(WBGetDefaultDisplay(), pOldFont->fid);
}

void WBFontNameFromAlias(const char *szFontName, char *szDest, int cbDest)
{
XFontStruct *pFSInfo=NULL;
char **ppNames=NULL;
int iCount=0;


  ppNames = XListFontsWithInfo(WBGetDefaultDisplay(), szFontName, 2, &iCount, &pFSInfo);
    // TODO:  if iCount > 0 is this a bad thing?  can I simply pick the 1st one anyway?

  bzero(szDest, cbDest);

  if(ppNames && iCount > 0) //== 1)
  {
    if(iCount > 1)
    {
      WB_WARN_PRINT("%s - WARNING:  WBFontNameFromAlias returns iCount > 1\n", __FUNCTION__);
    }

    strncpy(szDest, ppNames[0], cbDest);
  }

  XFreeFontInfo(ppNames, pFSInfo, iCount);
}

WB_FONT_INFO *WBParseFontName(const char *szFontName)
{
WB_FONT_INFO *pRval = NULL;
char tbuf[256], tbuf2[64];
char *p1, /* *p2,*/ *p3;

  if(!szFontName || !*szFontName)
    return NULL;

  if(szFontName[0] != '-')
  {
    // get the alias
    WBFontNameFromAlias(szFontName, tbuf, sizeof(tbuf));
    if(!*tbuf)
    {
      strcpy(tbuf, "-*-");
      strcat(tbuf, szFontName);
    }
    szFontName = tbuf;
  }

  if(szFontName[0] != '-')
  {
    WB_WARN_PRINT("%s - * BUG * font name doesn't start with a '-' \"%s\"\n", __FUNCTION__, szFontName);
    return NULL;  // should never happen
  }

  pRval = malloc(sizeof(WB_FONT_INFO) + strlen(szFontName));
  // -foundry-family-weight-slant-sWidth-adstyle-pixelsize-pointsize-resX-resY-spacing-avgwidth-registry-encoding

  if(!pRval)
    return NULL;

  bzero(pRval, sizeof(WB_FONT_INFO) + strlen(szFontName));

  p1 = (char *)(pRval->data);
  strcpy(p1, szFontName + 1);  // copy everything past the leading '-'

#define DO_FONT_PARSE_THING(X) pRval->X=p1; while(*p1 && *p1 != '-') p1++; if(*p1 == '-') *(p1++) = 0
#define DO_FONT_PARSE_THING1() bzero(tbuf2,sizeof(tbuf2)); p3=tbuf2; \
  while(*p1 && *p1 != '-' && p3 < (tbuf2 + sizeof(tbuf2) - 2)) *(p3++)=*(p1++); \
  while(*p1 && *p1 != '-') p1++; if(*p1 == '-') *(p1++) = 0
#define DO_FONT_PARSE_THING2(X) DO_FONT_PARSE_THING1(); \
  if(!tbuf2[0] || tbuf2[0]=='*') pRval->X = -1; else pRval->X = atoi(tbuf2)

  DO_FONT_PARSE_THING(szFoundry);
  DO_FONT_PARSE_THING(szFamily);
  DO_FONT_PARSE_THING1();
  if(!strcasecmp(tbuf2,"regular"))
    pRval->iWeight = 1;
  else if(!strcasecmp(tbuf2,"medium"))
    pRval->iWeight = 2;
  else if(!strcasecmp(tbuf2,"demibold"))
    pRval->iWeight = 3;
  else if(!strcasecmp(tbuf2,"bold"))
    pRval->iWeight = 4;
  else if(tbuf2[0] == '*')
    pRval->iWeight = -1;
  else
    pRval->iWeight = 0;

  DO_FONT_PARSE_THING1();
  if(tbuf2[0] == 'r')
    pRval->iSlant = 1;
  else if(tbuf2[0] == 'o')
    pRval->iSlant = 2;
  else if(tbuf2[0] == 'i')
    pRval->iSlant = 3;
  else if(tbuf2[0] == '*')
    pRval->iSlant = -1;
  else
    pRval->iSlant = 0;

  DO_FONT_PARSE_THING1();
  if(!strcasecmp(tbuf2,"normal"))
    pRval->iWidth = 1;
  else if(!strcasecmp(tbuf2,"semicondensed"))
    pRval->iWidth = 2;
  else if(!strcasecmp(tbuf2,"condensed"))
    pRval->iWidth = 3;  // not sure but it's here anyway
  else if(tbuf2[0] == '*')
    pRval->iWidth = -1;
  else
    pRval->iWidth = 0;

  DO_FONT_PARSE_THING(szAdStyle);
  DO_FONT_PARSE_THING2(iPixelSize);
  DO_FONT_PARSE_THING2(iPointSize);
  DO_FONT_PARSE_THING2(iResX);
  DO_FONT_PARSE_THING2(iResY);
  DO_FONT_PARSE_THING1();
  if(tbuf2[0] == 'c')
    pRval->iSpacing = 1;
  else if(tbuf2[0] == 'm')
    pRval->iSpacing = 2;
  else if(tbuf2[0] == 'p')
    pRval->iSpacing = 7;  // proportional (so it's WAY different than the others numerically)
  else if(tbuf2[0] == '*')
    pRval->iSpacing = -1;
  else
    pRval->iSpacing = 0;

  DO_FONT_PARSE_THING2(iAvgWidth);
  DO_FONT_PARSE_THING(szRegistry);
  DO_FONT_PARSE_THING(szEncoding);

// TEMPORARY - when I parse a font make sure it comes out the way I want it to
//  fprintf(stderr, "TEMPORARY:  parsing font %s\n", szFontName);
//  fprintf(stderr, "    szFoundry=%s szFamily=%s iWeight=%d iSlant=%d iWidth=%d szAdStyle=%s\n"
//                  "    iPixelSize=%d iPointSize=%d iResX=%d iResY=%d iSpacing=%d iAvgWidth=%d\n"
//                  "    szRegistry=%s szEncoding=%s\n",
//          pRval->szFoundry, pRval->szFamily, pRval->iWeight, pRval->iSlant,
//          pRval->iWidth, pRval->szAdStyle, pRval->iPixelSize, pRval->iPointSize,
//          pRval->iResX, pRval->iResY, pRval->iSpacing, pRval->iAvgWidth,
//          pRval->szRegistry, pRval->szEncoding);

#undef DO_FONT_PARSE_THING2
#undef DO_FONT_PARSE_THING1
#undef DO_FONT_PARSE_THING

  return pRval;
}

#define FUZZY_FONT_EXACT_MATCH (3 + 10 + 5 + 5 + 2 + 4 + 3 + 3 + 1 + 5 + 4 + 4)

static int InternalFontMatch(const WB_FONT_INFO *p1, const WB_FONT_INFO *p2)
{
  int iRval = 0;

  if(!strcasecmp(p1->szFoundry, p2->szFoundry) ||
     p1->szFoundry[0] == '*' || p2->szFoundry[0] == '*' ||
     !p1->szFoundry[0] || !p2->szFoundry[0])
  {
    iRval += 3;  // score 3 if the foundry matches
  }

  if(!strcasecmp(p1->szFamily, p2->szFamily) ||
     p1->szFamily[0] == '*' || p2->szFamily[0] == '*')
  {
    iRval += 10;  // score 10 for font name match
  }

  if(p1->iWeight == -1 || p2->iWeight == -1 || p1->iWeight == p2->iWeight)
    iRval += 5;  // score 5 for matching weight
  else
    iRval += 3 - abs(p1->iWeight - p2->iWeight);  // sort of fuzzy matching

  if(p1->iSlant == -1 || p2->iSlant == -1 || p1->iSlant == p2->iSlant)
    iRval += 5;  // score 5 for matching Slant
  else
    iRval += 3 - abs(p1->iSlant - p2->iSlant);  // sort of fuzzy matching

  if(p1->iWidth == -1 || p2->iWidth == -1 || p1->iWidth == p2->iWidth)
    iRval += 2;  // score 2 for matching Width

  // for 'szAdStyle' match, it's 'sans' 'ja' 'ko' or blank
  // since blank may match any of them (or none) it's a 2 point delta for 'sans', 1 otherwise

  if(!strcasecmp(p1->szAdStyle,p2->szAdStyle) ||
     p1->szAdStyle[0] == '*' || p2->szAdStyle[0] == '*')
  {
    iRval += 4;  // score 4 for matching style (sans, ko, ja, blank)
  }
  else if((!p1->szAdStyle[0] || !p1->szAdStyle[1]) &&
          (!strcasecmp(p1->szAdStyle,"sans") || !strcasecmp(p2->szAdStyle,"sans")))
  {
    iRval += 2;  // score 2 for 'sort of matching' (blank vs sans)
  }
  else if(!p1->szAdStyle[0] || !p1->szAdStyle[1])
  {
    iRval ++;  // score 1 for 'sort of matching' (blank vs something other than sans)
  }
  else
  {
    iRval -= 2;  // subtract 2 if there's any other combination
  }

  if(p1->iPixelSize == -1 || p2->iPixelSize == -1 || p1->iPixelSize == p2->iPixelSize)
    iRval += 3;  // score 3 for matching PixelSize
  else
    iRval += 2 - abs(p1->iPixelSize - p2->iPixelSize);  // sort of fuzzy matching

  if(p1->iPointSize == -1 || p2->iPointSize == -1 || p1->iPointSize == p2->iPointSize)
    iRval += 3;  // score 3 for matching PointSize
  else
    iRval += 2 - abs(p1->iPointSize - p2->iPointSize) / 10;  // sort of fuzzy matching

  if((p1->iResX == p2->iResX && p1->iResY == p2->iResY) ||
     (p1->iResX == -1 && p1->iResY == -1) ||
     (p2->iResX == -1 && p2->iResY == -1))
  {
    iRval++;  // 1 point for resolution (exact match only)
  }

  if(p1->iSpacing == -1 || p2->iSpacing == -1 || p1->iSpacing == p2->iSpacing)
    iRval += 5;  // 5 points if spacing matches
  else if(p1->iSpacing == 0 || p2->iSpacing == 0)
    iRval += 3;  // 3 points if either is unspecified but not wildcard
  else
    iRval += 3 - abs(p1->iSpacing - p2->iSpacing) / 5;  // 1/5 of the delta (somewhat relative to point sizes)

  if(!strcasecmp(p1->szRegistry,p2->szRegistry) ||
     !p1->szRegistry[0] || !p2->szRegistry[0] ||
     p1->szRegistry[0] == '*' || p2->szRegistry[0] == '*')
  {
    iRval += 4;  // score 4 for matching registry (iso8859 etc.)
  }

  if(!strcasecmp(p1->szEncoding,p2->szEncoding) ||
     !p1->szEncoding[0] || !p2->szEncoding[0] ||
     p1->szEncoding[0] == '*' || p2->szEncoding[0] == '*')
  {
    iRval += 4;  // score 4 for matching character encoding
  }

  return iRval;
}

static int InternalFontMatch2(const char *p1, const char *p2)
{
  int iRval = -1;
  WB_FONT_INFO *pfi1 = p1 ? WBParseFontName(p1) : NULL;
  WB_FONT_INFO *pfi2 = p2 ? WBParseFontName(p2) : NULL;

  if(pfi1 && pfi2)
  {
    iRval = InternalFontMatch(pfi1, pfi2);
  }

  if(pfi1)
    free(pfi1);
  if(pfi2)
    free(pfi2);

  return iRval;
}

// NOTE:  use   WB_IF_DEBUG_LEVEL( n ) macro to control output if you don't always want it

void WBDumpFontInfo(const char *szFontName)
{
XFontStruct *pFSInfo=NULL;
char **ppNames=NULL;
int i1, i2, iCount = 0;
char temp[1024];

  if(!szFontName || !*szFontName)
  {
    strcpy(temp, "*");
  }
  else if(szFontName[0] != '-')
  {
    strcpy(temp, "*-");
    strcat(temp, szFontName);
    strcat(temp, "-*");
  }
  else
  {
    strcpy(temp, "*");
    strcat(temp, szFontName);
    strcat(temp, "*");
  }

  if(szFontName && *szFontName)
  {
// use the first one when you anticipate a LOT of entries or you know that 'szFontName'
// isn't an alias.  Use the 2nd one for a font alias.
//    ppNames = XListFonts(WBGetDefaultDisplay(), szFontName, 0x7fffffff, &iCount);

    ppNames = XListFontsWithInfo(WBGetDefaultDisplay(), szFontName, 16384, &iCount, &pFSInfo);
  }

  if(!ppNames)
  {
//    fprintf(stderr, "TEMPORARY  listing fonts for %s\n", temp);
    ppNames = XListFonts(WBGetDefaultDisplay(), temp, 0x7fffffff, &iCount);
  }

  if(!ppNames)
  {
    WBDebugPrint("%s - no matching fonts\n", __FUNCTION__);
    return;
  }

  // use WBDebugPrint to make sure I dump all of the font into

  WBDebugPrint("%s", "\n** FONT LIST **\n");

  for(i1=0; i1 < iCount; i1++)
  {
// TEMPORARY - for debugginG purposes (remove ASAP)
//    void *pTemp = WBParseFontName(ppNames[i1]);
//    if(pTemp)
//      free(pTemp);

    WBDebugPrint("  %s\n", ppNames[i1]);

    if(pFSInfo)
    {
      WBDebugPrint("    Font      %d (%08xH)\n"
                   "    direction %d\n"
                   "    ascent    %d\n"
                   "    descent   %d\n",
                   (int)pFSInfo[i1].fid, (int)pFSInfo[i1].fid, pFSInfo[i1].direction,
                   pFSInfo[i1].ascent, pFSInfo[i1].descent);

      for(i2=0; i2 < pFSInfo[i1].n_properties && pFSInfo[i1].properties; i2++)
      {
        XFontProp *pProp = pFSInfo[i1].properties + i2;
        char *pName = XGetAtomName(WBGetDefaultDisplay(),pProp->name);

        if(pName)
        {
          strcpy(temp, pName);
          XFree(pName);
        }
        else
        {
          sprintf(temp, "Atom %d (%08xH)", (int)pProp->name, (int)pProp->name);
        }

        WBDebugPrint("    %-16s  %ld (%08lxH)\n",
                     temp, pProp->card32, pProp->card32);
      }
    }
  }

  WBDebugPrint("%s", "\n***************\n");

  if(pFSInfo)
  {
    XFreeFontInfo(ppNames, pFSInfo, iCount);
  }
  else
  {
    XFreeFontNames(ppNames);
  }
}

static __inline__ int __string_valid_check(const char *pString) { return pString && *pString; }

static void InternalBuildFontString(const char *szFontName, int iSize, int iFlags,
                                    char *pBuf, int cbBuf, int bForceWildcard)
{
  char *p1, /* *p2,*/ *pEnd;
  char tbuf[64];
  int iAvgWidth;
  WB_FONT_INFO *pFI = WBParseFontName(szFontName);

  if(!pFI)
  {
    strncpy(pBuf, szFontName, cbBuf);
    return;
  }

  p1 = pBuf;
  pEnd = pBuf + cbBuf;

  // build the string using 'pFI' and iFlags

#define DO_FONT_BUILD_THING(X) if((p1 + 2) >= pEnd) return; *(p1++) = '-'; \
  if(__string_valid_check(X)) { strncpy(p1, X, (pEnd - p1)); p1 += strlen(p1); } else *(p1++) = '*'; \
  *p1 = 0; if((p1 + 1) >= pEnd) return

  DO_FONT_BUILD_THING(pFI->szFoundry);
  DO_FONT_BUILD_THING(pFI->szFamily);

  *tbuf = 0;
  switch(pFI->iWeight)
  {
    case 1:
      strcpy(tbuf, "regular");
      break;
    case 2:
      strcpy(tbuf, "medium");
      break;
    case 3:
      strcpy(tbuf, "demibold");
      break;
    case 4:
      strcpy(tbuf, "bold");
      break;
    case -1:
      strcpy(tbuf, "*");
      break;
    default:
      *tbuf = 0;
  }

  switch(iFlags & WBFontFlag_WT_MASK)  // iFlags overrides
  {
    case WBFontFlag_WT_REGULAR:
      strcpy(tbuf, "regular");
      break;
    case WBFontFlag_WT_MEDIUM:
      strcpy(tbuf, "medium");
      break;
    case WBFontFlag_WT_DEMIBOLD:
      strcpy(tbuf, "demibold");
      break;
    case WBFontFlag_WT_BOLD:
      strcpy(tbuf, "bold");
      break;
    case WBFontFlag_WT_ANY:
      if(bForceWildcard || !*tbuf)
        strcpy(tbuf, "*");
      break;
  }

  DO_FONT_BUILD_THING(tbuf);  // commit what I just did

  *tbuf = 0;
  switch(pFI->iSlant)
  {
    case 1:
      strcpy(tbuf, "r");
      break;
    case 2:
      strcpy(tbuf, "o");
      break;
    case 3:
      strcpy(tbuf, "i");
      break;
    case -1:
      strcpy(tbuf, "*");
      break;
    default:
      *tbuf = 0;
  }

  switch(iFlags & WBFontFlag_SLANT_MASK)  // iFlags overrides
  {
    case WBFontFlag_SLANT_REGULAR:
      strcpy(tbuf, "r");
      break;
    case WBFontFlag_SLANT_OBLIQUE:
      strcpy(tbuf, "o");
      break;
    case WBFontFlag_SLANT_ITALIC:
      strcpy(tbuf, "i");
      break;
    case WBFontFlag_SLANT_ANY:
      if(bForceWildcard || !*tbuf)
        strcpy(tbuf, "*");
      break;
  }

  DO_FONT_BUILD_THING(tbuf);  // commit what I just did

  *tbuf = 0;
  switch(pFI->iWidth)
  {
    case 1:
      strcpy(tbuf, "normal");
      break;
    case 2:
      strcpy(tbuf, "semicondensed");
      break;
    case 3:                        // RESERVED (may not matter)
      strcpy(tbuf, "condensed");  // for now I have it here anyway
      break;
    case -1:
      strcpy(tbuf, "*");
      break;
    default:
      *tbuf = 0;
  }

  switch(iFlags & WBFontFlag_WIDTH_MASK)
  {
    case WBFontFlag_WIDTH_NORMAL:
      strcpy(tbuf, "normal");
      break;
    case WBFontFlag_WIDTH_SEMICOND:
      strcpy(tbuf, "semicondensed");
      break;
    case WBFontFlag_WIDTH_ANY:
      if(bForceWildcard || !*tbuf)
        strcpy(tbuf, "*");
      break;
  }

  DO_FONT_BUILD_THING(tbuf);  // commit what I just did

  strncpy(tbuf, pFI->szAdStyle, sizeof(tbuf));

  // if I'm insisting on serif then this must be blank
  switch(iFlags & WBFontFlag_STYLE_MASK)
  {
    case WBFontFlag_STYLE_SANS:
      strcpy(tbuf, "sans");
      break;
    case WBFontFlag_STYLE_SERIF:
      *tbuf = 0;
      break;
    case WBFontFlag_STYLE_ANY:
      if(bForceWildcard)
        strcpy(tbuf, "*");
      break;
  }

  DO_FONT_BUILD_THING(tbuf);

  // NOTE:  if I specify pixel size, then point size must be a wildcard
  //        unless the pixel size is <= 0 (and vice versa)

  iAvgWidth = pFI->iAvgWidth;

  if((iFlags & WBFontFlag_SIZE_MASK) == WBFontFlag_SIZE_PIXELS)
  {
    if(pFI->iPixelSize > 0 && iSize < 0 && !bForceWildcard)
      sprintf(tbuf, "%d", pFI->iPixelSize);
    else if(iSize > 0)
    {
      if(pFI->iPixelSize != iSize)
        iAvgWidth = -1;  // force this to be a wildcard
      sprintf(tbuf, "%d", iSize);
    }
    else
      strcpy(tbuf, "*");

    DO_FONT_BUILD_THING(tbuf);

    if(pFI->iPointSize > 0 && !bForceWildcard)
    {
      if(iSize <= 0 || iSize == pFI->iPixelSize)
        sprintf(tbuf, "%d", pFI->iPointSize);
      else
        sprintf(tbuf, "%d", ((pFI->iPointSize * 2 * iSize / pFI->iPixelSize) + 1) / 2);
    }
    else
      strcpy(tbuf, "*");

    DO_FONT_BUILD_THING(tbuf);
  }
  else if((iFlags & WBFontFlag_SIZE_MASK) == WBFontFlag_SIZE_POINTS ||
          (iFlags & WBFontFlag_SIZE_MASK) == WBFontFlag_SIZE_TWIPS)
  {
    if(pFI->iPointSize > 0 && !bForceWildcard)
    {
      if(iSize < 0 ||
         ((iFlags & WBFontFlag_SIZE_MASK) == WBFontFlag_SIZE_POINTS
          && iSize * 10 == pFI->iPointSize) ||
         ((iFlags & WBFontFlag_SIZE_MASK) == WBFontFlag_SIZE_TWIPS
          && iSize / 2 == pFI->iPointSize))
      {
        sprintf(tbuf, "%d", pFI->iPixelSize);
      }
      else if(!iSize)
      {
        strcpy(tbuf, "*");
      }
      else if((iFlags & WBFontFlag_SIZE_MASK) == WBFontFlag_SIZE_POINTS)
      {
        sprintf(tbuf, "%d", ((pFI->iPixelSize * 20 * iSize / pFI->iPointSize) + 1) / 2);
      }
      else
      {
        sprintf(tbuf, "%d", ((pFI->iPixelSize * iSize / pFI->iPointSize) + 1) / 2);
      }
    }
    else
      strcpy(tbuf, "*");

    DO_FONT_BUILD_THING(tbuf);

    if(pFI->iPointSize > 0 && iSize < 0 && !bForceWildcard)
      sprintf(tbuf, "%d", pFI->iPointSize);
    else if(iSize > 0)
    {
      if((iFlags & WBFontFlag_SIZE_MASK) == WBFontFlag_SIZE_POINTS)
      {
        sprintf(tbuf, "%d", iSize * 10);
        if(pFI->iPointSize != iSize * 10)
          iAvgWidth = -1;  // force this to be a wildcard
      }
      else
      {
        sprintf(tbuf, "%d", iSize / 2);
        if(pFI->iPointSize != iSize / 2)
          iAvgWidth = -1;  // force this to be a wildcard
      }
    }
    else
      strcpy(tbuf, "*");

    DO_FONT_BUILD_THING(tbuf);
  }
  else // a 'just in case' catchall
  {
    if(pFI->iPixelSize > 0 && !bForceWildcard)
      sprintf(tbuf, "%d", pFI->iPixelSize);
    else
      strcpy(tbuf, "*");

    DO_FONT_BUILD_THING(tbuf);

    if(pFI->iPointSize > 0 && !bForceWildcard)
      sprintf(tbuf, "%d", pFI->iPointSize);
    else
      strcpy(tbuf, "*");

    DO_FONT_BUILD_THING(tbuf);
  }

  if(!bForceWildcard && pFI->iResX > 0)  // for now wildcard applies to resX
    sprintf(tbuf, "%d", pFI->iResX);
  else
    strcpy(tbuf, "*");

  DO_FONT_BUILD_THING(tbuf);

  if(!bForceWildcard && pFI->iResY > 0)  // for now wildcard applies to resY
    sprintf(tbuf, "%d", pFI->iResY);
  else
    strcpy(tbuf, "*");

  DO_FONT_BUILD_THING(tbuf);

  *tbuf = 0;
  switch(pFI->iSpacing)
  {
    case 1:
      strcpy(tbuf, "c");
      break;
    case 2:
      strcpy(tbuf, "m");
      break;
    case 7:
      strcpy(tbuf, "p");
      break;
    case -1:
      strcpy(tbuf, "*");
      break;
  }

  switch(iFlags & WBFontFlag_PITCH_MASK)
  {
    case WBFontFlag_PITCH_FIXED:
      strcpy(tbuf, "m");
      break;
    case WBFontFlag_PITCH_CONDENSED:
      strcpy(tbuf, "c");
      break;
    case WBFontFlag_PITCH_VARIABLE:
      strcpy(tbuf, "p");
      break;
    case WBFontFlag_PITCH_ANY:
      if(!*tbuf || bForceWildcard)
        strcpy(tbuf, "*");
      break;
  }

  DO_FONT_BUILD_THING(tbuf);

  // average width (with forced wildcard, ALWAYS make it a wildcard; else actual value)
  if(bForceWildcard || iAvgWidth <= 0) // cached from above
    strcpy(tbuf, "*");
  else
    sprintf(tbuf, "%d", pFI->iAvgWidth);

  DO_FONT_BUILD_THING(tbuf);

  // registry + encoding

  if(!bForceWildcard || pFI->szRegistry[0]) // wildcard for a blank implies '*'
    strcpy(tbuf, pFI->szRegistry);
  else
    strcpy(tbuf, "*");

  // TODO:  the effect of 'iFlags' on these two

  DO_FONT_BUILD_THING(tbuf);

  if(!bForceWildcard || pFI->szEncoding[0]) // wildcard for a blank implies '*'
    strcpy(tbuf, pFI->szEncoding);
  else
    strcpy(tbuf, "*");

  DO_FONT_BUILD_THING(tbuf);
}

XFontStruct *WBLoadFont(Display *pDisplay, const char *szFontName,
                        int iFontSize, int iFlags)
{
XFontStruct *pRval=NULL, *pFSInfo=NULL;
char **ppNames;
int i1, i2, i3, iBest, iCount = 0, iWildcardFlag = 0;
char tbuf[512], tbuf2[512], tbuf3[512];

// font names follow one of these patterns...
//
// AliasName (not preceded by a '-')
//
//   or
//
// -foundry-family-weight-slant-sWidth-adstyle-pixelsize-pointsize-resX-resY-spacing-avgwidth-registry-encoding
//
// foundry = adoby, b&h, xfree86, etc.
// family = lucida, terminal, courier, etc.
// weight = bold, demibold, medium, regular
// slant = i, o, r (italic, oblique???, regular???)
// sWidth = normal, semicondensed
// adstyle = (blank), sans, ja, ko, ???
// pixelsize = height in pixels
// pointsize = width in 10*points
// resX, resY = resolution?
// spacing = c, m, p (condensed, medium, proportional)
// avgWidth (in points?)
// registry (i.e. 'iso8859' etc.)
// encoding (the '-' value following the registry, such as '1' for 'iso8859-1')


  // step 1:  if it's a font alias, get the REAL font info.  I'll need to do this if I'm requesting
  //          a bold or italic version of an aliased font, or even a different size.

  if(szFontName && *szFontName && !strchr(szFontName, '*') && !strchr(szFontName,'-'))
  {
    // get the alias name
    WBFontNameFromAlias(szFontName, tbuf, sizeof(tbuf));

    if(!*tbuf)
    {
      strcpy(tbuf, "-*-");
      strncpy(tbuf + 3, szFontName, sizeof(tbuf) - 3);
    }
  }
  else
  {
    iWildcardFlag = 1;  // additional information

    strncpy(tbuf, szFontName, sizeof(tbuf));
  }

  // at this point 'tbuf' is assumed to be a properly formatted font string

  if(iFlags || iFontSize)
  {
    InternalBuildFontString(tbuf, iFontSize, iFlags, tbuf2, sizeof(tbuf2), FALSE);
//    fprintf(stderr, "TEMPORARY:  font string %s\n", tbuf2);
  }
  else
    strncpy(tbuf2, tbuf, sizeof(tbuf2));

  ppNames = XListFontsWithInfo(pDisplay, tbuf2, 2, &iCount, &pFSInfo);

  // in this case if I only have one font returned, and there are no overrides in iFlags,
  // then that's the one I use.  This is the simplest form of font mapping

  if(iCount == 1 && ppNames)  // there is only a single match
    pRval = XLoadQueryFont(pDisplay, *ppNames);

  if(ppNames)
  {
    XFreeFontInfo(ppNames, pFSInfo, iCount);
    ppNames = NULL;
    pFSInfo = NULL;
    iCount = 0;
  }

  if(pRval)
    return pRval;

  // no match or multi-match - use wildcards, pick "the best one"

  InternalBuildFontString(tbuf, iFontSize, iFlags, tbuf3, sizeof(tbuf3), TRUE);
//  fprintf(stderr, "TEMPORARY:  font string 2 %s\n", tbuf3);

  ppNames = XListFontsWithInfo(pDisplay, tbuf3, 8192, &iCount, &pFSInfo);

  if(ppNames && iCount == 1)
  {
    pRval = XLoadQueryFont(pDisplay, *ppNames);
  }
  else if(ppNames && iCount > 1)
  {
    iBest = -1;
    for(i1 = 0, i2 = -1; i1 < iCount; i1++)
    {
      i3 = InternalFontMatch2(ppNames[i1], tbuf2);  // compare with non-forced-wildcard version
      if(i3 > iBest)
      {
        iBest = i3;
        i2 = i1;
      }
    }

    if(i2 >= 0)
    {
      pRval = XLoadQueryFont(pDisplay, ppNames[i2]);
//      fprintf(stderr, "TEMPORARY 3:  best match %s\n", ppNames[i2]);
    }
  }

  if(ppNames)
  {
    XFreeFontInfo(ppNames, pFSInfo, iCount);
    ppNames = NULL;
    pFSInfo = NULL;
    iCount = 0;
  }

  // TODO:  other forms of 'fuzzy' matching?

  return pRval;
}

XFontStruct *WBLoadModifyFont(Display *pDisplay, const XFontStruct *pOriginal,
                              int iFontSize, int iFlags)
{
unsigned long lName;
char *pName = NULL;
XFontStruct *pRval;

    // step 1:  generate font string from XFontStruct

  if(!pOriginal)
    return NULL;

  if(XGetFontProperty((XFontStruct *)pOriginal, XA_FONT, &lName))
  {
    pName = XGetAtomName(pDisplay ? pDisplay : WBGetDefaultDisplay(), (Atom)lName);

    if(!pName && pDisplay)
    {
      pName = XGetAtomName(WBGetDefaultDisplay(), (Atom)lName);
    }
  }

  if(!pName)
  {
    return NULL;
  }

  // if the user specified 'iFontSize' of zero, and did NOT include any
  // font size flags, make sure I duplicate the correct font size

  if(!iFontSize)
  {
    WB_FONT_INFO *pFI = WBParseFontName(pName);

    iFlags &= ~WBFontFlag_SIZE_MASK; // reserved for the future

    if(pFI)
    {
      if(pFI->iPixelSize > 0)
      {
        iFontSize = pFI->iPixelSize;
        iFlags |= WBFontFlag_SIZE_PIXELS;
      }
      else if(pFI->iPointSize > 0)
      {
        iFontSize = pFI->iPointSize;
        iFlags |= WBFontFlag_SIZE_POINTS;
      }
      else
      {
        free(pFI);
        pFI = NULL; // flag (see below)
      }
    }

    if(!pFI)
    {
      iFontSize = pOriginal->ascent + pOriginal->descent;
      iFlags |= WBFontFlag_SIZE_PIXELS;
    }
    else
    {
      free(pFI);
    }
  }

  // POOBAH

  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Font,
                 "%s(%s)\n", __FUNCTION__, pName);

  pRval = WBLoadFont(pDisplay, pName, iFontSize, iFlags);

  XFree(pName); // required

  if(!pRval)
  {
    return XLoadQueryFont(pDisplay, pName);  // a copy of the original
  }

#ifndef NO_DEBUG /* assign this to disable debugging - most likely a -D in Makefile */
  if((WBGetDebugLevel() & DebugLevel_MASK) >= FONT_DUMP_DEBUG_LEVEL ||
     (WBGetDebugLevel() & DebugSubSystem_Font))
  {
    WBDumpFontStruct(pRval);
  }
#endif // NO_DEBUG

  return pRval;  // the NEW font!
}


XFontSet WBFontSetFromFont(Display *pDisplay, const XFontStruct *pFont)
{
unsigned long lName;
char *pName = NULL;
XFontSet rVal = None;
char **ppMissing = NULL;
int nMissing = 0;
char *pDef = NULL;
char *p1;
static const char szISO[]="-ISO8859-";

  // step 1:  generate font string from XFontStruct

  if(!pFont)
  {
    pFont = WBGetDefaultFont();
    if(!pFont)
    {
      WB_ERROR_PRINT("%s - no font, returning NULL\n", __FUNCTION__);
      return NULL;
    }
  }

  if(XGetFontProperty((XFontStruct *)pFont, XA_FONT, &lName))
  {
    pName = XGetAtomName(pDisplay ? pDisplay : WBGetDefaultDisplay(), (Atom)lName);

    if(!pName && pDisplay)
    {
      pName = XGetAtomName(WBGetDefaultDisplay(), (Atom)lName);
    }
  }

  if(pName) // make a copy of 'pName' so that I can edit it
  {
    p1 = WBCopyString(pName);
    XFree(pName);
    if(p1)
    {
      pName = p1; // I can edit the copy
    }
  }

  if(!pName)
  {
    WB_ERROR_PRINT("%s - no font name, returning NULL\n", __FUNCTION__);
    return NULL;
  }

//  WB_ERROR_PRINT("TEMPORARY:  %s font name is \"%s\"\n", __FUNCTION__, pName);

  // using the font's name string, create a single entry font set for it
  // if the final entry is ISO8859-# change it to *-*

  // TODO:  check for other language-dependent things, or maybe just do the last 2 '-'s ?

  p1 = pName + strlen(pName) - sizeof(szISO);
  while(p1 > pName && strncmp(p1, szISO, sizeof(szISO)-1))
  {
    p1--;
  }
  if(p1 > pName) // found
  {
//    static int iOnce = 0;
//    if(!iOnce)
//    {
//      WB_ERROR_PRINT("TEMPORARY %s changing \"%s\" to \"-*-*\"\n", __FUNCTION__, p1);
//    }

    strcpy(p1, "-*-*");

//    if(!iOnce)
//    {
//      iOnce++;
//      WBDumpFontInfo(pName);
//    }
  }

  rVal = XCreateFontSet(pDisplay, pName, &ppMissing, &nMissing, &pDef);

  // TODO:  dump info?

  if(ppMissing)
  {
//    int i1;
//    for(i1=0; i1 < nMissing; i1++)
//    {
//      WB_ERROR_PRINT("MISSING %d : %s\n", i1, ppMissing[i1]);
//    }

    XFreeStringList(ppMissing);
  }

//  if(pDef) DO NOT DO THIS!
//  {
//    XFree(pDef); // NO NO NO (warning)
//  }

//  XFree(pName); // I made a copy of it...
  free(pName);

  if(!rVal)
  {
    WB_ERROR_PRINT("%s - no result, returning NULL\n", __FUNCTION__);
  }

  return rVal;
}



#ifndef NO_DEBUG

static void WBDumpFontStruct(XFontStruct *pFont)
{
int i1;

  typedef struct {
      XExtData *ext_data;      /* hook for extension to hang data */
      Font fid;                /* Font id for this font */
      unsigned direction;      /* hint about the direction font is painted */
      unsigned min_char_or_byte2;/* first character */
      unsigned max_char_or_byte2;/* last character */
      unsigned min_byte1;      /* first row that exists */
      unsigned max_byte1;      /* last row that exists */
      Bool all_chars_exist;    /* flag if all characters have nonzero size */
      unsigned default_char;   /* char to print for undefined character */
      int n_properties;        /* how many properties there are */
      XFontProp *properties;   /* pointer to array of additional properties */
      XCharStruct min_bounds;  /* minimum bounds over all existing char */
      XCharStruct max_bounds;  /* maximum bounds over all existing char */
      XCharStruct *per_char;   /* first_char to last_char information */
      int ascent;              /* logical extent above baseline for spacing */
      int descent;             /* logical decent below baseline for spacing */
  } XFontStruct;


  WB_WARN_PRINT("WBDumpFontStruct(%pH)\n", pFont);
  WB_WARN_PRINT("    ext_data         = %pH\n"
                "    fid              = %d (%08xH)\n"
                "    direction        = %d\n"
                "    min_char_or_byte2= %d\n"
                "    max_char_or_byte2= %d\n"
                "    min_byte1        = %d\n"
                "    max_byte1        = %d\n"
                "    all_chars_exist  = %d\n"
                "    default_char     = %d\n"
                "    n_properties     = %d\n",
                pFont->ext_data,
                (int)pFont->fid, (int)pFont->fid,
                pFont->direction,
                pFont->min_char_or_byte2,
                pFont->max_char_or_byte2,
                pFont->min_byte1,
                pFont->max_byte1,
                pFont->all_chars_exist,
                pFont->default_char,
                pFont->n_properties);

  for(i1=0; i1 < pFont->n_properties; i1++)
  {
    WB_WARN_PRINT("      %5d %-20s = %ld (%08lxH) %s\n",
                  (int)pFont->properties[i1].name,
                  XGetAtomName(WBGetDefaultDisplay(), pFont->properties[i1].name),
                  pFont->properties[i1].card32,
                  pFont->properties[i1].card32,
                  XGetAtomName(WBGetDefaultDisplay(), (Atom)pFont->properties[i1].card32));
  }

  WB_WARN_PRINT("    ascent           = %d\n"
                "    descent          = %d\n",
                pFont->ascent,
                pFont->descent);
}
#endif // NO_DEBUG

