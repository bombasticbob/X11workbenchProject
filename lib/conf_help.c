//////////////////////////////////////////////////////////////////////////////////////////
//                                  __     _            _                               //
//               ___  ___   _ __   / _|   | |__    ___ | | _ __     ___                 //
//              / __|/ _ \ | '_ \ | |_    | '_ \  / _ \| || '_ \   / __|                //
//             | (__| (_) || | | ||  _|   | | | ||  __/| || |_) |_| (__                 //
//              \___|\___/ |_| |_||_|_____|_| |_| \___||_|| .__/(_)\___|                //
//                                  |_____|               |_|                           //
//                                                                                      //
//                helper API for 'conf' files (global and per-user)                     //
//                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2019 by Bob Frazier (aka 'Big Bad Bombastic Bob')


  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.
               Any claims to alleged functionality or features should be
               considered 'preliminary', and might not function as advertised.

  MIT-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  MIT-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

/** \file conf_help.c
  * \brief 'configuration helper' implementation file for the X11 Work Bench Toolkit API
  *
  * X11 Work Bench Toolkit Toolkit API
*/


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/param.h> // for MAXPATHLEN and PATH_MAX (also includes limits.h in some cases)
#include <fcntl.h>
#include <netinet/in.h> // for htonl, htons, etc.
#include <X11/Xlib.h>
#include "conf_help.h"
#include "file_help.h"

#include "window_helper.h" // for debug stuff
#include "draw_text.h" // string-related stuff


// STRUCTURES

typedef struct _CONF_FILE_
{
  int iGlobal, iLocal;  // handles for global and local (typically read-only on global)
  int iOffsGlobal, iOffsLocal;  // offset in struct to global and local conf file names

  char *pBuf;  // a buffer for storing file names and other variable length data

  int cbBuf, cbBufMax;   // current size and max size of 'pBuf'

  file_help_buf_t *pfhbL, *pfhbG;  // local and global file help buffers

} CONF_FILE;


// GLOBAL VARIABLES

static const char * const *argv_copy = NULL;
static int argc_copy = 0;

static CHXSettings *pXSettings = NULL;


// PROTOTYPES

static void __settings_cleanup(void);



// INLINE UTILITIES

static __inline__ void trim_ends(const char **ppLeft, const char **ppRight)
{
  const char *p1=*ppLeft, *p2 = *ppRight;
  while(p1 < p2 && *p1 <= ' ')
  {
    p1++;
  }
  while(p2 > p1 && *(p2 - 1) <= ' ')
  {
    p2--;
  }

  *ppLeft = p1;
  *ppRight = p2;
}

static __inline__ char * DoMakePath(char *pSrc, const char *szPath, const char *szName, const char *szExt)
{
  const char *p1;
  char *pRval = pSrc;

  for(p1=szPath; *p1; p1++)
  {
    *(pRval++) = *p1;
  }

  if(*szPath && *(p1 - 1) != '/')
  {
    *(pRval++) = '/';  // add a slash to the end of the path
  }

  for(p1=szName; *p1; p1++)
  {
    *(pRval++) = *p1;
  }

  for(p1=szExt; *p1; p1++)
  {
    *(pRval++) = *p1;
  }

  *(pRval++) = 0;
  *pRval = 0;

  return pRval;
}


// initialization and termination

void CHRegisterArgs(int argc, char **argv)
{
  argc_copy = argc;
  argv_copy = (const char * const *)argv;

//  CHSettingsRefresh(); // let window_helper do this
}

void CHOnExit(void)
{
  // TODO:  uninitialization

  __settings_cleanup();
}



// atoms for querying settings manager
// for description on usage and format, see
//     http://standards.freedesktop.org/xsettings-spec/xsettings-spec-0.5.html
// selection atom:  _XSETTINGS_S#  where '#' is the screen ID formatted as %d
// xsettings atom:  _XSETTINGS_SETTINGS
// manager atom:    MANAGER
// use 'XInternAtom(display, szNAME, False)' to create an atom

// default GTK style colors:
//#define GTK_GRAY                0xdcdc, 0xdada, 0xd5d5
//#define GTK_DARK_GRAY           0xc4c4, 0xc2c2, 0xbdbd
//#define GTK_LIGHT_GRAY          0xeeee, 0xebeb, 0xe7e7
//#define GTK_WHITE               0xffff, 0xffff, 0xffff
//#define GTK_BLUE                0x4b4b, 0x6969, 0x8383
//#define GTK_VERY_DARK_GRAY      0x9c9c, 0x9a9a, 0x9494
//#define GTK_BLACK               0x0000, 0x0000, 0x0000
//#define GTK_WEAK_GRAY           0x7530, 0x7530, 0x7530

// NOTE:  use 'xrdb -query -all' as a hint of what the resource database has in it
//        use XScreenResourceString and XResourceManagerString to get the data
//        (it will need parsing)
//        ALSO see docs on 'listres' for 'widget-related' resource information



// OLD version - uses XResourceManagerSring and XScreenResourceString (deprecated)
// this version typically won't return anything useful any more.

int CHGetResourceString_Old(Display *pDisplay, const char *szIdentifier, char *szData, int cbData)
{
char *pData;
Screen *pScreen;
const char *p1, *p2, *p3;
int iRval = -1, iLen;

  iLen = strlen(szIdentifier);

  if(!iLen)
  {
    return -1;
  }

  pScreen = XDefaultScreenOfDisplay((Display *)pDisplay);
          // was (Screen *)XDefaultScreen((Display *)pDisplay);

  if(pScreen)
  {
    pData = XScreenResourceString(pScreen);
  }
  else
  {
    pData = NULL;
  }

  if(!pData)
  {
    pData = XResourceManagerString((Display *)pDisplay);
  }

  if(!pData)
  {
    return -1;
  }

  p1 = pData;
  while(*p1)
  {
    p2 = p1;
    while(*p1 && *p1 != '\n')
    {
      p1++;
    }

    p3 = p2;
    while(p3 < p1 && *p3 != ':')
    {
      p3++;
    }

    if(*p3 == ':')
    {
      if(iLen == (p3 - p2) &&
         !strncasecmp(p2, szIdentifier, iLen))
      {
        p3++;
        while(p3 < p1 && *p3 <= ' ')
        {
          p3++;
        }
        iRval = cbData - 1;
        if((p1 - p3) < (cbData - 1))
        {
          iRval = p1 - p3;
        }
        memcpy(szData, p3, iRval);
        szData[iRval] = 0;
        return iRval;
      }
    }

    while(*p1 && *p1 <= ' ')
    {
      p1++;
    }
  }

  // pass 2 - inexact matches

  if(szIdentifier[0] != '*' || !szIdentifier[1])
  {
    return -1;
  }

  p1 = pData;
  while(*p1)
  {
    p2 = p1;
    while(*p1 && *p1 != '\n')
    {
      p1++;
    }

    p3 = p2;
    while(p3 < p1 && *p3 != ':')
    {
      p3++;
    }

    if(*p3 == ':')
    {
      if((p2 + iLen - 1) <= p3)
      {
        if(!strncasecmp(p3 - iLen + 1, szIdentifier + 1, iLen - 1) &&
           (p2 == (p3 - iLen + 1) || *(p3 - iLen) == '.'))
        {
          p3++;
          while(p3 < p1 && *p3 <= ' ')
          {
            p3++;
          }
          iRval = cbData - 1;
          if((p1 - p3) < (cbData - 1))
          {
            iRval = p1 - p3;
          }
          memcpy(szData, p3, iRval);
          szData[iRval] = 0;
          break;
        }
      }
    }

    while(*p1 && *p1 <= ' ')
      p1++;
  }

  return iRval;
}


static const char * TranslateColorRequest(const char *szIdentifier)
{
int iLen;

  if(szIdentifier[0] != '*')
  {
    // is it one of the color names I might return?

    if(!strcmp(szIdentifier, "fg_color") ||
       !strcmp(szIdentifier, "bg_color") ||
       !strcmp(szIdentifier, "text_color") ||
       !strcmp(szIdentifier, "base_color") ||
       !strcmp(szIdentifier, "selected_fg_color") ||
       !strcmp(szIdentifier, "selected_bg_color") ||
       !strcmp(szIdentifier, "tooltip_fg_color") ||
       !strcmp(szIdentifier, "tooltip_bg_color"))
    {
//      WB_ERROR_PRINT("TEMPORARY:  %s - returning %s 'pass through'\n", __FUNCTION__, szIdentifier);
      return szIdentifier;
    }

    // TODO:  any OTHER pre-qualifiers?  or is returning 'NULL' correct?
    //        perhaps having the suffix '_color' ?

    return NULL;
  }

  // SPECIAL entries come first

  // menu colors slightly different

  if(!strcmp(szIdentifier, "*Menu.activeForeground"))
  {
    return "selected_fg_color";
  }

  if(!strcmp(szIdentifier, "*Menu.activeBackground"))
  {
    return "selected_bg_color";
  }

  // and text box and list box use 'input' colors

  if(!strcmp(szIdentifier, "*Text.foreground") ||
     !strcmp(szIdentifier, "*List.foreground") ||
     !strcmp(szIdentifier, "*Combo.foreground"))
  {
    return "text_color";
  }

  if(!strcmp(szIdentifier, "*Text.background") ||
     !strcmp(szIdentifier, "*List.background") ||
     !strcmp(szIdentifier, "*Combo.background"))
  {
    return "base_color";
  }


  // and then the (other) generic ones

  iLen = strlen(szIdentifier);

  if(iLen >= 11 &&
     (iLen == 11 || szIdentifier[iLen - 11] == '.') &&
     !strcmp(szIdentifier + iLen - 10, "foreground"))
  {
    return "fg_color";
  }

  if(iLen >= 11 &&
     (iLen == 11 || szIdentifier[iLen - 11] == '.') &&
     !strcmp(szIdentifier + iLen - 10, "background"))
  {
    return "bg_color";
  }

  if(iLen >= 7 &&
     (iLen == 7 || szIdentifier[iLen - 7] == '.') &&
     !strcmp(szIdentifier + iLen - 6, "border"))
  {
    return "fg_color"; // TODO:  return NULL instead?
  }

  if(iLen >= 12 &&
     (iLen == 12 || szIdentifier[iLen - 12] == '.') &&
     !strcmp(szIdentifier + iLen - 11, "borderColor"))
  {
    return "fg_color"; // TODO:  return NULL instead? or actual color?
  }

  if(iLen >= 17 &&
     (iLen == 17 || szIdentifier[iLen - 17] == '.') &&
     !strcmp(szIdentifier + iLen - 16, "activeForeground"))
  {
    return "text_color"; // instead of 'fg_color'
  }

  if(iLen >= 17 &&
     (iLen == 17 || szIdentifier[iLen - 17] == '.') &&
     !strcmp(szIdentifier + iLen - 16, "activeBackground"))
  {
    return "base_color"; // "bg_color"; - TODO:  derive this maybe?
  }

  if(iLen >= 17 &&
     (iLen == 17 || szIdentifier[iLen - 17] == '.') &&
     !strcmp(szIdentifier + iLen - 16, "selectForeground"))
  {
    return "selected_fg_color";
  }

  if(iLen >= 17 &&
     (iLen == 17 || szIdentifier[iLen - 17] == '.') &&
     !strcmp(szIdentifier + iLen - 16, "selectBackground"))
  {
    return "selected_bg_color";
  }

  if(iLen >= 20 &&
     (iLen == 20 || szIdentifier[iLen - 20] == '.') &&
     !strcmp(szIdentifier + iLen - 19, "highlightForeground"))
  {
    return "selected_fg_color";
  }

  if(iLen >= 20 &&
     (iLen == 20 || szIdentifier[iLen - 20] == '.') &&
     !strcmp(szIdentifier + iLen - 19, "highlightBackground"))
  {
    return "selected_bg_color";
  }

  // TODO:  others (like tooltips) - might return  text_color, base_color, tooltip_fg_color, tooltip_bg_color


  return NULL; // not recognized
}


int CHGetResourceString(Display *pDisplay, const char *szIdentifier, char *szData, int cbData)
{
int iRval = -1;//, iFormat;

  // TODO:  use XSETTINGS first, then resource manager
  // TODO:  see listres and appres and the 'X TOOLKIT' resource management system

// gnome config may have more useful information, see
// http://developer.gnome.org/integration-guide/stable/thumbnailer.html.en  (thumbnailers)
//
// main menu integration - /usr/[local/]share/applications and ~/.local/share/applications
// http://developer.gnome.org/integration-guide/stable/desktop-files.html.en
//
// and startup notification
// http://developer.gnome.org/integration-guide/stable/startup-notification.html.en
// http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt

  if(WB_LIKELY(pXSettings))
  {
    const CHXSetting *pXS;

    // mapping the string accordingly

    pXS = CHGetXSetting(pXSettings->pDisplay, szIdentifier); // exact match.

    if(!pXS)
    {
      // color schemes are stored hierarchically - look in Gtk/ColorScheme for now

      const char *pTemp = TranslateColorRequest(szIdentifier);

      if(pTemp && *pTemp)
      {
//        WB_ERROR_PRINT("TEMPORARY:  %s - found color %s from %s\n", __FUNCTION__, pTemp, szIdentifier);

        pXS = CHGetXSetting(pXSettings->pDisplay, "Gtk/ColorScheme"); // get color scheme info

        if(pXS && pXS->iType == XSettingsTypeString)
        {
          int iLen0 = strlen(pTemp);
          const char *p1 = pXS->uData.szData;
          // format is "colorname=#colordef\n"

          while(*p1)
          {
            const char *p2 = p1;

            p1 = p2;

            while(*p1 && *p1 != '\n')
            {
              p1++;
            }

//            WB_ERROR_PRINT("TEMPORARY:  %s - %-.*s\n", __FUNCTION__, p1 - p2, p2);

            if(!memcmp(p2, pTemp, iLen0) && p2[iLen0] == ':')
            {
              p2 = p2 + iLen0 + 1;
              iLen0 = p1 - p2;

              if(iLen0 >= cbData)
              {
                iLen0 = cbData - 1;
              }
              if(iLen0 > 0)
              {
                memcpy(szData, p2, iLen0);
              }

              szData[iLen0] = 0;
              return iLen0;
            }

            if(*p1 == '\n')
            {
              p1++;
            }
          }
        }

        pXS = NULL; // not found if it gets here
      }
    }

    if(pXS)
    {
      if(pXS->iType == XSettingsTypeInteger)
      {
        iRval = snprintf(szData, cbData, "%d", pXS->uData.iData);
      }
      else if(pXS->iType == XSettingsTypeString)
      {
        iRval = strlen(pXS->uData.szData);

        if(iRval >= cbData)
        {
          iRval = cbData - 1;
        }

        if(iRval > 0)
        {
          memcpy(szData, pXS->uData.szData, iRval);
        }

        szData[iRval] = 0;
      }
      else
      {
        iRval = -1; // for now... (later try and fix this)
      }
    }

//    iRval = something
  }

  if(iRval < 0)  // i.e. "not found"
  {
    return CHGetResourceString_Old(pDisplay, szIdentifier, szData, cbData); // fallback
  }

  return iRval;
}

int CHGetResourceInt(Display *pDisplay, const char *szIdentifier)
{
  int iLen;
  char tbuf[64];

  if((iLen = CHGetResourceString(pDisplay, szIdentifier, tbuf, sizeof(tbuf) - 1)) > 0)
  {
    tbuf[iLen] = 0;
    while(tbuf[0] && tbuf[0] <= ' ')
    {
      strcpy(tbuf, tbuf + 1);
    }

    if(tbuf[0])
    {
      return atoi(tbuf);
    }
  }

  return 0;
}



// argc/argv utilities (assigned via initialization)

int CHGetArgC()
{
  return argc_copy;
}

const char * const *CHGetArgV()
{
  return argv_copy;
}


// configuration file utilities

void * CHOpenConfFile(const char *szAppName, int iFlags)
{
  CONF_FILE *pRval;
  char *p1, *p2, *p3, *p4, /* *p5, */ *p6;
//  int i1;
  struct stat st;
//  file_help_buf_t *pFHB = NULL;

  static const char szGlobalPath[] = GLOBAL_PATH;
  static const char szGlobalXPath[] = GLOBAL_XPATH;
  static const char szLocalPath[] = LOCAL_PATH;
  static const char szConf[] = ".conf";
  char szLocalPath0[PATH_MAX];


  // create struct

  pRval = (CONF_FILE *)WBAlloc(sizeof(*pRval) + strlen(szAppName) * 4 + sizeof(szGlobalPath)
                               + sizeof(szGlobalXPath) + sizeof(szLocalPath) + 16 + PATH_MAX * 2);
  if(!pRval)
  {
    return NULL;
  }

  bzero(pRval, sizeof(*pRval));  // make sure it's zero'd out

  // construct file names

  p1 = (char *)pRval + sizeof(*pRval);  // this is the start of string buffers
  // it is also the global path, by default either /etc or /usr/local/etc

  p2 = DoMakePath(p1, szGlobalPath, szAppName, szConf);
  p3 = DoMakePath(p2, szGlobalXPath, szAppName, szConf);

  if(!(iFlags & CH_FLAGS_GLOBAL)) // not "global only"
  {
    // NOTE:  the new standard for config files is:
    //
    // ~/.config/application/whatever
    // ~/.local/share/application/whatever
    //
    // the old standard was ~/.application/whatever
    //
    // TODO:  a utility to move old files to new location?  yeah probably not...


    strcpy(szLocalPath0, szLocalPath); // ~/.local/share/
    if(!szLocalPath0[0] || szLocalPath0[strlen(szLocalPath0)-1] != '/') // unlikely
    {
      strcat(szLocalPath0, "/");
    }
//    strcat(szLocalPath0, "."); don't prepend a dot any more
    strncat(szLocalPath0, szAppName, sizeof(szLocalPath0) - strlen(szLocalPath0) - 1);  // now contains ~/.local/share/appname

    // make sure the directory 'szLocalPath0' exists
    p4 = WBGetCanonicalPath(szLocalPath0);
    if(p4)
    {
      if(!WBIsDirectory(p4)) // see if it exists first...
      {
        WBMkDir(p4, 0755); // TODO:  check user's UMASK ???
      }
      strncpy(szLocalPath0, p4, sizeof(szLocalPath0)); // the canonical path
      WBFree(p4);
    }

    if(szLocalPath0[strlen(szLocalPath0) - 1] != '/')
    {
      strcat(szLocalPath0, "/");
    }

    p4 = DoMakePath(p3, szLocalPath0, LOCAL_CONF_NAME, szConf); // first THIS one

    p6 = WBGetCanonicalPath(szLocalPath);
    if(p6)
    {
// NOTE:  p5 not being used; commented out because of linux gcc warnings
//      p5 = DoMakePath(p4, p6, szAppName, szConf); // then THIS one
      WBFree(p6);
    }
    else
    {
// NOTE:  p5 not being used; commented out because of linux gcc warnings
//      p5 = DoMakePath(p4, szLocalPath, szAppName, szConf); // alternate (uncanonical) name
    }
  }
  else
  {
    p4 = NULL;  // warning avoidance (uninitialized variable, actually won't matter)
  }

  if(!stat(p1, &st) && S_ISREG(st.st_mode))
  {
    if(iFlags & CH_FLAGS_WRITE)
    {
      pRval->iGlobal = open(p1,O_RDWR);
    }
    else
    {
      pRval->iGlobal = -1;
    }

    if(pRval->iGlobal == -1)
    {
      pRval->iGlobal = open(p1,O_RDONLY);
    }
  }

  if(pRval->iGlobal != -1)
  {
    pRval->iOffsGlobal = (int)(p1 - (char *)pRval);
  }
  else if(!stat(p2, &st) && S_ISREG(st.st_mode))
  {
    if(iFlags & CH_FLAGS_WRITE)
    {
      pRval->iGlobal = open(p2,O_RDWR);
    }
    else
    {
      pRval->iGlobal = -1;
    }
    if(pRval->iGlobal == -1)
    {
      pRval->iGlobal = open(p2,O_RDONLY);
    }
    if(pRval->iGlobal != -1)
    {
      pRval->iOffsGlobal = (int)(p2 - (char *)pRval);
    }
  }

  if(!(iFlags & CH_FLAGS_GLOBAL)) // not "global only"
  {
    // if local file does not exist, create it (always open read/write)

    if(!stat(p3, &st) && S_ISREG(st.st_mode))
    {
      pRval->iLocal = open(p3,O_RDWR);
    }
    else
    {
      pRval->iLocal = open(p3,O_CREAT|O_RDWR,0644); // use 0644 for now - TODO:  check umask
    }

    if(pRval->iLocal != -1)
    {
      pRval->iOffsLocal = (int)(p3 - (char *)pRval);
    }
    else // try the OTHER local
    {
      // if local file does not exist, create it (always open read/write)

      if(!stat(p4, &st) && S_ISREG(st.st_mode))
      {
        pRval->iLocal = open(p4,O_RDWR);
      }
      else
      {
        pRval->iLocal = open(p4,O_CREAT|O_RDWR,0644); // use 0644 for now - TODO:  check umask
      }

      if(pRval->iLocal != -1)
      {
        pRval->iOffsLocal = (int)(p4 - (char *)pRval);
      }
    }
  }
  else // GLOBAL ONLY
  {
    pRval->iLocal = -1;
    pRval->iOffsLocal = 0;
  }

  // next read and parse the files

  if(pRval->iLocal != -1)
  {
    pRval->pfhbL = FBGetFileBufViaHandle(pRval->iLocal);
    if(pRval->pfhbL)
    {
      FBParseFileBuf(pRval->pfhbL);
    }
    else
    {
      CHDestroyConfFile(pRval);
      return NULL;
    }
  }

  if(pRval->iGlobal != -1)
  {
    pRval->pfhbG = FBGetFileBufViaHandle(pRval->iGlobal);
    if(pRval->pfhbG)
    {
      FBParseFileBuf(pRval->pfhbG);
    }
    else
    {
      CHDestroyConfFile(pRval);
      return NULL;
    }
  }

  return pRval;
}

void CHCloseConfFile(void * pFile)
{
  CONF_FILE *pTemp = (CONF_FILE *)pFile;

  if(!pTemp)
  {
    return;
  }

  if(pTemp->iLocal != -1)
  {
    if(pTemp->pfhbL && FBIsFileBufDirty(pTemp->pfhbL))
    {
      FBWriteFileBufHandle(pTemp->iLocal, pTemp->pfhbL);
    }

    close(pTemp->iLocal);
    pTemp->iLocal = -1;
  }

  if(pTemp->iGlobal != -1)
  {
    if(pTemp->pfhbG && FBIsFileBufDirty(pTemp->pfhbG))
    {
      FBWriteFileBufHandle(pTemp->iGlobal, pTemp->pfhbG);
    }

    close(pTemp->iGlobal);
    pTemp->iGlobal = -1;
  }
}

void CHDestroyConfFile(void * pFile)
{
  CONF_FILE *pTemp = (CONF_FILE *)pFile;

  if(!pTemp)
  {
    return;
  }

  CHCloseConfFile(pFile);

  if(pTemp->pfhbL)
  {
    FBDestroyFileBuf(pTemp->pfhbL);
  }

  if(pTemp->pfhbG)
  {
    FBDestroyFileBuf(pTemp->pfhbG);
  }
}


// Utilities to find stuff within a config file
// on entry ppStart points to the beginning of the line, and ppEnd points to the end of it
// on return, ppStart points to the start of the data, ppEnd points to the end of it (excluding comments)

static void __get_line_strip_comments__(const char **ppStart, const char **ppEnd)
{
  const char *p1 = *ppStart, *p2 = *ppEnd;

  // skip leading white space
  while(p1 < p2 && *p1 <= ' ')
  {
    p1++;
  }
  if(p1 >= p2)
  {
    *ppStart = *ppEnd = p2;

    return;
  }

  *ppStart = p1;

  while(p1 < p2)
  {
    if(*p1 == '=')  // everything to the right of '=' isn't a comment
    {
      break;
    }

    if(*p1 == ';')  // comment?
    {
      p2 = p1;
      break;
    }

    p1++;
  }

  // now trim off any trailing white space
  p1 = *ppStart;
  while(p2 > p1 && *(p2 - 1) <= ' ')
  {
    p2--;
  }

  *ppEnd = p2;
}

static void __find_section__(void *hFile, const char *szSection,
                             const char **ppSection, const char **ppEndSection)
{
  int i1, /* i2,*/ iSectionLen;
  const char *p1, *p2, *pSection, *pEndSection;
  CONF_FILE *pTemp = (CONF_FILE *)hFile;

  *ppSection = pSection = NULL;
  *ppEndSection = pEndSection = NULL;

  if(!pTemp ||
     ((!pTemp->pfhbL || !pTemp->pfhbL->ppLineBuf) &&
      (!pTemp->pfhbG || !pTemp->pfhbG->ppLineBuf)))
  {
    return;
  }

  iSectionLen = strlen(szSection);

  if(pTemp->pfhbL)
  {
    for(i1=0; i1 < pTemp->pfhbL->lLineCount; i1++)
    {
      // search for the section header
      p1 = pTemp->pfhbL->ppLineBuf[i1];
      p2 = pTemp->pfhbL->ppLineBuf[i1 + 1];
      if(!p2)
      {
        p2 = pTemp->pfhbL->cData + pTemp->pfhbL->lBufferCount;
      }

      __get_line_strip_comments__(&p1, &p2);

      if((p2 - p1) >= iSectionLen + 2 && *p1 == '[' && *(p2 - 1) == ']')
      {
        p1++;
        p2--;
        trim_ends(&p1, &p2);
        if((p2 - p1) == iSectionLen && !strncasecmp(p1, szSection, iSectionLen))
        {
          pSection = pTemp->pfhbL->ppLineBuf[i1 + 1];
          break;
        }
      }
    }

    if(pSection)
    {
      // starting with the current position, keep going until I find another section

      for(i1++; i1 < pTemp->pfhbL->lLineCount; i1++)
      {
        // search for the section header
        p1 = pTemp->pfhbL->ppLineBuf[i1];
        p2 = pTemp->pfhbL->ppLineBuf[i1 + 1];
        if(!p2)
        {
          p2 = pTemp->pfhbL->cData + pTemp->pfhbL->lBufferCount;
        }

        __get_line_strip_comments__(&p1, &p2);

        if((p2 - p1) > 2 && *p1 == '[' && *(p2 - 1) == ']')
        {
          pEndSection = pTemp->pfhbL->ppLineBuf[i1];
          break;
        }
      }

      if(!pEndSection)
      {
        pEndSection = pTemp->pfhbL->cData + pTemp->pfhbL->lBufferCount;
      }

      // return values
      *ppSection = pSection;
      *ppEndSection = pEndSection;
    }
  }

  if(pTemp->pfhbG && !*ppSection) // not found yet
  {
    *ppSection = pSection = NULL; // make sure
    *ppEndSection = pEndSection = NULL;

    for(i1=0; i1 < pTemp->pfhbG->lLineCount; i1++)
    {
      // search for the section header
      p1 = pTemp->pfhbG->ppLineBuf[i1];
      p2 = pTemp->pfhbG->ppLineBuf[i1 + 1];
      if(!p2)
      {
        p2 = pTemp->pfhbG->cData + pTemp->pfhbG->lBufferCount;
      }

      __get_line_strip_comments__(&p1, &p2);

      if((p2 - p1) >= iSectionLen + 2 && *p1 == '[' && *(p2 - 1) == ']')
      {
        p1++;
        p2--;
        trim_ends(&p1, &p2);
        if((p2 - p1) == iSectionLen && !strncasecmp(p1, szSection, iSectionLen))
        {
          pSection = pTemp->pfhbG->ppLineBuf[i1 + 1];
          break;
        }
      }
    }

    if(!pSection)
    {
//      fprintf(stderr, "pSection is NULL\n");
      return;
    }

    // starting with the current position, keep going until I find another section

    for(i1++; i1 < pTemp->pfhbG->lLineCount; i1++)
    {
      // search for the section header
      p1 = pTemp->pfhbG->ppLineBuf[i1];
      p2 = pTemp->pfhbG->ppLineBuf[i1 + 1];
      if(!p2)
      {
        p2 = pTemp->pfhbG->cData + pTemp->pfhbG->lBufferCount;
      }

      __get_line_strip_comments__(&p1, &p2);

      if((p2 - p1) > 2 && *p1 == '[' && *(p2 - 1) == ']')
      {
        pEndSection = pTemp->pfhbG->ppLineBuf[i1];
        break;
      }
    }

    if(!pEndSection)
    {
      pEndSection = pTemp->pfhbG->cData + pTemp->pfhbG->lBufferCount;
    }

    // return values
    *ppSection = pSection;
    *ppEndSection = pEndSection;
  }

//  WB_ERROR_PRINT("TEMPORARY: %s \"%s\" section %d:\n", __FUNCTION__, szSection, (int)(pEndSection - pSection));
//  WB_ERROR_PRINT("%-.*s\n------------------------\n", (int)(pEndSection - pSection), pSection);

  fflush(stderr);
}

#if 0 // RESERVED (not currently used)

static void __find_global_section__(void *hFile, const char *szSection,
                                    const char **ppSection, const char **ppEndSection)
{
  int i1, /* i2,*/ iSectionLen;
  const char *p1, *p2, *pSection, *pEndSection;
  CONF_FILE *pTemp = (CONF_FILE *)hFile;

  *ppSection = pSection = NULL;
  *ppEndSection = pEndSection = NULL;

  if(!pTemp || !pTemp->pfhbG || !pTemp->pfhbG->ppLineBuf)
  {
    return;
  }

  iSectionLen = strlen(szSection);

  for(i1=0; i1 < pTemp->pfhbG->lLineCount; i1++)
  {
    // search for the section header
    p1 = pTemp->pfhbG->ppLineBuf[i1];
    p2 = pTemp->pfhbG->ppLineBuf[i1 + 1];
    if(!p2)
      p2 = pTemp->pfhbG->cData + pTemp->pfhbG->lBufferCount;

    __get_line_strip_comments__(&p1, &p2);

    if((p2 - p1) >= iSectionLen + 2 && *p1 == '[' && *(p2 - 1) == ']')
    {
      p1++;
      p2--;
      trim_ends(&p1, &p2);
      if((p2 - p1) == iSectionLen && !strncasecmp(p1, szSection, iSectionLen))
      {
        pSection = pTemp->pfhbG->ppLineBuf[i1 + 1];
        break;
      }
    }
  }

  if(!pSection)
    return;

  // starting with the current position, keep going until I find another section

  for(; i1 < pTemp->pfhbG->lLineCount; i1++)
  {
    // search for the section header
    p1 = pTemp->pfhbG->ppLineBuf[i1];
    p2 = pTemp->pfhbG->ppLineBuf[i1 + 1];
    if(!p2)
      p2 = pTemp->pfhbG->cData + pTemp->pfhbG->lBufferCount;

    __get_line_strip_comments__(&p1, &p2);

    if((p2 - p1) >= iSectionLen + 2 && *p1 == '[' && *(p2 - 1) == ']')
    {
      pEndSection = pTemp->pfhbG->ppLineBuf[i1];
      break;
    }
  }

  if(!pEndSection)
    pEndSection = pTemp->pfhbG->cData + pTemp->pfhbG->lBufferCount;

  // return values
  *ppSection = pSection;
  *ppEndSection = pEndSection;
}

#endif // 0


static int __enum_conf_file_sections__(void *hFile, char *szData, int cbData)
{
  int i1, i2;
  const char *p1, *p2;
  CONF_FILE *pTemp = (CONF_FILE *)hFile;

  if(!pTemp || !pTemp->pfhbL || !pTemp->pfhbL->ppLineBuf)
  {
    // TODO:  check globals also
    return -1;
  }

  for(i1=0, i2=0; i1 < pTemp->pfhbL->lLineCount; i1++)
  {
    // search for the section header
    p1 = pTemp->pfhbL->ppLineBuf[i1];
    p2 = pTemp->pfhbL->ppLineBuf[i1 + 1];
    if(!p2)
    {
      p2 = pTemp->pfhbL->cData + pTemp->pfhbL->lBufferCount;
    }

    __get_line_strip_comments__(&p1, &p2);

//    WB_ERROR_PRINT("TEMPORARY:  %s  \"%-.*s\"\n", __FUNCTION__, (int)(p2 - p1), p1);

    if((p2 - p1) >= 2 && *p1 == '[' && *(p2 - 1) == ']')
    {
      p1++;
      p2--;
      trim_ends(&p1, &p2);
      if(p2 > p1)
      {
        i2 += (p2 - p1) + 1;  // calculate additional space needed (always)
        if(cbData >= (p2 - p1) + 2)
        {
          // add the text for the section header to 'szData' if there's room for it
          memcpy(szData, p1, p2 - p1);
          szData[p2 - p1] = 0;
          szData[p2 - p1 + 1] = 0;

          szData += (p2 - p1) + 1;
          cbData -= (p2 - p1) + 1;
        }
        else
        {
          cbData = 0;  // because there's no more room
        }
      }
    }
  }

  // TODO:  enumerate global sections also

  i2++;  // always need room for 1 more
  return i2;
}


// Utilities to query and assign values within a config file

int CHGetConfFileString(void * hFile, const char *szSection,
                        const char *szIdentifier, char *szData, int cbData)
{
  int i1, i2, iIdentifierLen;
  const char *p1, *p2, *pSection, *pEndSection;
  CONF_FILE *pTemp = (CONF_FILE *)hFile;
  file_help_buf_t *pFHB = NULL;


  if(!pTemp || ((!pTemp->pfhbL || !pTemp->pfhbL->ppLineBuf)
             && (!pTemp->pfhbG || !pTemp->pfhbG->ppLineBuf)))
  {
    if(!pTemp)
    {
      WB_ERROR_PRINT("%s - hFile/pTemp is NULL\n", __FUNCTION__);
    }
    else
    {
      WB_ERROR_PRINT("%s - 'linebuf' problem - %p %p %p %p\n", __FUNCTION__,
                     pTemp->pfhbL, pTemp->pfhbL->ppLineBuf,
                     pTemp->pfhbG, pTemp->pfhbG->ppLineBuf);
    }

    return -1;
  }

  if(!szSection || !*szSection)  // empty section == get a list of all of them (ignore szIdentifier)
  {
    return __enum_conf_file_sections__(hFile, szData, cbData);
  }

  iIdentifierLen = strlen(szIdentifier);

  __find_section__(hFile, szSection, &pSection, &pEndSection);
  if(!pSection)
  {
    WB_ERROR_PRINT("TEMPORARY: %s - did not find section \"%s\"\n", __FUNCTION__, szSection);
    return -1;
  }

  // search for 'szIdentifier string' followed by '='

  if(pTemp->pfhbL &&
     pTemp->pfhbL->ppLineBuf &&
     pTemp->pfhbL->lLineCount > 0 &&
     pTemp->pfhbL->ppLineBuf[0] < pSection &&
     pTemp->pfhbL->ppLineBuf[pTemp->pfhbL->lLineCount - 1] >= pSection)
  {
    pFHB = pTemp->pfhbL;
  }
  else if(pTemp->pfhbG &&
          pTemp->pfhbG->ppLineBuf &&
          pTemp->pfhbG->lLineCount > 0 &&
          pTemp->pfhbG->ppLineBuf[0] < pSection &&
          pTemp->pfhbG->ppLineBuf[pTemp->pfhbG->lLineCount - 1] >= pSection)
  {
    pFHB = pTemp->pfhbG;
  }
  else
  {
//    WB_ERROR_PRINT("INTERNAL ERROR: %s\n", __FUNCTION__);
//    fprintf(stderr, "INTERNAL ERROR %s:%d\n", __FUNCTION__, __LINE__);
    return -1;
  }


  for(i1=0; i1 < pFHB->lLineCount && pFHB->ppLineBuf[i1] < pSection; i1++)
    ;

  for(; i1 < pFHB->lLineCount && pFHB->ppLineBuf[i1] < pEndSection; i1++)
  {
    p1 = pFHB->ppLineBuf[i1];
    p2 = pFHB->ppLineBuf[i1 + 1];

    if(!p2)
    {
      p2 = pFHB->cData + pFHB->lBufferCount;
    }

    while(p1 < p2 && *p1 <= ' ')
    {
      p1++;
    }

    if(*p1 == ';') // comment
    {
      continue;
    }

    if(p2 - p1 > iIdentifierLen &&
       !strncasecmp(szIdentifier, p1, iIdentifierLen) &&
       p1[iIdentifierLen] == '=')
    {
      // FOUND!  eliminate trailing newline but keep other white space (for now)
      p1 += iIdentifierLen + 1;
      if(p2 > p1 && *(p2 - 1) == '\n')
      {
        if(p2 > (p1 + 1) && *(p2 - 1) == '\n' && *(p2 - 2) == '\r')
        {
          p2--;
        }

        p2--;
      }
      // copy string into destination buffer and return the length of the actual data
      i2 = cbData;
      if(i2 > (p2 - p1))
      {
        i2 = p2 - p1;
      }
      if(i2 > 0)
      {
        memcpy(szData, p1, i2);
      }

      if(i2 < cbData)
      {
        szData[i2] = 0;  // as a matter of course
      }

      return p2 - p1;
    }
  }

  // not found locally - try global

  // TODO:  global


//  WB_ERROR_PRINT("TEMPORARY: %s - did not find section \"%s\" item \"%s\"\n", __FUNCTION__, szSection, szIdentifier);

  return -1;  // not found
}

int CHWriteConfFileString(void * hFile, const char *szSection,
                          const char *szIdentifier, const char *szData)
{
  int i1, i2, iSectionLine, iSectionLen, iIdentifierLen, iDataLen;
  char *pBuf;
  const char *p1, *p2, *pSection, *pEndSection;
  CONF_FILE *pTemp = (CONF_FILE *)hFile;
  file_help_buf_t *pFHB;


  if(!pTemp ||
     ((!pTemp->pfhbL || !pTemp->pfhbL->ppLineBuf) &&
      (!pTemp->pfhbG || !pTemp->pfhbG->ppLineBuf)))
  {
    return -1;
  }
  if(!szSection || !*szSection)
  {
    return -1;  // don't allow this on write
  }

  iIdentifierLen = strlen(szIdentifier);
  iDataLen = szData ? strlen(szData) : -1;

  __find_section__(hFile, szSection, &pSection, &pEndSection);
  if(pSection)
  {
    if(pTemp->pfhbL &&
       pTemp->pfhbL->ppLineBuf &&
       pTemp->pfhbL->lLineCount > 0 &&
       pTemp->pfhbL->ppLineBuf[0] < pSection &&
       pTemp->pfhbL->ppLineBuf[pTemp->pfhbL->lLineCount - 1] >= pSection)
    {
      pFHB = pTemp->pfhbL;
    }
    else if(pTemp->pfhbG &&
            pTemp->pfhbG->ppLineBuf &&
            pTemp->pfhbG->lLineCount > 0 &&
            pTemp->pfhbG->ppLineBuf[0] < pSection &&
            pTemp->pfhbG->ppLineBuf[pTemp->pfhbG->lLineCount - 1] >= pSection)
    {
      // TODO:  verify global CAN be written.  if not, assume 'local'
      pFHB = pTemp->pfhbG;
    }
    else
    {
      pSection = NULL; // will be added to 'local' or 'global' as needed
      pFHB = NULL;
    }
  }
  else
  {
    pFHB = NULL;
  }


  if(pFHB)
  {
    // search for 'szIdentifier string' followed by '='

    for(i1=0; i1 < pFHB->lLineCount && pFHB->ppLineBuf[i1] < pSection; i1++)
      ;

    iSectionLine = i1;

    for(; i1 < pFHB->lLineCount && pFHB->ppLineBuf[i1] < pEndSection; i1++)
    {
      p1 = pFHB->ppLineBuf[i1];
      p2 = pFHB->ppLineBuf[i1 + 1];

      if(!p2)
      {
        p2 = pFHB->cData + pFHB->lBufferCount;
      }

      while(p1 < p2 && *p1 <= ' ')
      {
        p1++;
      }

      if(*p1 == ';') // comment
      {
        continue;
      }

      if(p2 - p1 > iIdentifierLen &&
         !strncasecmp(szIdentifier, p1, iIdentifierLen) &&
         p1[iIdentifierLen] == '=')
      {
        // FOUND!  replace or delete contents (NULL szData --> delete)
        if(!szData)
        {
          FBDeleteLineFromFileBuf(pFHB, i1);
        }
        else
        {
          pBuf = (char *)WBAlloc(iDataLen + iIdentifierLen + 4);

          if(!pBuf)
          {
            WB_ERROR_PRINT("%s - 'pBuf' NULL (c)\n", __FUNCTION__);

            return -1;  // error
          }

          // todo:  search backwards from 'i1' for blanks & comments
          sprintf(pBuf, "%s=%s", szIdentifier, szData);

          if(pFHB == pTemp->pfhbG)
          {
            FBReplaceLineInFileBuf(&(pTemp->pfhbG), i1, pBuf);
          }
          else if(pFHB == pTemp->pfhbL)
          {
            FBReplaceLineInFileBuf(&(pTemp->pfhbL), i1, pBuf);
          }
          else
          {
            WBFree(pBuf);
            return -1; // error
          }

          WBFree(pBuf);
        }

        return 0;  // success
      }
    }

    if(!szData)
    {
      return 0; // success [deleting something that's not there is 'OK']
    }


    // since the section doesn't contain this entry, create it after the
    // last entry, searching back from 'pEndSection' skipping blank lines and comments
    // until I get to 'pSection' or an entry, whichever happens first.

    pBuf = (char *)WBAlloc(iDataLen + iIdentifierLen + 4);

    if(!pBuf)
    {
      WB_ERROR_PRINT("%s - 'pBuf' NULL (a)\n", __FUNCTION__);

      return -1;  // error
    }

    // search backwards from 'i1' for blank lines.  insert right after
    // the last non-blank line ABOVE where I am.

    while(i1 > iSectionLine)
    {
      p1 = pFHB->ppLineBuf[i1 - 1];
      if(p1 && *p1 != '\r' && *p1 != '\n')
      {
        break;
      }

      i1--;
    }

    sprintf(pBuf, "%s=%s", szIdentifier, szData);

    if(pTemp->pfhbL /*&&
       (!(pTemp->pfhbG) || !(pTemp->iFlags & CH_FLAGS_GLOBAL))*/) // local first, unless the 'global' flag is set
    {
      FBInsertLineIntoFileBuf(&(pTemp->pfhbL), i1, pBuf);
    }
    else if(pTemp->pfhbG)
    {
      FBInsertLineIntoFileBuf(&(pTemp->pfhbG), i1, pBuf);
    }

    WBFree(pBuf);

    return 0;  // ok!
  }

  if(!szData)
  {
    return 0;  // already deleted, no need for further effort
  }

  iSectionLen = strlen(szSection);

  // allocate memory for the section and the entry, and add each in its turn
  i1 = iSectionLen + 4;
  if(i1 < (iDataLen + iIdentifierLen + 2))
  {
    i1 =  iDataLen + iIdentifierLen + 2;
  }

  pBuf = (char *)WBAlloc(i1 + 2);

  if(!pBuf)
  {
    WB_ERROR_PRINT("%s - 'pBuf' NULL (b)\n", __FUNCTION__);

    return -1;  // error
  }

  sprintf(pBuf, "[%s]\n", szSection);

  if(pTemp->pfhbL /*&& // always do local FIRST if I can
     (!(pTemp->pfhbG) || !(pTemp->iFlags & CH_FLAGS_GLOBAL))*/)
  {
    i2 = pTemp->pfhbL->lLineCount;
    FBInsertLineIntoFileBuf(&(pTemp->pfhbL), pTemp->pfhbL->lLineCount, pBuf);
    if(i2 >= pTemp->pfhbL->lLineCount)
    {
      WBFree(pBuf);

      WB_ERROR_PRINT("%s - FBInsertLineIntoFileBuf failed (a)\n", __FUNCTION__);
      return -1;
    }

    // now do it again, this time for the data
    sprintf(pBuf, "%s=%s\n", szIdentifier, szData);

    i2 = pTemp->pfhbL->lLineCount;
    FBInsertLineIntoFileBuf(&(pTemp->pfhbL), pTemp->pfhbL->lLineCount, pBuf);
    WBFree(pBuf);

    if(i2 >= pTemp->pfhbL->lLineCount)
    {
      WB_ERROR_PRINT("%s - FBInsertLineIntoFileBuf failed (b)\n", __FUNCTION__);
      return -1;
    }
  }
  else if(pTemp->pfhbG) // global [TODO:  verify global can be written]
  {
    i2 = pTemp->pfhbG->lLineCount;
    FBInsertLineIntoFileBuf(&(pTemp->pfhbG), pTemp->pfhbG->lLineCount, pBuf);
    if(i2 >= pTemp->pfhbG->lLineCount)
    {
      WBFree(pBuf);
      WB_ERROR_PRINT("%s - FBInsertLineIntoFileBuf failed (c)\n", __FUNCTION__);
      return -1;
    }
    // now do it again, this time for the data
    sprintf(pBuf, "%s=%s\n", szIdentifier, szData);

    i2 = pTemp->pfhbG->lLineCount;
    FBInsertLineIntoFileBuf(&(pTemp->pfhbG), pTemp->pfhbG->lLineCount, pBuf);
    WBFree(pBuf);

    if(i2 >= pTemp->pfhbG->lLineCount)
    {
      WB_ERROR_PRINT("%s - FBInsertLineIntoFileBuf failed (d)\n", __FUNCTION__);
      return -1;
    }
  }
  else
  {
    WBFree(pBuf);
    WB_ERROR_PRINT("%s - pfhbG and pfhbL are both NULL\n", __FUNCTION__);

    return -1; // error
  }

  return 0;  // success!
}

int CHGetConfFileInt(void * hFile, const char *szSection, const char *szIdentifier)
{
  int iLen;
  char tbuf[64];

  if((iLen = CHGetConfFileString(hFile, szSection, szIdentifier, tbuf, sizeof(tbuf) - 1)) > 0)
  {
    tbuf[iLen] = 0;
    while(tbuf[0] && tbuf[0] <= ' ')
    {
      strcpy(tbuf, tbuf + 1);
    }

    if(tbuf[0])
    {
      return atoi(tbuf);
    }
  }

  return 0;
}

int CHWriteConfFileInt(void * hFile, const char *szSection, const char *szIdentifier, int iData)
{
  int iFlag;
  char tbuf[64];
  char *p1;

  if(iData < 0)
  {
    iFlag = -1;
    iData = -iData;
  }
  else
  {
    iFlag = 0;  // a sign flag, temporarily
  }

  p1 = tbuf + sizeof(tbuf) - 1;

  *p1 = 0;
  do
  {
    *(--p1) = (char)('0' + iData % 10);

    iData /= 10;

  } while(p1 > (tbuf + 1) && iData);

  if(iFlag < 0)
  {
    *(--p1) = '-';
  }

  return CHWriteConfFileString(hFile, szSection, szIdentifier, p1);
}





////////////////////////////////////////////////////////////////////////
//    __  __ ____   _____  _____  _____  ___  _   _   ____  ____      //
//    \ \/ // ___| | ____||_   _||_   _||_ _|| \ | | / ___|/ ___|     //
//     \  / \___ \ |  _|    | |    | |   | | |  \| || |  _ \___ \     //
//     /  \  ___) || |___   | |    | |   | | | |\  || |_| | ___) |    //
//    /_/\_\|____/ |_____|  |_|    |_|  |___||_| \_| \____||____/     //
//                                                                    //
////////////////////////////////////////////////////////////////////////

// INTERNAL STRUCTURES
// header, followed by 'nSettings' XSETTINGS_DATA structs (each of variable length)
typedef struct __XSETTINGS_HEADER__
{
  char cByteOrder, cUnused[3];
  unsigned int uiSerial;  // may be high or low endian, see 'cByteOrder'
  unsigned int nSettings; // may be high or low endian, see 'cByteOrder'
}  __attribute__((__packed__)) XSETTINGS_HEADER;

typedef struct __XSETTINGS_DATAHDR__
{
  char cSettingType, cUnused;
  unsigned short wNameLen;
  char szName[4];                  //  actually 'wNameLen' bytes long, including any padding
// unsigned int dwLastChangeSerial;    immediately follows 'szName'
} __attribute__((__packed__)) XSETTINGS_DATAHDR;

// data immediately follows XSETTINGS_DATAHDR, one of these three structs

typedef struct __XSETTINGS_DATA_INT__
{
  unsigned int uiValue;  // endian matches that of header
} XSETTINGS_DATA_INT;

typedef struct __XSETTINGS_DATA_STRING__
{
  unsigned int cbLength;
  char szData[4];         // followed immediately by character data (may be zero length)
} __attribute__((__packed__)) XSETTINGS_DATA_STRING;


const CHXSettings * CHGetXSettings(Display *pDisplay)
{
  return pXSettings;  // for now, just do this (if NULL do I call CHSettingsRefresh ?)
}

const CHXSetting * CHGetXSetting(Display *pDisplay, const char *szSettingName)
{
int i1, nSettings;

  if(!pXSettings || pXSettings->pDisplay != pDisplay)
  {
    return NULL;
  }

  nSettings = pXSettings->nSettings;

  for(i1=0; i1 < nSettings; i1++)
  {
    if(!strcasecmp(szSettingName, pXSettings->aData[i1].szName))
    {
      return pXSettings->aData + i1;
    }
  }

  return NULL;
}

void CHSettingsRefresh(Display *pDisplay)
{
// TODO:  implement an XSETTINGS (gnome-settings-manager) 'collection' object and query it
// NOTE:  so far gnome-settings-manager doesn't provide anything really useful except the theme name
//        and everything else is either cloned from or implemented as the old-style resource manager

int i1, iLen, nLen, iFormat, nItems, cbSize, cbNameLen, cbStrLen;
//unsigned long cbData0;
void *pData;
unsigned long cbLeft, nI;
char *pCur, *pDataEnd, *pXSCur, *pXSEnd;
Atom a_XSETTINGS_Sn, a_XSETTINGS_SETTINGS, aType;
Window wOwn;
XSETTINGS_HEADER *pHdr;
XSETTINGS_DATAHDR *pDHdr;
char tbuf[256];


//  aTARGET = XInternAtom(pDisplay, "TARGET", False);
//  a_MANAGER = XInternAtom(pDisplay, "MANAGER", False);
//  XA_CLIPBOARD=XInternAtom(pDisplay, "CLIPBOARD", False);
//  XA_CLIPBOARD_MANAGER=XInternAtom(pDisplay, "CLIPBOARD_MANAGER", False);
  a_XSETTINGS_Sn = XInternAtom(pDisplay, "_XSETTINGS_S0", False);
  a_XSETTINGS_SETTINGS = XInternAtom(pDisplay, "_XSETTINGS_SETTINGS", False);

  // see https://specifications.freedesktop.org/xsettings-spec/xsettings-spec-0.5.html

  XGrabServer(pDisplay); // required by above documentation
  wOwn = XGetSelectionOwner(pDisplay, a_XSETTINGS_Sn);

  if(wOwn == None)
  {
    XUngrabServer(pDisplay);
    WB_ERROR_PRINT("%s:%d - %s unable to retrieve XSETTINGS data (no owner)\n",
                   __FILE__, __LINE__, __FUNCTION__);
    return;
  }

  // read the property now

  pData = NULL;
  aType = None; //a_MANAGER;
  iFormat = 32;
  nI = 0;
  cbLeft = 0;

  if(XGetWindowProperty(pDisplay, wOwn, a_XSETTINGS_SETTINGS, 0, 0, False,
                        AnyPropertyType, &aType, &iFormat, &nI, &cbLeft, (unsigned char **)&pData))
  {
    XUngrabServer(pDisplay);
    WB_ERROR_PRINT("%s:%d - %s unable to retrieve XSETTINGS data (XSETTINGS_SETTINGS)(a)\n",
                   __FILE__, __LINE__, __FUNCTION__);
    return;
  }

  if(pData)
  {
    XFree(pData);
    pData = NULL;
  }

  // is this the actual data, or a return that says "do it incrementally" ?

  if(aType == aINCR) // incremental
  {
    XUngrabServer(pDisplay);
    WB_ERROR_PRINT("%s:%d - %s unable to retrieve XSETTINGS data (INCR)\n",
                   __FILE__, __LINE__, __FUNCTION__);
    return;
  }

  nLen = iLen = cbLeft; // the RAW length (in bytes)

  if(iFormat == 16)
  {
    nLen /= 2;
  }
  else if(iFormat == 32)
  {
    nLen /= 4;
  }

  // now get it for reals

  if(XGetWindowProperty(pDisplay, wOwn, a_XSETTINGS_SETTINGS, 0, nLen, False,
                        AnyPropertyType, &aType, &iFormat, &nI, &cbLeft, (unsigned char **)&pData)
     || !pData)
  {
    XUngrabServer(pDisplay);
    WB_ERROR_PRINT("%s:%d - %s unable to retrieve XSETTINGS data (XSETTINGS_SETTINGS)(b)\n",
                   __FILE__, __LINE__, __FUNCTION__);
    return;
  }

  XUngrabServer(pDisplay); // MUST do this or else bad things happen


  if(pData)
  {
    if(aType != a_XSETTINGS_SETTINGS)
    {
#ifndef NO_DEBUG
      char *p1 = WBGetAtomName(pDisplay, aType);
      WB_ERROR_PRINT("TEMPORARY:  %s:%d - %s returned type %d (%s)\n",
                     __FILE__, __LINE__, __FUNCTION__, (int)aType, p1);
      if(p1)
      {
        WBFree(p1);
      }
#endif // NO_DEBUG

      // TODO:  is this an error??
    }
  }
  else
  {
    WB_ERROR_PRINT("%s:%d - %s unable to retrieve XSETTINGS data\n",
                   __FILE__, __LINE__, __FUNCTION__);
    return;
  }


  // first part is __XSETTINGS_HEADER__ header
  pHdr = (XSETTINGS_HEADER *)pData;
  pCur = (char *)(pHdr + 1);
  pDataEnd = (char *)pData + iLen;//cbData0;

  if(pCur >= pDataEnd)
  {
    WB_ERROR_PRINT("%s:%d - %s XSETTINGS data corrupt (data buffer too small)\n",
                    __FILE__, __LINE__, __FUNCTION__);
    XFree(pData);
    return;
  }

//  WB_ERROR_PRINT("TEMPORARY:  pHdr %d %d %d\n",
//                  pHdr->cByteOrder, pHdr->uiSerial, pHdr->nSettings);

  cbSize = 0;
  if(pHdr->cByteOrder) // assume HIGH endian
  {
    nItems = htonl(pHdr->nSettings);
  }
  else
  {
    nItems = pHdr->nSettings;
  }

  for(i1=0; i1 < nItems; i1++)
  {
    pDHdr = (XSETTINGS_DATAHDR *)pCur;

    if((char *)(&(pDHdr->wNameLen) + 1) > pDataEnd) // make sure I can read wNameLen safely
    {
      WB_ERROR_PRINT("%s:%d - %s XSETTINGS data corrupt (data buffer too small)  %p %p %d of %d\n",
                      __FILE__, __LINE__, __FUNCTION__, pCur, pDataEnd, i1, nItems);
      XFree(pData);
      return;
    }

    cbNameLen = pHdr->cByteOrder ? htons(pDHdr->wNameLen) : pDHdr->wNameLen;

    if(pDHdr->szName + cbNameLen + 1 >= pDataEnd)
    {
      WB_ERROR_PRINT("%s:%d - %s XSETTINGS data corrupt (data buffer too small)\n",
                     __FILE__, __LINE__, __FUNCTION__);
      XFree(pData);
      return;
    }

    cbSize += sizeof(CHXSetting) + cbNameLen + 1;
    bzero(tbuf, sizeof(tbuf));
    if(cbNameLen < sizeof(tbuf))
    {
      memcpy(tbuf, pDHdr->szName, cbNameLen);
    }
    else
    {
      memcpy(tbuf, pDHdr->szName, sizeof(tbuf) - 1);
    }

    pCur = (char *)&(pDHdr->szName) + ((cbNameLen + 7) & (~3));

    switch(pDHdr->cSettingType)
    {
      case XSettingsTypeInteger:
//        WB_ERROR_PRINT("TEMPORARY:  integer %s  %d\n", tbuf, ((XSETTINGS_DATA_INT *)pCur)->uiValue);

        cbSize += sizeof(XSETTINGS_DATA_INT);
        pCur += sizeof(XSETTINGS_DATA_INT);

        break;

      case XSettingsTypeColor:
        cbSize += sizeof(XSETTINGS_DATA_COLOR);
        pCur += sizeof(XSETTINGS_DATA_COLOR);

        break;

      case XSettingsTypeString:

        if(pCur + sizeof(XSETTINGS_DATA_STRING)  - sizeof(((XSETTINGS_DATA_STRING *)0)->szData)
           >= pDataEnd) // make sure string length is readable
        {
          WB_ERROR_PRINT("%s:%d - %s XSETTINGS data corrupt (data buffer too small)\n",
                         __FILE__, __LINE__, __FUNCTION__);
          XFree(pData);
          return;
        }

        cbStrLen = pHdr->cByteOrder ? htons(((XSETTINGS_DATA_STRING *)pCur)->cbLength) : ((XSETTINGS_DATA_STRING *)pCur)->cbLength;

//          WB_ERROR_PRINT("TEMPORARY: string %s length %d\n", tbuf, cbStrLen);
//          WB_ERROR_PRINT("TEMPORARY:  string %s length %d \"%-.*s\"\n",
//                         tbuf, cbStrLen, cbStrLen, ((XSETTINGS_DATA_STRING *)pCur)->szData);

        if(cbStrLen > 0)
        {
          cbSize += sizeof(XSETTINGS_DATA_STRING) - sizeof(((XSETTINGS_DATA_STRING *)0)->szData) + cbStrLen + 1;
          pCur += sizeof(XSETTINGS_DATA_STRING) - sizeof(((XSETTINGS_DATA_STRING *)0)->szData)
                + ((cbStrLen + 3) & (~3));
        }
        else
        {
          cbSize += sizeof(XSETTINGS_DATA_STRING) - sizeof(((XSETTINGS_DATA_STRING *)0)->szData);
          pCur += sizeof(XSETTINGS_DATA_STRING) - sizeof(((XSETTINGS_DATA_STRING *)0)->szData);
        }

        break;
    }

    // must check this at end of loop

    if(pCur > pDataEnd) // last can have pCurDataEnd == pCur
    {
      WB_ERROR_PRINT("%s:%d - %s XSETTINGS data corrupt (data buffer too small)  %p %p %d of %d\n",
                      __FILE__, __LINE__, __FUNCTION__, pCur, pDataEnd, i1, nItems);
      XFree(pData);
      return;
    }
  }

//  WB_ERROR_PRINT("TEMPORARY:  total length needed %d bytes\n", cbSize);

  pCur = (char *)(pHdr + 1); // back to the beginning

  if(pXSettings)
  {
    WBFree(pXSettings);
    pXSettings = NULL;
  }

  pXSettings = (CHXSettings *)WBAlloc(cbSize + sizeof(CHXSettings));

  if(!pXSettings)
  {
    WB_ERROR_PRINT("%s:%d - %s not enough memory for XSettings\n",
                   __FILE__, __LINE__, __FUNCTION__);
    XFree(pData);
    return;
  }

  pXSettings->pDisplay = pDisplay;
  pXSettings->nSettings = nItems;
  pXSettings->uiSerial = pHdr->cByteOrder ? htonl(pHdr->uiSerial) : pHdr->uiSerial;

  pXSEnd = (char *)pXSettings + cbSize + sizeof(CHXSettings);  // to duplicate 'malloc' size calc
  pXSCur = (char *)(pXSettings->aData + nItems);  // this is where I put string data

  for(i1=0; i1 < nItems; i1++)
  {
    XSETTINGS_DATAHDR *pDHdr = (XSETTINGS_DATAHDR *)pCur;
    int cbNameLen = pHdr->cByteOrder ? htons(pDHdr->wNameLen) : pDHdr->wNameLen;
    CHXSetting *pXS = pXSettings->aData + i1;

    if(pXSCur + cbNameLen + 1 > pXSEnd)
    {
      WB_ERROR_PRINT("%s:%d - %s CHXSettings data corrupt (data buffer too small)\n",
                      __FILE__, __LINE__, __FUNCTION__);

      WBFree(pXSettings);
      pXSettings = NULL;

      XFree(pData);
      return;
    }

    pXS->szName = pXSCur;

    memcpy(pXSCur, pDHdr->szName, cbNameLen);
    pXSCur += cbNameLen;
    *(pXSCur++) = 0;

    pCur = (char *)&(pDHdr->szName) + ((cbNameLen + 7) & (~3));

    pXS->iType = pDHdr->cSettingType;

    switch(pDHdr->cSettingType)
    {
      case XSettingsTypeInteger:

        pXS->iLen = 0;
        pXS->uData.iData = ((XSETTINGS_DATA_INT *)pCur)->uiValue;

        pCur += sizeof(XSETTINGS_DATA_INT);

        break;

      case XSettingsTypeColor:

        pXS->iLen = 0;

        pXS->uData.clrData.sRed   = ((XSETTINGS_DATA_COLOR *)pCur)->sRed;
        pXS->uData.clrData.sBlue  = ((XSETTINGS_DATA_COLOR *)pCur)->sBlue;
        pXS->uData.clrData.sGreen = ((XSETTINGS_DATA_COLOR *)pCur)->sGreen;
        pXS->uData.clrData.sAlpha = ((XSETTINGS_DATA_COLOR *)pCur)->sAlpha;

        cbSize += sizeof(XSETTINGS_DATA_COLOR);
        pCur += sizeof(XSETTINGS_DATA_COLOR);

        break;

      case XSettingsTypeString:

        cbStrLen = pHdr->cByteOrder ? htons(((XSETTINGS_DATA_STRING *)pCur)->cbLength) : ((XSETTINGS_DATA_STRING *)pCur)->cbLength;
        pXS->iLen = cbStrLen;

        if(cbStrLen > 0)
        {
          if(pXSCur + cbStrLen + 1 > pXSEnd)
          {
            WB_ERROR_PRINT("%s:%d - %s CHXSettings data corrupt (data buffer too small)\n",
                            __FILE__, __LINE__, __FUNCTION__);

            WBFree(pXSettings);
            pXSettings = NULL;

            XFree(pData);
            return;
          }

          pXS->uData.szData = pXSCur;
          memcpy(pXSCur, ((XSETTINGS_DATA_STRING *)pCur)->szData, cbStrLen);

          pXSCur += cbStrLen;
          *(pXSCur++) = 0;

          pCur += sizeof(XSETTINGS_DATA_STRING) - sizeof(((XSETTINGS_DATA_STRING *)0)->szData)
                + ((cbStrLen + 3) & (~3));
        }
        else
        {
          pXS->uData.szData = ""; // so that it's not NULL

          pCur += sizeof(XSETTINGS_DATA_STRING) - sizeof(((XSETTINGS_DATA_STRING *)0)->szData);
        }

        break;
    }
  }

  // if I'm debuggin I'll want a copy of what's there

#ifndef NO_DEBUG
  WB_IF_DEBUG_LEVEL(DebugLevel_WARN | DebugSubSystem_Settings)
  {
    CHDumpConfig();
  }
#endif // !NO_DEBUG
}

static void __settings_cleanup(void)
{
  if(pXSettings)
  {
    WBFree(pXSettings);
    pXSettings = NULL;
  }
}



///////////////////////////
// QUERY SYSTEM PARAMETERS
///////////////////////////


// basic 'window_helper' helpers
// NOTE:  see page on Specifications/XSettingsRegistry at freedesktop.org
//        http://www.freedesktop.org/wiki/Specifications/XSettingsRegistry

#define DEFAULT_DOUBLE_CLICK_TIME 250 /* msec */
#define DEFAULT_DOUBLE_CLICK_DISTANCE 5 /* pixels */
#define DEFAULT_DRAG_THRESHOLD 9 /* pixels */
#define DEFAULT_CURSOR_BLINK (!0) /* boolean */
#define DEFAULT_CURSOR_BLINK_TIME 1200 /* msec */


int CHGetDoubleClickTime(Display *pDisplay)
{
static int iFirstTime = 1, iRval = DEFAULT_DOUBLE_CLICK_TIME;
static unsigned int uiSerial;
const CHXSetting *pXS;

  // These first checks should be optimized for speed.  It is likely that
  // they will be performed OFTEN, as often as 'every message'

  if(WB_UNLIKELY(!pXSettings))
  {
    return iRval;  // last known value
  }

  if(WB_LIKELY(!iFirstTime) &&
     WB_LIKELY(uiSerial == pXSettings->uiSerial) &&
     WB_LIKELY((!pDisplay || pDisplay == pXSettings->pDisplay)))
  {
    return iRval;  // no need to check again
  }

  if(pDisplay && pDisplay != pXSettings->pDisplay)
  {
    return DEFAULT_DOUBLE_CLICK_TIME;  // return the default value (for now)
  }

  iFirstTime = 0;  // make sure
  uiSerial = pXSettings->uiSerial;  // keep track of serial #

  pXS = CHGetXSetting(pXSettings->pDisplay, "Net/DoubleClickTime");

  if(pXS && pXS->iType == XSettingsTypeInteger)
  {
    iRval = pXS->uData.iData;
  }

  return iRval;
}

int CHGetDoubleClickDistance(Display *pDisplay)
{
static int iFirstTime = 1, iRval = DEFAULT_DOUBLE_CLICK_DISTANCE;
static unsigned int uiSerial;
const CHXSetting *pXS;

  // These first checks should be optimized for speed.  It is likely that
  // they will be performed OFTEN, as often as 'every message'

  if(WB_UNLIKELY(!pXSettings))
  {
    return iRval;  // last known value
  }

  if(WB_LIKELY(!iFirstTime) &&
     WB_LIKELY(uiSerial == pXSettings->uiSerial) &&
     WB_LIKELY((!pDisplay || pDisplay == pXSettings->pDisplay)))
  {
    return iRval;  // no need to check again
  }

  if(pDisplay && pDisplay != pXSettings->pDisplay)
  {
    return DEFAULT_DOUBLE_CLICK_DISTANCE;  // return the default value (for now)
  }

  iFirstTime = 0;  // make sure
  uiSerial = pXSettings->uiSerial;  // keep track of serial #

  pXS = CHGetXSetting(pXSettings->pDisplay, "Net/DoubleClickDistance");

  if(pXS && pXS->iType == XSettingsTypeInteger)
  {
    iRval = pXS->uData.iData;
  }

  return iRval;
}

int CHGetDragThreshold(Display *pDisplay)
{
static int iFirstTime = 1, iRval = DEFAULT_DRAG_THRESHOLD;
static unsigned int uiSerial;
const CHXSetting *pXS;

  // These first checks should be optimized for speed.  It is likely that
  // they will be performed OFTEN, as often as 'every message'

  if(WB_UNLIKELY(!pXSettings))
  {
    return iRval;  // last known value
  }

  if(WB_LIKELY(!iFirstTime) &&
     WB_LIKELY(uiSerial == pXSettings->uiSerial) &&
     WB_LIKELY((!pDisplay || pDisplay == pXSettings->pDisplay)))
  {
    return iRval;  // no need to check again
  }

  if(pDisplay && pDisplay != pXSettings->pDisplay)
  {
    return DEFAULT_DRAG_THRESHOLD;  // return the default value (for now)
  }

  iFirstTime = 0;  // make sure
  uiSerial = pXSettings->uiSerial;  // keep track of serial #

  pXS = CHGetXSetting(pXSettings->pDisplay, "Net/DndDragThreshold");

  if(pXS && pXS->iType == XSettingsTypeInteger)
  {
    iRval = pXS->uData.iData;
  }

  return iRval;
}

int CHGetCursorBlink(Display *pDisplay)
{
static int iFirstTime = 1, iRval = DEFAULT_CURSOR_BLINK;
static unsigned int uiSerial;
const CHXSetting *pXS;

  // These first checks should be optimized for speed.  It is likely that
  // they will be performed OFTEN, as often as 'every message'

  if(WB_UNLIKELY(!pXSettings))
  {
    return iRval;  // last known value
  }

  if(WB_LIKELY(!iFirstTime) &&
     WB_LIKELY(uiSerial == pXSettings->uiSerial) &&
     WB_LIKELY((!pDisplay || pDisplay == pXSettings->pDisplay)))
  {
    return iRval;  // no need to check again
  }

  if(pDisplay && pDisplay != pXSettings->pDisplay)
  {
    return DEFAULT_CURSOR_BLINK;  // return the default value (for now)
  }

  iFirstTime = 0;  // make sure
  uiSerial = pXSettings->uiSerial;  // keep track of serial #

  pXS = CHGetXSetting(pXSettings->pDisplay, "Net/CursorBlink");

  if(pXS && pXS->iType == XSettingsTypeInteger)
  {
    iRval = pXS->uData.iData ? !0 : 0; // convert to "true boolean"
  }

  return iRval;
}

int CHGetCursorBlinkTime(Display *pDisplay)
{
static int iFirstTime = 1, iRval = DEFAULT_CURSOR_BLINK_TIME;
static unsigned int uiSerial;
const CHXSetting *pXS;

  // These first checks should be optimized for speed.  It is likely that
  // they will be performed OFTEN, as often as 'every message'

  if(WB_UNLIKELY(!pXSettings))
  {
    return iRval;  // last known value
  }

  if(WB_LIKELY(!iFirstTime) &&
     WB_LIKELY(uiSerial == pXSettings->uiSerial) &&
     WB_LIKELY((!pDisplay || pDisplay == pXSettings->pDisplay)))
  {
    return iRval;  // no need to check again
  }

  if(pDisplay && pDisplay != pXSettings->pDisplay)
  {
    return DEFAULT_CURSOR_BLINK_TIME;  // return the default value (for now)
  }

  iFirstTime = 0;  // make sure
  uiSerial = pXSettings->uiSerial;  // keep track of serial #

  pXS = CHGetXSetting(pXSettings->pDisplay, "Net/CursorBlinkTime");

  if(pXS && pXS->iType == XSettingsTypeInteger)
  {
    iRval = pXS->uData.iData;
  }

  return iRval;
}



///////////////////////////
// X M L   P A R S I N G //
///////////////////////////

/** \ingroup text_xml
  * \brief Parses contents of an XML tag, returning as WBAlloc'd string list similar to environment strings
  *
  * \param ppOrigin A pointer to the 'origin' pointer for CHXMLEntry array
  *
  * Internal function for use by CHParseXML, to recurse levels of XML
  *
**/
static const char *InternalParseXML(CHXMLEntry **ppOrigin, int *pcbOrigin, CHXMLEntry **ppCur,
                                    char **ppData, int *pcbData, char **ppCurData,
                                    const char *ppXMLData, const char *pXMLDataEnd)
{
  // parse a section of XML, adding contents to the end of 'ppOrigin', and returning
  // a pointer to the next element on success (or NULL otherwise).  This function will
  // re-allocate '*ppOrigin' as needed, storing the max size in '*pcbOrigin'.  It can
  // also recurse to embedded sections, and then process them as needed to get the XML
  // hierarchy correct in the CHXMLEntry pointed to by 'ppOrigin'.
  //
  // A recursive call can affect *ppOrigin.  It should be explicitly re-loaded on return.

  // this isn't needed per se, but having it here can't hurt..
  if(!ppOrigin || !*ppOrigin || !pcbOrigin || !ppCur || !*ppCur ||
     !ppXMLData || !*ppXMLData || !pXMLDataEnd ||
     (((WB_UINTPTR)pXMLDataEnd) < ((WB_UINTPTR)*ppXMLData))) // warning abatement, use type cast for WB_UINTPTR
  {
    return NULL; // just reject these possibilities outright and return "error"
  }

  // this function will return on error or if it finds and parses the ending tag

    // OK what kind of tag do we have now?


//    pCur = CHFindNextXMLTag(pCur, cbLength, 0);
//
//    if(!pCur) // no more tags
//    {
//      break;
//    }
//
//    pCur++; // points past the tag


  // returned pointer is the next point at which to parse a 'same level' tag

  return pXMLDataEnd; // for now
}


//  typedef struct _CHXMLEntry_
//  {
//    int iNextIndex;      // 0-based index for next item at this level; <= 0 for none.  0 marks "end of list" for top level
//    int iContainer;      // 0-based index for container; <= 0 for none.
//    int iContentsIndex;  // 0-based first array index for 'contents' for this entry; <= 0 for none
//
//    int nLabelOffset;    // BYTE offset to label (zero-byte-terminated) string (from beginning of array)
//                         // for this entry; <= 0 for 'no label'
//    int nDataOffset;     // BYTE offset to data (zero-byte-terminated) string (from beginning of array)
//                         // for the entry data; <= 0 for 'no data'
//
//  } CHXMLEntry;

CHXMLEntry *CHParseXML(const char *pXMLData, int cbLength)
{
CHXMLEntry *pRval = NULL;
CHXMLEntry *pXE, *pXCur;
int cbRval, cbData, cbNeed, cbOffs;
const char *pEnd = pXMLData + cbLength;
const char *pCur;
char *pData, *pCurData;


  if(!pXMLData || !cbLength || !*pXMLData)
  {
    return NULL;
  }

  cbRval = 0x1000 * sizeof(CHXMLEntry); // 64k entries
  cbData = 0x100000; // 256k, to start with

  pRval = (CHXMLEntry *)malloc(cbRval);
  pData = malloc(cbData);
  if(!pRval || !pData)
  {
    if(pRval)
    {
      free(pRval);
    }

    if(pData)
    {
      free(pData);
    }
    return NULL; // not enough memory (oops)
  }



  pCur = pXMLData;
  pXCur = pRval;
  pCurData = pData;

  *pData = 0; // ending zero byte - must be present at pData[length]

  pXCur->iNextIndex = 0; // marks "end of list"
  pXCur->iContainer = 0; // marks it as "top level"
  pXCur->iContentsIndex = 0;
  pXCur->nLabelOffset = 0;
  pXCur->nDataOffset = 0;


  while(pCur < pEnd)
  {
    // call recursive function that does "one level" of XML and all of its contents

    pCur = InternalParseXML(&pRval, &cbRval, &pXCur, &pData, &cbData, &pCurData, pCur, pEnd);

    if(!pCur) // error
    {
      goto error_exit;
    }

    // TODO:  look at the beginning for things like <?xml version="xx"?> and <!DOCTYPE xxx>

  }

  // at this point 'pXCur' is the pointer to the final entry, and there's room in the array for it.

  pXCur->iNextIndex = 0; // marks "end of list"
  pXCur->iContainer = 0; // assign the other zeros by convention
  pXCur->iContentsIndex = 0;
  pXCur->nLabelOffset = 0;
  pXCur->nDataOffset = 0;

  cbOffs = ((char *)(pXCur + 1) - (char *)pRval); // offset to where the data is, for fixups
           // I use 'pXCur + 1' here because I'll increment it later.  but I also need it
           // for a limit pointer in the fixup loop, so I don't increment it YET...
  cbNeed = cbOffs + 2 * sizeof(*pXCur)
         + (pCurData - pData); // the actual size of the data

  if(cbNeed > cbRval) // need to re-allocate
  {
    void *pTemp = realloc(pRval, cbNeed);

    if(!pTemp)
    {
      goto error_exit;
    }

    pXCur = (pXCur - pRval) + ((CHXMLEntry *)pTemp); // new 'pXCur'
    pRval = (CHXMLEntry *)pTemp;                     // new 'pRval'
  }

  // fix up all of the data indices
  for(pXE=pRval; pXE < pXCur; pXE++)
  {
    if(pXCur->nLabelOffset >= 0) // allow '0' for this part
    {
      pXCur->nLabelOffset += cbOffs; // fix up the data offset
    }
    else
    {
      pXCur->nLabelOffset = 0; // make it zero to mark it 'unused'
    }

    if(pXCur->nDataOffset >= 0) // allow '0' for this part
    {
      pXCur->nDataOffset += cbOffs; // fix up the data offset
    }
    else
    {
      pXCur->nDataOffset = 0; // make it zero to mark it 'unused'
    }
  }

  pXCur++; // this is where the data will start, now

  // copy the data where it needs to be

  memcpy(pXCur, pData, (pCurData - pData) + 1); // copy data, including the final 0-byte at 'pData[length]'

  // and now I'm done!

  goto the_end;

error_exit:

  free(pRval);
  pRval = NULL;


the_end:
  free(pData); // not needed any more

  return pRval; // the self-contained structure, or NULL on error
}

char *CHParseXMLTagContents(const char *pTagContents, int cbLength)
{
const char *pCur = pTagContents, *pEnd = pTagContents + cbLength;
const char *p1, *p2, *p3;
char *pRval, *pC, *pE, *p4, *p5;
int i1, cbRval = 4096;

  if(!pCur)
  {
    return NULL;
  }

  if(cbLength < 0)
  {
    cbLength = strlen(pTagContents);
    pEnd = pTagContents + cbLength;
  }

  pC = pRval = WBAlloc(cbRval);
  if(!pRval)
  {
    WB_ERROR_PRINT("%s - not enough memory\n", __FUNCTION__);
    return NULL;
  }

  pE = pRval + cbRval;

  pC[0] = pC[1] = 0;


  // NOTE:  XML spec requires that '>' and '&' be treated special, and quotes ignored for these.
  //        The strings "&amp;" "&lt;" "&gt;" must also be honored inside or outside of quotes.
  //        when I find '>' inside of quotes, I could optionally ignore it, but the spec says "NO"
  //        so the result should be some kind of XML syntax error...

  while(pCur < pEnd && *pCur)
  {
    // find value name
    while(pCur < pEnd && *pCur && *pCur <= ' ')
    {
      pCur++; // skip white space
    }

    p1 = pCur;
    while(pCur < pEnd && *pCur > ' ' && *pCur != '=' && *pCur != '>' && *pCur != '[' && *pCur != '(')
    {
      pCur++; // find end of string
    }

    if(pCur >= pEnd)
    {
      break; // went past the end of the buffer
    }

    if(*pCur == '>') // end of tag?
    {
      if(pCur == p1) // empty value
      {
        break; // I am done
      }
      else if(pCur >= p1 + 2 && *(pCur - 1) == '-' && *(pCur - 2) == '-')
      {
        pCur -= 2; // prior to '-->'
      }
      else if(*(pCur - 1) == '/')
      {
        pCur --; // prior to '/>'
      }
    }
#if 0
    else if(*pCur == '(' || *pCur == '[') // an embedded section ??? [this only applies to CDATA]
    {
      // in this case it's an embedded entity and I want to preserve it in its entirety
      char cTemp = *pCur;

      if(cTemp == '(')
      {
        cTemp = ')';
      }
      else
      {
        cTemp = ']';
      }

      pCur++;
      if(pCur >= pEnd)
      {
        break; // I'm outa here - past end of buffer
      }

      p2 = pCur;
      pCur = CHFindEndOfXMLSection(pCur, pEnd - pCur, cTemp, 0); // find end of section

      if(pCur < pEnd)
      {
        pCur++; // point to next char past the end of this section
      }

      p5 = WBCopyStringN(p2, pCur - p2); // make a copy of the section, allocated as p5

      goto value_is_now_p5; // this will check for NULL 'p5' also
    }
#endif // 0

    if(pCur == p1)
    {
      break; // I am done
    }


    p2 = pCur;

    while(pCur < pEnd && *pCur && *pCur <= ' ')
    {
      pCur++; // skip white space
    }

    // NOTE:  this function does not handle '&amp;' or '&gt;' etc. outside of quotes

    if(pCur < pEnd && *pCur == '=') // value follows
    {
      pCur++;

      while(pCur < pEnd && *pCur && *pCur <= ' ')
      {
        pCur++; // skip white space
      }

      p3 = pCur;

      if(*pCur == '"' || *pCur == '\'') // quoted string
      {
        char c1 = *pCur;
        pCur++;
        while(pCur < pEnd && *pCur &&
              (*pCur != c1 || (pCur < pEnd - 1 && pCur[1] == c1)))
        {
          if(*pCur == c1) // will be < pEnd - 1
          {
            pCur += 2;
          }
          else
          {
            pCur++;
          }
        }

        if(*pCur == '"')
        {
          pCur++; // now past the quote
        }

        p5 = WBCopyStringN(p3, pCur - p3); // copy all including start/end quotes

        // make de-quoted normalized version
        if(p5)
        {
          WBNormalizeXMLString(p5); // remove quotes and sub '&gt;' '&amp;' etc.
        }
      }
      else
      {
        while(pCur < pEnd && *pCur > ' ' && *pCur != '>')
        {
          pCur++; // find end of string
        }

        if(*pCur == '>') // end of tag?
        {
          if(pCur == p3) // empty value
          {
            goto no_value;
          }
          else if(pCur >= p3 + 2 && *(pCur - 1) == '-' && *(pCur - 2) == '-')
          {
            pCur -= 2; // prior to '-->'
          }
          else if(*(pCur - 1) == '/')
          {
            pCur --; // prior to '/>'
          }
        }

        if(pCur == p3) // 'value= />'  yeah, I accept it
        {
          goto no_value;
        }

        p5 = WBCopyStringN(p3, pCur - p3);

        // make normalized version
        if(p5)
        {
          WBNormalizeXMLString(p5); // remove quotes and sub '&gt;' '&amp;' etc.
        }
      }

//value_is_now_p5:

      if(!p5)
      {
        WBFree(pRval);
        WB_ERROR_PRINT("%s - not enough memory\n", __FUNCTION__);
        return NULL;
      }

      // value is now p5

      if(pC + (p2 - p1) + strlen(p5) + 4 >= pE)
      {
        i1 = 4096;
        while((p2 - p1) + strlen(p5) + 4 >= i1)
        {
          i1 += 4096; // to make sure it's big enough in 4k increments
        }

        cbRval += i1;
        p4 = WBReAlloc(pRval, cbRval);

        if(!p4)
        {
          WBFree(p5);
          WBFree(pRval);
          WB_ERROR_PRINT("%s - not enough memory\n", __FUNCTION__);
          return NULL;
        }

        if(p4 != pRval)
        {
          pC = p4 + (pC - pRval);
          pRval = p4;
        }

        pE = pRval + cbRval;
      }

      // now do value=the value\0\0 and point 'pC' to the 2nd '\0'
      memcpy(pC, p1, p2 - p1);
      pC += p2 - p1;
      *(pC++) = '=';
      strcpy(pC, p5);
      pC += strlen(pC) + 1;
      *pC = 0;

      WBFree(p5); // done with it
    }
    else // no value
    {
no_value:
      if(pC + (p2 - p1) + 3 >= pE)
      {
        i1 = 4096;
        while((p2 - p1) + 3 >= i1)
        {
          i1 += 4096; // to make sure it's big enough in 4k increments
        }

        cbRval += i1;
        p4 = WBReAlloc(pRval, cbRval);

        if(!p4)
        {
          WBFree(pRval);
          WB_ERROR_PRINT("%s - not enough memory\n", __FUNCTION__);
          return NULL;
        }

        if(p4 != pRval)
        {
          pC = p4 + (pC - pRval);
          pRval = p4;
        }

        pE = pRval + cbRval;
      }

      // now do value=\0\0 and point 'pC' to the 2nd '\0'
      memcpy(pC, p1, p2 - p1);
      pC += p2 - p1;
      *(pC++) = '=';
      *(pC++) = 0;
      *pC = 0; // by convention
    }
  }


  return pRval;
}

const char *CHFindNextXMLTag(const char *pTagContents, int cbLength, int nNestingFlags)
{
const char *p1, *pEnd = pTagContents + cbLength;


  if(!pTagContents || cbLength == 0 || !*pTagContents)
  {
    return pTagContents;
  }

  if(cbLength < 0)
  {
    cbLength = strlen(pTagContents);
  }

  p1 = pTagContents;

  // outside of a tag, we don't check quote marks.  however, I do check for parens
  // when the bit flags in 'nNestingFlags' tell me to.
  // TODO:  add a 'quote mark' check to 'nNestingFlags' ?

  // NOTE:  XML spec requires that '>' and '&' be treated special, and quotes ignored for these.
  //        The strings "&amp;" "&lt;" "&gt;" must also be honored inside or outside of quotes.
  //        when I find '>' inside of quotes, I could optionally ignore it, but the spec says "NO"
  //        so the result should be some kind of XML syntax error...

  while(p1 < pEnd && *p1)
  {
    if(*p1 == '<') // next tag (includes comment tags, etc.)
    {
      break;
    }

    // TODO:  exit if I find ending tag?

    if((nNestingFlags & CHPARSEXML_PAREN) && (*p1 == '(' || *p1 == ')'))
    {
      break;
    }

    if((nNestingFlags & CHPARSEXML_BRACKET) && (*p1 == '[' || *p1 == ']'))
    {
      break;
    }

    p1++;
  }

  return p1;
}


const char *CHFindEndOfXMLSection(const char *pTagContents, int cbLength, char cEndChar, int bUseQuotes)
{
register const char *p1 = pTagContents;
const char *pE;


  if(!p1 || !cbLength)
  {
    return NULL;
  }

  if(cbLength < 0)
  {
    cbLength = strlen(p1);
  }

  pE = p1 + cbLength;

  // in cases of <!CDATA ... >  and other tags that might have nesting within them, this
  // function needs to pay attention to '[' ']' '(' and ')' that are OUTSIDE of quoted strings

  // NOTE:  XML spec requires that '>' and '&' be treated special, and quotes ignored for these.
  //        The strings "&amp;" "&lt;" "&gt;" must also be honored inside or outside of quotes.
  //        when I find '>' inside of quotes, I could optionally ignore it, but the spec says "NO"
  //        so the result should be some kind of XML syntax error...

  while(p1 < pE && *p1)
  {
    // need to parse out this tag.
    if(bUseQuotes && (*p1 == '"' || *p1 == '\'')) //handle quotes
    {
      char c1 = *p1;
      p1++;
      if(p1 >= pE)
      {
        break;
      }

      while(p1 < pE && *p1 &&
            (*p1 != c1 || ((p1 + 1) < pE && p1[1] == c1)))
      {
        if(*p1 == c1) // doubled quote?
        {
          p1 += 2;
        }
        else
        {
          p1++;
        }
      }

      if(p1 >= pE)
      {
        break;
      }

      if(*p1 == c1)
      {
        p1++; // now past the quote
      }
    }
    else if(*p1 == cEndChar) // end of the tag/section
    {
      break;
    }

    // Assuming we are already "within a tag" it's possible, for some tags, to have
    // a bunch of stuff embedded within them using '( )' '[ ]' etc..  This function
    // will recurse and allow for nested things like that.

    else if(*p1 == '(') // now we look for embedded things
    {
      p1++;
      if(p1 >= pE)
      {
        break;
      }

      p1 = CHFindEndOfXMLSection(p1, pE - p1, ')', 0);

      if(!p1 || p1 >= pE || !*p1 )
      {
        break;
      }

      p1++; // point it past the ')' I just found
    }
    else if(*p1 == '[')
    {
      p1++;
      if(p1 >= pE)
      {
        break;
      }

      p1 = CHFindEndOfXMLSection(p1, pE - p1, ']', 0);

      if(!p1 || p1 >= pE || !*p1 )
      {
        break;
      }

      p1++; // point it past the ']' I just found
    }
    else if(!bUseQuotes && *p1 == '<' && (cEndChar == ']' || cEndChar == ')'))
    {
      // special case within an embedded section surrounded by '[]' or '()'
      //   IF I'm searching for an end bracket/paren, and
      //   IF I've just run across the beginning of a tag, and
      //   IF I'm currently ignoring quote marks
      //   THEN, I want to parse the XML tag with respect to quote marks until the end of the tag

      p1++;
      if(p1 >= pE)
      {
        break;
      }

      p1 = CHFindEndOfXMLSection(p1, pE - p1, '>', 1);

      if(!p1 || p1 >= pE || !*p1 )
      {
        break;
      }

      p1++; // point it past the '>' I just found (it's embedded)
    }
    else
    {
      p1++;
    }
  }

  return p1;
}

const char *CHFindEndOfXMLTag(const char *pTagContents, int cbLength)
{
  return CHFindEndOfXMLSection(pTagContents, cbLength, '>', 1);
}



///////////////
// MIME HELPERS
///////////////

char *CHGetFileMimeType(const char *szFileName)
{
char *pRval, *p2;

  // for NOW just do this... later check if it's just a file extension
  // and get the mime type from just that

  pRval = WBRunResult("xdg-mime","query","filetype",szFileName,NULL);

  // right-trim the result (always)
  if(pRval)
  {
    p2 = pRval + strlen(pRval);
    while(p2 > pRval && *(p2 - 1) <= ' ')
    {
      *(--p2) = 0;
    }
  }

  return pRval;
}

char *CHGetMimeDefaultApp(const char *szMimeType)
{
char *pRval, *p2;

  // this function uses xdg-mime to obtain the correct default application
  // for handling whatever mime type has been passed to the function

  pRval = WBRunResult("xdg-mime","query","default",szMimeType,NULL);

  // right-trim the result (always)

  if(pRval)
  {
    p2 = pRval + strlen(pRval);
    while(p2 > pRval && *(p2 - 1) <= ' ')
    {
      *(--p2) = 0;
    }
  }

//  if(pRval && *pRval) // make sure the thing exists
//  {
//    if(WBStat(pRval, NULL));
//    {
//      WB_ERROR_PRINT("%s - unable to stat \"%s\"\n", __FUNCTION__, pRval);
//
//      // if the file does not exist or does not resolve, then I'm
//      // more or less "b0ned" and must return NULL to indicate the error...
//
//      WBFree(pRval);
//      pRval = NULL;
//    }
//  }

  return pRval;
}

// NOTE: according to http://standards.freedesktop.org/desktop-entry-spec/latest/ar01s06.html
//       the 'Exec' key in a '.desktop' file may have the following parameters:
//       %f - a single file name
//       %F - one or more file names
//       %u - a single URL
//       %U - one or more URLs
//       %i - the icon key expanded as 2 arguments (see web page)
//       %c - the translated application name (see web page)
//       %k - the desktop file's name/location/URI/whatever (see web page)
//       (all others are deprecated)

char *CHGetDesktopFileInfo(const char *szDesktopFile, const char *szInfo)
{
char *pRval, *p1, *p2, *pTemp;
int i1;

  p1 = WBSearchPath(szDesktopFile);
  if(!p1)
  {
    // desktop files can be in a couple of OTHER places...

    if(*szDesktopFile != '/')
    {
      p1 = WBAlloc(PATH_MAX * 2 + strlen(szDesktopFile));
      if(p1)
      {
        // NOTE:  there may be some system config var that tells me whether to use "/usr/share" or "/usr/local/share"
        //        may ALSO want to look in '/usr/local/share/applications/*' (xdg-open does)
        //        additionally, '~/.local/share/applications
        static const char * const aszPaths[]=
          { "/usr/local/share/applications/", "/usr/share/applications/",
            "/usr/local/share/app-install/desktop/", "/usr/share/app-install/desktop/"  };

        char *p2 = WBGetCanonicalPath("~/.local/share/applications/");
        if(p2)
        {
          strcpy(p1, p2);
          WBFree(p2); // keep non-NULL as a flag for later

          strcat(p1, szDesktopFile);
          if(WBStat(p1, NULL))
          {
            p2 = NULL; // as a flag, i.e. NOT found
          }
        }

        if(!p2) // did not find file in '~/.local/share/applications'
        {
          for(i1=0; i1 < sizeof(aszPaths)/sizeof(aszPaths[0]); i1++)
          {
            strcpy(p1, aszPaths[i1]);
            strcat(p1, szDesktopFile);
            if(!WBStat(p1, NULL)) // file exists?
            {
              break;
            }
          }

          if(i1 >= sizeof(aszPaths)/sizeof(aszPaths[0]))
          {
            WBFree(p1);
            p1 = NULL;
          }
        }
      }
    }
  }

  if(!p1)
  {
    WB_ERROR_PRINT("%s - File \"%s\" does not exist or cannot be located\n", __FUNCTION__, szDesktopFile);
    return NULL;
  }

  pTemp = WBCopyString("^");

  if(pTemp)
  {
    WBCatString(&pTemp, szInfo);
  }
  if(pTemp)
  {
    WBCatString(&pTemp, "=");  // '^whatever=' for szInfo -> "whatever"
  }

  if(!pTemp)
  {
    WBFree(p1);
    return NULL;
  }

  pRval = WBRunResult("grep",pTemp,p1,NULL);

  WBFree(p1);
  p1 = NULL;

  WB_ERROR_PRINT("TEMPORARY: %s - result \"%s\"\n", __FUNCTION__, pRval);


  if(pRval && strlen(pRval) >= strlen(pTemp))
  {
    strcpy(pRval, pRval + strlen(pTemp) - 1); // note '^' at beginning won't be in the result
    // TODO:  find the '=' and use THAT instead?
  }

  WBFree(pTemp);

  // right-trim the result (always)
  if(pRval)
  {
    p2 = pRval + strlen(pRval);
    while(p2 > pRval && *(p2 - 1) <= ' ')
    {
      *(--p2) = 0;
    }

    if(!*pRval) // if the resulting string is BLANK
    {
      WBFree(pRval);
      pRval = NULL;
    }
  }

  return pRval;
}



/////////////////////
// DEBUG FUNCTIONS
/////////////////////

#ifndef NO_DEBUG
void CHDumpConfig()
{
int i1, nSettings;

  if(!pXSettings)
  {
    WBDebugPrint("WARNING:  no CHXSettings data in CHDumpConfig\n");
    return;
  }

  WBDebugPrint("========================================================================\n");
  WBDebugPrint("CHXSettings dump - DISP: %p  # %d  SER: %u (%08xH)\n",
                pXSettings->pDisplay, pXSettings->nSettings, pXSettings->uiSerial, pXSettings->uiSerial);

  nSettings = pXSettings->nSettings;

  for(i1=0; i1 < nSettings; i1++)
  {
    WBDebugPrint("%3d %-32.32s ", i1, pXSettings->aData[i1].szName);

    switch(pXSettings->aData[i1].iType)
    {
      case XSettingsTypeInteger:
        WBDebugPrint("  integer %d (%08xH)\n",
                      pXSettings->aData[i1].uData.iData,
                      pXSettings->aData[i1].uData.iData);
        break;

      case XSettingsTypeColor:
        WBDebugPrint("  color R:%d B:%d G:%d A:%d\n",
                      pXSettings->aData[i1].uData.clrData.sRed,
                      pXSettings->aData[i1].uData.clrData.sBlue,
                      pXSettings->aData[i1].uData.clrData.sGreen,
                      pXSettings->aData[i1].uData.clrData.sAlpha);
        break;

      case XSettingsTypeString:
//        if(pXSettings->aData[i1].iLen > 32)
//        {
//          WBDebugPrint("  \"%-.32s ...\n",
//                        pXSettings->aData[i1].uData.szData);
//        }
//        else
        {
          WBDebugPrint("  \"%s\"\n",
                        pXSettings->aData[i1].uData.szData);
        }
        break;
    }
  }

  WBDebugPrint("========================================================================\n");

}

#endif // !NO_DEBUG

