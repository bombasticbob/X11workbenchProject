//////////////////////////////////////////////////////////////////////////////////////////////
//    __                                            _             _                         //
//   / _| _ __  __ _  _ __ ___    ___    __      __(_) _ __    __| |  ___ __      __  ___   //
//  | |_ | '__|/ _` || '_ ` _ \  / _ \   \ \ /\ / /| || '_ \  / _` | / _ \\ \ /\ / / / __|  //
//  |  _|| |  | (_| || | | | | ||  __/    \ V  V / | || | | || (_| || (_) |\ V  V /_| (__   //
//  |_|  |_|   \__,_||_| |_| |_| \___|_____\_/\_/  |_||_| |_| \__,_| \___/  \_/\_/(_)\___|  //
//                                   |_____|                                                //
//                                                                                          //
//    a top-level window that can have menus, toolbars, a status bar, and a client area     //
//                                                                                          //
//////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2016 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no waranties, either implied or explicit.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

/** \file frame_window.c
  * \brief Frame Window API function implementation
  *
  * A frame window is a top level window that can have a menu and an icon, and may
  * contain child windows within it.  It can USUALLY be resized, minimized, and maximized.
*/


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <signal.h>
#include <time.h>

#define _FRAME_WINDOW_C_ /* because of the atoms */

#include "window_helper.h"
#include "pixmap_helper.h"  // pixmap helpers, including pre-defined icons
#include "frame_window.h"
#include "child_frame.h"
#include "conf_help.h"
#include "draw_text.h"


#define TAB_BAR_HEIGHT           24 /* for now */
#define TAB_BAR_TAB_WIDTH        20 /* 20 average characters wide */
#define TAB_BAR_SCROLL_WIDTH     12 /* width of 'tab scroll' buttons */
#define TAB_BAR_ADD_BUTTON_WIDTH 12 /* width of 'tab add' button */
#define STATUS_BAR_HEIGHT        20
#define DEFAULT_STATUS_BAR_TAB   16 /* default 16 characters per column */

// NOTE:  estimating twice the average font char width as 12.  Should see at least 2 tabs, always, with min width (YMMV)
#define FRAME_WINDOW_MIN_WIDTH  (100 + 12 * TAB_BAR_TAB_WIDTH)             /* re-sizable window absolute minimum width */
#define FRAME_WINDOW_MIN_HEIGHT (100 + TAB_BAR_HEIGHT + STATUS_BAR_HEIGHT) /* re-sizable window absolute minimum height */



typedef struct __FRAME_WINDOW__
{
  WBFrameWindow wbFW;

  WBFWMenuHandler *pMenuHandler;     // pointer to the current menu handler structure array (internally allocated)
  WBFWMenuHandler *pDefMenuHandler;  // pointer to default menu handler (assigned by 'FWSetMenuHandlers()')

  int nChildFrames;                  // total number of child frames
  int nMaxChildFrames;               // max number of child frames within the current array
  WBChildFrame **ppChildFrames;      // Pointer to type-abstracted array of child frames
                                     // ctrl+alt+pageup/pagedown to navigate from one tab to another
  // NOTE:  'ppChildFrames' is a contiguous array, without any NULLs in between

  WB_RECT rctTabBar;                 // tab bar rectangle for mousie hits (from last Expose)
  int nFocusTab;                     // which tab has the focus?  0 if no tabs
  int nLastTab;                      // last tab to have focus; -1 when no tabs visible
  int nLeftTab, nRightTab;           // left and right tab indices, same order as in ppChildFrames (0 if no tabs)

  char *szTitle;                     // title bar string (malloc'd)
  char *szStatus;                    // status bar string (malloc'd)

  int nAvgCharWidth;                 // average character width for the specified font

  int nStatusBarTabs;                // # of tab entries.  can be negative if pStatusBarTabs is NULL
  int *pStatusBarTabs;               // status bar tab values (malloc'd).  may be NULL.

  char *pDefaultMenuResource;        // menu resource for 'default' menu

  int (* pFWCallback)(Window wID, XEvent *pEvent); // registered callback function (for various things)

  int bTabBarRectAntiRecurse;        // anti-recurse flag for calculating tab bar rect
  WB_RECT rctLastTabBarRect;         // cached value of tab bar rectangle
  int nTabBarTabWidth;               // cached calculated width of a tab on the tab bar
  int nTabBarButtonFlags;            // button flags for tab bar ('pressed')

  struct __FRAME_WINDOW__ *pNext;    // next in chain (internal use)

} FRAME_WINDOW;

struct __status_tab_cols__
{
  int left;
  int right;
  int align;
};

enum __tab_bar_button_flags__
{
  tab_bar_button_PREV       = 1, // left-scroll button "clicked" - ctrl+alt+pageup
  tab_bar_button_NEXT       = 2, // right-scroll button "clicked" - ctrl+alt_pagedown
  tab_bar_button_NEW        = 4, // new tab - ctrl+N
  tab_bar_button_BUTTONMASK = 7, // bitmask for the buttons (disables 'drag' handling)
  tab_bar_button_GRAB       = 8  // mouse being grabbed
};




int FWDefaultCallback(Window wID, XEvent *pEvent);  // default callback for frame windows (call for default processing)

static FRAME_WINDOW *InternalGet_FRAME_WINDOW(WBFrameWindow *pFW);

static void InternalPaintTabBar(FRAME_WINDOW *pFrameWindow, XExposeEvent *pEvent);
static void InternalPaintStatusBar(FRAME_WINDOW *pFrameWindow, XExposeEvent *pEvent);

static int Internal_Tab_Bar_Event(FRAME_WINDOW *pFrameWindow, XEvent *pEvent);

static void InternalCalcStatusBarRect(FRAME_WINDOW *pFrameWindow, WB_RECT *pRect);
static void InternalCalcTabBarRect(FRAME_WINDOW *pFrameWindow, WB_RECT *pRect);

int __internal_do_status_tab_cols(FRAME_WINDOW *pFrameWindow, const WB_RECT *prct, char ***pppCols, char **ppData,
                                  struct __status_tab_cols__ **ppTabs, int *pnCol);


static FRAME_WINDOW *pFrames = NULL;  // pointer to linked list of frame windows (malloc'd)

static XColor clrFG, clrBG, clrBD, clrBD2, clrBD3, clrABG;
static int iInitColorFlag = 0;


// ATOMS used by frame windows

/** \ingroup frame_window
  * \hideinitializer
  * @{
**/
Atom aNEW_TAB = None;      ///< command sent by Client Message to create a new tab (also ctrl+N)
Atom aNEXT_TAB = None;     ///< command sent by Client Message to switch to the next tab (also ctrl+alt+pgdn)
Atom aPREV_TAB = None;     ///< command sent by Client Message to switch to the previous tab (also ctrl+alt+pgup)
Atom aSET_TAB = None;      ///< command sent by Client Message to switch to the specified tab
Atom aCLOSE_TAB = None;    ///< command sent by Client Message to close the specified tab
Atom aREORDER_TAB = None;  ///< command sent by Client Message to re-order the specified tab (activate with mouse-drag)
/**
  * @}
**/



static void __internal_destroy_frame_window(FRAME_WINDOW *pTemp)
{
  int i1;

  if(pTemp->ppChildFrames)
  {
    for(i1=0; i1 < pTemp->nChildFrames && i1 < pTemp->nMaxChildFrames; i1++)
    {
      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Frame,
                     "%s - Destroy contents %d\n",
                     __FUNCTION__, i1 + 1);

      if(pTemp->ppChildFrames[i1])
      {
        // validate the pointer
#ifndef NO_DEBUG /* warning off for release build */
#warning this is potentially unsafe code...
#endif // !NO_DEBUG

        WBDestroyWindow(pTemp->ppChildFrames[i1]->wID); // TODO:  improve this
      }
    }

    free(pTemp->ppChildFrames);
    pTemp->ppChildFrames = NULL;
    pTemp->nChildFrames = 0; // by convention
    pTemp->nMaxChildFrames = 0; // this too
  }

  if(pTemp->szTitle)
  {
    free(pTemp->szTitle);
    pTemp->szTitle = NULL;
  }

  if(pTemp->szStatus)
  {
    free(pTemp->szStatus);
    pTemp->szStatus = NULL;
  }

  if(pTemp->pStatusBarTabs)
  {
    free(pTemp->pStatusBarTabs);
    pTemp->pStatusBarTabs = NULL;
  }

  if(pTemp->pDefaultMenuResource)
  {
    free(pTemp->pDefaultMenuResource);
    pTemp->pDefaultMenuResource = NULL;
  }
}

void WBFrameWindowExit()
{
  // destroy all of the frame windows

  while(pFrames)
  {
    FRAME_WINDOW *pTemp = pFrames;
    pFrames = pFrames->pNext;

    // slightly different - free the structure first, THEN destroy the window
    WBSetWindowData(pTemp->wbFW.wID, 0, NULL);
    __internal_destroy_frame_window(pTemp);
    free(pTemp);

    WBDestroyWindow(pTemp->wbFW.wID);  // making sure...
  }

}

static void InternalCheckFWAtoms(void)
{
Display *pDisplay = WBGetDefaultDisplay();

  if(aNEW_TAB      == None || // TODO:  use '&&' instad of '||' ?  only check ONE of them?  use a 'one time' flag?
     aNEXT_TAB     == None ||
     aPREV_TAB     == None ||
     aSET_TAB      == None ||
     aCLOSE_TAB    == None ||
     aREORDER_TAB  == None)
  {
    aNEW_TAB          = XInternAtom(pDisplay, "FW_NEW_TAB", False);
    aNEXT_TAB         = XInternAtom(pDisplay, "FW_NEXT_TAB", False);
    aPREV_TAB         = XInternAtom(pDisplay, "FW_PREV_TAB", False);
    aSET_TAB          = XInternAtom(pDisplay, "FW_SET_TAB", False);
    aCLOSE_TAB        = XInternAtom(pDisplay, "FW_CLOSE_TAB", False);
    aREORDER_TAB      = XInternAtom(pDisplay, "FW_REORDER_TAB", False);

    if(aNEW_TAB      == None ||
       aNEXT_TAB     == None ||
       aPREV_TAB     == None ||
       aSET_TAB      == None ||
       aCLOSE_TAB    == None ||
       aREORDER_TAB  == None)
    {
      WB_ERROR_PRINT("ERROR:  %s - unable to initialize atom(s)\n", __FUNCTION__);
    }
  }
}


#define LOAD_COLOR0(X,Y) if(CHGetResourceString(WBGetDefaultDisplay(), X, Y, sizeof(Y)) > 0) {  }
#define LOAD_COLOR(X,Y,Z) if(CHGetResourceString(WBGetDefaultDisplay(), X, Y, sizeof(Y)) <= 0){ WB_WARN_PRINT("%s - WARNING:  can't find color %s, using default value %s\n", __FUNCTION__, X, Z); strcpy(Y,Z); }

static void InternalCheckFWColors(void)
{
  Colormap colormap;

  // *Frame.background, *Frame.foreground, *WmFrame.background, *WmFrame.foreground,
  // *Form.background, *Form.foreground, *background, *foreground

  if(!iInitColorFlag)
  {
    static const char szBD2[]="#FFFFFF"; // border colors (TODO:  derive them?)
    static const char szBD3[]="#9C9A94";
    char szFG[16], szBG[16], szBD[16], szABG[16]; // note colors can typically be up to 13 characters + 0 byte

    colormap = DefaultColormap(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));

    // TODO:  add some sanity to this, maybe an API for loading colors?  *MOST* of this is now obsolete
    //        and XSETTINGS uses completely different naming.

    // (these color names and standards have changed *WAY* too many times...)

    LOAD_COLOR0("*Frame.foreground",szFG) else LOAD_COLOR0("*Form.foreground", szFG)
     else LOAD_COLOR0("*WmFrame.foreground",szFG) else LOAD_COLOR0("*WmForm.foreground", szFG)
     else LOAD_COLOR("*foreground", szFG, "#000000");
    LOAD_COLOR0("*Frame.background",szBG) else LOAD_COLOR0("*Form.background", szBG)
     else LOAD_COLOR0("*WmFrame.background",szBG) else LOAD_COLOR0("*WmForm.background", szBG)
     else LOAD_COLOR("*background", szBG, "#dcdad5"); // default for gnome
    LOAD_COLOR0("*Frame.border",szBD) else LOAD_COLOR0("*Form.border", szBD)
     else LOAD_COLOR0("*WmFrame.border",szBD) else LOAD_COLOR0("*WmForm.border", szBD)
     else LOAD_COLOR0("*borderColor", szBD)
     else LOAD_COLOR("*border", szBD, "black"); // default for gnome

    LOAD_COLOR("selected_bg_color", szABG, "#0040FF"); // a slightly greenish blue for the 'selected' color

    WB_ERROR_PRINT("TEMPORARY:  %s - szABG is \"%s\"\n", __FUNCTION__, szABG);

    XParseColor(WBGetDefaultDisplay(), colormap, szFG, &clrFG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrFG);
    XParseColor(WBGetDefaultDisplay(), colormap, szBG, &clrBG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrBG);
    XParseColor(WBGetDefaultDisplay(), colormap, szBD, &clrBD);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrBD);
    XParseColor(WBGetDefaultDisplay(), colormap, szBD2, &clrBD2);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrBD2);
    XParseColor(WBGetDefaultDisplay(), colormap, szBD3, &clrBD3);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrBD3);

    XParseColor(WBGetDefaultDisplay(), colormap, szABG, &clrABG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrABG);

    iInitColorFlag = 1;
  }
}

XColor FWGetDefaultFG(void)
{
  InternalCheckFWColors();

  return clrFG;
}

XColor FWGetDefaultBG(void)
{
  InternalCheckFWColors();

  return clrBG;
}

XColor FWGetDefaultBD(void)
{
  InternalCheckFWColors();

  return clrBD;
}


static FRAME_WINDOW *InternalGet_FRAME_WINDOW(WBFrameWindow *pFW)
{
FRAME_WINDOW *pTemp;


  if(!pFW || pFW->ulTag != FRAME_WINDOW_TAG)
  {
    return NULL; // not valid
  }

  // normally will not take long - there aren't many frame windows

  pTemp = pFrames; // start at the head of the list

  while(pTemp && pTemp != (FRAME_WINDOW *)pFW)
  {
    pTemp = pTemp->pNext;
  }

  if(pTemp)
  {
    return(pTemp);
  }

  return NULL; // not valid (this also helps with possible 'use after free' bugs)
}


WBFrameWindow *FWCreateFrameWindow(const char *szTitle, int idIcon, const char *szMenuResource,
                                   int iX, int iY, int iWidth, int iHeight,
                                   WBWinEvent pUserCallback, int iFlags)
{
  FRAME_WINDOW *pNew;
  Display *pDisplay;
  XSetWindowAttributes xswa;  /* Temporary Set Window Attribute struct */
  XSizeHints  xsh;            /* Size hints for window manager */
  XWMHints xwmh;
//  Atom aProto[3];

  pNew = (FRAME_WINDOW *)malloc(sizeof(*pNew));

  if(!pNew)
  {
    return NULL;
  }

  pDisplay = WBGetDefaultDisplay();

  InternalCheckFWColors(); // this assigns clrBD and clrBG properly
  InternalCheckFWAtoms(); // if not already done, assign atoms at this time


  bzero(pNew, sizeof(*pNew));  // NULL out the entire structure
  // assign the 'non-NULL' values for structure members
  pNew->wbFW.ulTag = FRAME_WINDOW_TAG;
  pNew->wbFW.wID = -1;         // initial (bad) value
  pNew->wbFW.iFlags = iFlags;  // save this while I'm at it

  if(szTitle)
  {
    pNew->szTitle = malloc(strlen(szTitle) + 1);
    if(!pNew->szTitle)
    {
      free(pNew);
      return NULL;
    }
    strcpy(pNew->szTitle, szTitle);
  }

  pNew->nStatusBarTabs = 0; // DEFAULT_STATUS_BAR_TAB;
  pNew->pStatusBarTabs = NULL;

  pNew->nAvgCharWidth = -1; // mostly for status bar, marks that it needs to be re-calc'd
  pNew->bTabBarRectAntiRecurse = 0; // must do this too (anti-recurse flag for tab bar)
  pNew->nTabBarButtonFlags = 0;  // must do this as well (tab bar button bit flags)

  // do the default status now

  if(WBFrameWindow_STATUS_BAR & pNew->wbFW.iFlags)
  {
    pNew->szStatus = WBCopyString("Status: none"); // default status bar text (mostly for testing)
//    WB_ERROR_PRINT("TEMPORARY: %s - window has a status bar\n", __FUNCTION__);
  }
  else
  {
    pNew->szStatus = NULL;
//    WB_ERROR_PRINT("TEMPORARY: %s - window has NO status bar\n", __FUNCTION__);
  }

  // add struct to beginning of linked list 'cause it's faster that way

  pNew->pNext = pFrames;
  pFrames = pNew;

  // NOW I get to create the actual window with its GC and callback proc

  bzero(&xswa, sizeof(xswa));

  xswa.border_pixel = clrBD.pixel;
  xswa.background_pixel = clrBG.pixel;
  xswa.colormap = DefaultColormap(pDisplay, DefaultScreen(pDisplay));
  xswa.bit_gravity = CenterGravity;

  pNew->wbFW.wID = WBCreateWindow(pDisplay, None, FWDefaultCallback, "FrameWindow",
                                  iX, iY, iWidth, iHeight, 1, InputOutput,
                                  CWBorderPixel | CWBackPixel | CWColormap | CWBitGravity,
                                  &xswa);

  if(pNew->wbFW.wID == None)//<= 0)
  {
    FWDestroyFrameWindow2((WBFrameWindow *)pNew);

    WB_ERROR_PRINT("ERROR: %s - unable to create frame window (WBCreateWindow failed)\r\n", __FUNCTION__);

    return NULL;
  }

  // immediately identify this window using window data
  WBSetWindowData(pNew->wbFW.wID, 0, (void *)pNew);
  pNew->pFWCallback = pUserCallback;

  bzero(&xsh, sizeof(xsh));

  xsh.flags = (USPosition | USSize | PBaseSize | PWinGravity);
  xsh.x = iX;
  xsh.y = iY;
  xsh.width = iWidth;
  xsh.height = iHeight;
  xsh.base_width = iWidth / 8 > FRAME_WINDOW_MIN_WIDTH ? iWidth / 8 : FRAME_WINDOW_MIN_WIDTH;      // set min size
  xsh.base_height = iHeight / 8 > FRAME_WINDOW_MIN_HEIGHT ? iHeight / 8 : FRAME_WINDOW_MIN_HEIGHT;

  // if I have a status bar, assign space for it in the 'base height'
  if(WBFrameWindow_STATUS_BAR & pNew->wbFW.iFlags) // window has tabs
  {
    xsh.base_height += STATUS_BAR_HEIGHT;  // TODO:  base this on font height.  use the same font as the menu.
  }

  xsh.win_gravity = NorthWestGravity; // StaticGravity

  bzero(&xwmh, sizeof(xwmh));
  xwmh.flags = InputHint;
  xwmh.input = !0;  // this represents 'Locally Active'

// from http://mail.gnome.org/archives/wm-spec-list/2007-March/msg00000.html

// The ICCCM provides for focus models for a window:
//
// Input Model     Input Field     WM_TAKE_FOCUS
// No Input        False           Absent
// Passive         True            Absent
// Locally Active  True            Present
// Globally Active False           Present
//
// No Input - The application never expects to receive focus.
//
// Passive - The application will get focus but it will not grab it on
// its own. Instead it will only get focus if the window manager gives it
// to it. The application cannot help determine if it wants the focus or
// not at the given time/situation.
//
// Locally Active - The same as passive, but the application will also
// give focus to other windows that it owns of its own free will, without
// any interaction with the window manager, using XSetInputFocus.
//
// Globally Active - The application will not receive focus from the
// window manager. Instead it will determine when it wants focus (from
// WM_TAKE_FOCUS suggestions given by the window manager, or from events
// such as ButtonPress or KeyPress). The application will then acquire
// focus on its own using XSetInputFocus.

  // set title, size hints, and 'WM_HINTS' hints (so WM knows where to put the window and how to set focus)
  WBSetWMProperties(pNew->wbFW.wID, szTitle, &xsh, &xwmh, NULL);

#if 0
  aProto[0] = aWM_DELETE_WINDOW;  // for now, that's the only one
  aProto[1] = aWM_TAKE_FOCUS;     // GDK does this, see set_wm_protocols() in gdkwindow-x11.c
//  aProto[2] = a_NET_WM_PING;      // GDK does this, see set_wm_protocols() in gdkwindow-x11.c
//  aProto[3] = a_NET_WM_SYNC_REQUEST; // GDK does this when HAVE_XSYNC is enabled

  aProto[sizeof(aProto)/sizeof(aProto[0]) - 1] = None;  // have an extra one at the end

  XSetWMProtocols(pDisplay, pNew->wbFW.wID, aProto, sizeof(aProto)/sizeof(aProto[0]) - 1);
      // sets WM_PROTOCOLS property for the main window...
#endif // 0

  WBSetWMProtocols(pNew->wbFW.wID, aWM_DELETE_WINDOW, aWM_TAKE_FOCUS, None);

  WBCreateWindowDefaultGC(pNew->wbFW.wID, clrFG.pixel, clrBG.pixel);

  // now allow specific kinds of input messages
  XSelectInput(pDisplay, pNew->wbFW.wID,
               WB_STANDARD_INPUT_MASK | WB_MOUSE_INPUT_MASK | WB_KEYBOARD_INPUT_MASK);


  // NEXT, create the menu (if the resource string isn't NULL)

  if(szMenuResource && *szMenuResource)
  {
    WBMenuBarWindow *pMenu;

    pNew->pDefaultMenuResource = WBCopyString(szMenuResource);

    if(!pNew->pDefaultMenuResource)
    {
      FWDestroyFrameWindow2((WBFrameWindow *)pNew);
      return NULL;
    }

    pMenu = MBCreateMenuBarWindow(pNew->wbFW.wID, szMenuResource, 0);

    if(!pMenu)
    {
      FWDestroyFrameWindow2((WBFrameWindow *)pNew);
      return NULL;
    }
  }

  FWRecalcLayout(pNew->wbFW.wID); // prior to making me visible do this

  WBSetWindowIcon(pNew->wbFW.wID, idIcon);

  if(iFlags & WBFrameWindow_APP_WINDOW)
  {
    WBSetApplicationWindow(pNew->wbFW.wID);
  }

  if(iFlags & WBFrameWindow_VISIBLE)
  {
    WBMapWindow(pDisplay, pNew->wbFW.wID);  // make window visible
    WBGetParentWindow(pNew->wbFW.wID);  // this syncs everything up
  }

  return (WBFrameWindow *)pNew;
}

void FWDestroyFrameWindow(Window wID)
{
  FWDestroyFrameWindow2(FWGetFrameWindowStruct(wID));
}

void FWDestroyFrameWindow2(WBFrameWindow *pFrameWindow)
{
  // step 1:  unhook pFrameWindow
  FRAME_WINDOW *pTemp = pFrames;
  FRAME_WINDOW *pPrev = NULL;
  Window wID;
//  int i1;

  if(!pFrameWindow || pFrameWindow->ulTag != FRAME_WINDOW_TAG)
  {
    WB_ERROR_PRINT("ERROR:  %s - invalid frame window pointer!\n", __FUNCTION__);

    return;
  }

  wID = pFrameWindow->wID;

  // this next part validates that it's in the linked list

  while(pTemp && pTemp != (FRAME_WINDOW *)pFrameWindow)
  {
    pPrev = pTemp;
    pTemp = pTemp->pNext;
  }

  if(pTemp)
  {
    if(pPrev)
      pPrev->pNext = pTemp->pNext;  // unhook
    else if(pFrames == pTemp)
      pFrames = pTemp->pNext;
  }


  if(wID > 0)
    WBDestroyWindow(wID);  // this will free the structure
  else
  {
    // I must destroy malloc'd entries and contained windows in lieu of 'FWDefaultCallback'
    __internal_destroy_frame_window((FRAME_WINDOW *)pFrameWindow);
    free(pFrameWindow);
  }
}

void FWSetUserCallback(WBFrameWindow *pFW, WBWinEvent pCallBack)
{
FRAME_WINDOW *pFrameWindow;


  if(!pFW || pFW->ulTag != FRAME_WINDOW_TAG)
  {
    return;
  }

  pFrameWindow = InternalGet_FRAME_WINDOW(pFW);

  if(!pFrameWindow)
  {
    WB_ERROR_PRINT("ERROR:  %s - no frame window pointer!\n", __FUNCTION__);

    return;
  }

  pFrameWindow->pFWCallback = pCallBack;
}

void FWSetMenuHandlers(WBFrameWindow *pFW, const WBFWMenuHandler *pHandlerArray)
{
int i1;
const WBFWMenuHandler *pH;
FRAME_WINDOW *pFrameWindow;


  if(!pFW || pFW->ulTag != FRAME_WINDOW_TAG)
  {
    return;
  }

  pFrameWindow = InternalGet_FRAME_WINDOW(pFW);

  if(!pFrameWindow)
  {
    WB_ERROR_PRINT("ERROR:  %s - no frame window pointer!\n", __FUNCTION__);

    return;
  }

  if(pFrameWindow->pMenuHandler)
  {
    free(pFrameWindow->pMenuHandler);

    pFrameWindow->pMenuHandler = NULL;
  }

  if(!pHandlerArray)
  {
    return;
  }

  // count the number of entries
  for(i1=0, pH = pHandlerArray; pH->lMenuID || pH->callback || pH->UIcallback; i1++, pH++)
  {
    // NOTHING inside the loop
  }

  // allocate space and make a copy

  pFrameWindow->pMenuHandler = (WBFWMenuHandler *)malloc(sizeof(WBFWMenuHandler) * (i1 + 2));

  if(pFrameWindow->pMenuHandler)
  {
    memcpy(pFrameWindow->pMenuHandler, pHandlerArray,
           sizeof(WBFWMenuHandler) * (i1 + 1));
  }
}

int FWDefaultCallback(Window wID, XEvent *pEvent)
{
  FRAME_WINDOW *pFrameWindow;
  Window wIDMenu;
  int iRval = 0;
#ifndef NO_DEBUG
  char tbuf[32]; // for keyboard input
  int nChar = sizeof(tbuf);
#endif // NO_DEBUG


  pFrameWindow = (FRAME_WINDOW *)FWGetFrameWindowStruct(wID);

  if(!pFrameWindow)
  {
    WB_ERROR_PRINT("ERROR:  %s - no frame window pointer!\n", __FUNCTION__);

    return 0;
  }

  wIDMenu = WBGetMenuWindow(wID);

  // TODO:  message re-direction to children BEFORE 'pFWCallback'

  if(wIDMenu)
  {
    switch(pEvent->type)
    {
      case ButtonPress:
      case ButtonRelease:
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                         "%s - BUTTON PRESS/RELEASE\n", __FUNCTION__);

        // check tab bar first since I might be grabbing the mouse
        if(WBPointInRect(pEvent->xbutton.x, pEvent->xbutton.y, pFrameWindow->rctTabBar) ||
           (pFrameWindow->nTabBarButtonFlags & tab_bar_button_GRAB))
        {
          return Internal_Tab_Bar_Event(pFrameWindow, pEvent);
        }

        if(WBPointInWindow(pEvent->xbutton.window, pEvent->xbutton.x, pEvent->xbutton.y, wIDMenu))
        {
          return WBWindowDispatch(wIDMenu, pEvent);  // menu window should handle THESE mousie events
        }

        break;

      case MotionNotify:
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                         "%s - MOTION NOTIFY\n", __FUNCTION__);

        // check tab bar first since I might be grabbing the mouse
        if(WBPointInRect(pEvent->xbutton.x, pEvent->xbutton.y, pFrameWindow->rctTabBar) ||
           (pFrameWindow->nTabBarButtonFlags & tab_bar_button_GRAB))
        {
          return Internal_Tab_Bar_Event(pFrameWindow, pEvent);
        }

        if(WBPointInWindow(pEvent->xmotion.window, pEvent->xmotion.x, pEvent->xmotion.y, wIDMenu))
        {
          return(WBWindowDispatch(wIDMenu, pEvent));  // menu window should handle mousie events
        }

        break;

      case ConfigureNotify:  // window size/position change
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                       "%s - CONFIGURE NOTIFY\n", __FUNCTION__);

        // allow message to process first, and post a message to myself
        // to re-evaluate the layout.  This is to avoid having a window that's
        // not "changed" yet trying to update its size info when size info is
        // not yet accurate.
        //
        // ALSO - I can get this on a window MOVE without a resize...

        {
          Display *pDisplay;
          XClientMessageEvent evt;

          pDisplay = WBGetWindowDisplay(wID);

          bzero(&evt, sizeof(evt));
          evt.type = ClientMessage;

          evt.display = pDisplay;
          evt.window = wID;
          evt.message_type = aRESIZE_NOTIFY;
          evt.format = 32;  // always
          evt.data.l[0] = pEvent->xconfigure.x;
          evt.data.l[1] = pEvent->xconfigure.y;
          evt.data.l[2] = pEvent->xconfigure.x + pEvent->xconfigure.width; // right
          evt.data.l[3] = pEvent->xconfigure.y + pEvent->xconfigure.height; // bottom
          evt.data.l[4] = pEvent->xconfigure.border_width; // RESERVED (for now, just do it)

          WBPostEvent(wID, (XEvent *)&evt); // NOTE:  if too slow, post 'priority' instead
        }  
        
        break;


      case ClientMessage:  // menus, etc. (they generate the 'ClientMessage')

#ifndef NO_DEBUG
        {
          char *p1 = XGetAtomName(WBGetWindowDisplay(wID), pEvent->xclient.message_type);

          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                         "%s - CLIENT MESSAGE:  %s\n", __FUNCTION__, p1);

          if(p1)
          {
            XFree(p1);
          }
        }
#endif // NO_DEBUG

        if(pEvent->xclient.message_type == aSET_FOCUS)
        {
          // set focus to window in data.l[0], or "default" if it's 'None'

          if(pEvent->xclient.data.l[0] == None)
          {
            // do I have a 'focus' child frame?
            WBChildFrame *pFocus = FWGetFocusWindow(&(pFrameWindow->wbFW));

            if(pFocus)
            {
              WBSetInputFocus(pFocus->wID);
            }
            else
            {
              WBSetInputFocus(wID); // set input focus to myself
            }
          }
          else
          {
            WBSetInputFocus((Window)pEvent->xclient.data.l[0]);
          }
        }
        else if(pEvent->xclient.message_type == aRESIZE_NOTIFY)
        {
          FWRecalcLayout(wID);

          return 1; // handled (TODO:  send to user-defined callback as well?)
        }
        else if(pEvent->xclient.message_type == aMENU_COMMAND)
        {
          //////////////////////////////////////////////////////////////////////////
          //                                _                     _ _             //
          //   _ __ ___   ___ _ __  _   _  | |__   __ _ _ __   __| | | ___ _ __   //
          //  | '_ ` _ \ / _ \ '_ \| | | | | '_ \ / _` | '_ \ / _` | |/ _ \ '__|  //
          //  | | | | | |  __/ | | | |_| | | | | | (_| | | | | (_| | |  __/ |     //
          //  |_| |_| |_|\___|_| |_|\__,_| |_| |_|\__,_|_| |_|\__,_|_|\___|_|     //
          //                                                                      //
          //////////////////////////////////////////////////////////////////////////


          // check the container window that has the current focus, and THEN
          // check the frame window for an appropriate handler

          WBChildFrame *pFocus = FWGetFocusWindow(&(pFrameWindow->wbFW));

          if(pFocus) // if a tab has a focus, use that window's event handler first
          {
            int iRet = WBWindowDispatch(pFocus->wID, pEvent);

            if(iRet) // non-zero return
            {
              return iRet; // the handler MUST return non-zero if the message should NOT be processed by the frame!
            }
          }

          if(pFrameWindow->pMenuHandler)
          {
            // search for the matching menu or ID - anything above 0x10000 is assumed to be a pointer
            const WBFWMenuHandler *pHandler = pFrameWindow->pMenuHandler;

            while(pHandler->lMenuID) // zero marks the end
            {
              long lID = pHandler->lMenuID;

              if(pHandler->lMenuID >= 0x10000L)
              {
                lID = XInternAtom(WBGetDefaultDisplay(), (const char *)lID, False);

                if(!lID)
                {
                  continue;
                }
              }

              if(pEvent->xclient.data.l[0] == lID)
              {
                if(pHandler->callback)
                {
                  if(pHandler->callback(&(pEvent->xclient)))
                  {
                    return 1;
                  }
                }

                return 0; // NOT handled or handler returned zero
              }

              pHandler++;
            }
          }
        }
        else if(pEvent->xclient.message_type == aMENU_UI_COMMAND)
        {
          //////////////////////////////////////////////////////////////////////////////////////
          //                                _   _ ___   _                     _ _             //
          //   _ __ ___   ___ _ __  _   _  | | | |_ _| | |__   __ _ _ __   __| | | ___ _ __   //
          //  | '_ ` _ \ / _ \ '_ \| | | | | | | || |  | '_ \ / _` | '_ \ / _` | |/ _ \ '__|  //
          //  | | | | | |  __/ | | | |_| | | |_| || |  | | | | (_| | | | | (_| | |  __/ |     //
          //  |_| |_| |_|\___|_| |_|\__,_|  \___/|___| |_| |_|\__,_|_| |_|\__,_|_|\___|_|     //
          //                                                                                  //
          //////////////////////////////////////////////////////////////////////////////////////

          // check 'contained' window for an appropriate UI handler before passing
          // it off to the frame window's handler

          WBChildFrame *pFocus = FWGetFocusWindow(&(pFrameWindow->wbFW));
          if(pFocus)
          {
            int iRet = WBWindowDispatch(pFocus->wID, pEvent);
            if(iRet >= 0)
            {
              return iRet;
            }

            // TODO:  determine if a '-1' value really SHOULD grey out the menu choice anyway or
            //        if I should return some OTHER value to differentiate 'grey' from 'no handler'
          }

          if(pFrameWindow->pMenuHandler)
          {
            const WBFWMenuHandler *pHandler = pFrameWindow->pMenuHandler;

            while(pHandler->lMenuID) // zero marks the end
            {
              long lID = pHandler->lMenuID;

              if(pHandler->lMenuID >= 0x10000L)
              {
                lID = XInternAtom(WBGetDefaultDisplay(), (const char *)lID, False);

                if(!lID)
                {
                  continue;
                }
              }

              if(pEvent->xclient.data.l[0] == lID) // a message handler exists
              {
                if(pHandler->UIcallback)
                {
                  WBMenu *pMenu;
                  WBMenuItem *pItem;

                  // important detail - the 'data.l' array is assumed to have 32-bit values in it,
                  // regardless of how its definition and 64/32-bitness affects the actual data storage.
                  // In effect, only the lower 32-bits is valid.  Hence, I must combine two 32-bit values
                  // together in order to make a 64-bit pointer.  For consistency I always use 2 values
                  // per pointer to pass the information via the message structure.  otherwise it gets
                  // complicated and I really don't like complicated.  it causes mistakes, errors, crashes...

#if !defined(__SIZEOF_POINTER__) // TODO find a better way to deal with pointer size
#define __SIZEOF_POINTER__ 0
#endif
#if __SIZEOF_POINTER__ == 4 /* to avoid warnings in 32-bit linux */
                  pMenu = (WBMenu *)pEvent->xclient.data.l[1];
                  pItem = (WBMenuItem *)pEvent->xclient.data.l[3];
#else // assume 64-bit pointers here, and if they truncate, should NOT get any warnings... well that's the idea
                  pMenu = (WBMenu *)((unsigned long long)pEvent->xclient.data.l[1] | ((unsigned long long)pEvent->xclient.data.l[2] << 32));
                  pItem = (WBMenuItem *)((unsigned long long)pEvent->xclient.data.l[3] | ((unsigned long long)pEvent->xclient.data.l[4] << 32));
#endif
                  // TODO:  validate pointers, otherwise a posted message might crash me (like a vulnerability)

#ifndef NO_DEBUG /* warning off for release build */
#warning this code potentially has a vulnerability in it
#endif // !NO_DEBUG

                  // if(!WBIsValidMenu(pMenu) || !WBIsValidMenuItem(pItem)) { do not do it }

                  return pHandler->UIcallback(pMenu, pItem);
                }

                return 0; // NO UI handler so return '0' [aka 'normal']
              }

              pHandler++;
            }
          }

          return -1; // if there's no handler and no UI handler, always return 'disabled'
        }
#ifndef NO_DEBUG
        else
        {
          char *p1 = XGetAtomName(WBGetWindowDisplay(wID), pEvent->xclient.message_type);

          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                         "%s - Client message %s not handled by frame window\n",
                          __FUNCTION__, p1);

          if(p1)
          {
            XFree(p1);
          }
        }
#endif // NO_DEBUG

        break;

      default:
        break;
    }
  }

  // TAB BAR (but with no menu)

  if(!(WBFrameWindow_NO_TABS & pFrameWindow->wbFW.iFlags)) // I have a tab bar
  {
    if(pEvent->type == ButtonPress ||
       pEvent->type == ButtonRelease ||
       pEvent->type == MotionNotify)
    {
      if(WBPointInRect(pEvent->xbutton.x, pEvent->xbutton.y, pFrameWindow->rctTabBar) ||
                       (pFrameWindow->nTabBarButtonFlags & tab_bar_button_GRAB)) // grabbing mouse means I get the event
      {
        return Internal_Tab_Bar_Event(pFrameWindow, pEvent);
      }
    }
    else if(pEvent->type == Expose)
    {
      InternalPaintTabBar(pFrameWindow, &(pEvent->xexpose));  // this will 'validate' the tab bar area, preventing re-paint
    }
    else if(pEvent->type == ClientMessage && // tab-related client messages
            (pEvent->xclient.message_type == aNEW_TAB ||
             pEvent->xclient.message_type == aPREV_TAB ||
             pEvent->xclient.message_type == aNEXT_TAB ||
             pEvent->xclient.message_type == aSET_TAB))
    {
//      WB_ERROR_PRINT("TODO:  %s - handle ClientMessage for the tab bar\n", __FUNCTION__);
//      WBDebugDumpEvent(pEvent);
      if(pEvent->xclient.message_type == aNEW_TAB)
      {
        // TODO:  post a WM_FILE_NEW menu command to the owner
      }
      else if(pEvent->xclient.message_type == aPREV_TAB)
      {
        if(pFrameWindow->nFocusTab > 0)
        {
          FWSetFocusWindowIndex(&(pFrameWindow->wbFW), pFrameWindow->nFocusTab - 1);
        }
      }
      else if(pEvent->xclient.message_type == aNEXT_TAB)
      {
        if((pFrameWindow->nFocusTab + 1) < pFrameWindow->nChildFrames)
        {
          FWSetFocusWindowIndex(&(pFrameWindow->wbFW), pFrameWindow->nFocusTab + 1);
        }
      }
      else if(pEvent->xclient.message_type == aSET_TAB)
      {
        if((int)pEvent->xclient.data.l[0] >= 0 &&
           (int)pEvent->xclient.data.l[0] < pFrameWindow->nChildFrames)
        {
          FWSetFocusWindowIndex(&(pFrameWindow->wbFW), (int)pEvent->xclient.data.l[0]);
        }
      }

      return 1; // handled
    }
  }


  // expose event for status bar - painting the status bar and tab bar.

  if(pEvent->type == Expose &&
     (WBFrameWindow_STATUS_BAR & pFrameWindow->wbFW.iFlags))
  {
    InternalPaintStatusBar(pFrameWindow, &(pEvent->xexpose));  // this will 'validate' the status bar area, preventing re-paint
  }


  // user callback function

  if(pFrameWindow->pFWCallback)
  {
    // for most messages, if I handle it here, I don't do further processing

    iRval = (pFrameWindow->pFWCallback)(wID, pEvent);

    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_Event | DebugSubSystem_Frame,
                   "%s - %s event and user callback returns %d\n", __FUNCTION__, WBEventName(pEvent->type), iRval);

    if(iRval)
    {
      // check message types that I do *NOT* want to 'bail out' for, as well as those
      // that I _MUST_ bail out for.

      switch(pEvent->type)
      {
        case DestroyNotify: // must process after user callback
          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                         "%s DestroyNotify and user callback returned a non-zero value\n", __FUNCTION__);

          // CONTINUE PROCESSING - after the user's callback handles DestroyNotify I must handle
          //                       it here also (at the very end)

          break;

        case Expose: // no further processing needed, special debug notification
          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                         "%s Expose event and user callback returns %d\n", __FUNCTION__, iRval);
          return iRval;  // 'expose' event already handled


        default: // all other messages, no further processing needed
          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                         "%s - %s event and user callback returns %d\n", __FUNCTION__, WBEventName(pEvent->type), iRval);
          return iRval;
      }
    }
    else
    {
      // TODO:  deal with specific events NOT handled by the user callback
    }
  }


  // At this point iRval _COULD_  be non-zero (example, DestroyNotify)
  // so don't do any handling for those messages.  For everything else,
  // a return value of ZERO means "not handled", so handle them.

  if(!iRval)
  {
    switch(pEvent->type)
    {
      case KeyPress:
        {
#ifndef NO_DEBUG
          int iACS = 0;
          int iKey = WBKeyEventProcessKey((XKeyEvent *)pEvent, tbuf, &nChar, &iACS);

          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame | DebugSubSystem_Keyboard,
                         "%s KEY PRESS for KEY %d KEYCODE %d MASK=%d (%xH)\n",
                           __FUNCTION__, iKey, ((XKeyEvent *)pEvent)->keycode,
                           ((XKeyEvent *)pEvent)->state, ((XKeyEvent *)pEvent)->state);
#endif // NO_DEBUG

          // check for menu and hotkey activation.
//          if(nChar > 0) // only for "real" characters (i.e. not just the ALT key)
          {
            WBMenuBarWindow *pMenuBar = MBGetMenuBarWindowStruct(WBGetMenuWindow(wID));

            if(pMenuBar)  // menu bar exists?
            {
              WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Menu | DebugSubSystem_Frame | DebugSubSystem_Keyboard,
                             "%s call to MBMenuProcessHotKey for menu window %d (%08xH)\n",
                             __FUNCTION__, (int)pMenuBar->wSelf, (int)pMenuBar->wSelf);

              iRval = MBMenuProcessHotKey(pMenuBar->pMenu, (XKeyEvent *)pEvent);
            }
          }
        }
        break;

      case KeyRelease:
        {
          // KeyRelease
#ifndef NO_DEBUG
          int iACS = 0, iKey = WBKeyEventProcessKey((XKeyEvent *)pEvent, tbuf, &nChar, &iACS);

          if(nChar > 0)
          {
            WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame | DebugSubSystem_Keyboard,
                           "%s KEY RELEASE for KEY %d KEYCODE %d  MASK=%d (%xH)\n",
                           __FUNCTION__, iKey, ((XKeyEvent *)pEvent)->keycode,
                           ((XKeyEvent *)pEvent)->state, ((XKeyEvent *)pEvent)->state);

          }
#endif // NO_DEBUG

        }

        break;



      case SelectionRequest:
      case SelectionClear:
      case SelectionNotify:

        return 0; // NOT handled (default handler might want to handle them, but not me)

//        return FWDoSelectionEvents(&(pFrameWindow->wbFW), wID, wIDMenu, pEvent);  <-- no longer needed
    }
  }


  // TODO:   message re-direction to children AFTER 'pFWCallback'



  // ----------------------------------------
  // DESTROY DESTROY DESTROY DESTROY DESTROY
  //
  //   special handling for 'DestroyNotify'
  //
  // DESTROY DESTROY DESTROY DESTROY DESTROY
  // ----------------------------------------


  if(pEvent->type == DestroyNotify &&
     pEvent->xdestroywindow.window == wID)
  {
//    int boolQuitFlag = (pFrameWindow->wbFW.iFlags & WBFrameWindow_APP_WINDOW) != 0;

    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                   "%s - DestroyNotify\n", __FUNCTION__);

    WBSetWindowData(wID, 0, NULL);

    __internal_destroy_frame_window(pFrameWindow);

    free(pFrameWindow);

//    if(boolQuitFlag)
//      bQuitFlag = TRUE;  // set the global 'quit' flag if I'm an application top-level window

    WB_DEBUG_PRINT(DebugLevel_Verbose | DebugSubSystem_Event | DebugSubSystem_Frame,
                   "%s - frame window destroyed\n", __FUNCTION__);
    return 1;
  }

  WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Event | DebugSubSystem_Frame,
                 "%s - frame window callback returns %d\n", __FUNCTION__, iRval);

  return iRval;  // return back the 'handled' status
}



static void InternalCalcStatusBarRect(FRAME_WINDOW *pFrameWindow, WB_RECT *pRect)
{
int iBarHeight;
XFontStruct *pFont;


  WBGetClientRect(pFrameWindow->wbFW.wID, pRect); // get the rectangle for the client area

  pFont = WBGetDefaultFont();

  if(pFrameWindow->nAvgCharWidth <= 0)
  {
    pFrameWindow->nAvgCharWidth = WBFontAvgCharWidth(WBGetDefaultDisplay(), pFont);
  }

  iBarHeight = pFont->ascent + pFont->descent + 8; // 8 pixels more than overall font height

  if(iBarHeight < STATUS_BAR_HEIGHT) // the minimum value
  {
    iBarHeight = STATUS_BAR_HEIGHT;
  }

  pRect->top = pRect->bottom - iBarHeight; // TODO:  base this on font height
}

static void InternalCalcTabBarRect(FRAME_WINDOW *pFrameWindow, WB_RECT *pRect)
{
Window wIDMenu;
WB_RECT rct, rct2;
WBMenuBarWindow *pMB;
int iBarHeight, nVisibleTabs;
XFontStruct *pFont;


  if(pFrameWindow->bTabBarRectAntiRecurse)
  {
    memcpy(pRect, &(pFrameWindow->rctLastTabBarRect), sizeof(*pRect));
    return; // don't do anything if I'm recursing
  }

  WBGetClientRect(pFrameWindow->wbFW.wID, pRect); // get the rectangle for the client area (always)

  if(WBFrameWindow_NO_TABS & pFrameWindow->wbFW.iFlags) // window has NO tabs
  {
    pRect->bottom = pRect->top; // no tab bar (empty rectangle where it WOULD be)

    pFrameWindow->nFocusTab = 0;
    pFrameWindow->nLastTab = -1;
    pFrameWindow->nLeftTab = 0;
    pFrameWindow->nRightTab = 0;

    WB_ERROR_PRINT("TEMPORARY:  %s - EMPTY tab rectangle\n", __FUNCTION__);

    memcpy(&(pFrameWindow->rctLastTabBarRect), pRect, sizeof(*pRect));

    return;
  }

  pFont = WBGetDefaultFont();

  if(pFrameWindow->nAvgCharWidth <= 0)
  {
    pFrameWindow->nAvgCharWidth = WBFontAvgCharWidth(WBGetDefaultDisplay(), pFont);
  }

  iBarHeight = pFont->ascent + pFont->descent + 14; // 14 pixels more than overall font height

  if(iBarHeight < TAB_BAR_HEIGHT) // the minimum value
  {
    iBarHeight = TAB_BAR_HEIGHT;
  }

  WBGetClientRect(pFrameWindow->wbFW.wID, &rct); // get the rectangle for the client area

  pRect->top = rct.top;
  pRect->left = rct.left;
  pRect->right = rct.right;
  pRect->bottom = rct.bottom;

  wIDMenu = WBGetMenuWindow(pFrameWindow->wbFW.wID);

  if(wIDMenu != None)
  {
    pMB = MBGetMenuBarWindowStruct(wIDMenu);

    if(pMB)
    {
      WBGetWindowRect(wIDMenu, &rct2);

      // what I want is the height.
      pRect->top += rct2.bottom - rct2.top + 1;  // regardless of rct2 values, add the height, plus 1 pixel as calculated here
    }
  }

  pRect->bottom = pRect->top + iBarHeight;

#ifndef NO_DEBUG
  if(memcmp(&(pFrameWindow->rctLastTabBarRect), pRect, sizeof(*pRect)))
  {
    WB_ERROR_PRINT("TEMPORARY:  %s - new 'last tab bar rect': %d, %d, %d, %d\n", __FUNCTION__,
                   pRect->left, pRect->top, pRect->right, pRect->bottom);

    // since the rectangle has changed, I need to re-paint things

    WBInvalidateRect(pFrameWindow->wbFW.wID, pRect, 0); // make sure I re-paint the tab bar, but not *RIGHT* *NOW*
  }
#endif // NO_DEBUG

  memcpy(&(pFrameWindow->rctLastTabBarRect), pRect, sizeof(*pRect)); // cache for later

  // NOW, use the current 'focus tab' to determine which tabs should be visible.  AND, determine
  // which tabs should be visible based on the WIDTH.

  if(!pFrameWindow->nChildFrames) // there aren't any
  {
    pFrameWindow->nFocusTab = 0;
    pFrameWindow->nLastTab = -1;
    pFrameWindow->nLeftTab = 0;
    pFrameWindow->nRightTab = 0;
    
    return;
  }

  // verify valid 'focus tab'
  if(pFrameWindow->nFocusTab < 0)
  {
    pFrameWindow->bTabBarRectAntiRecurse = 1;

    FWSetFocusWindowIndex(&(pFrameWindow->wbFW), 0);

    pFrameWindow->bTabBarRectAntiRecurse = 0;
  }
  else if(pFrameWindow->nFocusTab >= pFrameWindow->nChildFrames)
  {
    pFrameWindow->bTabBarRectAntiRecurse = 1;

    WB_ERROR_PRINT("TEMPORARY:  %s - focus tab exceeds # child frames - %d >= %d\n", __FUNCTION__,
                   pFrameWindow->nFocusTab, pFrameWindow->nChildFrames);

    FWSetFocusWindowIndex(&(pFrameWindow->wbFW), pFrameWindow->nChildFrames - 1);

    pFrameWindow->bTabBarRectAntiRecurse = 0;
  }

  // figure out what the width of a single 'tab' will be
  pFrameWindow->nTabBarTabWidth = (TAB_BAR_TAB_WIDTH * pFrameWindow->nAvgCharWidth)
                                + 6 + 14;  // 6 is border and spacing plus 12 for doc icon and spacing

  // verify the right/left tabs are 'in range' by calculating tab width and placement

  // CALCULATE TOTAL WIDTH OF TAB AREA, THEN DIVIDE BY TAB BAR WIDTH
  nVisibleTabs = pRect->right - pRect->left
               - TAB_BAR_SCROLL_WIDTH * 2
               - TAB_BAR_ADD_BUTTON_WIDTH
               - 8; // 8 pixels for additional spacing - 1 per scroll button, 2 more for 'add' buttun, + 2 more

  // figure out how many "full" tabs I can view in the current tab bar area
  nVisibleTabs /= pFrameWindow->nTabBarTabWidth;
  if(nVisibleTabs <= 0)
  {
    nVisibleTabs = 1; // always, just in case
  }

  // now, adjust the tab bar width UP to match "that"

  pFrameWindow->nTabBarTabWidth = (pRect->right - pRect->left
                                   - TAB_BAR_SCROLL_WIDTH * 2
                                   - TAB_BAR_ADD_BUTTON_WIDTH
                                   - 8) // 8 pixels for additional spacing - 1 per scroll button, 2 more for 'add' buttun, + 2 more
                                / nVisibleTabs; // re-calculates based on # of visible tabs - so they're a tad bigger now...

  if(nVisibleTabs >= pFrameWindow->nChildFrames) // enough room for everyone?  If so, show maximum # of tabs
  {
    pFrameWindow->nLeftTab = 0;
    pFrameWindow->nRightTab = pFrameWindow->nChildFrames - 1;

//    WB_ERROR_PRINT("TEMPORARY:  %s - left tab=%d, right tab=%d\n", __FUNCTION__,
//                   pFrameWindow->nLeftTab, pFrameWindow->nRightTab);
  }
  else // mangling the right/left tabs to include focus tab, and fit in the width
  {
    // in case right/left are out of range, fix them first
    if(pFrameWindow->nRightTab >= pFrameWindow->nChildFrames)
    {
      pFrameWindow->nRightTab = pFrameWindow->nChildFrames - 1;
      pFrameWindow->nLeftTab = pFrameWindow->nChildFrames - nVisibleTabs;
    }

    if(pFrameWindow->nLeftTab < 0)
    {
      pFrameWindow->nLeftTab = 0;
      pFrameWindow->nRightTab = pFrameWindow->nLeftTab + nVisibleTabs - 1;
    }

    // shrank window and not as many tabs are visible now??
    if(pFrameWindow->nRightTab >= pFrameWindow->nLeftTab + nVisibleTabs)
    {
      pFrameWindow->nRightTab = pFrameWindow->nLeftTab + nVisibleTabs - 1;
    }

    // grew window and more than the previous visible tabs are visible now?
    if(pFrameWindow->nLeftTab + nVisibleTabs >= pFrameWindow->nRightTab)
    {
      // extend left to include more tabs
      pFrameWindow->nLeftTab = pFrameWindow->nRightTab - nVisibleTabs + 1;

      if(pFrameWindow->nLeftTab < 0)
      {
        pFrameWindow->nRightTab -= pFrameWindow->nLeftTab;
        pFrameWindow->nLeftTab = 0;
      }
    }

    if(pFrameWindow->nFocusTab < pFrameWindow->nLeftTab)     // is my focus tab scrolled too far left?
    {
      pFrameWindow->nLeftTab = pFrameWindow->nFocusTab;
      pFrameWindow->nRightTab = pFrameWindow->nLeftTab + nVisibleTabs - 1;
    }
    else if(pFrameWindow->nFocusTab > pFrameWindow->nRightTab)     // is my focus tab scrolled too far right?
    {
      pFrameWindow->nRightTab = pFrameWindow->nFocusTab;
      pFrameWindow->nLeftTab = pFrameWindow->nRightTab - nVisibleTabs +1;
    }

//    WB_ERROR_PRINT("TEMPORARY:  %s - left tab=%d, right tab=%d, focus tab = %d\n", __FUNCTION__,
//                   pFrameWindow->nLeftTab, pFrameWindow->nRightTab, pFrameWindow->nFocusTab);
  }

  // th-dya th-dya th-dya th-that's all, folks!
}

void FWRecalcLayout(Window wID)
{
WB_RECT rct, rct2;
FRAME_WINDOW *pFrameWindow;
Window wIDMenu;
WBMenuBarWindow *pMB;
WBChildFrame *pCW;
int i1, iMax;


  pFrameWindow = (FRAME_WINDOW *)FWGetFrameWindowStruct(wID);

  if(!pFrameWindow)
  {
    WB_ERROR_PRINT("ERROR:  %s - no frame window pointer!\n", __FUNCTION__);

    return;
  }

  // this callback happens any time I change the window size.  Use this
  // also to re-size scrollbars and status bars and menus.

  // calculate the actual size of the client area and inform all of the 'Child Frame'
  // windows so that they can assign the size and fix scrollbars, etc. as appropriate

  WBGetClientRect(wID, &rct); // get the rectangle for the entire client area

  // obtain the height and position of the menu (if any), toolbar (if any), and tab area (if any)
  // and subtract that from rct.top - then record this as my "client area" in the FRAME_WINDOW
  // structure (iClientX, iClientY, iClientWidth, iClientHeight).


  if(!(WBFrameWindow_NO_TABS & pFrameWindow->wbFW.iFlags)) // window has tabs
  {
    InternalCalcTabBarRect(pFrameWindow, &rct2);

    rct.top = rct2.bottom + 1;
  }
  else if(None != (wIDMenu = WBGetMenuWindow(wID)))
  {
    pMB = MBGetMenuBarWindowStruct(wIDMenu);

    if(pMB)
    {
      WBGetWindowRect(wIDMenu, &rct2);

      // what I want is the height.
      rct.top += rct2.bottom - rct2.top + 1;  // regardless of rct2 values, add the height, plus 1 pixel as calculated here
    }
  }


  // if this window has a status bar on the bottom, subtract an appropriate height
  // from the bottom of the client area.

  if(WBFrameWindow_STATUS_BAR & pFrameWindow->wbFW.iFlags) // window has a status bar
  {
    InternalCalcStatusBarRect(pFrameWindow, &rct2);

    rct.bottom = rct2.top - 1;
  }

  iMax = FWGetNumContWindows(&(pFrameWindow->wbFW)); // grab this value now.  will use it later

  // Now that I've calculated the new client rectangle area, assign appropriate thingies
  // (but if it matches, skip next part, since nothing changed)

  rct.right -= rct.left; // now it's a width
  rct.bottom -= rct.top;  // now it's a height

  if(pFrameWindow->wbFW.iClientX == rct.left &&
     pFrameWindow->wbFW.iClientY == rct.top &&
     pFrameWindow->wbFW.iClientWidth == rct.right &&
     pFrameWindow->wbFW.iClientHeight == rct.bottom)
  {
    goto check_curtab; // nothing changed
  }

  // assign the new values.  This will be the "true" client area
  // of the frame window, excluding "things"
  pFrameWindow->wbFW.iClientX      = rct.left;
  pFrameWindow->wbFW.iClientY      = rct.top;
  pFrameWindow->wbFW.iClientWidth  = rct.right; // which is now a width
  pFrameWindow->wbFW.iClientHeight = rct.bottom; // which is now a height


  // next, inform all of the child frames that I'm different now

  for(i1=0; i1 < iMax; i1++)
  {
    pCW = FWGetContainedWindowByIndex(&(pFrameWindow->wbFW), i1);

    if(pCW)
    {
      FWChildFrameRecalcLayout(pCW); // inform the child frame of the layout change.  should only invalidate, not re-paint
    }
  }

  // temporarily use 'error level' so I can always see this
  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                 "%s - %d, %d, %d, %d\n", __FUNCTION__,
                 pFrameWindow->wbFW.iClientX, pFrameWindow->wbFW.iClientY,
                 pFrameWindow->wbFW.iClientWidth, pFrameWindow->wbFW.iClientHeight);

  WBInvalidateGeom(wID, NULL, 1); // and, finally, force a re-paint (mostly hidden by child frame, except tabs, borders, etc.)

check_curtab:

  // if my tab focus has changed, notify all child windows

  if(!iMax)
  {
    pFrameWindow->nLastTab = -1; // always assign to '-1' if there are no tabs

    return; // no need to update anything
  }

  // did I switch tabs?  if so, notify the NEW focus window that it needs to display itself

  pCW = FWGetContainedWindowByIndex(&(pFrameWindow->wbFW), pFrameWindow->nFocusTab);

  if(pFrameWindow->nFocusTab != pFrameWindow->nLastTab)
  {
    pFrameWindow->nLastTab = pFrameWindow->nFocusTab;

    if(pCW)
    {
      WBInvalidateRect(pCW->wID, NULL, 0);  // invalidate window
    }
  }

  // if re-calc layout in any way caused a need to update the child window, do it NOW
  // this is a do-nothing if the invalid region is empty

  if(pCW)
  {
    WBUpdateWindow/*Immediately*/(pCW->wID);
  }
}


// CONTAINED WINDOWS

int FWGetNumContWindows(const WBFrameWindow *pFW)
{
const FRAME_WINDOW *pFrameWindow;


  pFrameWindow = InternalGet_FRAME_WINDOW((WBFrameWindow *)pFW);

  if(!pFrameWindow)
  {
    WB_ERROR_PRINT("ERROR:  %s - no frame window pointer!\n", __FUNCTION__);

    return -1;
  }

  if(!pFrameWindow->ppChildFrames)
  {
    return 0;
  }

  return pFrameWindow->nChildFrames;
}

WBChildFrame * FWGetContainedWindowByIndex(const WBFrameWindow *pFW, int iIndex)
{
const FRAME_WINDOW *pFrameWindow;


  pFrameWindow = InternalGet_FRAME_WINDOW((WBFrameWindow *)pFW);

  if(!pFrameWindow)
  {
    WB_ERROR_PRINT("ERROR:  %s - no frame window pointer!\n", __FUNCTION__);

    return NULL;
  }

  if(iIndex < 0) // implies "the current focus"
  {
    iIndex = pFrameWindow->nFocusTab;
  }

  if(iIndex < 0 || !pFrameWindow->ppChildFrames || iIndex >= pFrameWindow->nChildFrames)
  {
    return NULL;
  }

  return pFrameWindow->ppChildFrames[iIndex];
}

int FWAddContainedWindow(WBFrameWindow *pFW, WBChildFrame *pNew)
{
FRAME_WINDOW *pFrameWindow;
int iRval;


  pFrameWindow = InternalGet_FRAME_WINDOW(pFW);

  if(!pFrameWindow)
  {
    WB_ERROR_PRINT("ERROR:  %s - no frame window pointer!\n", __FUNCTION__);

    return -1;
  }

  if(!pFrameWindow->ppChildFrames)
  {
    pFrameWindow->nMaxChildFrames = 256; // for now

    pFrameWindow->ppChildFrames = (WBChildFrame **)malloc(pFrameWindow->nMaxChildFrames * sizeof(WBChildFrame *));
    if(!pFrameWindow->ppChildFrames)
    {
no_memory:
      WB_ERROR_PRINT("ERROR:  %s - not enough memory\n", __FUNCTION__);
      return -1;
    }

    pFrameWindow->nChildFrames = 0; // initially
  }
  else if((pFrameWindow->nChildFrames + 1) >= pFrameWindow->nMaxChildFrames)
  {
    void *pTemp = realloc(pFrameWindow->ppChildFrames,
                          (pFrameWindow->nMaxChildFrames + 128) * sizeof(WBChildFrame *));

    if(!pTemp)
    {
      goto no_memory;
    }

    pFrameWindow->nMaxChildFrames += 128;
    pFrameWindow->ppChildFrames = (WBChildFrame **)pTemp; // re-assign new pointer    
  }

  // ADD NEW CHILD FRAME TO THE END [TODO insert just past current focus window instead?]

  iRval = pFrameWindow->nChildFrames; // always add to end of list.
  (pFrameWindow->nChildFrames)++;
  pFrameWindow->ppChildFrames[iRval] = pNew;

  WB_ERROR_PRINT("TEMPORARY:  %s - adding tab %d\n", __FUNCTION__, iRval);

  FWSetFocusWindowIndex(pFW, iRval); // set focus to it

  return iRval;
}

void FWRemoveContainedWindow(WBFrameWindow *pFW, WBChildFrame *pCont)
{
FRAME_WINDOW *pFrameWindow;
int iIndex, i2;

  pFrameWindow = InternalGet_FRAME_WINDOW(pFW);

  if(!pFrameWindow)
  {
    WB_ERROR_PRINT("ERROR:  %s - no frame window pointer!\n", __FUNCTION__);

    return;
  }

  if(!pFrameWindow->ppChildFrames || !pFrameWindow->nChildFrames)
  {
    return; // no child windows in list
  }

  for(iIndex=0; iIndex < pFrameWindow->nChildFrames; iIndex++)
  {
    if(pFrameWindow->ppChildFrames[iIndex] == pCont)
    {
      WB_ERROR_PRINT("TEMPORARY:  %s - removing tab %d\n", __FUNCTION__, iIndex);

      for(i2=iIndex + 1; i2 < pFrameWindow->nChildFrames; i2++)
      {
        pFrameWindow->ppChildFrames[i2 - 1] = pFrameWindow->ppChildFrames[i2]; // slide 'em up
      }

      pFrameWindow->nChildFrames --;
      pFrameWindow->ppChildFrames[pFrameWindow->nChildFrames] = NULL;  // by convention, to ensure no pointer re-use

      if(pFrameWindow->nFocusTab >= pFrameWindow->nChildFrames)
      {
        pFrameWindow->nFocusTab--;
      }

      // invalidate the tab bar rectangle first, before I continue
      WBInvalidateRect(pFW->wID, &(pFrameWindow->rctLastTabBarRect), 0);

      FWRecalcLayout(pFW->wID); // recalculate layout (this also updates the frame window and whatnot)

      // docs say "does not destroy the window".  it only gets removed, that's all

      return;
    }
  }
}

void FWSetFocusWindow(WBFrameWindow *pFW, WBChildFrame *pCont)
{
FRAME_WINDOW *pFrameWindow;
int iIndex;

  pFrameWindow = InternalGet_FRAME_WINDOW(pFW);

  if(!pFrameWindow)
  {
    WB_ERROR_PRINT("ERROR:  %s - no frame window pointer!\n", __FUNCTION__);

    return;
  }

  // locate the contained window from my list.  then set as 'focus tab'

  if(!pFrameWindow->ppChildFrames || !pFrameWindow->nChildFrames)
  {
    return; // no child windows in list
  }

  for(iIndex=0; iIndex < pFrameWindow->nChildFrames; iIndex++)
  {
    if(pFrameWindow->ppChildFrames[iIndex] == pCont)
    {
      FWSetFocusWindowIndex(pFW, iIndex);
      return;
    }
  }
}

void FWSetFocusWindowIndex(WBFrameWindow *pFW, int iIndex)
{
FRAME_WINDOW *pFrameWindow;
WBChildFrame *pC;
int i1;
Display *pDisplay = WBGetWindowDisplay(pFW->wID);


  pFrameWindow = InternalGet_FRAME_WINDOW(pFW);

  if(!pFrameWindow || iIndex < 0)
  {
    WB_ERROR_PRINT("ERROR:  %s - no frame window pointer!\n", __FUNCTION__);

    return;
  }

  // locate the contained window from my list.  then set as 'focus tab'

  if(!pFrameWindow->ppChildFrames || iIndex >= pFrameWindow->nChildFrames)
  {
    return; // no child windows in list, or index is greater than the maximum
  }

  pFrameWindow->nFocusTab = iIndex; // set focus to THIS one

  // go through the list and hide all of the others NOT the focus window
  for(i1=0; i1 < pFrameWindow->nChildFrames; i1++)
  {
    if(i1 == iIndex)
    {
      continue;
    }

    pC = pFrameWindow->ppChildFrames[i1];
    if(WBIsMapped(pDisplay, pC->wID))
    {
      WBUnmapWindow(pDisplay, pC->wID); // unmap it (make it invisible)
    }
  }

  // invalidate the tab bar rectangle first, before I continue
  WBInvalidateRect(pFW->wID, &(pFrameWindow->rctLastTabBarRect), 0);

  FWRecalcLayout(pFW->wID); // recalculate layout (this also updates the frame window and whatnot)
  // note that recalc'ing the layout does NOT re-paint the window.

  pC = pFrameWindow->ppChildFrames[iIndex];

//  if(!WBIsMapped(pDisplay, pC->wID))  determine why this is NOT working
  {
    WBMapWindow(pDisplay, pC->wID);     // make sure it's mapped
  }

  WBUpdateWindow(pFW->wID);  // update these windows now
  WBUpdateWindow(pC->wID);
}


void FWSetStatusText(WBFrameWindow *pFW, const char *szText)
{
WB_RECT rct;
FRAME_WINDOW *pFrameWindow;


  pFrameWindow = InternalGet_FRAME_WINDOW(pFW);

  if(!pFrameWindow)
  {
    WB_ERROR_PRINT("ERROR:  %s - no frame window pointer!\n", __FUNCTION__);

    return;
  }

  if(pFrameWindow->szStatus)
  {
    free(pFrameWindow->szStatus);
    pFrameWindow->szStatus = NULL;
  }

  if(szText)
  {
    pFrameWindow->szStatus = WBCopyString(szText);

    if(!pFrameWindow->szStatus)
    {
      WB_ERROR_PRINT("ERROR:  %s - no memory\n", __FUNCTION__);
    }
  }

  InternalCalcStatusBarRect(pFrameWindow, &rct);

  WBInvalidateRect(pFrameWindow->wbFW.wID, &rct, 1); // and, finally, invalidate the status bar and force a re-paint
}

void FWSetStatusTabInfo(WBFrameWindow *pFW, int nTabs, const int *pTabs)
{
WB_RECT rct;
FRAME_WINDOW *pFrameWindow;


  pFrameWindow = InternalGet_FRAME_WINDOW(pFW);

  if(!pFrameWindow)
  {
    WB_ERROR_PRINT("ERROR:  %s - no frame window pointer!\n", __FUNCTION__);

    return;
  }

  if(pFrameWindow->pStatusBarTabs)
  {
    free(pFrameWindow->pStatusBarTabs);

    pFrameWindow->pStatusBarTabs = NULL;
  }

  pFrameWindow->nStatusBarTabs = nTabs;

  if(pTabs)
  {
    pFrameWindow->pStatusBarTabs = (int *)malloc(sizeof(int) * (nTabs + 1));

    if(!pFrameWindow->pStatusBarTabs)
    {
      WB_ERROR_PRINT("ERROR: %s - no memory (attempt to allocate %d integers)\n", __FUNCTION__, nTabs);

      return;
    }

    memcpy(pFrameWindow->pStatusBarTabs, pTabs, sizeof(int) * nTabs);
    pFrameWindow->pStatusBarTabs[nTabs] = 0;  // always end in a zero, for now    
  }

  InternalCalcTabBarRect(pFrameWindow, &rct);

  WBInvalidateRect(pFrameWindow->wbFW.wID, &rct, 0); // and, finally, invalidate the status bar but don't re-paint yet
}

static void Internal_CalcTabRect(FRAME_WINDOW *pFrameWindow, int iIndex, WB_RECT *prctTab)
{
  if(!pFrameWindow->ppChildFrames || iIndex >= pFrameWindow->nChildFrames ||
     iIndex < pFrameWindow->nLeftTab || iIndex > pFrameWindow->nRightTab)
  {
    prctTab->left = prctTab->right = prctTab->top = prctTab->bottom = 0;
    return;
  }   

  prctTab->top = pFrameWindow->rctLastTabBarRect.top + 2;
  prctTab->bottom = pFrameWindow->rctLastTabBarRect.bottom;
  prctTab->left = (iIndex - pFrameWindow->nLeftTab) * pFrameWindow->nTabBarTabWidth
                + TAB_BAR_SCROLL_WIDTH + 2;
  prctTab->right = prctTab->left + pFrameWindow->nTabBarTabWidth;
}

static void Internal_CalcTabGeom(FRAME_WINDOW *pFrameWindow, int iIndex, WB_GEOM *pgTab)
{
  if(!pFrameWindow->ppChildFrames || iIndex >= pFrameWindow->nChildFrames ||
     iIndex < pFrameWindow->nLeftTab || iIndex > pFrameWindow->nRightTab)
  {
    pgTab->x = pgTab->y = pgTab->width = pgTab->height = 0;
    return;
  }   

  pgTab->y = pFrameWindow->rctLastTabBarRect.top + 2;
  pgTab->height = pFrameWindow->rctLastTabBarRect.bottom - pgTab->y;
  pgTab->x = (iIndex - pFrameWindow->nLeftTab) * pFrameWindow->nTabBarTabWidth
           + TAB_BAR_SCROLL_WIDTH + 2;
  pgTab->width = pFrameWindow->nTabBarTabWidth;
}

static int Internal_Tab_Bar_Event(FRAME_WINDOW *pFrameWindow, XEvent *pEvent)
{
WB_RECT rctLeft, rctRight, rctNew, rctTemp;
Display *pDisplay = WBGetWindowDisplay(pFrameWindow->wbFW.wID);
XClientMessageEvent evt;
int i1;


  if(pEvent->type == ButtonPress)
  {
    // button press within the tab zone means "grab the mouse"

    BEGIN_XCALL_DEBUG_WRAPPER
    XGrabPointer(pDisplay, pFrameWindow->wbFW.wID, 1,
                 ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | PointerMotionMask
                  | EnterWindowMask | LeaveWindowMask,
                 GrabModeAsync, // pointer mode
                 GrabModeAsync, // keyboard mode
                 None, None, CurrentTime);
    END_XCALL_DEBUG_WRAPPER

    pFrameWindow->nTabBarButtonFlags |= tab_bar_button_GRAB;
    pFrameWindow->nTabBarButtonFlags &= ~tab_bar_button_BUTTONMASK;

    // calculate the rectangle for each tab, the scroll left, the scroll right, the 'x'
    // buttons for each of the tabs, *AND* the 'new tab' button.  Handle each one as needed.

    // scroll buttons first
    // if I'm clicking within one of the scroll buttons, or the 'new tab' button, I can
    // leave now, after setting the appropriate bit.  Drags won't be relevant.

    rctLeft.top = rctRight.top = rctNew.top = pFrameWindow->rctLastTabBarRect.top + 2;
    rctLeft.bottom = rctRight.bottom = rctNew.bottom = pFrameWindow->rctLastTabBarRect.bottom - 2;

    rctLeft.left = pFrameWindow->rctLastTabBarRect.left + 2;
    rctLeft.right = rctLeft.left + TAB_BAR_SCROLL_WIDTH - 2;

    rctRight.right = pFrameWindow->rctLastTabBarRect.right - 2;
    rctRight.left = rctRight.right - TAB_BAR_SCROLL_WIDTH + 2;

    // TODO:  verify this formula works correctly
    rctNew.right = rctRight.right - TAB_BAR_SCROLL_WIDTH - 2;
    rctNew.left = rctNew.right - TAB_BAR_ADD_BUTTON_WIDTH - 2;

    if(WBPointInRect(pEvent->xbutton.x, pEvent->xbutton.y, rctLeft))
    {
      pFrameWindow->nTabBarButtonFlags |= tab_bar_button_PREV; // TODO:  handle if button 'inactive'
    }
    else if(WBPointInRect(pEvent->xbutton.x, pEvent->xbutton.y, rctRight))
    {
      pFrameWindow->nTabBarButtonFlags |= tab_bar_button_NEXT; // TODO:  handle if button 'inactive'
    }
    else if(WBPointInRect(pEvent->xbutton.x, pEvent->xbutton.y, rctNew))
    {
      pFrameWindow->nTabBarButtonFlags |= tab_bar_button_NEW;
    }

    if(pFrameWindow->nTabBarButtonFlags & tab_bar_button_BUTTONMASK) // I set a button flag?
    {
      // force re-paint of tab bar rect
//      WB_ERROR_PRINT("TEMPORARY:  %s - invalidate rect: %d, %d, %d, %d\n", __FUNCTION__,
//                     pFrameWindow->rctLastTabBarRect.left,
//                     pFrameWindow->rctLastTabBarRect.top,
//                     pFrameWindow->rctLastTabBarRect.right,
//                     pFrameWindow->rctLastTabBarRect.bottom);

      WBInvalidateRect(pFrameWindow->wbFW.wID, &(pFrameWindow->rctLastTabBarRect), 1);

      return 1; // and return, saying "I did it"
    }

//    WB_ERROR_PRINT("TODO:  %s - see if I'm clicking on a tab, a tab 'close' button, etc.\n", __FUNCTION__);

    // check to see which tab I might be clicking in

    if(pFrameWindow->nChildFrames)
    {
      for(i1=pFrameWindow->nLeftTab; i1 <= pFrameWindow->nRightTab; i1++)
      {
        Internal_CalcTabRect(pFrameWindow, i1, &rctTemp);

        if(WBPointInRect(pEvent->xbutton.x, pEvent->xbutton.y, rctTemp))
        {
          XFontStruct *pFont = WBGetDefaultFont();
          
          // did I click on the 'x' button in the upper right corner?
          // form a square equal to half the height (wide
          rctTemp.right -= 2; // 2 from the right edge
          rctTemp.left = rctTemp.right - (pFont->ascent + pFont->descent) / 2; // approximate font width
          rctTemp.top += 2 + pFont->ascent / 2; // 2 pixels plus half of the ascent down
          rctTemp.bottom = rctTemp.top + pFont->ascent / 2 + pFont->descent / 2; // bottom is 'rest of font'

// TODO:  do I really want to post/send message or should i wait until mouse release?  In the
//        case of tab delete, I might query for "are you sure" like if the file has not been saved

          bzero(&evt, sizeof(evt));
          evt.type = ClientMessage;

          evt.display = pDisplay;
          evt.window = pFrameWindow->wbFW.wID;

          if(WBPointInRect(pEvent->xbutton.x, pEvent->xbutton.y, rctTemp))
          {
            // clicking on the 'x' button to close the tab

            evt.message_type = aCLOSE_TAB;
          }
          else
          {
            // set focus to tab (do it on button press)

            if(i1 == pFrameWindow->nFocusTab)
            {
              return 1;  // do nothing (already there)
            }

            evt.message_type = aSET_TAB;
          }

          evt.data.l[0] = i1; // the tab index
          evt.format = 32;  // always

          WBPostEvent(pFrameWindow->wbFW.wID, (XEvent *)&evt); // this will re-paint

          return 1;
        }
      }
    }
    
    return 1; // for now assume "I handled it" since the mousie was grabbed
  }
  else if(pEvent->type == ButtonRelease)
  {
    if(!(pFrameWindow->nTabBarButtonFlags & tab_bar_button_GRAB)) // mouse grabbed?
    {
      pFrameWindow->nTabBarButtonFlags &= ~tab_bar_button_BUTTONMASK; // turn off button mask if not grabbed
      return 0; // "not handled"
    }

    BEGIN_XCALL_DEBUG_WRAPPER
    XUngrabPointer(pDisplay, CurrentTime);
    END_XCALL_DEBUG_WRAPPER

    pFrameWindow->nTabBarButtonFlags &= ~tab_bar_button_GRAB;

    if(!(pFrameWindow->nTabBarButtonFlags & tab_bar_button_BUTTONMASK)) // clicked on a tab, did we?
    {
      // if I'm releasing on a tab, and I dragged it, change the tab order according to the tab
      // that I'm sitting on at the moment...

// TODO:  enable this while dragging stuff, to re-paint the tabs during the drag.  but until then, don't
//      WBInvalidateRect(pFrameWindow->wbFW.wID, &(pFrameWindow->rctLastTabBarRect), 1);

      WB_ERROR_PRINT("TODO:  %s - handle tab-drags, except when I clicked the 'delete tab' button\n", __FUNCTION__);
    }
    else
    {
      // notifications

      bzero(&evt, sizeof(evt));
      evt.type = ClientMessage;

      evt.display = pDisplay;
      evt.window = pFrameWindow->wbFW.wID;

      if(pFrameWindow->nTabBarButtonFlags & tab_bar_button_NEXT)
      {
        if(pFrameWindow->nRightTab < (pFrameWindow->nChildFrames - 1))
        {
          evt.message_type = aNEXT_TAB;
        }
        else
        {
          goto no_message;
        }
      }
      else if(pFrameWindow->nTabBarButtonFlags & tab_bar_button_PREV)
      {
        if(pFrameWindow->nLeftTab > 0)
        {
          evt.message_type = aPREV_TAB;
        }
        else
        {
          goto no_message;
        }
      }
      else if(pFrameWindow->nTabBarButtonFlags & tab_bar_button_NEW)
      {
        evt.message_type = aNEW_TAB;
      }

      evt.format = 32;  // always

      WBPostEvent(pFrameWindow->wbFW.wID, (XEvent *)&evt);

no_message:

      pFrameWindow->nTabBarButtonFlags &= ~tab_bar_button_BUTTONMASK;

      WBInvalidateRect(pFrameWindow->wbFW.wID, &(pFrameWindow->rctLastTabBarRect), 1);
    }

    return 1;
  }
  else if(pEvent->type == MotionNotify)
  {
    if(pFrameWindow->nTabBarButtonFlags & tab_bar_button_GRAB) // mouse grabbed?
    {
      if(!(pFrameWindow->nTabBarButtonFlags & tab_bar_button_BUTTONMASK)) // drag not relevant for these
      {
        WB_ERROR_PRINT("TODO:  %s - handle tab-drags via visual feedback\n", __FUNCTION__);

        return 1; // "handled" (by ignoring it)
      }
    }
  }

  return 0; // not handled
}


static void InternalPaintTabBar(FRAME_WINDOW *pFrameWindow, XExposeEvent *pEvent)
{
WB_RECT rct0, rctExpose;
WB_GEOM geom0;
GC gc0;
XFontStruct *fontBold = NULL;


  if(WBFrameWindow_NO_TABS & pFrameWindow->wbFW.iFlags) // window has no tab bar?
  {
    return; // no tab bar, just bail
  }

  // obtain the most recent cached location of the tab bar.  this is important.

  memcpy(&rct0, &(pFrameWindow->rctLastTabBarRect), sizeof(rct0));

  // cache the tab bar rectangle for mouse hit tests.  not the same rect as rctLastTabBarRect
  
  pFrameWindow->rctTabBar.left   = rct0.left + 1;   // add 1 pixel for border
  pFrameWindow->rctTabBar.top    = rct0.top + 1;
  pFrameWindow->rctTabBar.right  = rct0.right - 1;  // subtract 1 pixel for border
  pFrameWindow->rctTabBar.bottom = rct0.bottom - 1;


  // does the Expose event intersect my tab bar?

  rctExpose.left   = pEvent->x;
  rctExpose.top    = pEvent->y;
  rctExpose.right  = rctExpose.left + pEvent->width;
  rctExpose.bottom = rctExpose.top + pEvent->height;

  if(!WBRectOverlapped(rct0, rctExpose))
  {
//    WB_ERROR_PRINT("TEMPORARY: %s - expose event excludes tab bar\n", __FUNCTION__);

    return; // do nothing (no overlap)
  }

  // intersect the two rectangles so I only re-paint what I have to

  if(rctExpose.top < rct0.top)
  {
    rctExpose.top = rct0.top;
  }

  if(rctExpose.bottom > rct0.bottom)
  {
    rctExpose.bottom = rct0.bottom;
  }

  if(rctExpose.left < rct0.left)
  {
    rctExpose.left = rct0.left;
  }

  if(rctExpose.right > rct0.right)
  {
    rctExpose.right = rct0.right;
  }

  // time to start painting

  geom0.x      = rctExpose.left;
  geom0.y      = rctExpose.top;
  geom0.width  = rctExpose.right - rctExpose.left;
  geom0.height = rctExpose.bottom - rctExpose.top;

//  WB_ERROR_PRINT("TEMPORARY: %s - tab bar EXPOSE rect %d, %d, %d, %d\n",
//                 __FUNCTION__, rctExpose.left, rctExpose.top, rctExpose.right, rctExpose.bottom);

  gc0 = WBBeginPaintGeom(pFrameWindow->wbFW.wID, &geom0);

  if(gc0 == None)
  {
    WB_ERROR_PRINT("ERROR: %s - no GC from WBBeginPaintGeom\n", __FUNCTION__);
  }
  else
  {
    Display *pDisplay = WBGetWindowDisplay(pFrameWindow->wbFW.wID);
    Drawable dw;
    WB_GEOM geom, g2;
    GC gc;
    WB_RECT rct, rctTemp;
    XColor clr;


    gc = WBGetWindowCopyGC2(pFrameWindow->wbFW.wID, gc0);

    if(gc != None)
    {
      BEGIN_XCALL_DEBUG_WRAPPER
      XCopyGC(pDisplay, gc0,
              GCFont | GCFillStyle | GCForeground | GCBackground | GCCapStyle | GCFunction | GCLineWidth,
              gc);
      END_XCALL_DEBUG_WRAPPER
    }

    BEGIN_XCALL_DEBUG_WRAPPER
    dw = (Drawable)XCreatePixmap(pDisplay, pFrameWindow->wbFW.wID,
                                 rct0.right - rct0.left, rct0.bottom - rct0.top,
                                 DefaultDepth(pDisplay, DefaultScreen(pDisplay)));
    END_XCALL_DEBUG_WRAPPER

    if(gc == None || dw == None)
    {
      BEGIN_XCALL_DEBUG_WRAPPER
      if(gc != None)
      {
        XFreeGC(pDisplay, gc);
      }

      if(dw != None)
      {
        XFreePixmap(pDisplay, (Pixmap)dw);
      }
      END_XCALL_DEBUG_WRAPPER

      dw = pFrameWindow->wbFW.wID;
      gc = gc0; // as a fallback

      memcpy(&rct, &rct0, sizeof(rct));
      memcpy(&geom, &geom0, sizeof(geom));

      WB_ERROR_PRINT("ERROR:  %s - unable to create pixmap or 2nd gc; fallback invoked\n", __FUNCTION__);
    }
    else
    {
      Region rgn;

      rct.left = rct.top = 0;

      rct.right = rct0.right - rct0.left;
      rct.bottom = rct0.bottom - rct0.top;

      geom.x = geom.y = 0;
      geom.width = geom0.width;
      geom.height = geom0.height;
      geom.border = geom0.border;

      rgn = WBRectToRegion(&rct);

      BEGIN_XCALL_DEBUG_WRAPPER
      XSetRegion(pDisplay, gc, rgn); // new GC has different clip region
      END_XCALL_DEBUG_WRAPPER

      if(rgn != None)
      {
        XDestroyRegion(rgn);
      }
    }

//    WB_ERROR_PRINT("TEMPORARY: %s - filling display geom %d, %d, %d, %d\n",
//                   __FUNCTION__, geom.x, geom.y, geom.width, geom.height);

    // fill the rectangle with the background color

    BEGIN_XCALL_DEBUG_WRAPPER
    XSetForeground(pDisplay, gc, clrBG.pixel);

    XFillRectangle(pDisplay, dw, gc, rct.left, rct.top, rct.right - rct.left, rct.bottom - rct.top);

    XSetForeground(pDisplay, gc, clrFG.pixel);
    END_XCALL_DEBUG_WRAPPER

    // draw some lines in some colors for the border

    g2.x = rct.left;
    g2.y = rct.top;
    g2.width = rct.right - rct.left;
    g2.height = rct.bottom - rct.top;

    WBDraw3DBorderRect(pDisplay, dw, gc, &g2, clrBD3.pixel, clrBD2.pixel); // sunken


    // draw the 'left' (aka 'PREV') button

    g2.x = rct.left + 1;
    g2.y = rct.top + 1;
    g2.width = TAB_BAR_SCROLL_WIDTH;
    g2.height = rct.bottom - rct.top - 2;

    if((pFrameWindow->nTabBarButtonFlags & tab_bar_button_PREV) && pFrameWindow->nLeftTab > 0)
    {
      WBDraw3DBorderRect(pDisplay, dw, gc, &g2, clrBD3.pixel, clrBD2.pixel);
    }
    else
    {
      WBDraw3DBorderRect(pDisplay, dw, gc, &g2, clrBD2.pixel, clrBD3.pixel);
    }

    g2.y += g2.height >> 2;
    g2.height = (g2.height >> 2) + (g2.height >> 2);

    WBDrawLeftArrow(pDisplay, dw, gc, &g2,
                    (pFrameWindow->nLeftTab > 0) ? clrFG.pixel : clrBD3.pixel);


    // draw the 'right' (aka 'NEXT') button

    g2.x = rct.right - TAB_BAR_SCROLL_WIDTH - 1;
    g2.y = rct.top + 1;
    g2.width = TAB_BAR_SCROLL_WIDTH;
    g2.height = rct.bottom - rct.top - 2;

    if((pFrameWindow->nTabBarButtonFlags & tab_bar_button_NEXT) && pFrameWindow->nRightTab < (pFrameWindow->nChildFrames - 1))
    {
      WBDraw3DBorderRect(pDisplay, dw, gc, &g2, clrBD3.pixel, clrBD2.pixel);
    }
    else
    {
      WBDraw3DBorderRect(pDisplay, dw, gc, &g2, clrBD2.pixel, clrBD3.pixel);
    }

    g2.y += g2.height >> 2;
    g2.height = (g2.height >> 2) + (g2.height >> 2);

    WBDrawRightArrow(pDisplay, dw, gc, &g2,
                     (pFrameWindow->nRightTab < (pFrameWindow->nChildFrames - 1)) ? clrFG.pixel : clrBD3.pixel);


    // draw the '+' button for new document

    g2.x = (rct.right - TAB_BAR_SCROLL_WIDTH - 1) - (TAB_BAR_ADD_BUTTON_WIDTH + 1);
    g2.y = rct.top + 1;
    g2.width = TAB_BAR_ADD_BUTTON_WIDTH;
    g2.height = rct.bottom - rct.top - 2;

    if(pFrameWindow->nTabBarButtonFlags & tab_bar_button_NEW)
    {
      WBDraw3DBorderRect(pDisplay, dw, gc, &g2, clrBD3.pixel, clrBD2.pixel);
    }
    else
    {
      WBDraw3DBorderRect(pDisplay, dw, gc, &g2, clrBD2.pixel, clrBD3.pixel);
    }

    g2.y += 2;
    g2.height -= 4;

    // invent my own color for the '+' button, in this case #0040A0
    RGB255_TO_XCOLOR(0, 0x40, 0xa0, clr);

    PXM_RGBToPixel(NULL, &clr);
//    WB_ERROR_PRINT("TEMPORARY:  red=%d, green=%d, blue=%d, pixel=%d\n",
//                   clr.red, clr.green, clr.blue, clr.pixel);
    
    BEGIN_XCALL_DEBUG_WRAPPER
    XSetForeground(pDisplay, gc, clr.pixel/*clrFG.pixel*/); // for now use foreground color; later, ??
    END_XCALL_DEBUG_WRAPPER

    rctTemp.left = g2.x;
    rctTemp.top = g2.y;
    rctTemp.right = g2.x + g2.width;
    rctTemp.bottom = g2.y + g2.height;

    // NEXT, load a BOLD version of the default font to display the '+'

    fontBold = WBLoadModifyFont(pDisplay, WBGetDefaultFont(), 0, WBFontFlag_WT_BOLD);

    // put a 'splat' in the middle of this button
    DTDrawSingleLineText(fontBold ? fontBold : WBGetDefaultFont(),
                         "+", pDisplay, gc, dw, 0, 0, &rctTemp,
                         DTAlignment_HCENTER | DTAlignment_VCENTER);

    BEGIN_XCALL_DEBUG_WRAPPER
    XSetForeground(pDisplay, gc, clrFG.pixel); // by convention, (re)set FG color again [for text I need this]
    END_XCALL_DEBUG_WRAPPER

    // TODO:  draw the actual tabs and the text within them

//  WB_RECT rctLastTabBarRect;         // cached value of tab bar rectangle
//  int nTabBarTabWidth;               // cached calculated width of a tab on the tab bar
//  int nTabBarButtonFlags;            // button flags for tab bar ('pressed')

    if(pFrameWindow->ppChildFrames && pFrameWindow->nChildFrames)
    {
      WBChildFrame *pC;
      int i1;

      for(i1=pFrameWindow->nRightTab; i1 >= pFrameWindow->nLeftTab; i1--)
      {
        if(i1 != pFrameWindow->nFocusTab)
        {
          if(i1 >= pFrameWindow->nChildFrames)
          {
            continue;
          }

          pC = pFrameWindow->ppChildFrames[i1];

          if(!pC)
          {
            continue;
          }

          Internal_CalcTabGeom(pFrameWindow, i1, &g2); // the geom in window coordinates
          g2.x -= rct0.left; // translate to 'drawable' coordinates
          g2.y -= rct0.top;

          WBDraw3DBorderTab(pDisplay, dw, gc, &g2, 0, clrFG.pixel, clrBG.pixel,
                            clrBD2.pixel, clrBD3.pixel, clrABG.pixel,
                            WBGetDefaultFont(), fontBold,
                            pC->aImageAtom, pC->szDisplayName);
        }
      }

      i1 = pFrameWindow->nFocusTab; // this one is done last

      if(i1 < pFrameWindow->nChildFrames)
      {
        pC = pFrameWindow->ppChildFrames[i1];

        if(pC)
        {
          Internal_CalcTabGeom(pFrameWindow, i1, &g2); // the geom in window coordinates
          g2.x -= rct0.left; // translate to 'drawable' coordinates
          g2.y -= rct0.top;

          WBDraw3DBorderTab(pDisplay, dw, gc, &g2, 1, clrFG.pixel, clrBG.pixel,
                            clrBD2.pixel, clrBD3.pixel, clrABG.pixel,
                            WBGetDefaultFont(), fontBold,
                            pC->aImageAtom, pC->szDisplayName);
        }
      }
    }

    // if I'm using a pixmap, now I copy it to the window

    if(dw != pFrameWindow->wbFW.wID)
    {
      BEGIN_XCALL_DEBUG_WRAPPER
      // copy my drawn pixmap onto the window
      XCopyArea(pDisplay, dw, pFrameWindow->wbFW.wID, gc0,
                rct.left, rct.top, rct.right - rct.left, rct.bottom - rct.top,
                rct0.left, rct0.top);
      END_XCALL_DEBUG_WRAPPER
    }

    // RESOURCE CLEANUP

    BEGIN_XCALL_DEBUG_WRAPPER
    if(fontBold)
    {
      XFreeFont(pDisplay, fontBold);

      fontBold = NULL; // avoid re-use
    }

    if(gc != gc0)
    {
      XFreeGC(pDisplay, gc);
      gc = None;
    }

    if(dw != pFrameWindow->wbFW.wID)
    {
      XFreePixmap(pDisplay, (Pixmap)dw);
      dw = None;
    }
    END_XCALL_DEBUG_WRAPPER

    WBEndPaint(pFrameWindow->wbFW.wID, gc0);  // and that's it!
  }

  // finally, alter the expose event slightly so that it reflects the 'painted' area

  if(pEvent->y < rct0.bottom)
  {
//    WB_ERROR_PRINT("TEMPORARY: %s - altering x and height in Expose event\n", __FUNCTION__);

    if(pEvent->y >= rct0.top && pEvent->y < rct0.bottom) // so it only includes the tab area but overlaps it
    {
      pEvent->height -= rct0.bottom - pEvent->y;
      pEvent->y = rct0.bottom;

      if(pEvent->height < 0) // just in case
      {
        pEvent->height = 0;
      }
    }
  }
}


static void InternalPaintStatusBar(FRAME_WINDOW *pFrameWindow, XExposeEvent *pEvent)
{
WB_RECT rct, rctExpose, rctTemp, rctPrev;
WB_GEOM geom;
GC gc;
int i1;



  if(!(WBFrameWindow_STATUS_BAR & pFrameWindow->wbFW.iFlags)) // window has a status bar?
  {
    return; // no status bar, just bail
  }

  // calculate the location of the status bar

  InternalCalcStatusBarRect(pFrameWindow, &rct);

  // does the Expose event intersect my status bar?

  rctExpose.left   = pEvent->x;
  rctExpose.top    = pEvent->y;
  rctExpose.right  = rctExpose.left + pEvent->width;
  rctExpose.bottom = rctExpose.top + pEvent->height;

  if(!WBRectOverlapped(rct, rctExpose))
  {
//    WB_ERROR_PRINT("TEMPORARY: %s - expose event excludes status bar\n", __FUNCTION__);

    return; // do nothing (no overlap)
  }

  // intersect the two rectangles so I only re-paint what I have to

  if(rctExpose.top < rct.top)
  {
    rctExpose.top = rct.top;
  }

  if(rctExpose.bottom > rct.bottom)
  {
    rctExpose.bottom = rct.bottom;
  }

  if(rctExpose.left < rct.left)
  {
    rctExpose.left = rct.left;
  }

  if(rctExpose.right > rct.right)
  {
    rctExpose.right = rct.right;
  }

  // time to start painting

  geom.x      = rctExpose.left;
  geom.y      = rctExpose.top;
  geom.width  = rctExpose.right - rctExpose.left;
  geom.height = rctExpose.bottom - rctExpose.top;

  gc = WBBeginPaintGeom(pFrameWindow->wbFW.wID, &geom);

  if(gc == None)
  {
    WB_ERROR_PRINT("ERROR: %s - no GC from WBBeginPaintGeom\n", __FUNCTION__);
  }
  else
  {
    XFontStruct *pFont = WBGetDefaultFont(); // for now, use the default font
    Display *pDisplay = WBGetWindowDisplay(pFrameWindow->wbFW.wID);
    XPoint xpt[3];

    // fill the rectangle with the background color

    WBClearWindow(pFrameWindow->wbFW.wID, gc); // should only paint my little rectangle

    // draw some lines in some colors for the border

    // paint the 3D-looking border
    XSetForeground(pDisplay, gc, clrBD2.pixel);
    xpt[0].x=rct.left;
    xpt[0].y=rct.bottom - 2;  // exclude first point
    xpt[1].x=rct.left;
    xpt[1].y=rct.top;
    xpt[2].x=rct.right - 2;   // exclude last point
    xpt[2].y=rct.top;

    XDrawLines(pDisplay, pFrameWindow->wbFW.wID, gc, xpt, 3, CoordModeOrigin);

    XSetForeground(pDisplay, gc, clrBD3.pixel);
    xpt[0].x=rct.right - 1;
    xpt[0].y=rct.top + 1;              // exclude first point
    xpt[1].x=rct.right - 1;
    xpt[1].y=rct.bottom - 1;
    xpt[2].x=rct.left + 1;              // exclude final point
    xpt[2].y=rct.bottom - 1;

    XDrawLines(pDisplay, pFrameWindow->wbFW.wID, gc, xpt, 3, CoordModeOrigin);

    XSetForeground(pDisplay, gc, clrFG.pixel); // by convention, set it to FG [for text I need this]

    if(pFrameWindow->szStatus && pFont)
    {
      rctTemp.left = rct.left + 8;     // this is the outside bounding rectangle
      rctTemp.top = rct.top + 2;       // for the entire status bar.
      rctTemp.right = rct.right - 8;
      rctTemp.bottom = rct.bottom - 2;

      if(!pFrameWindow->pStatusBarTabs || !pFrameWindow->nStatusBarTabs) // fixed tab width (or no tabs)
      {
        int iFixedTab = pFrameWindow->nStatusBarTabs;
        
        if(!iFixedTab)
        {
          iFixedTab = DEFAULT_STATUS_BAR_TAB;
        }

        iFixedTab *= pFrameWindow->nAvgCharWidth; //WBFontAvgCharWidth(pDisplay, pFont);

        DTDrawSingleLineText(pFont,
                             pFrameWindow->szStatus, pDisplay,
                             gc, pFrameWindow->wbFW.wID,
                             iFixedTab, 0, // fixed tab widths
                             &rctTemp, DTAlignment_VCENTER | DTAlignment_HLEFT);
      }
      else
      {
        char **ppCols = NULL;
        char *pData = NULL;
        struct __status_tab_cols__ *pTabs;
        int nCol;

        // create the tab and column list using a utility (to simplify THIS code)
        
        if(!__internal_do_status_tab_cols(pFrameWindow, &rctTemp, &ppCols, &pData, &pTabs, &nCol))
        {
          memcpy(&rctPrev, &rctTemp, sizeof(rctTemp));

          for(i1=0; i1 < nCol && ppCols[i1]; i1++)
          {
            rctTemp.left = pTabs[i1].left;
            rctTemp.right = pTabs[i1].right;

            DTDrawSingleLineText(pFont, ppCols[i1],
                                 pDisplay, gc, pFrameWindow->wbFW.wID,
                                 0, 0, // no tabs (won't be any)
                                 &rctTemp, DTAlignment_VCENTER | pTabs[i1].align);

            rctTemp.top = rctPrev.top;
            rctTemp.bottom = rctPrev.bottom; // restore these two 'just in case'
          }

          // free the 3 'malloc'd arrays
          free(ppCols);
          free(pData);
          free(pTabs);
        }
      }
    }                         

    WBEndPaint(pFrameWindow->wbFW.wID, gc);  // and that's it!
  }

  // finally, alter the expose event slightly so that it reflects the 'painted' area

  if(pEvent->height + pEvent->x > rct.top)
  {
//    WB_ERROR_PRINT("TEMPOPRARY: %s - altering height in Expose event\n", __FUNCTION__);

    pEvent->height = rct.top - pEvent->x;
    if(pEvent->height < 0)
    {
      pEvent->height = 0;
    }
  }

  // TODO:  manage top, left, right and x, y, width?  probably don't need to

}


int __internal_do_status_tab_cols(FRAME_WINDOW *pFrameWindow, const WB_RECT *prct, char ***pppCols, char **ppData,
                                  struct __status_tab_cols__ **ppTabs, int *pnCol)
{
int i1, i2, i3, i4, iTab, nCol;
char *p1;

//      if(!pFrameWindow->pStatusBarTabs || !pFrameWindow->nStatusBarTabs) // fixed tab width (or no tabs)

  // this is where things get a bit more fun.  Look through 'pStatusBarTabs' for
  // left-aligned and right-aligned tabs.  Sort them accordingly to determine the width
  // of each column.  THEN, create the 'pTabs' and associated 'pCols' entries from that
  // so that strings and columns align to one another.

  // step 1: how many columns?

  *ppTabs = NULL;
  *pppCols = NULL;

  *ppData = WBCopyString(pFrameWindow->szStatus);

  if(!*ppData)
  {
error_return:

    *pnCol = 0;

    WB_ERROR_PRINT("ERROR:  %s - no memory\n", __FUNCTION__);

    return 1; // error return
  }


  p1 = *ppData;
  nCol = 0;

  if(*p1)
  {
    for(nCol = 1; *p1; )
    {
      while(*p1 && *p1 != '\t')
      {
        p1++;
      }

      if(*p1 == '\t')
      {
        *p1 = 0;

        nCol++;
        p1++;
      }
    }
  }

  if(nCol > pFrameWindow->nStatusBarTabs)
  {
    nCol = pFrameWindow->nStatusBarTabs; // this may get even smaller
  }

  *pnCol = nCol;

  // 'nCol' is now the total # of columns I'll be printing to.  Allocate pppCols now

  *pppCols = (char **)malloc(sizeof(char *)*(nCol + 2));

  if(!*pppCols)
  {
error_return2:

    free(*ppData);
    *ppData = NULL;

    goto error_return;
  }

  *ppTabs = (struct __status_tab_cols__ *)malloc(sizeof(**ppTabs) * (pFrameWindow->nStatusBarTabs + 1));
  if(!*ppTabs)
  {
    free(*pppCols);
    *pppCols = NULL;

    goto error_return2;    
  }

  // time to build up 'pppCols'
  p1 = *ppData;

  for(i1=0; i1 < nCol; i1++)
  {
    (*pppCols)[i1] = p1;

    p1 += strlen(p1) + 1;
  }

  // now, set up the tabs so the represent 'columns'.  'left-oriented' tabs will assign
  // the 'left' member and 'right' will be -1.  'right-oriented' tabs will assign the
  // 'right' member and 'left' will be -1.  Then I'll generate columns from the other tab info.

  for(i1=0, iTab=0; i1 < pFrameWindow->nStatusBarTabs; i1++)
  {
    i2 = pFrameWindow->pStatusBarTabs[i1];
    if(i2 & WBStatusTabInfo_BREAK) // a 'tab break', not an actual column
    {
      continue;
    }

    if(i2 & WBStatusTabInfo_RTL_COLUMN)
    {
      (*ppTabs)[iTab].left = -1;
      (*ppTabs)[iTab].right = prct->right
                            - (i2 & WBStatusTabInfo_MASK) * pFrameWindow->nAvgCharWidth;
      (*ppTabs)[iTab].align = i2 & WBStatusTabInfo_JUSTIFY_MASK;
    }
    else
    {
      (*ppTabs)[iTab].left = prct->left 
                           + (i2 & WBStatusTabInfo_MASK) * pFrameWindow->nAvgCharWidth;
      (*ppTabs)[iTab].right = -1;
      (*ppTabs)[iTab].align = i2 & WBStatusTabInfo_JUSTIFY_MASK;
    }

    iTab++; // increment total count of actual tabs
  }

  *pnCol = iTab; // the real # of columns when I have tabs specified


  // NOW, go through this list and determine how wide each column should be
  // 

  for(i1=0; i1 < iTab; i1++)
  {
    if((*ppTabs)[i1].left < 0) // RTL column
    {
      i3 = prct->left; // use the left edge for my new 'left'.  initially
    }
    else
    {
      i3 = prct->right; // use the right edge for my new 'right'.  initially
    }

    for(i2=0; i2 < pFrameWindow->nStatusBarTabs; i2++)
    {
      // find the minimum 'right' or maximum 'left' position for this column

      i4 = pFrameWindow->pStatusBarTabs[i2];

      if(i4 & WBStatusTabInfo_RTL_COLUMN)
      {
        i4 = prct->right - (i4 & WBStatusTabInfo_MASK) * pFrameWindow->nAvgCharWidth;
      }
      else
      {
        i4 = prct->left + (i4 & WBStatusTabInfo_MASK) * pFrameWindow->nAvgCharWidth;
      }

      if((*ppTabs)[iTab].left < 0) // right-justified tab
      {
        if(i4 >= (*ppTabs)[iTab].right) // don't do this, it's further right than me
        {
          continue;
        }

        if(i4 >= i3) // further right than the most current 'left'?
        {
          i3 = i4 + 1; // note I add 1 to this for column spacing
        }
      }
      else
      {
        if(i4 <= (*ppTabs)[iTab].left) // don't do this, it's further left than me
        {
          continue;
        }

        if(i4 <= i3) // further left than the most current 'right'?
        {
          i3 = i4 - 1; // note I add 1 to this for column spacing
        }
      }
    }

    if((*ppTabs)[i1].left < 0) // RTL column
    {
      (*ppTabs)[i1].left = i3;
    }
    else
    {
      (*ppTabs)[i1].right = i3;
    }
  }

  return 0; // ok!
}



