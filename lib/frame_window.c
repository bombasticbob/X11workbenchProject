//////////////////////////////////////////////////////////////////////////////////////////////
//    __                                            _             _                         //
//   / _| _ __  __ _  _ __ ___    ___    __      __(_) _ __    __| |  ___ __      __  ___   //
//  | |_ | '__|/ _` || '_ ` _ \  / _ \   \ \ /\ / /| || '_ \  / _` | / _ \\ \ /\ / / / __|  //
//  |  _|| |  | (_| || | | | | ||  __/    \ V  V / | || | | || (_| || (_) |\ V  V /_| (__   //
//  |_|  |_|   \__,_||_| |_| |_| \___|_____\_/\_/  |_||_| |_| \__,_| \___/  \_/\_/(_)\___|  //
//                                   |_____|                                                //
//                                                                                          //
//    a top-level window that can have menus, toolbars, a status bar, and a client area     //
//                                                                                          //
//////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2016 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no waranties, either implied or explicit.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

/** \file frame_window.c
  * \brief Frame Window API function implementation
  *
  * A frame window is a top level window that can have a menu and an icon, and may
  * contain child windows within it.  It can USUALLY be resized, minimized, and maximized.
*/


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <signal.h>
#include <time.h>

#include "window_helper.h"
#include "pixmap_helper.h"  // pixmap helpers, including pre-defined icons
#include "frame_window.h"
#include "child_frame.h"
#include "conf_help.h"
#include "draw_text.h"


#define FRAME_WINDOW_MIN_WIDTH 160  /* re-sizable window absolute minimum width */
#define FRAME_WINDOW_MIN_HEIGHT 120 /* re-sizable window absolute minimum height */

#define TAB_BAR_HEIGHT         20 /* for now */
#define STATUS_BAR_HEIGHT      20
#define DEFAULT_STATUS_BAR_TAB 16

typedef struct __FRAME_WINDOW__
{
  WBFrameWindow wbFW;

  WBFWMenuHandler *pMenuHandler;     // pointer to the current menu handler structure array (internally allocated)
  WBFWMenuHandler *pDefMenuHandler;  // pointer to default menu handler (assigned by 'FWSetMenuHandlers()')

  int nChildFrames;                  // total number of child frames
  int nMaxChildFrames;               // max number of child frames within the current array
  WBChildFrame **ppChildFrames;      // Pointer to type-abstracted array of child frames
                                     // ctrl+alt+pageup/pagedown to navigate from one tab to another
  // NOTE:  'ppChildFrames' is a contiguous array, without any NULLs in between

  int nFocusTab;                     // which tab has the focus?  normally 0
  int nLeftTab, nRightTab;           // left and right tab indices, same order as in ppChildFrames (0 if no tabs)

  char *szTitle;                     // title bar string (malloc'd)
  char *szStatus;                    // status bar string (malloc'd)

  int nStatusBarTabs;                // # of tab entries.  can be negative if pStatusBarTabs is NULL
  int *pStatusBarTabs;               // status bar tab values (malloc'd).  may be NULL.

  char *pDefaultMenuResource;        // menu resource for 'default' menu

  int (* pFWCallback)(Window wID, XEvent *pEvent); // registered callback function (for various things)

  struct __FRAME_WINDOW__ *pNext;    // next in chain (internal use)

} FRAME_WINDOW;


int FWDefaultCallback(Window wID, XEvent *pEvent);  // default callback for frame windows (call for default processing)

static void InternalPaintStatusBar(FRAME_WINDOW *pFrameWindow, XExposeEvent *pEvent);


static FRAME_WINDOW *pFrames = NULL;  // pointer to linked list of frame windows (malloc'd)

static XColor clrFG, clrBG, clrBD, clrBD2, clrBD3;
static int iInitColorFlag = 0;



static void __internal_destroy_frame_window(FRAME_WINDOW *pTemp)
{
  int i1;

  if(pTemp->ppChildFrames)
  {
    for(i1=0; i1 < pTemp->nChildFrames && i1 < pTemp->nMaxChildFrames; i1++)
    {
      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Frame,
                     "%s - Destroy contents %d\n",
                     __FUNCTION__, i1 + 1);

      if(pTemp->ppChildFrames[i1])
      {
        // validate the pointer
#ifndef NO_DEBUG /* warning off for release build */
#warning this is potentially unsafe code...
#endif // !NO_DEBUG

        WBDestroyWindow(pTemp->ppChildFrames[i1]->wID); // TODO:  improve this
      }
    }

    free(pTemp->ppChildFrames);
    pTemp->ppChildFrames = NULL;
    pTemp->nChildFrames = 0; // by convention
    pTemp->nMaxChildFrames = 0; // this too
  }

  if(pTemp->szTitle)
  {
    free(pTemp->szTitle);
    pTemp->szTitle = NULL;
  }

  if(pTemp->szStatus)
  {
    free(pTemp->szStatus);
    pTemp->szStatus = NULL;
  }

  if(pTemp->pStatusBarTabs)
  {
    free(pTemp->pStatusBarTabs);
    pTemp->pStatusBarTabs = NULL;
  }

  if(pTemp->pDefaultMenuResource)
  {
    free(pTemp->pDefaultMenuResource);
    pTemp->pDefaultMenuResource = NULL;
  }
}

void WBFrameWindowExit()
{
  // destroy all of the frame windows

  while(pFrames)
  {
    FRAME_WINDOW *pTemp = pFrames;
    pFrames = pFrames->pNext;

    // slightly different - free the structure first, THEN destroy the window
    WBSetWindowData(pTemp->wbFW.wID, 0, NULL);
    __internal_destroy_frame_window(pTemp);
    free(pTemp);

    WBDestroyWindow(pTemp->wbFW.wID);  // making sure...
  }

}

#define LOAD_COLOR0(X,Y) if(CHGetResourceString(WBGetDefaultDisplay(), X, Y, sizeof(Y)) > 0) {  }
#define LOAD_COLOR(X,Y,Z) if(CHGetResourceString(WBGetDefaultDisplay(), X, Y, sizeof(Y)) <= 0){ WB_WARN_PRINT("%s - WARNING:  can't find color %s, using default value %s\n", __FUNCTION__, X, Z); strcpy(Y,Z); }

static void InternalCheckColors(void)
{
  Colormap colormap;

  // *Frame.background, *Frame.foreground, *WmFrame.background, *WmFrame.foreground,
  // *Form.background, *Form.foreground, *background, *foreground

  if(!iInitColorFlag)
  {
    static const char szBD2[]="#FFFFFF";
    static const char szBD3[]="#9C9A94";
    char szFG[16], szBG[16], szBD[16];
    colormap = DefaultColormap(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));

    LOAD_COLOR0("*Frame.foreground",szFG) else LOAD_COLOR0("*Form.foreground", szFG)
     else LOAD_COLOR0("*WmFrame.foreground",szFG) else LOAD_COLOR0("*WmForm.foreground", szFG)
     else LOAD_COLOR("*foreground", szFG, "#000000");
    LOAD_COLOR0("*Frame.background",szBG) else LOAD_COLOR0("*Form.background", szBG)
     else LOAD_COLOR0("*WmFrame.background",szBG) else LOAD_COLOR0("*WmForm.background", szBG)
     else LOAD_COLOR("*background", szBG, "#dcdad5"); // default for gnome
    LOAD_COLOR0("*Frame.border",szBD) else LOAD_COLOR0("*Form.border", szBD)
     else LOAD_COLOR0("*WmFrame.border",szBD) else LOAD_COLOR0("*WmForm.border", szBD)
     else LOAD_COLOR0("*borderColor", szBD)
     else LOAD_COLOR("*border", szBD, "black"); // default for gnome

    XParseColor(WBGetDefaultDisplay(), colormap, szFG, &clrFG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrFG);
    XParseColor(WBGetDefaultDisplay(), colormap, szBG, &clrBG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrBG);
    XParseColor(WBGetDefaultDisplay(), colormap, szBD, &clrBD);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrBD);
    XParseColor(WBGetDefaultDisplay(), colormap, szBD2, &clrBD2);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrBD2);
    XParseColor(WBGetDefaultDisplay(), colormap, szBD3, &clrBD3);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrBD3);

    iInitColorFlag = 1;
  }
}

XColor FWGetDefaultFG(void)
{
  InternalCheckColors();

  return clrFG;
}

XColor FWGetDefaultBG(void)
{
  InternalCheckColors();

  return clrBG;
}

XColor FWGetDefaultBD(void)
{
  InternalCheckColors();

  return clrBD;
}



WBFrameWindow *FWCreateFrameWindow(const char *szTitle, int idIcon, const char *szMenuResource,
                                   int iX, int iY, int iWidth, int iHeight,
                                   WBWinEvent pUserCallback, int iFlags)
{
  FRAME_WINDOW *pNew;
  Display *pDisplay;
  XSetWindowAttributes xswa;  /* Temporary Set Window Attribute struct */
  XSizeHints  xsh;            /* Size hints for window manager */
  XWMHints xwmh;
//  Atom aProto[3];

  pNew = malloc(sizeof(*pNew)/*sizeof(FRAME_WINDOW)*/);

  if(!pNew)
    return NULL;

  pDisplay = WBGetDefaultDisplay();

  InternalCheckColors(); // this assigns clrBD and clrBG properly

  bzero(pNew, sizeof(*pNew));  // NULL out the entire structure
  // assign the 'non-NULL' values for structure members
  pNew->wbFW.ulTag = FRAME_WINDOW_TAG;
  pNew->wbFW.wID = -1;         // initial (bad) value
  pNew->wbFW.iFlags = iFlags;  // save this while I'm at it


  if(szTitle)
  {
    pNew->szTitle = malloc(strlen(szTitle) + 1);
    if(!pNew->szTitle)
    {
      free(pNew);
      return NULL;
    }
    strcpy(pNew->szTitle, szTitle);
  }

  pNew->nStatusBarTabs = DEFAULT_STATUS_BAR_TAB;
  pNew->pStatusBarTabs = NULL;

  // do the default status now

  if(WBFrameWindow_STATUS_BAR & pNew->wbFW.iFlags)
  {
    pNew->szStatus = WBCopyString("Status: none"); // default status bar text (mostly for testing)
    WB_ERROR_PRINT("TEMPORARY: %s - window has a status bar\n", __FUNCTION__);
  }
  else
  {
    pNew->szStatus = NULL;
    WB_ERROR_PRINT("TEMPORARY: %s - window has NO status bar\n", __FUNCTION__);
  }

  // add struct to beginning of linked list 'cause it's faster that way

  pNew->pNext = pFrames;
  pFrames = pNew;

  // NOW I get to create the actual window with its GC and callback proc

  bzero(&xswa, sizeof(xswa));

  xswa.border_pixel = clrBD.pixel;
  xswa.background_pixel = clrBG.pixel;
  xswa.colormap = DefaultColormap(pDisplay, DefaultScreen(pDisplay));
  xswa.bit_gravity = CenterGravity;

  pNew->wbFW.wID = WBCreateWindow(pDisplay, None, FWDefaultCallback, "FrameWindow",
                                  iX, iY, iWidth, iHeight, 1, InputOutput,
                                  CWBorderPixel | CWBackPixel | CWColormap | CWBitGravity,
                                  &xswa);

  if(pNew->wbFW.wID == None)//<= 0)
  {
    FWDestroyFrameWindow2((WBFrameWindow *)pNew);

    WB_ERROR_PRINT("ERROR: %s - unable to create frame window (WBCreateWindow failed)\r\n", __FUNCTION__);

    return NULL;
  }

  // immediately identify this window using window data
  WBSetWindowData(pNew->wbFW.wID, 0, (void *)pNew);
  pNew->pFWCallback = pUserCallback;

  bzero(&xsh, sizeof(xsh));

  xsh.flags = (USPosition | USSize | PBaseSize | PWinGravity);
  xsh.x = iX;
  xsh.y = iY;
  xsh.width = iWidth;
  xsh.height = iHeight;
  xsh.base_width = iWidth / 8 > FRAME_WINDOW_MIN_WIDTH ? iWidth / 8 : FRAME_WINDOW_MIN_WIDTH;      // set min size
  xsh.base_height = iHeight / 8 > FRAME_WINDOW_MIN_HEIGHT ? iHeight / 8 : FRAME_WINDOW_MIN_HEIGHT;

  // if I have a status bar, assign space for it in the 'base height'
  if(WBFrameWindow_STATUS_BAR & pNew->wbFW.iFlags) // window has tabs
  {
    xsh.base_height += STATUS_BAR_HEIGHT;  // TODO:  base this on font height.  use the same font as the menu.
  }

  xsh.win_gravity = NorthWestGravity; // StaticGravity

  bzero(&xwmh, sizeof(xwmh));
  xwmh.flags = InputHint;
  xwmh.input = !0;  // this represents 'Locally Active'

// from http://mail.gnome.org/archives/wm-spec-list/2007-March/msg00000.html

// The ICCCM provides for focus models for a window:
//
// Input Model     Input Field     WM_TAKE_FOCUS
// No Input        False           Absent
// Passive         True            Absent
// Locally Active  True            Present
// Globally Active False           Present
//
// No Input - The application never expects to receive focus.
//
// Passive - The application will get focus but it will not grab it on
// its own. Instead it will only get focus if the window manager gives it
// to it. The application cannot help determine if it wants the focus or
// not at the given time/situation.
//
// Locally Active - The same as passive, but the application will also
// give focus to other windows that it owns of its own free will, without
// any interaction with the window manager, using XSetInputFocus.
//
// Globally Active - The application will not receive focus from the
// window manager. Instead it will determine when it wants focus (from
// WM_TAKE_FOCUS suggestions given by the window manager, or from events
// such as ButtonPress or KeyPress). The application will then acquire
// focus on its own using XSetInputFocus.

  // set title, size hints, and 'WM_HINTS' hints (so WM knows where to put the window and how to set focus)
  WBSetWMProperties(pNew->wbFW.wID, szTitle, &xsh, &xwmh, NULL);

#if 0
  aProto[0] = aWM_DELETE_WINDOW;  // for now, that's the only one
  aProto[1] = aWM_TAKE_FOCUS;     // GDK does this, see set_wm_protocols() in gdkwindow-x11.c
//  aProto[2] = a_NET_WM_PING;      // GDK does this, see set_wm_protocols() in gdkwindow-x11.c
//  aProto[3] = a_NET_WM_SYNC_REQUEST; // GDK does this when HAVE_XSYNC is enabled

  aProto[sizeof(aProto)/sizeof(aProto[0]) - 1] = None;  // have an extra one at the end

  XSetWMProtocols(pDisplay, pNew->wbFW.wID, aProto, sizeof(aProto)/sizeof(aProto[0]) - 1);
      // sets WM_PROTOCOLS property for the main window...
#endif // 0

  WBSetWMProtocols(pNew->wbFW.wID, aWM_DELETE_WINDOW, aWM_TAKE_FOCUS, None);

  WBCreateWindowDefaultGC(pNew->wbFW.wID, clrFG.pixel, clrBG.pixel);

  // now allow specific kinds of input messages
  XSelectInput(pDisplay, pNew->wbFW.wID,
               WB_STANDARD_INPUT_MASK | WB_MOUSE_INPUT_MASK | WB_KEYBOARD_INPUT_MASK);


  // NEXT, create the menu (if the resource string isn't NULL)

  if(szMenuResource && *szMenuResource)
  {
    WBMenuBarWindow *pMenu;

    pNew->pDefaultMenuResource = WBCopyString(szMenuResource);

    if(!pNew->pDefaultMenuResource)
    {
      FWDestroyFrameWindow2((WBFrameWindow *)pNew);
      return NULL;
    }

    pMenu = MBCreateMenuBarWindow(pNew->wbFW.wID, szMenuResource, 0);

    if(!pMenu)
    {
      FWDestroyFrameWindow2((WBFrameWindow *)pNew);
      return NULL;
    }
  }

  FWRecalcLayout(pNew->wbFW.wID); // prior to making me visible do this

  WBSetWindowIcon(pNew->wbFW.wID, idIcon);

  if(iFlags & WBFrameWindow_APP_WINDOW)
  {
    WBSetApplicationWindow(pNew->wbFW.wID);
  }

  if(iFlags & WBFrameWindow_VISIBLE)
  {
    WBMapWindow(pDisplay, pNew->wbFW.wID);  // make window visible
    WBGetParentWindow(pNew->wbFW.wID);  // this syncs everything up
  }

  return (WBFrameWindow *)pNew;
}

void FWDestroyFrameWindow(Window wID)
{
  FWDestroyFrameWindow2(FWGetFrameWindowStruct(wID));
}

void FWDestroyFrameWindow2(WBFrameWindow *pFrameWindow)
{
  // step 1:  unhook pFrameWindow
  FRAME_WINDOW *pTemp = pFrames;
  FRAME_WINDOW *pPrev = NULL;
  Window wID;
//  int i1;

  if(!pFrameWindow || pFrameWindow->ulTag != FRAME_WINDOW_TAG)
    return;

  wID = pFrameWindow->wID;

  while(pTemp && pTemp != (FRAME_WINDOW *)pFrameWindow)
  {
    pPrev = pTemp;
    pTemp = pTemp->pNext;
  }

  if(pTemp)
  {
    if(pPrev)
      pPrev->pNext = pTemp->pNext;  // unhook
    else if(pFrames == pTemp)
      pFrames = pTemp->pNext;
  }


  if(wID > 0)
    WBDestroyWindow(wID);  // this will free the structure
  else
  {
    // I must destroy malloc'd entries and contained windows in lieu of 'FWDefaultCallback'
    __internal_destroy_frame_window((FRAME_WINDOW *)pFrameWindow);
    free(pFrameWindow);
  }
}

void FWSetUserCallback(WBFrameWindow *pFrameWindow, WBWinEvent pCallBack)
{
  if(pFrameWindow->ulTag != FRAME_WINDOW_TAG)
    return;

  ((FRAME_WINDOW *)pFrameWindow)->pFWCallback = pCallBack;
}

void FWSetMenuHandlers(WBFrameWindow *pFrameWindow, const WBFWMenuHandler *pHandlerArray)
{
int i1;
const WBFWMenuHandler *pH;

  if(!pFrameWindow)
    return;

  if(((FRAME_WINDOW *)pFrameWindow)->pMenuHandler)
  {
    free(((FRAME_WINDOW *)pFrameWindow)->pMenuHandler);

    ((FRAME_WINDOW *)pFrameWindow)->pMenuHandler = NULL;
  }

  if(!pHandlerArray)
  {
    return;
  }

  // count the number of entries
  for(i1=0, pH = pHandlerArray; pH->lMenuID || pH->callback || pH->UIcallback; i1++, pH++) { }

  // allocate space and make a copy

  ((FRAME_WINDOW *)pFrameWindow)->pMenuHandler =
    (WBFWMenuHandler *)malloc(sizeof(WBFWMenuHandler) * (i1 + 2));

  if(((FRAME_WINDOW *)pFrameWindow)->pMenuHandler)
  {
    memcpy(((FRAME_WINDOW *)pFrameWindow)->pMenuHandler, pHandlerArray,
           sizeof(WBFWMenuHandler) * (i1 + 1));
  }
}

int FWDefaultCallback(Window wID, XEvent *pEvent)
{
  FRAME_WINDOW *pFrameWindow = (FRAME_WINDOW *)FWGetFrameWindowStruct(wID);
  Window wIDMenu;
  int iRval = 0;
#ifndef NO_DEBUG
  char tbuf[32]; // for keyboard input
  int nChar = sizeof(tbuf);
#endif // NO_DEBUG


  if(!pFrameWindow)
  {
    WB_ERROR_PRINT("%s - ERROR - no frame window pointer!\n", __FUNCTION__);
    return 0;
  }

  wIDMenu = WBGetMenuWindow(wID);

  // TODO:  message re-direction to children BEFORE 'pFWCallback'

  if(wIDMenu)
  {
    switch(pEvent->type)
    {
      case ButtonPress:
      case ButtonRelease:
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                         "%s - BUTTON PRESS\n", __FUNCTION__);

        if(WBPointInWindow(pEvent->xbutton.window, pEvent->xbutton.x, pEvent->xbutton.y, wIDMenu))
        {
          return(WBWindowDispatch(wIDMenu, pEvent));  // menu window should handle mousie events
        }

        break;

      case MotionNotify:
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                         "%s - MOTION NOTIFY\n", __FUNCTION__);

        if(WBPointInWindow(pEvent->xmotion.window, pEvent->xmotion.x, pEvent->xmotion.y, wIDMenu))
        {
          return(WBWindowDispatch(wIDMenu, pEvent));  // menu window should handle mousie events
        }

        break;

      case ConfigureNotify:  // window size/position change
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                       "%s - CONFIGURE NOTIFY\n", __FUNCTION__);

        // allow message to process first, and post a message to myself
        // to re-evaluate the layout.  This is to avoid having a window that's
        // not "changed" yet trying to update its size info when size info is
        // not yet accurate.
        //
        // ALSO - I can get this on a window MOVE without a resize...

        {
          Display *pDisplay;
          XClientMessageEvent evt;

          pDisplay = WBGetWindowDisplay(wID);

          bzero(&evt, sizeof(evt));
          evt.type = ClientMessage;

          evt.display = pDisplay;
          evt.window = wID;
          evt.message_type = aRESIZE_NOTIFY;
          evt.format = 32;  // always
          evt.data.l[0] = pEvent->xconfigure.x;
          evt.data.l[1] = pEvent->xconfigure.y;
          evt.data.l[2] = pEvent->xconfigure.x + pEvent->xconfigure.width; // right
          evt.data.l[3] = pEvent->xconfigure.y + pEvent->xconfigure.height; // bottom
          evt.data.l[4] = pEvent->xconfigure.border_width; // RESERVED (for now, just do it)

          WBPostEvent(wID, (XEvent *)&evt); // NOTE:  if too slow, post 'priority' instead
        }  
        
        break;


      case ClientMessage:  // menus, etc. (they generate the 'ClientMessage')

#ifndef NO_DEBUG
        {
          char *p1 = XGetAtomName(WBGetWindowDisplay(wID), pEvent->xclient.message_type);

          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                         "%s - CLIENT MESSAGE:  %s\n", __FUNCTION__, p1);

          if(p1)
          {
            XFree(p1);
          }
        }
#endif // NO_DEBUG

        if(pEvent->xclient.message_type == aRESIZE_NOTIFY)
        {
          FWRecalcLayout(wID);

          return 1; // handled (TODO:  send to user-defined callback as well?)
        }
        else if(pEvent->xclient.message_type == aMENU_COMMAND)
        {
          //////////////////////////////////////////////////////////////////////////
          //                                _                     _ _             //
          //   _ __ ___   ___ _ __  _   _  | |__   __ _ _ __   __| | | ___ _ __   //
          //  | '_ ` _ \ / _ \ '_ \| | | | | '_ \ / _` | '_ \ / _` | |/ _ \ '__|  //
          //  | | | | | |  __/ | | | |_| | | | | | (_| | | | | (_| | |  __/ |     //
          //  |_| |_| |_|\___|_| |_|\__,_| |_| |_|\__,_|_| |_|\__,_|_|\___|_|     //
          //                                                                      //
          //////////////////////////////////////////////////////////////////////////


          // check the container window that has the current focus, and THEN
          // check the frame window for an appropriate handler

          WBChildFrame *pFocus = FWGetFocusWindow(&(pFrameWindow->wbFW));

          if(pFocus) // if a tab has a focus, use that window's event handler first
          {
            int iRet = WBWindowDispatch(pFocus->wID, pEvent);

            if(iRet) // non-zero return
            {
              return iRet; // the handler MUST return non-zero if the message should NOT be processed by the frame!
            }
          }

          if(pFrameWindow->pMenuHandler)
          {
            // search for the matching menu or ID - anything above 0x10000 is assumed to be a pointer
            const WBFWMenuHandler *pHandler = pFrameWindow->pMenuHandler;

            while(pHandler->lMenuID) // zero marks the end
            {
              long lID = pHandler->lMenuID;

              if(pHandler->lMenuID >= 0x10000L)
              {
                lID = XInternAtom(WBGetDefaultDisplay(), (const char *)lID, False);

                if(!lID)
                {
                  continue;
                }
              }

              if(pEvent->xclient.data.l[0] == lID)
              {
                if(pHandler->callback)
                {
                  if(pHandler->callback(&(pEvent->xclient)))
                  {
                    return 1;
                  }
                }

                return 0; // NOT handled or handler returned zero
              }

              pHandler++;
            }
          }
        }
        else if(pEvent->xclient.message_type == aMENU_UI_COMMAND)
        {
          //////////////////////////////////////////////////////////////////////////////////////
          //                                _   _ ___   _                     _ _             //
          //   _ __ ___   ___ _ __  _   _  | | | |_ _| | |__   __ _ _ __   __| | | ___ _ __   //
          //  | '_ ` _ \ / _ \ '_ \| | | | | | | || |  | '_ \ / _` | '_ \ / _` | |/ _ \ '__|  //
          //  | | | | | |  __/ | | | |_| | | |_| || |  | | | | (_| | | | | (_| | |  __/ |     //
          //  |_| |_| |_|\___|_| |_|\__,_|  \___/|___| |_| |_|\__,_|_| |_|\__,_|_|\___|_|     //
          //                                                                                  //
          //////////////////////////////////////////////////////////////////////////////////////

          // check 'contained' window for an appropriate UI handler before passing
          // it off to the frame window's handler

          WBChildFrame *pFocus = FWGetFocusWindow(&(pFrameWindow->wbFW));
          if(pFocus)
          {
            int iRet = WBWindowDispatch(pFocus->wID, pEvent);
            if(iRet >= 0)
            {
              return iRet;
            }

            // TODO:  determine if a '-1' value really SHOULD grey out the menu choice anyway or
            //        if I should return some OTHER value to differentiate 'grey' from 'no handler'
          }

          if(pFrameWindow->pMenuHandler)
          {
            const WBFWMenuHandler *pHandler = pFrameWindow->pMenuHandler;

            while(pHandler->lMenuID) // zero marks the end
            {
              long lID = pHandler->lMenuID;

              if(pHandler->lMenuID >= 0x10000L)
              {
                lID = XInternAtom(WBGetDefaultDisplay(), (const char *)lID, False);

                if(!lID)
                {
                  continue;
                }
              }

              if(pEvent->xclient.data.l[0] == lID) // a message handler exists
              {
                if(pHandler->UIcallback)
                {
                  WBMenu *pMenu;
                  WBMenuItem *pItem;

                  // important detail - the 'data.l' array is assumed to have 32-bit values in it,
                  // regardless of how its definition and 64/32-bitness affects the actual data storage.
                  // In effect, only the lower 32-bits is valid.  Hence, I must combine two 32-bit values
                  // together in order to make a 64-bit pointer.  For consistency I always use 2 values
                  // per pointer to pass the information via the message structure.  otherwise it gets
                  // complicated and I really don't like complicated.  it causes mistakes, errors, crashes...

#if !defined(__SIZEOF_POINTER__) // TODO find a better way to deal with pointer size
#define __SIZEOF_POINTER__ 0
#endif
#if __SIZEOF_POINTER__ == 4 /* to avoid warnings in 32-bit linux */
                  pMenu = (WBMenu *)pEvent->xclient.data.l[1];
                  pItem = (WBMenuItem *)pEvent->xclient.data.l[3];
#else // assume 64-bit pointers here, and if they truncate, should NOT get any warnings... well that's the idea
                  pMenu = (WBMenu *)((unsigned long long)pEvent->xclient.data.l[1] | ((unsigned long long)pEvent->xclient.data.l[2] << 32));
                  pItem = (WBMenuItem *)((unsigned long long)pEvent->xclient.data.l[3] | ((unsigned long long)pEvent->xclient.data.l[4] << 32));
#endif
                  // TODO:  validate pointers, otherwise a posted message might crash me (like a vulnerability)

#ifndef NO_DEBUG /* warning off for release build */
#warning this code potentially has a vulnerability in it
#endif // !NO_DEBUG

                  // if(!WBIsValidMenu(pMenu) || !WBIsValidMenuItem(pItem)) { do not do it }

                  return pHandler->UIcallback(pMenu, pItem);
                }

                return 0; // NO UI handler so return '0' [aka 'normal']
              }

              pHandler++;
            }
          }

          return -1; // if there's no handler and no UI handler, always return 'disabled'
        }
#ifndef NO_DEBUG
        else
        {
          char *p1 = XGetAtomName(WBGetWindowDisplay(wID), pEvent->xclient.message_type);

          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                         "%s - Client message %s not handled by frame window\n",
                          __FUNCTION__, p1);

          if(p1)
          {
            XFree(p1);
          }
        }
#endif // NO_DEBUG

        break;

      default:
        break;
    }
  }

  // expose event - painting the status bar.

  if(pEvent->type == Expose &&
     (WBFrameWindow_STATUS_BAR & pFrameWindow->wbFW.iFlags))
  {
    InternalPaintStatusBar(pFrameWindow, &(pEvent->xexpose));  // this will 'validate' the status bar area, preventing re-paint
  }

  if(pFrameWindow->pFWCallback)
  {
    // for most messages, if I handle it here, I don't do further processing

    iRval = (pFrameWindow->pFWCallback)(wID, pEvent);

    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_Event | DebugSubSystem_Frame,
                   "%s - %s event and user callback returns %d\n", __FUNCTION__, WBEventName(pEvent->type), iRval);

    if(iRval)
    {
      // check message types that I do *NOT* want to 'bail out' for, as well as those
      // that I _MUST_ bail out for.

      switch(pEvent->type)
      {
        case DestroyNotify: // must process after user callback
          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                         "%s DestroyNotify and user callback returned a non-zero value\n", __FUNCTION__);

          // CONTINUE PROCESSING - after the user's callback handles DestroyNotify I must handle
          //                       it here also (at the very end)

          break;

        case Expose: // no further processing needed, special debug notification
          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                         "%s Expose event and user callback returns %d\n", __FUNCTION__, iRval);
          return iRval;  // 'expose' event already handled


        default: // all other messages, no further processing needed
          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                         "%s - %s event and user callback returns %d\n", __FUNCTION__, WBEventName(pEvent->type), iRval);
          return iRval;
      }
    }
    else
    {
      // TODO:  deal with specific events NOT handled by the user callback
    }
  }


  // At this point iRval _COULD_  be non-zero (example, DestroyNotify)
  // so don't do any handling for those messages.

  if(!iRval)
  {
    switch(pEvent->type)
    {
      case KeyPress:
        {
#ifndef NO_DEBUG
          int iACS = 0;
          int iKey = WBKeyEventProcessKey((XKeyEvent *)pEvent, tbuf, &nChar, &iACS);

          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame | DebugSubSystem_Keyboard,
                         "%s KEY PRESS for KEY %d KEYCODE %d MASK=%d (%xH)\n",
                           __FUNCTION__, iKey, ((XKeyEvent *)pEvent)->keycode,
                           ((XKeyEvent *)pEvent)->state, ((XKeyEvent *)pEvent)->state);
#endif // NO_DEBUG

          // check for menu and hotkey activation.
//          if(nChar > 0) // only for "real" characters (i.e. not just the ALT key)
          {
            WBMenuBarWindow *pMenuBar = MBGetMenuBarWindowStruct(WBGetMenuWindow(wID));

            if(pMenuBar)  // menu bar exists?
            {
              WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Menu | DebugSubSystem_Frame | DebugSubSystem_Keyboard,
                             "%s call to MBMenuProcessHotKey for menu window %d (%08xH)\n",
                             __FUNCTION__, (int)pMenuBar->wSelf, (int)pMenuBar->wSelf);

              iRval = MBMenuProcessHotKey(pMenuBar->pMenu, (XKeyEvent *)pEvent);
            }
          }
        }
        break;

      case KeyRelease:
        {
          // KeyRelease
#ifndef NO_DEBUG
          int iACS = 0, iKey = WBKeyEventProcessKey((XKeyEvent *)pEvent, tbuf, &nChar, &iACS);

          if(nChar > 0)
          {
            WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame | DebugSubSystem_Keyboard,
                           "%s KEY RELEASE for KEY %d KEYCODE %d  MASK=%d (%xH)\n",
                           __FUNCTION__, iKey, ((XKeyEvent *)pEvent)->keycode,
                           ((XKeyEvent *)pEvent)->state, ((XKeyEvent *)pEvent)->state);

          }
#endif // NO_DEBUG

        }

        break;



      case SelectionRequest:
      case SelectionClear:
      case SelectionNotify:

        return 0; // NOT handled (default handler might want to handle them, but not me)

//        return FWDoSelectionEvents(&(pFrameWindow->wbFW), wID, wIDMenu, pEvent);  <-- no longer needed
    }
  }


  // TODO:   message re-direction to children AFTER 'pFWCallback'



  // ----------------------------------------
  // DESTROY DESTROY DESTROY DESTROY DESTROY
  //
  //   special handling for 'DestroyNotify'
  //
  // DESTROY DESTROY DESTROY DESTROY DESTROY
  // ----------------------------------------


  if(pEvent->type == DestroyNotify &&
     pEvent->xdestroywindow.window == wID)
  {
//    int boolQuitFlag = (pFrameWindow->wbFW.iFlags & WBFrameWindow_APP_WINDOW) != 0;

    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                   "%s - DestroyNotify\n", __FUNCTION__);

    WBSetWindowData(wID, 0, NULL);

    __internal_destroy_frame_window(pFrameWindow);

    free(pFrameWindow);

//    if(boolQuitFlag)
//      bQuitFlag = TRUE;  // set the global 'quit' flag if I'm an application top-level window

    WB_DEBUG_PRINT(DebugLevel_Verbose | DebugSubSystem_Event | DebugSubSystem_Frame,
                   "%s - frame window destroyed\n", __FUNCTION__);
    return 1;
  }

  WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Event | DebugSubSystem_Frame,
                 "%s - frame window callback returns %d\n", __FUNCTION__, iRval);

  return iRval;  // what happens when nothing is handled
}

void FWRecalcLayout(Window wID)
{
WB_RECT rct, rct2;
FRAME_WINDOW *pFrameWindow;
Window wIDMenu;
WBMenuBarWindow *pMB;
int i1, iMax;


  pFrameWindow = (FRAME_WINDOW *)FWGetFrameWindowStruct(wID);

  if(!pFrameWindow)
  {
    WB_ERROR_PRINT("%s - ERROR - no frame window pointer!\n", __FUNCTION__);
    return;
  }

  // this callback happens any time I change the window size.  Use this
  // also to re-size scrollbars and status bars and menus.

  // calculate the actual size of the client area and inform all of the 'Child Frame'
  // windows so that they can assign the size and fix scrollbars, etc. as appropriate

  WBGetClientRect(wID, &rct); // get the rectangle for the client area

  // obtain the height and position of the menu (if any), toolbar (if any), and tab area (if any)
  // and subtract that from rct.top - then record this as my "client area" in the FRAME_WINDOW
  // structure (iClientX, iClientY, iClientWidth, iClientHeight).

  wIDMenu = WBGetMenuWindow(wID);

  if(wIDMenu != None)
  {
    pMB = MBGetMenuBarWindowStruct(wIDMenu);

    if(pMB)
    {
      WBGetWindowRect(wIDMenu, &rct2);

      // what I want is the height.
      rct.top += rct2.bottom - rct2.top + 1;  // regardless of rect, this will be the height, plus 1 pixel
    }
  }


  if(!(WBFrameWindow_NO_TABS & pFrameWindow->wbFW.iFlags)) // window has tabs
  {
    rct.top += TAB_BAR_HEIGHT;  // TODO:  base this on font height.  use the same font as the menu.
  }

  // if this window has a status bar on the bottom, subtract an appropriate height
  // from the bottom of the client area.

  if(WBFrameWindow_STATUS_BAR & pFrameWindow->wbFW.iFlags) // window has a status bar
  {
    rct.bottom -= STATUS_BAR_HEIGHT;  // TODO:  base this on font height.  use the same font as the menu.
  }


  // Now that I've calculated the new client rectangle area, assign appropriate thingies
  // (but if it matches, bail here, no need for anything else, since nothing changed)

  rct.right -= rct.left; // now it's a width
  rct.bottom -= rct.top;  // now it's a height

  if(pFrameWindow->wbFW.iClientX == rct.left &&
     pFrameWindow->wbFW.iClientY == rct.top &&
     pFrameWindow->wbFW.iClientWidth == rct.right &&
     pFrameWindow->wbFW.iClientHeight == rct.bottom)
  {
    return; // nothing changed
  }

  // assign the new values.  This will be the "true" client area
  // of the frame window, excluding "things"
  pFrameWindow->wbFW.iClientX      = rct.left;
  pFrameWindow->wbFW.iClientY      = rct.top;
  pFrameWindow->wbFW.iClientWidth  = rct.right;
  pFrameWindow->wbFW.iClientHeight = rct.bottom;


  // next, inform all of the child frames that I'm different now

  iMax = FWGetNumContWindows(&(pFrameWindow->wbFW));

  for(i1=0; i1 < iMax; i1++)
  {
    WBChildFrame *pCW = FWGetContainedWindowByIndex(&(pFrameWindow->wbFW), i1);

    if(pCW)
    {
      FWChildFrameRecalcLayout(pCW); // inform the child frame of the layout change
    }
  }

  // temporarily use 'error level' so I can always see this
  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                 "%s - %d, %d, %d, %d\n", __FUNCTION__,
                 pFrameWindow->wbFW.iClientX, pFrameWindow->wbFW.iClientY,
                 pFrameWindow->wbFW.iClientWidth, pFrameWindow->wbFW.iClientHeight);

  WBInvalidateGeom(wID, NULL, 1); // and, finally, force a re-paint (mostly hidden by child frame, except tabs, borders, etc.)
}


// CONTAINED WINDOWS

int FWGetNumContWindows(const WBFrameWindow *pFrameWindow)
{
  return -1;  // for now
}

WBChildFrame * FWGetContainedWindowByIndex(const WBFrameWindow *pFrameWindow, int iIndex)
{
  return NULL; // for now
}

int FWAddContainedWindow(WBFrameWindow *pFrameWindow, WBChildFrame *pNew)
{
  return -1;  // for now
}

void FWRemoveContainedWindow(WBFrameWindow *pFrameWindow, WBChildFrame *pCont)
{
}

void FWSetFocusWindow(WBFrameWindow *pFrameWindow, WBChildFrame *pCont)
{
}

void FWSetFocusWindowIndex(WBFrameWindow *pFrameWindow, int iIndex)
{
}


void FWSetStatusText(WBFrameWindow *pFrameWindow, const char *szText)
{
}

void FWSetStatusTabInfo(WBFrameWindow *pFrameWindow, int nTabs, const int *pTabs)
{
}



static void InternalPaintStatusBar(FRAME_WINDOW *pFrameWindow, XExposeEvent *pEvent)
{
WB_RECT rct, rctExpose;
WB_GEOM geom;
GC gc;


  if(!(WBFrameWindow_STATUS_BAR & pFrameWindow->wbFW.iFlags)) // window has a status bar?
  {
    return; // no status bar, just bail
  }

  // calculate the location of the status bar

  WBGetClientRect(pFrameWindow->wbFW.wID, &rct); // get the rectangle for the client area

  rct.top = rct.bottom - STATUS_BAR_HEIGHT;

//  rct.top -= 4 * STATUS_BAR_HEIGHT; // temporary

//  WB_ERROR_PRINT("TEMPORARY: %s - status bar rect:  (%d,%d,%d,%d)\n",
//                  __FUNCTION__, rct.left, rct.top, rct.right, rct.bottom);

  // does the Expose event intersect my status bar?

  rctExpose.left   = pEvent->x;
  rctExpose.top    = pEvent->y;
  rctExpose.right  = rctExpose.left + pEvent->width;
  rctExpose.bottom = rctExpose.top + pEvent->height;

  if(!WBRectOverlapped(rct, rctExpose))
  {
    WB_ERROR_PRINT("INFO: %s - expose event excludes status bar\n", __FUNCTION__);

    return; // do nothing (no overlap)
  }

  // intersect the two rectangles so I only re-paint what I have to

  if(rctExpose.top < rct.top)
  {
    rctExpose.top = rct.top;
  }

  if(rctExpose.bottom > rct.bottom)
  {
    rctExpose.bottom = rct.bottom;
  }

  if(rctExpose.left < rct.left)
  {
    rctExpose.left = rct.left;
  }

  if(rctExpose.right > rct.right)
  {
    rctExpose.right = rct.right;
  }

  // time to start painting

  geom.x      = rctExpose.left;
  geom.y      = rctExpose.top;
  geom.width  = rctExpose.right - rctExpose.left;
  geom.height = rctExpose.bottom - rctExpose.top;

  gc = WBBeginPaintGeom(pFrameWindow->wbFW.wID, &geom);

  if(gc == None)
  {
    WB_ERROR_PRINT("ERROR: %s - no GC from WBBeginPaintGeom\n", __FUNCTION__);
  }
  else
  {
    Display *pDisplay = WBGetWindowDisplay(pFrameWindow->wbFW.wID);
    XPoint xpt[3];

    // fill the rectangle with the background color

    WBClearWindow(pFrameWindow->wbFW.wID, gc); // should only paint my little rectangle

    // draw some lines in some colors for the border

    // paint the 3D-looking border
    XSetForeground(pDisplay, gc, clrBD2.pixel);
    xpt[0].x=rct.left;
    xpt[0].y=rct.bottom - 2;  // exclude first point
    xpt[1].x=rct.left;
    xpt[1].y=rct.top;
    xpt[2].x=rct.right - 2;   // exclude last point
    xpt[2].y=rct.top;

    XDrawLines(pDisplay, pFrameWindow->wbFW.wID, gc, xpt, 3, CoordModeOrigin);

    XSetForeground(pDisplay, gc, clrBD3.pixel);
    xpt[0].x=rct.right - 1;
    xpt[0].y=rct.top + 1;              // exclude first point
    xpt[1].x=rct.right - 1;
    xpt[1].y=rct.bottom - 1;
    xpt[2].x=rct.left + 1;              // exclude final point
    xpt[2].y=rct.bottom - 1;

    XDrawLines(pDisplay, pFrameWindow->wbFW.wID, gc, xpt, 3, CoordModeOrigin);

    XSetForeground(pDisplay, gc, clrFG.pixel); // by convention, set it to FG [for text I need this]

    // TODO:  the tabbed columns and their enclosed text

    if(pFrameWindow->szStatus)
    {
      WB_RECT rctTemp;

      rctTemp.left = rct.left + 8;
      rctTemp.top = rct.top + 4;
      rctTemp.right = rct.right - 8;
      rctTemp.bottom = rct.bottom - 4;

      // temporary:  just paint the text
//      DTDrawSingleLineText(WBGetDefaultFont(),
//                           pFrameWindow->szStatus, pDisplay,
//                           gc, pFrameWindow->wbFW.wID, 0, 0, &rctTemp, 0);
      XDrawString(pDisplay, pFrameWindow->wbFW.wID, gc, rctTemp.left, rctTemp.bottom - 2,
                  pFrameWindow->szStatus, strlen(pFrameWindow->szStatus));
    }                         

    WBEndPaint(pFrameWindow->wbFW.wID, gc);  // and that's it!
  }

  // finally, alter the expose event slightly so that it reflects the 'painted' area

  if(pEvent->height + pEvent->x > rct.top)
  {
//    WB_ERROR_PRINT("TEMPOPRARY: %s - altering height in Expose event\n", __FUNCTION__);

    pEvent->height = rct.top - pEvent->x;
    if(pEvent->height < 0)
    {
      pEvent->height = 0;
    }
  }

  // TODO:  manage top, left, right and x, y, width?  probably don't need to

}




#if 0 /* these are handled separately - don't do this */

// CLIPBOARD / SELECTION EVENTS
//
// NOTES:
//
// KDE wants _QT_SELECTION
// GNOME wants GDK_SELECTION
// 'libXt' wants _XT_SELECTION (see XtOwnSelection, XtGetSelectionValue, etc.)
//
// (nothing else seen so far)

int FWDoSelectionEvents(WBFrameWindow *pFrameWindow, Window wID, Window wIDMenu, XEvent *pEvent)
{
Display *pDisplay = WBGetWindowDisplay(wID);
FRAME_WINDOW *pFW = (FRAME_WINDOW *)pFrameWindow;

  // this is what the libXt function 'RequestSelectionValue' does
  // XConvertSelection(info->ctx->dpy, selection, target,   // 'selection' and 'target' are Atoms
  //                   info->property, XtWindow(info->widget), info->time);


  // TEMPORARY:  doing what WBDefault does

  if(pEvent->type == SelectionRequest)
  {
    char *p1 = pEvent->xselectionrequest.selection != None ? XGetAtomName(pDisplay, pEvent->xselectionrequest.selection) : NULL;
    char *p2 = pEvent->xselectionrequest.target != None ? XGetAtomName(pDisplay, pEvent->xselectionrequest.target) : NULL;
    char *p3 = pEvent->xselectionrequest.property != None ? XGetAtomName(pDisplay, pEvent->xselectionrequest.property) : NULL;

    WB_ERROR_PRINT("TEMPORARY - %s - SelectionRequest owner=%d requestor=%d selection=%s target=%s property=%s\n",
                   __FUNCTION__,
                   (int)pEvent->xselectionrequest.owner,
                   (int)pEvent->xselectionrequest.requestor,
                   p1 ? p1 : "NULL",
                   p2 ? p2 : "NULL",
                   p3 ? p3 : "NULL");

    if(p1)
    {
      XFree(p1);
    }                   
    if(p2)
    {
      XFree(p2);
    }                   
    if(p3)
    {
      XFree(p3);
    }                   

    // the default rejects the request.  Send a 'SelectionNotify' to indicate the failure

    if(pEvent->xselectionrequest.owner == wID) // only if I'm the selection owner
    {
      XSelectionEvent evtN;

      memset(&evtN, 0, sizeof(evtN));

      evtN.type = SelectionNotify;
      evtN.send_event = True; // 'cause I'm going to use 'XSendEvent' to reply immediately
      evtN.requestor = pEvent->xselectionrequest.requestor;
      evtN.selection = pEvent->xselectionrequest.selection;
      evtN.target = pEvent->xselectionrequest.target;
      evtN.property = None; // to indicate failure
      evtN.time = pEvent->xselectionrequest.time; // same time as request (for now)

      BEGIN_XCALL_DEBUG_WRAPPER
      XSendEvent(pDisplay, evtN.requestor, False, 0, (XEvent *)&evtN);
      END_XCALL_DEBUG_WRAPPER
    }

    return 1; // "handled"
  }
  else if(pEvent->type == SelectionClear)
  {
    char *p1 = XGetAtomName(pDisplay, pEvent->xselectionclear.selection);

    WB_ERROR_PRINT("TEMPORARY - %s - SelectionClear window=%d selection=%s\n",
                   __FUNCTION__,
                   (int)pEvent->xselectionclear.window,
                   p1 ? p1 : "NULL");

    if(p1)
    {
      XFree(p1);
    }                   

    // the default rejects the request.  Send a 'SelectionNotify' to indicate the failure

    if(pEvent->xselectionrequest.owner == wID) // only if I'm the selection owner
    {
      XSelectionEvent evtN;

      memset(&evtN, 0, sizeof(evtN));

      evtN.type = SelectionNotify;
      evtN.send_event = True; // 'cause I'm going to use 'XSendEvent' to reply immediately
      evtN.requestor = pEvent->xselectionrequest.requestor;
      evtN.selection = pEvent->xselectionrequest.selection;
      evtN.target = None;
      evtN.property = None; // to indicate failure (?)
      evtN.time = pEvent->xselectionrequest.time; // same time as request (for now)

      BEGIN_XCALL_DEBUG_WRAPPER
      XSendEvent(pDisplay, evtN.requestor, False, 0, (XEvent *)&evtN);
      END_XCALL_DEBUG_WRAPPER
    }

    return 1; // "handled"
  }
  else if(pEvent->type == SelectionNotify)
  {
    char *p1 = XGetAtomName(pDisplay, pEvent->xselection.selection);
    char *p2 = XGetAtomName(pDisplay, pEvent->xselection.target);
    char *p3 = XGetAtomName(pDisplay, pEvent->xselection.property);

    WB_ERROR_PRINT("TEMPORARY - %s - SelectionNotify requestor=%d selection=%s target=%s property=%s\n",
                   __FUNCTION__,
                   (int)pEvent->xselection.requestor,
                   p1 ? p1 : "NULL",
                   p2 ? p2 : "NULL",
                   p3 ? p3 : "NULL");

    if(p1)
    {
      XFree(p1);
    }                   
    if(p2)
    {
      XFree(p2);
    }                   
    if(p3)
    {
      XFree(p3);
    }                   

    return 1; // "handled"
  }




  return 0; // for now
}

#endif // 0

