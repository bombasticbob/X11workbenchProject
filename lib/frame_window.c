//////////////////////////////////////////////////////////////////////////////////////////////
//    __                                            _             _                         //
//   / _| _ __  __ _  _ __ ___    ___    __      __(_) _ __    __| |  ___ __      __  ___   //
//  | |_ | '__|/ _` || '_ ` _ \  / _ \   \ \ /\ / /| || '_ \  / _` | / _ \\ \ /\ / / / __|  //
//  |  _|| |  | (_| || | | | | ||  __/    \ V  V / | || | | || (_| || (_) |\ V  V /_| (__   //
//  |_|  |_|   \__,_||_| |_| |_| \___|_____\_/\_/  |_||_| |_| \__,_| \___/  \_/\_/(_)\___|  //
//                                   |_____|                                                //
//                                                                                          //
//    a top-level window that can have menus, toolbars, a status bar, and a client area     //
//                                                                                          //
//////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2016 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no waranties, either implied or explicit.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

/** \file frame_window.c
  * \brief Frame Window API function implementation
  *
  * A frame window is a top level window that can have a menu and an icon, and may
  * contain child windows within it.  It can USUALLY be resized, minimized, and maximized.
*/


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <signal.h>
#include <time.h>

#include "window_helper.h"
#include "pixmap_helper.h"  // pixmap helpers, including pre-defined icons
#include "frame_window.h"
#include "child_frame.h"
#include "conf_help.h"
#include "draw_text.h"


#define FRAME_WINDOW_MIN_WIDTH 160  /* re-sizable window absolute minimum width */
#define FRAME_WINDOW_MIN_HEIGHT 120 /* re-sizable window absolute minimum height */


typedef struct __FRAME_WINDOW__
{
  WBFrameWindow wbFW;

  WBFWMenuHandler *pMenuHandler;     // pointer to the current menu handler structure array (internally allocated)
  WBFWMenuHandler *pDefMenuHandler;  // pointer to default menu handler (assigned by 'FWSetMenuHandlers()')

//  Window *pwContents;                // malloc'd array of 'contents' window IDs (determines tab order)

  int nChildFrames;                  // total number of child frames
  int nMaxChildFrames;               // max # of child frames within the current array
  WBChildFrame **ppChildFrames;      // Pointer to type-abstracted array of child frames
                                     // ctrl+alt+pageup/pagedown to navigate from one tab to another
  // NOTE:  'ppChildFrames' is a contiguous array, without any NULLs in between

  int nFocusTab;                     // which tab has the focus?  normally 0
  int nLeftTab, nRightTab;           // left and right tab indices, same order as in ppChildFrames (0 if no tabs)

  char *szTitle;                     // title bar string (malloc'd)

  char *pDefaultMenuResource;        // menu resource for 'default' menu

  int (* pFWCallback)(Window wID, XEvent *pEvent); // registered callback function (for various things)

  struct __FRAME_WINDOW__ *pNext;    // next in chain (internal use)

} FRAME_WINDOW;


int FWDefaultCallback(Window wID, XEvent *pEvent);  // default callback for frame windows (call for default processing)


static FRAME_WINDOW *pFrames = NULL;  // pointer to linked list of frame windows (malloc'd)

static XColor clrFG, clrBG, clrBD;
static int iInitColorFlag = 0;

static void __internal_destroy_frame_window(FRAME_WINDOW *pTemp)
{
  int i1;

  if(pTemp->ppChildFrames)
  {
    for(i1=0; i1 < pTemp->nChildFrames && i1 < pTemp->nMaxChildFrames; i1++)
    {
      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Frame,
                     "%s - Destroy contents %d\n",
                     __FUNCTION__, i1 + 1);

      if(pTemp->ppChildFrames[i1])
      {
        // validate the pointer
#warning this is potentially unsafe code...

        WBDestroyWindow(pTemp->ppChildFrames[i1]->wSelf); // TODO:  improve this
      }
    }

    free(pTemp->ppChildFrames);
    pTemp->ppChildFrames = NULL;
    pTemp->nChildFrames = 0; // by convention
    pTemp->nMaxChildFrames = 0; // this too
  }

  if(pTemp->szTitle)
  {
    free(pTemp->szTitle);
    pTemp->szTitle = NULL;
  }

  if(pTemp->pDefaultMenuResource)
  {
    free(pTemp->pDefaultMenuResource);
    pTemp->pDefaultMenuResource = NULL;
  }

}

void WBFrameWindowExit()
{
  // destroy all of the frame windows

  while(pFrames)
  {
    FRAME_WINDOW *pTemp = pFrames;
    pFrames = pFrames->pNext;

    // slightly different - free the structure first, THEN destroy the window
    WBSetWindowData(pTemp->wbFW.wID, 0, NULL);
    __internal_destroy_frame_window(pTemp);
    free(pTemp);

    WBDestroyWindow(pTemp->wbFW.wID);  // making sure...
  }

}

#define LOAD_COLOR0(X,Y) if(CHGetResourceString(WBGetDefaultDisplay(), X, Y, sizeof(Y)) > 0) {  }
#define LOAD_COLOR(X,Y,Z) if(CHGetResourceString(WBGetDefaultDisplay(), X, Y, sizeof(Y)) <= 0){ WB_WARN_PRINT("%s - WARNING:  can't find color %s, using default value %s\n", __FUNCTION__, X, Z); strcpy(Y,Z); }

static void InternalCheckColors(void)
{
  Colormap colormap;

  // *Frame.background, *Frame.foreground, *WmFrame.background, *WmFrame.foreground,
  // *Form.background, *Form.foreground, *background, *foreground

  if(!iInitColorFlag)
  {
    char szFG[16], szBG[16], szBD[16];
    colormap = DefaultColormap(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));

    LOAD_COLOR0("*Frame.foreground",szFG) else LOAD_COLOR0("*Form.foreground", szFG)
     else LOAD_COLOR0("*WmFrame.foreground",szFG) else LOAD_COLOR0("*WmForm.foreground", szFG)
     else LOAD_COLOR("*foreground", szFG, "#000000");
    LOAD_COLOR0("*Frame.background",szBG) else LOAD_COLOR0("*Form.background", szBG)
     else LOAD_COLOR0("*WmFrame.background",szBG) else LOAD_COLOR0("*WmForm.background", szBG)
     else LOAD_COLOR("*background", szBG, "#dcdad5"); // default for gnome
    LOAD_COLOR0("*Frame.border",szBD) else LOAD_COLOR0("*Form.border", szBD)
     else LOAD_COLOR0("*WmFrame.border",szBD) else LOAD_COLOR0("*WmForm.border", szBD)
     else LOAD_COLOR0("*borderColor", szBD)
     else LOAD_COLOR("*border", szBD, "black"); // default for gnome

    XParseColor(WBGetDefaultDisplay(), colormap, szFG, &clrFG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrFG);
    XParseColor(WBGetDefaultDisplay(), colormap, szBG, &clrBG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrBG);
    XParseColor(WBGetDefaultDisplay(), colormap, szBD, &clrBD);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrBD);

    iInitColorFlag = 1;
  }
}

WBFrameWindow *FWCreateFrameWindow(const char *szTitle, int idIcon, const char *szMenuResource,
                                   int iX, int iY, int iWidth, int iHeight,
                                   WBWinEvent pUserCallback, int iFlags)
{
  FRAME_WINDOW *pNew;
  Display *pDisplay;
  XSetWindowAttributes xswa;  /* Temporary Set Window Attribute struct */
  XSizeHints  xsh;            /* Size hints for window manager */
  XWMHints xwmh;
//  Atom aProto[3];

  pNew = malloc(sizeof(*pNew)/*sizeof(FRAME_WINDOW)*/);

  if(!pNew)
    return NULL;

  pDisplay = WBGetDefaultDisplay();

  InternalCheckColors(); // this assigns clrBD and clrBG properly

  bzero(pNew, sizeof(*pNew));  // NULL out the entire structure
  // assign the 'non-NULL' values for structure members
  pNew->wbFW.ulTag = FRAME_WINDOW_TAG;
  pNew->wbFW.wID = -1;         // initial (bad) value
  pNew->wbFW.iFlags = iFlags;  // save this while I'm at it


  if(szTitle)
  {
    pNew->szTitle = malloc(strlen(szTitle) + 1);
    if(!pNew->szTitle)
    {
      free(pNew);
      return NULL;
    }
    strcpy(pNew->szTitle, szTitle);
  }

  // add struct to beginning of linked list 'cause it's faster that way

  pNew->pNext = pFrames;
  pFrames = pNew;

  // NOW I get to create the actual window with its GC and callback proc

  bzero(&xswa, sizeof(xswa));

  xswa.border_pixel = clrBD.pixel;
  xswa.background_pixel = clrBG.pixel;
  xswa.colormap = DefaultColormap(pDisplay, DefaultScreen(pDisplay));
  xswa.bit_gravity = CenterGravity;

  pNew->wbFW.wID = WBCreateWindow(pDisplay, None, FWDefaultCallback, "FrameWindow",
                                  iX, iY, iWidth, iHeight, 1, InputOutput,
                                  CWBorderPixel | CWBackPixel | CWColormap | CWBitGravity,
                                  &xswa);

  if(pNew->wbFW.wID == None)//<= 0)
  {
    FWDestroyFrameWindow2((WBFrameWindow *)pNew);
    return NULL;
  }

  // immediately identify this window using window data
  WBSetWindowData(pNew->wbFW.wID, 0, (void *)pNew);
  pNew->pFWCallback = pUserCallback;

  bzero(&xsh, sizeof(xsh));

  xsh.flags = (USPosition | USSize | PBaseSize | PWinGravity);
  xsh.x = iX;
  xsh.y = iY;
  xsh.width = iWidth;
  xsh.height = iHeight;
  xsh.base_width = iWidth / 8 > FRAME_WINDOW_MIN_WIDTH ? iWidth / 8 : FRAME_WINDOW_MIN_WIDTH;      // set min size
  xsh.base_height = iHeight / 8 > FRAME_WINDOW_MIN_HEIGHT ? iHeight / 8 : FRAME_WINDOW_MIN_HEIGHT;
  xsh.win_gravity = NorthWestGravity; // StaticGravity

  bzero(&xwmh, sizeof(xwmh));
  xwmh.flags = InputHint;
  xwmh.input = !0;  // this represents 'Locally Active'

// from http://mail.gnome.org/archives/wm-spec-list/2007-March/msg00000.html

// The ICCCM provides for focus models for a window:
//
// Input Model     Input Field     WM_TAKE_FOCUS
// No Input        False           Absent
// Passive         True            Absent
// Locally Active  True            Present
// Globally Active False           Present
//
// No Input - The application never expects to receive focus.
//
// Passive - The application will get focus but it will not grab it on
// its own. Instead it will only get focus if the window manager gives it
// to it. The application cannot help determine if it wants the focus or
// not at the given time/situation.
//
// Locally Active - The same as passive, but the application will also
// give focus to other windows that it owns of its own free will, without
// any interaction with the window manager, using XSetInputFocus.
//
// Globally Active - The application will not receive focus from the
// window manager. Instead it will determine when it wants focus (from
// WM_TAKE_FOCUS suggestions given by the window manager, or from events
// such as ButtonPress or KeyPress). The application will then acquire
// focus on its own using XSetInputFocus.

  // set title, size hints, and 'WM_HINTS' hints (so WM knows where to put the window and how to set focus)
  WBSetWMProperties(pNew->wbFW.wID, szTitle, &xsh, &xwmh, NULL);

#if 0
  aProto[0] = aWM_DELETE_WINDOW;  // for now, that's the only one
  aProto[1] = aWM_TAKE_FOCUS;     // GDK does this, see set_wm_protocols() in gdkwindow-x11.c
//  aProto[2] = a_NET_WM_PING;      // GDK does this, see set_wm_protocols() in gdkwindow-x11.c
//  aProto[3] = a_NET_WM_SYNC_REQUEST; // GDK does this when HAVE_XSYNC is enabled

  aProto[sizeof(aProto)/sizeof(aProto[0]) - 1] = None;  // have an extra one at the end

  XSetWMProtocols(pDisplay, pNew->wbFW.wID, aProto, sizeof(aProto)/sizeof(aProto[0]) - 1);
      // sets WM_PROTOCOLS property for the main window...
#endif // 0

  WBSetWMProtocols(pNew->wbFW.wID, aWM_DELETE_WINDOW, aWM_TAKE_FOCUS, None);

  WBCreateWindowDefaultGC(pNew->wbFW.wID, clrFG.pixel, clrBG.pixel);

  // now allow specific kinds of input messages
  XSelectInput(pDisplay, pNew->wbFW.wID,
               WB_STANDARD_INPUT_MASK | WB_MOUSE_INPUT_MASK | WB_KEYBOARD_INPUT_MASK);


  // NEXT, create the menu (if the resource string isn't NULL)

  if(szMenuResource && *szMenuResource)
  {
    WBMenuBarWindow *pMenu;

    pNew->pDefaultMenuResource = WBCopyString(szMenuResource);

    if(!pNew->pDefaultMenuResource)
    {
      FWDestroyFrameWindow2((WBFrameWindow *)pNew);
      return NULL;
    }

    pMenu = MBCreateMenuBarWindow(pNew->wbFW.wID, szMenuResource, 0);

    if(!pMenu)
    {
      FWDestroyFrameWindow2((WBFrameWindow *)pNew);
      return NULL;
    }
  }

  FWRecalcLayout(pNew->wbFW.wID); // prior to making me visible do this

  WBSetWindowIcon(pNew->wbFW.wID, idIcon);

  if(iFlags & WBFrameWindow_APP_WINDOW)
  {
    WBSetApplicationWindow(pNew->wbFW.wID);
  }

  if(iFlags & WBFrameWindow_VISIBLE)
  {
    WBMapWindow(pDisplay, pNew->wbFW.wID);  // make window visible
    WBGetParentWindow(pNew->wbFW.wID);  // this syncs everything up
  }

  return (WBFrameWindow *)pNew;
}

void FWDestroyFrameWindow(Window wID)
{
  FWDestroyFrameWindow2(FWGetFrameWindowStruct(wID));
}

void FWDestroyFrameWindow2(WBFrameWindow *pFrameWindow)
{
  // step 1:  unhook pFrameWindow
  FRAME_WINDOW *pTemp = pFrames;
  FRAME_WINDOW *pPrev = NULL;
  Window wID;
//  int i1;

  if(!pFrameWindow || pFrameWindow->ulTag != FRAME_WINDOW_TAG)
    return;

  wID = pFrameWindow->wID;

  while(pTemp && pTemp != (FRAME_WINDOW *)pFrameWindow)
  {
    pPrev = pTemp;
    pTemp = pTemp->pNext;
  }

  if(pTemp)
  {
    if(pPrev)
      pPrev->pNext = pTemp->pNext;  // unhook
    else if(pFrames == pTemp)
      pFrames = pTemp->pNext;
  }


  if(wID > 0)
    WBDestroyWindow(wID);  // this will free the structure
  else
  {
    // I must destroy malloc'd entries and contained windows in lieu of 'FWDefaultCallback'
    __internal_destroy_frame_window((FRAME_WINDOW *)pFrameWindow);
    free(pFrameWindow);
  }
}

void FWSetUserCallback(WBFrameWindow *pFrameWindow, WBWinEvent pCallBack)
{
  if(pFrameWindow->ulTag != FRAME_WINDOW_TAG)
    return;

  ((FRAME_WINDOW *)pFrameWindow)->pFWCallback = pCallBack;
}

void FWSetMenuHandlers(WBFrameWindow *pFrameWindow, const WBFWMenuHandler *pHandlerArray)
{
int i1;
const WBFWMenuHandler *pH;

  if(!pFrameWindow)
    return;

  if(((FRAME_WINDOW *)pFrameWindow)->pMenuHandler)
  {
    free(((FRAME_WINDOW *)pFrameWindow)->pMenuHandler);

    ((FRAME_WINDOW *)pFrameWindow)->pMenuHandler = NULL;
  }

  if(!pHandlerArray)
  {
    return;
  }

  // count the number of entries
  for(i1=0, pH = pHandlerArray; pH->lMenuID || pH->callback || pH->UIcallback; i1++, pH++) { }

  // allocate space and make a copy

  ((FRAME_WINDOW *)pFrameWindow)->pMenuHandler =
    (WBFWMenuHandler *)malloc(sizeof(WBFWMenuHandler) * (i1 + 2));

  if(((FRAME_WINDOW *)pFrameWindow)->pMenuHandler)
  {
    memcpy(((FRAME_WINDOW *)pFrameWindow)->pMenuHandler, pHandlerArray,
           sizeof(WBFWMenuHandler) * (i1 + 1));
  }
}

int FWDefaultCallback(Window wID, XEvent *pEvent)
{
  FRAME_WINDOW *pFrameWindow = (FRAME_WINDOW *)FWGetFrameWindowStruct(wID);
  Window wIDMenu;
  int iRval = 0;
#ifndef NO_DEBUG
  char tbuf[32]; // for keyboard input
  int nChar = sizeof(tbuf);
#endif // NO_DEBUG


  if(!pFrameWindow)
  {
    WB_ERROR_PRINT("%s - ERROR - no frame window pointer!\n", __FUNCTION__);
    return 0;
  }

  wIDMenu = WBGetMenuWindow(wID);

  // TODO:  message re-direction to children BEFORE 'pFWCallback'

  if(wIDMenu)
  {
    switch(pEvent->type)
    {
      case ButtonPress:
      case ButtonRelease:
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                         "%s - BUTTON PRESS\n", __FUNCTION__);

        if(WBPointInWindow(pEvent->xbutton.window, pEvent->xbutton.x, pEvent->xbutton.y, wIDMenu))
        {
          return(WBWindowDispatch(wIDMenu, pEvent));  // menu window should handle mousie events
        }

        break;

      case MotionNotify:
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                         "%s - MOTION NOTIFY\n", __FUNCTION__);

        if(WBPointInWindow(pEvent->xmotion.window, pEvent->xmotion.x, pEvent->xmotion.y, wIDMenu))
        {
          return(WBWindowDispatch(wIDMenu, pEvent));  // menu window should handle mousie events
        }

        break;

      case ClientMessage:  // menus, etc. (they generate the 'ClientMessage')

        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                       "%s - CLIENT MESSAGE\n", __FUNCTION__);

        if(pEvent->xclient.message_type == aMENU_COMMAND)
        {
          //////////////////////////////////////////////////////////////////////////
          //                                _                     _ _             //
          //   _ __ ___   ___ _ __  _   _  | |__   __ _ _ __   __| | | ___ _ __   //
          //  | '_ ` _ \ / _ \ '_ \| | | | | '_ \ / _` | '_ \ / _` | |/ _ \ '__|  //
          //  | | | | | |  __/ | | | |_| | | | | | (_| | | | | (_| | |  __/ |     //
          //  |_| |_| |_|\___|_| |_|\__,_| |_| |_|\__,_|_| |_|\__,_|_|\___|_|     //
          //                                                                      //
          //////////////////////////////////////////////////////////////////////////


          // check the container window that has the current focus, and THEN
          // check the frame window for an appropriate handler

          Window wFocus = FWGetFocusWindow(&(pFrameWindow->wbFW));
          if(wFocus != None)
          {
            int iRet = WBWindowDispatch(wFocus, pEvent);
            if(iRet) // non-zero return
            {
              return iRet; // the handler MUST return non-zero if the message should NOT be processed by the frame!
            }
          }

          if(pFrameWindow->pMenuHandler)
          {
            // search for the matching menu or ID - anything above 0x10000 is assumed to be a pointer
            const WBFWMenuHandler *pHandler = pFrameWindow->pMenuHandler;

            while(pHandler->lMenuID) // zero marks the end
            {
              long lID = pHandler->lMenuID;

              if(pHandler->lMenuID >= 0x10000L)
              {
                lID = XInternAtom(WBGetDefaultDisplay(), (const char *)lID, False);

                if(!lID)
                {
                  continue;
                }
              }

              if(pEvent->xclient.data.l[0] == lID)
              {
                if(pHandler->callback)
                {
                  if(pHandler->callback(&(pEvent->xclient)))
                  {
                    return 1;
                  }
                }

                return 0; // NOT handled or handler returned zero
              }

              pHandler++;
            }
          }
        }
        else if(pEvent->xclient.message_type == aMENU_UI_COMMAND)
        {
          //////////////////////////////////////////////////////////////////////////////////////
          //                                _   _ ___   _                     _ _             //
          //   _ __ ___   ___ _ __  _   _  | | | |_ _| | |__   __ _ _ __   __| | | ___ _ __   //
          //  | '_ ` _ \ / _ \ '_ \| | | | | | | || |  | '_ \ / _` | '_ \ / _` | |/ _ \ '__|  //
          //  | | | | | |  __/ | | | |_| | | |_| || |  | | | | (_| | | | | (_| | |  __/ |     //
          //  |_| |_| |_|\___|_| |_|\__,_|  \___/|___| |_| |_|\__,_|_| |_|\__,_|_|\___|_|     //
          //                                                                                  //
          //////////////////////////////////////////////////////////////////////////////////////

          // check 'contained' window for an appropriate UI handler before passing
          // it off to the frame window's handler

          Window wFocus = FWGetFocusWindow(&(pFrameWindow->wbFW));
          if(wFocus != None)
          {
            int iRet = WBWindowDispatch(wFocus, pEvent);
            if(iRet >= 0)
            {
              return iRet;
            }

            // TODO:  determine if a '-1' value really SHOULD grey out the menu choice anyway or
            //        if I should return some OTHER value to differentiate 'grey' from 'no handler'
          }

          if(pFrameWindow->pMenuHandler)
          {
            const WBFWMenuHandler *pHandler = pFrameWindow->pMenuHandler;

            while(pHandler->lMenuID) // zero marks the end
            {
              long lID = pHandler->lMenuID;

              if(pHandler->lMenuID >= 0x10000L)
              {
                lID = XInternAtom(WBGetDefaultDisplay(), (const char *)lID, False);

                if(!lID)
                {
                  continue;
                }
              }

              if(pEvent->xclient.data.l[0] == lID) // a message handler exists
              {
                if(pHandler->UIcallback)
                {
                  WBMenu *pMenu;
                  WBMenuItem *pItem;

                  // important detail - the 'data.l' array is assumed to have 32-bit values in it,
                  // regardless of how its definition and 64/32-bitness affects the actual data storage.
                  // In effect, only the lower 32-bits is valid.  Hence, I must combine two 32-bit values
                  // together in order to make a 64-bit pointer.  For consistency I always use 2 values
                  // per pointer to pass the information via the message structure.  otherwise it gets
                  // complicated and I really don't like complicated.  it causes mistakes, errors, crashes...

#if !defined(__SIZEOF_POINTER__) // TODO find a better way to deal with pointer size
#define __SIZEOF_POINTER__ 0
#endif
#if __SIZEOF_POINTER__ == 4 /* to avoid warnings in 32-bit linux */
                  pMenu = (WBMenu *)pEvent->xclient.data.l[1];
                  pItem = (WBMenuItem *)pEvent->xclient.data.l[3];
#else // assume 64-bit pointers here, and if they truncate, should NOT get any warnings... well that's the idea
                  pMenu = (WBMenu *)((unsigned long long)pEvent->xclient.data.l[1] | ((unsigned long long)pEvent->xclient.data.l[2] << 32));
                  pItem = (WBMenuItem *)((unsigned long long)pEvent->xclient.data.l[3] | ((unsigned long long)pEvent->xclient.data.l[4] << 32));
#endif
                  // TODO:  validate pointers, otherwise a posted message might crash me (like a vulnerability)

#warning this code potentially has a vulnerability in it

                  // if(!WBIsValidMenu(pMenu) || !WBIsValidMenuItem(pItem)) { do not do it }

                  return pHandler->UIcallback(pMenu, pItem);
                }

                return 0; // NO UI handler so return '0' [aka 'normal']
              }

              pHandler++;
            }
          }

          return -1; // if there's no handler and no UI handler, always return 'disabled'
        }
        else
        {
          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                         "%s - Client message not handled by frame window\n", __FUNCTION__);
        }

        break;

      default:
        break;
    }
  }


  if(pFrameWindow->pFWCallback)
  {
    // for most messages, if I handle it here, I don't do further processing

    iRval = (pFrameWindow->pFWCallback)(wID, pEvent);

    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_Event | DebugSubSystem_Frame,
                   "%s - %s event and user callback returns %d\n", __FUNCTION__, WBEventName(pEvent->type), iRval);

    if(iRval)
    {
      // check message types that I do *NOT* want to 'bail out' for, as well as those
      // that I _MUST_ bail out for.

      switch(pEvent->type)
      {
        case DestroyNotify: // must process after user callback
          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                         "%s DestroyNotify and user callback returned a non-zero value\n", __FUNCTION__);

          // CONTINUE PROCESSING - after the user's callback handles DestroyNotify I must handle
          //                       it here also (at the very end)

          break;

        case Expose: // no further processing needed, special debug notification
          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                         "%s Expose event and user callback returns %d\n", __FUNCTION__, iRval);
          return iRval;  // 'expose' event already handled


        default: // all other messages, no further processing needed
          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                         "%s - %s event and user callback returns %d\n", __FUNCTION__, WBEventName(pEvent->type), iRval);
          return iRval;
      }
    }
    else
    {
      // TODO:  deal with specific events NOT handled by the user callback
    }
  }


  // At this point iRval _COULD_  be non-zero (example, DestroyNotify)
  // so don't do any handling for those messages.

  if(!iRval)
  {
    switch(pEvent->type)
    {
      case KeyPress:
        {
#ifndef NO_DEBUG
          int iACS = 0;
          int iKey = WBKeyEventProcessKey((XKeyEvent *)pEvent, tbuf, &nChar, &iACS);

          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame | DebugSubSystem_Keyboard,
                         "%s KEY PRESS for KEY %d KEYCODE %d MASK=%d (%xH)\n",
                           __FUNCTION__, iKey, ((XKeyEvent *)pEvent)->keycode,
                           ((XKeyEvent *)pEvent)->state, ((XKeyEvent *)pEvent)->state);
#endif // NO_DEBUG

          // check for menu and hotkey activation.
//          if(nChar > 0) // only for "real" characters (i.e. not just the ALT key)
          {
            WBMenuBarWindow *pMenuBar = MBGetMenuBarWindowStruct(WBGetMenuWindow(wID));

            if(pMenuBar)  // menu bar exists?
            {
              WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Menu | DebugSubSystem_Frame | DebugSubSystem_Keyboard,
                             "%s call to MBMenuProcessHotKey for menu window %d (%08xH)\n",
                             __FUNCTION__, (int)pMenuBar->wSelf, (int)pMenuBar->wSelf);

              iRval = MBMenuProcessHotKey(pMenuBar->pMenu, (XKeyEvent *)pEvent);
            }
          }
        }
        break;

      case KeyRelease:
        {
          // KeyRelease
#ifndef NO_DEBUG
          int iACS = 0, iKey = WBKeyEventProcessKey((XKeyEvent *)pEvent, tbuf, &nChar, &iACS);

          if(nChar > 0)
          {
            WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame | DebugSubSystem_Keyboard,
                           "%s KEY RELEASE for KEY %d KEYCODE %d  MASK=%d (%xH)\n",
                           __FUNCTION__, iKey, ((XKeyEvent *)pEvent)->keycode,
                           ((XKeyEvent *)pEvent)->state, ((XKeyEvent *)pEvent)->state);

          }
#endif // NO_DEBUG

        }

        break;



      case SelectionRequest:
      case SelectionClear:
      case SelectionNotify:

        return 0; // NOT handled (default handler might want to handle them, but not me)

//        return FWDoSelectionEvents(&(pFrameWindow->wbFW), wID, wIDMenu, pEvent);  <-- no longer needed
    }
  }


  // TODO:   message re-direction to children AFTER 'pFWCallback'



  // ----------------------------------------
  // DESTROY DESTROY DESTROY DESTROY DESTROY
  //
  //   special handling for 'DestroyNotify'
  //
  // DESTROY DESTROY DESTROY DESTROY DESTROY
  // ----------------------------------------


  if(pEvent->type == DestroyNotify &&
     pEvent->xdestroywindow.window == wID)
  {
//    int boolQuitFlag = (pFrameWindow->wbFW.iFlags & WBFrameWindow_APP_WINDOW) != 0;

    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                   "%s - DestroyNotify\n", __FUNCTION__);

    WBSetWindowData(wID, 0, NULL);

    __internal_destroy_frame_window(pFrameWindow);

    free(pFrameWindow);

//    if(boolQuitFlag)
//      bQuitFlag = TRUE;  // set the global 'quit' flag if I'm an application top-level window

    WB_DEBUG_PRINT(DebugLevel_Verbose | DebugSubSystem_Event | DebugSubSystem_Frame,
                   "%s - frame window destroyed\n", __FUNCTION__);
    return 1;
  }

  WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Event | DebugSubSystem_Frame,
                 "%s - frame window callback returns %d\n", __FUNCTION__, iRval);

  return iRval;  // what happens when nothing is handled
}

void FWRecalcLayout(Window wID)
{
  // this callback happens any time I change the window size.  Use this
  // also to re-size scrollbars and status bars and menus.



  WBInvalidateGeom(wID, NULL, 1); // for now, just force a re-paint
}


// CONTAINED WINDOWS

int FWGetNumContWindows(const WBFrameWindow *pFrameWindow)
{
  return -1;  // for now
}

Window FWGetContainedWindowByIndex(const WBFrameWindow *pFrameWindow, int iIndex)
{
  return None; // for now
}

int FWAddContainedWindow(WBFrameWindow *pFrameWindow, Window idNew)
{
  return -1;  // for now
}

void FWRemoveContainedWindow(WBFrameWindow *pFrameWindow, Window idCont)
{
}

void FWSetFocusWindow(WBFrameWindow *pFrameWindow, Window idCont)
{
}

void FWSetFocusWindowIndex(WBFrameWindow *pFrameWindow, int iIndex)
{
}



#if 0 /* these are handled separately - don't do this */

// CLIPBOARD / SELECTION EVENTS
//
// NOTES:
//
// KDE wants _QT_SELECTION
// GNOME wants GDK_SELECTION
// 'libXt' wants _XT_SELECTION (see XtOwnSelection, XtGetSelectionValue, etc.)
//
// (nothing else seen so far)

int FWDoSelectionEvents(WBFrameWindow *pFrameWindow, Window wID, Window wIDMenu, XEvent *pEvent)
{
Display *pDisplay = WBGetWindowDisplay(wID);
FRAME_WINDOW *pFW = (FRAME_WINDOW *)pFrameWindow;

  // this is what the libXt function 'RequestSelectionValue' does
  // XConvertSelection(info->ctx->dpy, selection, target,   // 'selection' and 'target' are Atoms
  //                   info->property, XtWindow(info->widget), info->time);


  // TEMPORARY:  doing what WBDefault does

  if(pEvent->type == SelectionRequest)
  {
    char *p1 = pEvent->xselectionrequest.selection != None ? XGetAtomName(pDisplay, pEvent->xselectionrequest.selection) : NULL;
    char *p2 = pEvent->xselectionrequest.target != None ? XGetAtomName(pDisplay, pEvent->xselectionrequest.target) : NULL;
    char *p3 = pEvent->xselectionrequest.property != None ? XGetAtomName(pDisplay, pEvent->xselectionrequest.property) : NULL;

    WB_ERROR_PRINT("TEMPORARY - %s - SelectionRequest owner=%d requestor=%d selection=%s target=%s property=%s\n",
                   __FUNCTION__,
                   (int)pEvent->xselectionrequest.owner,
                   (int)pEvent->xselectionrequest.requestor,
                   p1 ? p1 : "NULL",
                   p2 ? p2 : "NULL",
                   p3 ? p3 : "NULL");

    if(p1)
    {
      XFree(p1);
    }                   
    if(p2)
    {
      XFree(p2);
    }                   
    if(p3)
    {
      XFree(p3);
    }                   

    // the default rejects the request.  Send a 'SelectionNotify' to indicate the failure

    if(pEvent->xselectionrequest.owner == wID) // only if I'm the selection owner
    {
      XSelectionEvent evtN;

      memset(&evtN, 0, sizeof(evtN));

      evtN.type = SelectionNotify;
      evtN.send_event = True; // 'cause I'm going to use 'XSendEvent' to reply immediately
      evtN.requestor = pEvent->xselectionrequest.requestor;
      evtN.selection = pEvent->xselectionrequest.selection;
      evtN.target = pEvent->xselectionrequest.target;
      evtN.property = None; // to indicate failure
      evtN.time = pEvent->xselectionrequest.time; // same time as request (for now)

      BEGIN_XCALL_DEBUG_WRAPPER
      XSendEvent(pDisplay, evtN.requestor, False, 0, (XEvent *)&evtN);
      END_XCALL_DEBUG_WRAPPER
    }

    return 1; // "handled"
  }
  else if(pEvent->type == SelectionClear)
  {
    char *p1 = XGetAtomName(pDisplay, pEvent->xselectionclear.selection);

    WB_ERROR_PRINT("TEMPORARY - %s - SelectionClear window=%d selection=%s\n",
                   __FUNCTION__,
                   (int)pEvent->xselectionclear.window,
                   p1 ? p1 : "NULL");

    if(p1)
    {
      XFree(p1);
    }                   

    // the default rejects the request.  Send a 'SelectionNotify' to indicate the failure

    if(pEvent->xselectionrequest.owner == wID) // only if I'm the selection owner
    {
      XSelectionEvent evtN;

      memset(&evtN, 0, sizeof(evtN));

      evtN.type = SelectionNotify;
      evtN.send_event = True; // 'cause I'm going to use 'XSendEvent' to reply immediately
      evtN.requestor = pEvent->xselectionrequest.requestor;
      evtN.selection = pEvent->xselectionrequest.selection;
      evtN.target = None;
      evtN.property = None; // to indicate failure (?)
      evtN.time = pEvent->xselectionrequest.time; // same time as request (for now)

      BEGIN_XCALL_DEBUG_WRAPPER
      XSendEvent(pDisplay, evtN.requestor, False, 0, (XEvent *)&evtN);
      END_XCALL_DEBUG_WRAPPER
    }

    return 1; // "handled"
  }
  else if(pEvent->type == SelectionNotify)
  {
    char *p1 = XGetAtomName(pDisplay, pEvent->xselection.selection);
    char *p2 = XGetAtomName(pDisplay, pEvent->xselection.target);
    char *p3 = XGetAtomName(pDisplay, pEvent->xselection.property);

    WB_ERROR_PRINT("TEMPORARY - %s - SelectionNotify requestor=%d selection=%s target=%s property=%s\n",
                   __FUNCTION__,
                   (int)pEvent->xselection.requestor,
                   p1 ? p1 : "NULL",
                   p2 ? p2 : "NULL",
                   p3 ? p3 : "NULL");

    if(p1)
    {
      XFree(p1);
    }                   
    if(p2)
    {
      XFree(p2);
    }                   
    if(p3)
    {
      XFree(p3);
    }                   

    return 1; // "handled"
  }




  return 0; // for now
}

#endif // 0

