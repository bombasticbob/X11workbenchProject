/////////////////////////////////////////////////////////////////////////////////////////////
//      _  _         _                             _             _                         //
//   __| |(_)  __ _ | |  ___    __ _    __      __(_) _ __    __| |  ___ __      __  ___   //
//  / _` || | / _` || | / _ \  / _` |   \ \ /\ / /| || '_ \  / _` | / _ \\ \ /\ / / / __|  //
// | (_| || || (_| || || (_) || (_| |    \ V  V / | || | | || (_| || (_) |\ V  V /_| (__   //
//  \__,_||_| \__,_||_| \___/  \__, |_____\_/\_/  |_||_| |_| \__,_| \___/  \_/\_/(_)\___|  //
//                             |___/|_____|                                                //
//                                                                                         //
//                  modal or modeless window based on a dialog template                    //
//                                                                                         //
/////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2016 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no waranties, either implied or explicit.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

/** \file dialog_window.c Implementation for dialog (frame) window and intercommunication structures and APIs
*/


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <signal.h>
#include <time.h>

#ifndef XK_Delete /* moslty for interix */
#define XK_MISCELLANY /* mostly for interix */
#include <X11/keysymdef.h> // some platforms don't automatically include this with X headers
#endif // XK_Delete

#include "window_helper.h"
#include "pixmap_helper.h"  // pixmap helpers, including pre-defined icons
#include "dialog_window.h"
#include "dialog_controls.h"
#include "conf_help.h"
#include "draw_text.h"


#ifdef HAVE_MALLOC_USABLE_SIZE
#ifdef __FreeBSD__
#include <malloc_np.h>
#else
#include <malloc.h>
#endif // __FreeBSD__
#endif // HAVE_MALLOC_USABLE_SIZE

#define THIS_SUBSYSTEM DebugSubSystem_Dialog



/** \ingroup dialog
  * \struct __DIALOG_WINDOW__
  * \brief DIALOG_WINDOW structure (internal)
  *
  * Dialog 'owner' window structure, kept internally as part of a link list.
  * This structure keeps track of the child (control) windows and global
  * properties.  See also \ref WB_DIALOG_PROP and \ref WBDialogPropList.\n
*/

typedef struct __DIALOG_WINDOW__
{
  WBDialogWindow wbDLG;            ///< WBDialogWIndow structure, required to be at the beginning

  WBDialogEntry *pwContents;       ///< malloc'd array of child window/control information as \ref WBDialogEntry following order of windows creation and tab order

  int nContents;                   ///< size of 'pwContents' when pwContents is not NULL
  int nMaxContents;                ///< extent of 'pwContents' when pwContents is not NULL
  char *szTitle;                   ///< title bar string (malloc'd pointer, must free on destroy)

  WBWinEvent pDLGCallback;         ///< pointer to dialog window callback function

  struct __DIALOG_WINDOW__ *pNext; ///< internal use only, pointer to next entry in chain (linked list)

} DIALOG_WINDOW;


static int InternalCreateChildWindows(DIALOG_WINDOW *pDlg, const char *szDialogResource);

int DLGDefaultCallback(Window wID, XEvent *pEvent);  // default callback for dialog windows (call for default processing)

static DIALOG_WINDOW *pDialogs = NULL;  // pointer to linked list of dialog windows (malloc'd)

static XColor clrFG, clrBG, clrBD;
static int iInitColorFlag = 0;

static void __internal_destroy_dialog_window(DIALOG_WINDOW *pTemp)
{
  int i1;
  if(pTemp->pwContents)
  {
    WBDialogEntry *pwContents = pTemp->pwContents;
    int nContents = pTemp->nContents;
    int nMaxContents = pTemp->nMaxContents;

    pTemp->pwContents = NULL;
    pTemp->nContents = 0;
    pTemp->nMaxContents = 0;

    for(i1=0; i1 < nContents && i1 < nMaxContents; i1++)
    {
      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Frame,
                     "%s - Destroy contents %d\n",
                     __FUNCTION__, i1 + 1);

      if((int)(pwContents[i1].wID) > 0)
        WBDestroyWindow(pwContents[i1].wID);

      // TODO:  do I need to release/free 'aClass' or shall I organize this elsewhere?
    }

    free(pwContents);
  }

  if(pTemp->szTitle)
    free(pTemp->szTitle);

  pTemp->szTitle = NULL;
}


int DLGPixelHeight(WBDialogWindow *pDlg, int iHeight)
{
  return iHeight * 2; // for now
}

int DLGPixelWidth(WBDialogWindow *pDlg, int iWidth)
{
  return iWidth * 2;  // for now
}

void WBDialogWindowExit()
{
  // destroy all of the dialog windows

  while(pDialogs)
  {
    DIALOG_WINDOW *pTemp = pDialogs;
    Window wID = pTemp->wbDLG.wID;

    pDialogs = pDialogs->pNext;

    WB_ERROR_PRINT("WARNING: %s - dialog window %d not previously destroyed\n", __FUNCTION__, (int)(pTemp->wbDLG.wID));

    // slightly different - free the structure first, THEN destroy the window
    WBSetWindowData(pTemp->wbDLG.wID, 0, NULL);
    __internal_destroy_dialog_window(pTemp);
    free(pTemp);

    if(wID > 0)
      WBDestroyWindow(wID);  // making sure...
  }

}

#define LOAD_COLOR0(X,Y) if(CHGetResourceString(WBGetDefaultDisplay(), X, Y, sizeof(Y)) > 0) {  }
#define LOAD_COLOR(X,Y,Z) if(CHGetResourceString(WBGetDefaultDisplay(), X, Y, sizeof(Y)) <= 0){ WB_WARN_PRINT("%s - WARNING:  can't find color %s, using default value %s\n", __FUNCTION__, X, Z); strcpy(Y,Z); }

static void InternalCheckColors(void)
{
  Colormap colormap;

  // *Dialog.background, *Dialog.foreground, *WmDialog.background, *WmDialog.foreground,
  // *Form.background, *Form.foreground, *background, *foreground

  if(!iInitColorFlag)
  {
    char szFG[16], szBG[16], szBD[16];
    colormap = DefaultColormap(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));

    LOAD_COLOR0("*Dialog.foreground",szFG) else LOAD_COLOR0("*Form.foreground", szFG)
     else LOAD_COLOR0("*WmDialogShell.foreground",szFG) else LOAD_COLOR0("*WmForm.foreground", szFG)
     else LOAD_COLOR("*foreground", szFG, "#000000");
    LOAD_COLOR0("*Dialog.background",szBG) else LOAD_COLOR0("*Form.background", szBG)
     else LOAD_COLOR0("*WmDialogShell.background",szBG) else LOAD_COLOR0("*WmForm.background", szBG)
     else LOAD_COLOR("*background", szBG, "#dcdad5"); // default for gnome
    LOAD_COLOR0("*Dialog.border",szBD) else LOAD_COLOR0("*Form.border", szBD)
     else LOAD_COLOR0("*WmDialogShell.border",szBD) else LOAD_COLOR0("*WmForm.border", szBD)
     else LOAD_COLOR0("*borderColor", szBD)
     else LOAD_COLOR("*border", szBD, "black"); // default for gnome

    XParseColor(WBGetDefaultDisplay(), colormap, szFG, &clrFG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrFG);
    XParseColor(WBGetDefaultDisplay(), colormap, szBG, &clrBG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrBG);
    XParseColor(WBGetDefaultDisplay(), colormap, szBD, &clrBD);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrBD);

    iInitColorFlag = 1;
  }
}

WBDialogWindow *DLGCreateDialogWindow(const char *szTitle, const char *szDialogResource,
                                      int iX, int iY, int iWidth, int iHeight,
                                      WBWinEvent pUserCallback, int iFlags, void *pUserData)
{
  DIALOG_WINDOW *pNew = malloc(sizeof(DIALOG_WINDOW));
  Display *pDisplay = WBGetDefaultDisplay();
  XSetWindowAttributes xswa;  /* Temporary Set Window Attribute struct */
  XSizeHints  xsh;            /* Size hints for window manager */
  XWMHints xwmh;
//  Atom aProto[3];
  XClientMessageEvent evt;
  int i1;
//#ifndef NODEBUG
//  WB_UINT64 ullTime = WBGetTimeIndex();
//#endif // NODEBUG


//  WB_ERROR_PRINT("TEMPORARY:  %s line %d  delta tick %lld\n", __FUNCTION__, __LINE__, (WBGetTimeIndex() - ullTime));

  if(!pNew)
  {
    WB_ERROR_PRINT("%s - not enough memory to create dialog window (1)\n", __FUNCTION__);
    return NULL;
  }

  WBDialogControlsInit();  // make sure I initialize all of the dialog controls stuff

  InternalCheckColors(); // must do this first

  bzero(pNew, sizeof(*pNew));
  pNew->wbDLG.ulTag = DIALOG_WINDOW_TAG;
  pNew->wbDLG.wID = -1;  // initial (bad) value
  pNew->wbDLG.wIDOwner = None;  // initially, no owner
  pNew->wbDLG.iFlags = iFlags;  // save this while I'm at it
  pNew->wbDLG.pUserData = pUserData; // save this too

  if(szTitle)
  {
    pNew->szTitle = malloc(strlen(szTitle) + 1);
    if(!pNew->szTitle)
    {
      free(pNew);

      WB_ERROR_PRINT("%s - not enough memory to create dialog window (2)\n", __FUNCTION__);
      return NULL;
    }
    strcpy(pNew->szTitle, szTitle);
  }

  // add struct to beginning of linked list 'cause it's faster that way

  pNew->pNext = pDialogs;
  pDialogs = pNew;

  // NOW I get to create the actual window with its GC and callback proc

  // copy standard colors into structure at this time [I will reference 'pNew->wbDLG' values from this point]
  memcpy(&(pNew->wbDLG.clrFG), &clrFG, sizeof(clrFG));
  memcpy(&(pNew->wbDLG.clrBG), &clrBG, sizeof(clrBG));
  memcpy(&(pNew->wbDLG.clrBD), &clrBD, sizeof(clrBD));

  // setting up the standard attributes
  bzero(&xswa, sizeof(xswa));

  xswa.border_pixel = pNew->wbDLG.clrBD.pixel;
  xswa.background_pixel = pNew->wbDLG.clrBG.pixel;
  xswa.colormap = DefaultColormap(pDisplay, DefaultScreen(pDisplay));
  xswa.bit_gravity = CenterGravity;

  WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Dialog,
                 "%s - creating dialog window at %d %d %d %d\n",
                 __FUNCTION__, iX, iY, iWidth, iHeight);

  pNew->wbDLG.wID = WBCreateWindow(pDisplay, None, DLGDefaultCallback, "DialogWindow",
                                   iX, iY, iWidth, iHeight, 1, InputOutput,
                                   CWBorderPixel | CWBackPixel | CWColormap | CWBitGravity,
                                   &xswa);
  if(pNew->wbDLG.wID <= 0)
  {
    DLGDestroyDialogWindow2((WBDialogWindow *)pNew);

    WB_ERROR_PRINT("DLGCreateDialogWindow - XCreateWindow fail\n");
    return NULL;
  }

  // immediately identify this window using window data
  WBSetWindowData(pNew->wbDLG.wID, 0, (void *)pNew);

  // register user callback function
  pNew->pDLGCallback = pUserCallback;

  // before I do anything else, create the child windows (this will set up the correct dialog size)

  if(!InternalCreateChildWindows(pNew, szDialogResource))
  {
    // since the window wasn't exposed yet, I have to post the destroy
    // rather than destroy it directly...

    WB_WARN_PRINT("%s - InternalCreateChildWindows failed, destroying dialog box\n", __FUNCTION__);

    DLGDestroyDialogWindow2((WBDialogWindow *)pNew);  // don't display the dialog box
    return NULL;
  }

  // NOW, set up the window properties, including sizeability and the correct min/max/current dimensions

  bzero(&xsh, sizeof(xsh));

  xsh.flags = (USPosition | USSize | PWinGravity);
  xsh.x = iX;
  xsh.y = iY;
  xsh.win_gravity = NorthWestGravity; // StaticGravity

  if(pNew->wbDLG.iClientWidth > 0 && pNew->wbDLG.iClientHeight > 0)  // for now only allow this
  {
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Dialog,
                   "%s setting width/height, iClientWidth=%d iClientHeight=%d\n",
                   __FUNCTION__, pNew->wbDLG.iClientWidth, pNew->wbDLG.iClientHeight);

    xsh.width = DLGPixelWidth((WBDialogWindow *)pNew, pNew->wbDLG.iClientWidth) + 2; /* 2 is twice border width */
    xsh.height = DLGPixelHeight((WBDialogWindow *)pNew, pNew->wbDLG.iClientHeight) + 2;
  }
  else // dialog is NOT resizeable
  {
    xsh.width = xsh.base_width = iWidth;
    xsh.height = xsh.base_height = iHeight;
  }

  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Dialog,
                 "%s calling XMoveResizeWindow, iX=%d iY=%d iWidth=%d iHeight=%d xsh.width=%d xsh.height=%d\n",
                 __FUNCTION__, iX, iY, iWidth, iHeight, xsh.width, xsh.height);

  XMoveResizeWindow(pDisplay, pNew->wbDLG.wID, iX, iY, xsh.width, xsh.height); // do this FIRST before doing 'hints'

  if(1) // dialog cannot be re-sized
  {
    xsh.flags |= (PMinSize | PMaxSize);

    xsh.min_width = xsh.max_width = xsh.width;
    xsh.min_height = xsh.max_height = xsh.height;

    xsh.flags |= PBaseSize;
    xsh.base_width = xsh.min_width;   // 'base width' is like "where you start from" I think... ( == min_width if not specified)
    xsh.base_height = xsh.min_height; // 'base height'  is like "where you start from" I think... ( == min_height if not specified)
  }
  else
  {
    // TODO: resizable dialog box
  }

  bzero(&xwmh, sizeof(xwmh));
  xwmh.flags = InputHint;
  xwmh.input = !0;  // this represents 'Locally Active'

// from http://mail.gnome.org/archives/wm-spec-list/2007-March/msg00000.html

// The ICCCM provides for focus models for a window:
//
// Input Model     Input Field     WM_TAKE_FOCUS
// No Input        False           Absent
// Passive         True            Absent
// Locally Active  True            Present
// Globally Active False           Present
//
// No Input - The application never expects to receive focus.
//
// Passive - The application will get focus but it will not grab it on
// its own. Instead it will only get focus if the window manager gives it
// to it. The application cannot help determine if it wants the focus or
// not at the given time/situation.
//
// Locally Active - The same as passive, but the application will also
// give focus to other windows that it owns of its own free will, without
// any interaction with the window manager, using XSetInputFocus.
//
// Globally Active - The application will not receive focus from the
// window manager. Instead it will determine when it wants focus (from
// WM_TAKE_FOCUS suggestions given by the window manager, or from events
// such as ButtonPress or KeyPress). The application will then acquire
// focus on its own using XSetInputFocus.

  // set title, size hints, and 'WM_HINTS' hints (so WM knows where to put the window and how to set focus)
  WBSetWMProperties(pNew->wbDLG.wID, szTitle, &xsh, &xwmh, NULL);

#if 0
  aProto[0] = aWM_DELETE_WINDOW;  // for now, that's the only one
  aProto[1] = aWM_TAKE_FOCUS;     // GDK does this, see set_wm_protocols() in gdkwindow-x11.c
//  aProto[2] = a_NET_WM_PING;      // GDK does this, see set_wm_protocols() in gdkwindow-x11.c
//  aProto[3] = a_NET_WM_SYNC_REQUEST; // GDK does this when HAVE_XSYNC is enabled

  aProto[sizeof(aProto)/sizeof(aProto[0]) - 1] = None; // have an extra one at the end

  XSetWMProtocols(pDisplay, pNew->wbDLG.wID, aProto, sizeof(aProto)/sizeof(aProto[0]) - 1);
#endif // 0

  WBSetWMProtocols(pNew->wbDLG.wID, aWM_DELETE_WINDOW, aWM_TAKE_FOCUS, None);

  WBCreateWindowDefaultGC(pNew->wbDLG.wID, pNew->wbDLG.clrFG.pixel, pNew->wbDLG.clrBG.pixel);

  // now allow certain kinds of input messages (I should be able to handle messages at this point)
  XSelectInput(pDisplay, pNew->wbDLG.wID, WB_STANDARD_INPUT_MASK | WB_KEYBOARD_INPUT_MASK);

  // now that the controls have been created, assign the title, and send
  // an event to the user callback to initialize the dialog box contents

//  WBSetWindowIcon(pNew->wbDLG.wID, idIcon);  TODO:  get icon info from resource??

  if(pUserCallback)
  {
    bzero(&evt, sizeof(evt));
    evt.type = ClientMessage;
    evt.display = pDisplay;
    evt.window = pNew->wbDLG.wID;
    evt.message_type = aDIALOG_INIT;
    evt.format = 32;

    if(!pUserCallback(pNew->wbDLG.wID, (XEvent *)&evt))  // callback returned zero?
    {
      DLGDestroyDialogWindow2((WBDialogWindow *)pNew);  // don't display the dialog box

      WB_ERROR_PRINT("DLGCreateDialogWindow - callback returns zero on init\n");
      return NULL;
    }
  }

  // Last but not least, set the focus for the control that's
  // first in my list that has the 'CAN_HAVE_FOCUS' bit set.

  for(i1=0; i1 < pNew->nContents; i1++)
  {
    if(pNew->pwContents[i1].iFlags & WBDialogEntry_CAN_HAVE_FOCUS)  // TODO:  check visibility?
    {
      pNew->pwContents[i1].iFlags |= WBDialogEntry_HAS_FOCUS;

      break;
    }
  }

  DLGRecalcLayout(pNew->wbDLG.wID); // prior to making me visible do this

  if(iFlags & WBDialogWindow_APP_WINDOW)
  {
    WBSetApplicationWindow(pNew->wbDLG.wID);
  }

  if((iFlags & WBDialogWindow_VISIBLE) ||
     (iFlags & WBDialogWindow_DOMODAL)) // 'DOMODAL' implies visible
  {
    WBMapWindow(pDisplay, pNew->wbDLG.wID);  // make window visible

    // 'warp' the mouse pointer to the center of the dialog box

    if(iFlags & (WBDialogWindow_DOMODAL | WBDialogWindow_CENTERMOUSE))
    {
      BEGIN_XCALL_DEBUG_WRAPPER
      XWarpPointer(pDisplay, None, pNew->wbDLG.wID, 0, 0, 0, 0, xsh.width / 2, xsh.height / 2);
      END_XCALL_DEBUG_WRAPPER
    }
  }

  if(iFlags & WBDialogWindow_DOMODAL)
  {
    WBShowModal(pNew->wbDLG.wID, 0);  // ignore return value
    WBGetParentWindow(pNew->wbDLG.wID);  // this syncs everything up
  }

  return (WBDialogWindow *)pNew;
}

void DLGAssignOwner(WBDialogWindow *pDlg, Window wIDOwner)
{
  if(!pDlg || pDlg->ulTag != DIALOG_WINDOW_TAG)
  {
    return;
  }

  pDlg->wIDOwner = wIDOwner;
}

void DLGDestroyDialogWindow(Window wID)
{
  DLGDestroyDialogWindow2(DLGGetDialogWindowStruct(wID));
}

void DLGDestroyDialogWindow2(WBDialogWindow *pDialogWindow)
{
  // step 1:  unhook pDialogWindow
  DIALOG_WINDOW *pTemp = pDialogs;
  DIALOG_WINDOW *pPrev = NULL;
  Window wID; //, wIDOwner;
//  int i1;

  if(!pDialogWindow || pDialogWindow->ulTag != DIALOG_WINDOW_TAG)
  {
    return;
  }

  wID = pDialogWindow->wID;
//  wIDOwner = pDialogWindow->wIDOwner;

  WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Dialog,
                 "%s - Destroying dialog window %d (%08xH)\n",
                 __FUNCTION__, (int)wID, (int)wID);

  while(pTemp && pTemp != (DIALOG_WINDOW *)pDialogWindow)
  {
    pPrev = pTemp;
    pTemp = pTemp->pNext;
  }

  if(pTemp)
  {
    if(pPrev)
      pPrev->pNext = pTemp->pNext;  // unhook
    else if(pDialogs == pTemp)
      pDialogs = pTemp->pNext;
  }


  if(wID > 0)
  {
    WBDestroyWindow(wID);  // this will free the structure
  }
  else
  {
    // I must destroy malloc'd entries and contained windows in lieu of 'DLGDefaultCallback'
    __internal_destroy_dialog_window((DIALOG_WINDOW *)pDialogWindow);
    free(pDialogWindow);
  }

}

void DLGSetUserCallback(WBDialogWindow *pDialogWindow, WBWinEvent pCallBack)
{
  if(pDialogWindow->ulTag != DIALOG_WINDOW_TAG)
    return;

  ((DIALOG_WINDOW *)pDialogWindow)->pDLGCallback = pCallBack;
}

int DLGDefaultCallback(Window wID, XEvent *pEvent)
{
  Display *pDisplay = WBGetWindowDisplay(wID);
  DIALOG_WINDOW *pDialogWindow = (DIALOG_WINDOW *)DLGGetDialogWindowStruct(wID);
  int i1, i2, iRval;
//  Window wIDMenu;

  if(!pDialogWindow || pDialogWindow->wbDLG.ulTag != DIALOG_WINDOW_TAG)
  {
    WB_WARN_PRINT("%s - invalid 'pDialogWindow' for window %d (%08xH)\n",
                  __FUNCTION__, (unsigned int)wID, (unsigned int)wID);
    return 0;
  }

  // TODO:  message re-direction to children BEFORE 'pDLGCallback'

//  if(pEvent->type == DestroyNotify)
//  {
//    WB_ERROR_PRINT("!!!TEMPORARY:  %s wID=%d got DestroyNotify for %d\n",
//                   __FUNCTION__, (int)wID, (int)pEvent->xdestroywindow.window);
//  }

  switch(pEvent->type)
  {
    case ButtonPress:
      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Dialog,
                     "%s - BUTTON PRESS - dialog window\n", __FUNCTION__);

      break;

    case ButtonRelease:
      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Dialog,
                     "%s - BUTTON RELEASE - dialog window\n", __FUNCTION__);

      break;

    case MotionNotify:
      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Dialog,
                     "%s - MOTION NOTIFY - dialog window\n", __FUNCTION__);

      break;

    case ClientMessage:  // menus, etc.
      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Dialog,
                     "%s - CLIENT MESSAGE - dialog window\n", __FUNCTION__);

      if(pEvent->xclient.message_type == aWM_PROTOCOLS && pEvent->xclient.window == wID)
      {
        if(pEvent->xclient.data.l[0] == aWM_DELETE_WINDOW)
        {
          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Dialog,
                         "%s - WM_DELETE_WINDOW (calling WBDestroyWindow(%d))\n", __FUNCTION__, (int)wID);
          WBDestroyWindow(wID); // should be safe to call this under any circumstances

#if 0
          Window wIDOwner = pDialogWindow->wbDLG.wIDOwner;

          WBUnmapWindow(pDisplay, wID);
          WBSetWindowData(wID, 0, NULL); // divorce 'pDialogWindow' from the window

          __internal_destroy_dialog_window(pDialogWindow);

          free(pDialogWindow); // 'pDialogWindow' will never be referenced again

          // note - this MIGHT recurse
          WBDestroyWindow(wID); // should be safe to call this under any circumstances
//          // NOTE:  if I'm already "being destroyed" I don't want to call this
//          BEGIN_XCALL_DEBUG_WRAPPER
//          XDestroyWindow(pDisplay, wID);
//          END_XCALL_DEBUG_WRAPPER

          // if the window had an owner, raise it and assign focus to it

          if(wIDOwner != None)
          {
            WBPostDelayedSetFocusAppEvent(WBGetWindowDisplay(wIDOwner), wIDOwner, wID, 100); // 100 msec delay
          }
#endif // 0
          return 1;
        }
      }
      else if(pEvent->xclient.message_type == aCONTROL_NOTIFY) // 'control notification' messages
      {
        // for control notifications, FIRST give the user callback a chance to handle it
        // and if nothing is done (zero return), I do my own processing here

        if(pDialogWindow->pDLGCallback)
        {
          // if I handle it here, I don't do further processing

          iRval = pDialogWindow->pDLGCallback(wID, pEvent);

          if(iRval)
          {
            return iRval;
          }
        }

        // check for OK/Cancel/Yes/No/Retry/Ignore/Abort button press and exit modal for any of them

        if(pEvent->xclient.data.l[0] == (long)aBUTTON_PRESS &&
           (pEvent->xclient.data.l[1] == IDOK || pEvent->xclient.data.l[1] == IDCANCEL ||
            pEvent->xclient.data.l[1] == IDYES || pEvent->xclient.data.l[1] == IDNO ||
            pEvent->xclient.data.l[1] == IDRETRY || pEvent->xclient.data.l[1] == IDABORT ||
            pEvent->xclient.data.l[1] == IDIGNORE))
        {
          WBEndModal(wID, pEvent->xclient.data.l[1]);

          return 1;  // handled
        }
        else if(pEvent->xclient.data.l[0] == (long)aLIST_NOTIFY)
        {
          if(pEvent->xclient.data.l[2] == WB_LIST_DBLCLICK)
          {
            // default behavior on list double click is to close the dialog with 'IDOK'
            WBEndModal(wID, IDOK);

            return 1; // handled
          }

          WB_WARN_PRINT("%s - TODO:  LIST_NOTIFY control notification message %ld (%s)  %ld (%08lxH), %ld (%08lxH)\n",
                        __FUNCTION__, pEvent->xclient.data.l[0],
                        XGetAtomName(pDisplay, (Atom)pEvent->xclient.data.l[0]),
                        pEvent->xclient.data.l[1], pEvent->xclient.data.l[1],
                        pEvent->xclient.data.l[2], pEvent->xclient.data.l[2]);

          return 0;  // NOT handled (default response for unhandled stuff
        }

        WB_WARN_PRINT("%s - TODO:  control notification messages %ld (%s)  %ld (%08lxH), %ld (%08lxH)\n",
                      __FUNCTION__, pEvent->xclient.data.l[0],
                      XGetAtomName(pDisplay, (Atom)pEvent->xclient.data.l[0]),
                      pEvent->xclient.data.l[1], pEvent->xclient.data.l[1],
                      pEvent->xclient.data.l[2], pEvent->xclient.data.l[2]);
      }
      else if(pEvent->xclient.message_type == aGOTFOCUS)   // 'focus change' messages
      {
        WBDialogEntry *pEntry = (WBDialogEntry *)(((XClientMessageEvent *)pEvent)->data.l[1]);

        if(pEntry < pDialogWindow->pwContents ||
           pEntry >= pDialogWindow->pwContents + pDialogWindow->nContents ||
           (((unsigned long)pEntry - (unsigned long)pDialogWindow->pwContents) % sizeof(*pEntry)) != 0)
        {
          // validity check - if it fails, it's not a valid pointer and I reject it

          WB_WARN_PRINT("%s - WARNING:  invalid dialog entry pointer in GOTFOCUS message (ignored)\n",
                        __FUNCTION__);
        }
        else if(pEntry->iFlags & WBDialogEntry_HAS_FOCUS)
        {
          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Dialog,
                         "%s - INFO:  control already has focus in GOTFOCUS message\n",
                         __FUNCTION__);
        }
        else if(pEntry->iFlags & WBDialogEntry_CAN_HAVE_FOCUS)
        {
          for(i1=0; i1 < pDialogWindow->nContents; i1++)
          {
            if(pEntry == pDialogWindow->pwContents + i1)
            {
              continue;
            }
            if(pDialogWindow->pwContents[i1].iFlags & WBDialogEntry_HAS_FOCUS)
            {
              pDialogWindow->pwContents[i1].iFlags &= ~WBDialogEntry_HAS_FOCUS;
            }
          }

          pEntry->iFlags |= WBDialogEntry_HAS_FOCUS;
        }
        else // items that can't actually get the focus - need to handle it properly
        {
          int bFound = 0;
          // set focus to NEXT control that can have focus (if it does not already have focus)

          i2 = (pEntry - pDialogWindow->pwContents);

          for(i1 = i2 + 1; i1 < pDialogWindow->nContents; i1++)
          {
            if(pDialogWindow->pwContents[i1].iFlags & WBDialogEntry_CAN_HAVE_FOCUS)
            {
              if(pDialogWindow->pwContents[i1].iFlags & WBDialogEntry_HAS_FOCUS)
              {
                // already has focus - nothing left to do
                bFound = -1;  // to indicate 'do nothing'
                break;
              }

              // this is my new focus item - unset focus for everything else

              for(i2=0; i2 < pDialogWindow->nContents; i2++)
              {
                if(i2 == i1)
                {
                  continue;
                }

                if(pDialogWindow->pwContents[i2].iFlags & WBDialogEntry_HAS_FOCUS)
                {
                  pDialogWindow->pwContents[i2].iFlags &= ~WBDialogEntry_HAS_FOCUS;

                  WBInvalidateGeom(pDialogWindow->pwContents[i2].wID, NULL, 1);  // force re-paint
                }
              }

              bFound = 1;

              break;
            }
          }

          // wrap around
          if(!bFound)
          {
            for(i1 = 0; i1 < i2; i1++)
            {
              if(pDialogWindow->pwContents[i1].iFlags & WBDialogEntry_CAN_HAVE_FOCUS)
              {
                if(pDialogWindow->pwContents[i1].iFlags & WBDialogEntry_HAS_FOCUS)
                {
                  // already has focus - nothing left to do
                  bFound = -1;  // to indicate 'do nothing'
                  break;
                }

                // this is my new focus item - unset focus for everything else

                for(i2=0; i2 < pDialogWindow->nContents; i2++)
                {
                  if(i2 == i1)
                  {
                    continue;
                  }

                  if(pDialogWindow->pwContents[i2].iFlags & WBDialogEntry_HAS_FOCUS)
                  {
                    pDialogWindow->pwContents[i2].iFlags &= ~WBDialogEntry_HAS_FOCUS;

                    WBInvalidateGeom(pDialogWindow->pwContents[i2].wID, NULL, 1);  // force re-paint
                  }
                }

                bFound = 1;

                break;
              }
            }
          }

          // now post the "set focus to this item" event (high priority)
          if(bFound > 0) // need to send message for focus change
          {
            XClientMessageEvent evt = {
                                        .type=ClientMessage,
                                        .serial=0,
                                        .send_event=0,
                                        .display=pDisplay,
                                        .window=wID,
                                        .message_type=aDLG_FOCUS,
                                        .format=32
                                      };
            evt.data.l[0] = 0;
            evt.data.l[1] = pDialogWindow->pwContents[i1].iID;

            WBPostPriorityEvent(wID, (XEvent *)&evt);  // priority event makes it happen faster
          }
        }
      }
      else if(pEvent->xclient.message_type == aLOSTFOCUS)   // 'focus change' messages
      {
        WB_WARN_PRINT("%s - TODO:  handle 'LOST FOCUS' notifications - control id %d\n",
                      __FUNCTION__, ((WBDialogEntry *)(((XClientMessageEvent *)pEvent)->data.l[1]))->iID);
      }
      else if(pEvent->xclient.message_type == aDLG_FOCUS)  // dialog focus change message
      {
        // data.l[0] == 0 for "set to specific dialog control"
        // data.l[0] < 0 for 'previous', > 0 for 'next'
        // this must be sent via the message queue or recursion might occur

        WBDialogEntry *pEntry = NULL;
        Window wFocus;
        int iCurFocus;

        // FIRST, find out which dialog control entry belongs to the item that will
        // end up with the focus.  If the focus bit is already set, just exit.

        if(!pEvent->xclient.data.l[0])
        {
          for(i1=0; i1 < pDialogWindow->nContents; i1++)
          {
            if(pDialogWindow->pwContents[i1].iID == pEvent->xclient.data.l[1])
            {
              pEntry = pDialogWindow->pwContents + i1;
              break;
            }
          }
        }
        else
        {
          // who has focus RIGHT NOW ?
          for(iCurFocus = -1, i1=0; i1 < pDialogWindow->nContents; i1++)
          {
            if(pDialogWindow->pwContents[i1].iFlags & WBDialogEntry_HAS_FOCUS)
            {
              iCurFocus = i1;
              break;
            }
          }

          if(iCurFocus < 0)
          {
            // no focus, so find the first one (or last one) possible
            if(pEvent->xclient.data.l[0] < 0)
            {
              for(i1=pDialogWindow->nContents - 1; i1 >= 0; i1--)
              {
                if(pDialogWindow->pwContents[i1].iFlags & WBDialogEntry_CAN_HAVE_FOCUS)
                {
                  pEntry = pDialogWindow->pwContents + i1;
                  break;
                }
              }
            }
            else
            {
              for(i1=0; i1 < pDialogWindow->nContents; i1++)
              {
                if(pDialogWindow->pwContents[i1].iFlags & WBDialogEntry_CAN_HAVE_FOCUS)
                {
                  pEntry = pDialogWindow->pwContents + i1;
                  break;
                }
              }
            }
          }
          else
          {
            if(pEvent->xclient.data.l[0] < 0)
            {
              for(i1=iCurFocus - 1; i1 >= 0; i1++)
              {
                if(pDialogWindow->pwContents[i1].iFlags & WBDialogEntry_CAN_HAVE_FOCUS)
                {
                  pEntry = pDialogWindow->pwContents + i1;
                  break;
                }
              }

              if(!pEntry)
              {
                for(i1=pDialogWindow->nContents - 1; i1 > iCurFocus; i1--)
                {
                  if(pDialogWindow->pwContents[i1].iFlags & WBDialogEntry_CAN_HAVE_FOCUS)
                  {
                    pEntry = pDialogWindow->pwContents + i1;
                    break;
                  }
                }
              }
            }
            else
            {
              for(i1=iCurFocus + 1; i1 < pDialogWindow->nContents; i1++)
              {
                if(pDialogWindow->pwContents[i1].iFlags & WBDialogEntry_CAN_HAVE_FOCUS)
                {
                  pEntry = pDialogWindow->pwContents + i1;
                  break;
                }
              }

              if(!pEntry)
              {
                for(i1=0; i1 < iCurFocus; i1++)
                {
                  if(pDialogWindow->pwContents[i1].iFlags & WBDialogEntry_CAN_HAVE_FOCUS)
                  {
                    pEntry = pDialogWindow->pwContents + i1;
                    break;
                  }
                }
              }
            }
          }
        }

        if(!pEntry)
        {
          WB_WARN_PRINT("%s - unable to set focus for DLG_FOCUS event, l[0]=%ld, l[1]=%ld\n",
                        __FUNCTION__, pEvent->xclient.data.l[0], pEvent->xclient.data.l[1]);
          // no focus - can't do it
          break;  // for now allow it without error
        }

        // set all of the focus bits correctly

        for(i1=0; i1 < pDialogWindow->nContents; i1++)
        {
          if(pEntry == pDialogWindow->pwContents + i1)
          {
            pEntry->iFlags |= WBDialogEntry_HAS_FOCUS;
          }
          else if(pDialogWindow->pwContents[i1].iFlags & WBDialogEntry_HAS_FOCUS)
          {
            pDialogWindow->pwContents[i1].iFlags &= ~WBDialogEntry_HAS_FOCUS;
            WBInvalidateGeom(pDialogWindow->pwContents[i1].wID, NULL, 1);  // force re-paint
          }
        }

        // NEXT, see if I (or any of my children) have the focus.  If not, I've already
        // set the 'HAS FOCUS' bit so exit without actually changing the focus.
        // Otherwise I'll need to actually set the focus via WBSetInputFocus

        wFocus = None;
        XGetInputFocus(pDisplay, &wFocus, &i1);

        if(wFocus != None && (wFocus == wID || WBIsChildWindow(wID, wFocus)))
        {
          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Dialog,
                         "%s - me or child has focus, setting to %d (%s), %d (%08xH)\n",
                         __FUNCTION__, pEntry->iID,
                         XGetAtomName(pDisplay, (Atom)pEntry->iID),
                         (int)pEntry->wID, (int)pEntry->wID);

          //XSetInputFocus(pDisplay, pEntry->wID, RevertToParent, CurrentTime);
          WBSetInputFocus(pEntry->wID);
          WBInvalidateGeom(pEntry->wID, NULL, 1);  // force re-paint
        }
      }

      break;

    case KeyPress:
    case KeyRelease:

      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Keyboard | DebugSubSystem_Dialog,
                     "%s KEY PRESS/RELEASE - dialog window - check for hotkeys\n", __FUNCTION__);

      iRval = DLGProcessHotKey((WBDialogWindow *)pDialogWindow, pEvent);

      if(iRval)
      {
        return iRval;
      }

      break;

    case FocusIn:

      WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Dialog,
                     "%s - FocusIn handler\n", __FUNCTION__);

      for(i1=0; i1 < pDialogWindow->nContents; i1++)
      {
        if(pDialogWindow->pwContents[i1].iFlags & WBDialogEntry_HAS_FOCUS)
        {
          Display *pDisplay = WBGetWindowDisplay(pDialogWindow->pwContents[i1].wID);
          Window wID = pDialogWindow->pwContents[i1].wID;

          if(WBIsValid(pDisplay, wID))
          {
            WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Dialog,
                           "%s - me or child has focus, setting to %d (%s), %d (%08xH)\n",
                           __FUNCTION__, pDialogWindow->pwContents[i1].iID,
                           XGetAtomName(pDisplay, (Atom)pDialogWindow->pwContents[i1].iID),
                           (int)pDialogWindow->pwContents[i1].wID, (int)pDialogWindow->pwContents[i1].wID);

            //XSetInputFocus(pDisplay, wID, RevertToParent, CurrentTime);
            WBSetInputFocus(wID);

            break;
          }
          else
          {
            WB_WARN_PRINT("Warning:  %s %s:%d window %d (%08xH) isn't valid, can't set focus\n",
                          __FUNCTION__, __FILE__, __LINE__, (int)wID, (int)wID);
          }
        }
      }

      if(i1 >= pDialogWindow->nContents)  // none had the focus?  Find one and set it!
      {
        for(i1=0; i1 < pDialogWindow->nContents; i1++)
        {
          if(pDialogWindow->pwContents[i1].iFlags & WBDialogEntry_CAN_HAVE_FOCUS)
          {
            Display *pDisplay = WBGetWindowDisplay(pDialogWindow->pwContents[i1].wID);
            Window wID = pDialogWindow->pwContents[i1].wID;

            // TODO:  check visibility?
            if(WBIsValid(pDisplay,wID))
            {
              pDialogWindow->pwContents[i1].iFlags |= WBDialogEntry_HAS_FOCUS;

              WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Dialog,
                             "%s - me or child has focus, setting to %d (%s), %d (%08xH)\n",
                             __FUNCTION__, pDialogWindow->pwContents[i1].iID,
                             XGetAtomName(pDisplay, (Atom)pDialogWindow->pwContents[i1].iID),
                             (int)pDialogWindow->pwContents[i1].wID, (int)pDialogWindow->pwContents[i1].wID);

              //XSetInputFocus(pDisplay, wID, RevertToParent, CurrentTime);
              WBSetInputFocus(wID);
              break;
            }
            else
            {
              WB_WARN_PRINT("Warning:  %s %s:%d window %d (%08xH) isn't valid, can't set focus\n",
                            __FUNCTION__, __FILE__, __LINE__, (int)wID, (int)wID);
            }
          }
        }
      }

      break;
  }


  if(pDialogWindow->pDLGCallback)
  {
    // for most messages, if I handle it here, I don't do further processing

    iRval = pDialogWindow->pDLGCallback(wID, pEvent);

    if(iRval)
    {
      // check message types that I do *NOT* want to 'bail out' for

      switch(pEvent->type)
      {
        case DestroyNotify:
          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Dialog,
                         "%s - DestroyNotify and user callback returned a non-zero value\n", __FUNCTION__);
          break;

        case Expose:
          return iRval;  // 'expose' event already handled

        default:
          return iRval;
      }
    }
  }

  // TODO:   message re-direction to children AFTER 'pDLGCallback'
  // the system is SUPPOSED to destroy children first...

  // special handling for 'destroy'
  if(pEvent->type == DestroyNotify &&
     pEvent->xdestroywindow.window == wID)
  {
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Dialog,
                   "%s - DestroyNotify Window=%d\n", __FUNCTION__, (int)wID);

    WBSetWindowData(wID, 0, NULL);

    if(pDialogWindow)
    {
      Window wIDOwner = pDialogWindow->wbDLG.wIDOwner;
      __internal_destroy_dialog_window(pDialogWindow);

      free(pDialogWindow);

      // if the window had an owner, raise it and assign focus to it

      if(wIDOwner != None)
      {
        WBPostDelayedSetFocusAppEvent(WBGetWindowDisplay(wIDOwner), wIDOwner, wID, 100); // 100 msec delay
      }
    }

    return 1; // tells caller I did internal handling for this
  }

  return 0;
}

void DLGRecalcLayout(Window wID)
{
  // this callback happens any time I change the window size.  Use this
  // also to re-size scrollbars and status bars and menus.

}

void * DLGGetDialogWindowUserData(Window wID)
{
  DIALOG_WINDOW *pDlg = (DIALOG_WINDOW *)DLGGetDialogWindowStruct(wID);

  if(!pDlg)
  {
    return NULL;
  }

  return pDlg->wbDLG.pUserData;
}

Window DLGGetDialogControl(WBDialogWindow *pDialog, int iControlID)
{
  DIALOG_WINDOW *pSelf = (DIALOG_WINDOW *)pDialog;
  int i1;

  if(!pSelf || !pSelf->pwContents)
    return None; /* 0 */

  for(i1=0; i1 < pSelf->nContents && i1 < pSelf->nMaxContents; i1++)
  {
    if(pSelf->pwContents[i1].iID == iControlID)
    {
      return pSelf->pwContents[i1].wID;
    }
  }

  return None;
}

WBDialogEntry *DLGGetDialogControlEntry(WBDialogWindow *pDialog, Window idControl)
{
  DIALOG_WINDOW *pSelf = (DIALOG_WINDOW *)pDialog;
  int i1;

  if(!pSelf || !pSelf->pwContents)
    return NULL;

  for(i1=0; i1 < pSelf->nContents && i1 < pSelf->nMaxContents; i1++)
  {
    if(pSelf->pwContents[i1].wID == idControl)
    {
      return pSelf->pwContents + i1;
    }
  }

  return NULL;
}

Window DLGGetFirstDialogControl(WBDialogWindow *pDialog)
{
  DIALOG_WINDOW *pSelf = (DIALOG_WINDOW *)pDialog;

  if(!pSelf || !pSelf->pwContents)
    return None; /* 0 */

  return pSelf->pwContents[0].wID;
}

Window DLGGetNextDialogControl(WBDialogWindow *pDialog, Window idControl)
{
  DIALOG_WINDOW *pSelf = (DIALOG_WINDOW *)pDialog;
  int i1;

  if(!pSelf || !pSelf->pwContents)
    return None;

  for(i1=0; i1 < pSelf->nContents && i1 < pSelf->nMaxContents; i1++)
  {
    if(pSelf->pwContents[i1].wID == idControl)
    {
      if((i1 + 1) >= pSelf->nContents || (i1 + 1) >= pSelf->nMaxContents)
        i1 = 0;
      else
        i1++;

      return pSelf->pwContents[i1].wID;
    }
  }

  return None;
}

Window DLGGetPrevDialogControl(WBDialogWindow *pDialog, Window idControl)
{
  DIALOG_WINDOW *pSelf = (DIALOG_WINDOW *)pDialog;
  int i1;

  if(!pSelf || !pSelf->pwContents)
    return None;

  for(i1=0; i1 < pSelf->nContents && i1 < pSelf->nMaxContents; i1++)
  {
    if(pSelf->pwContents[i1].wID == idControl)
    {
      if(i1 == 0)
      {
        i1 = pSelf->nContents - 1;

        if(i1 >= pSelf->nMaxContents)
          i1 = pSelf->nMaxContents - 1;
      }
      else
        i1--;

      return pSelf->pwContents[i1].wID;
    }
  }

  return None;
}


int DLGProcessHotKey(WBDialogWindow *pDLG, XEvent *pEvent)
{
//char tbuf[16];
//int cbLen;
KeySym ks;
int iACSMask = ShiftMask | ControlMask | Mod1Mask /* | Mod2Mask | Mod3Mask | Mod4Mask | Mod5Mask */;
int i1, /* iCtrl, iAlt, iShift, */ iNoEnter = 0, iNoEsc = 0, iNoTab = 0;
WBDialogEntry *pFocusEntry = NULL, *pDefaultEntry = NULL, *pCancelEntry = NULL;
Display *pDisplay = WBGetWindowDisplay(pDLG->wID);


  iACSMask &= ((XKeyEvent *)pEvent)->state;

// TODO:  do I need the CTRL/ALT/SHIFT info?  uncomment these later if I need it
//        for now they are commented out because linux GCC barphs on unused assigned vars
//  iCtrl = (iACSMask & ControlMask) ? 1 : 0;
//  iShift = (iACSMask & ShiftMask) ? 1 : 0;
//  iAlt = (iACSMask & Mod1Mask) ? 1 : 0;

  // find default & current focus control entries
  for(i1=0; ((DIALOG_WINDOW *)pDLG)->pwContents && i1 < ((DIALOG_WINDOW *)pDLG)->nContents; i1++)
  {
    if(((DIALOG_WINDOW *)pDLG)->pwContents[i1].iFlags & WBDialogEntry_HAS_FOCUS)
    {
      pFocusEntry = ((DIALOG_WINDOW *)pDLG)->pwContents + i1;
    }

    if(((DIALOG_WINDOW *)pDLG)->pwContents[i1].iFlags & WBDialogEntry_DEFAULT)
    {
      pDefaultEntry = ((DIALOG_WINDOW *)pDLG)->pwContents + i1;
    }

    if(((DIALOG_WINDOW *)pDLG)->pwContents[i1].aClass == aCANCELBUTTON_CONTROL)
    {
      pCancelEntry = ((DIALOG_WINDOW *)pDLG)->pwContents + i1;
    }

    if(pDefaultEntry && pFocusEntry && pCancelEntry)
    {
      break;
    }
  }

  if(pFocusEntry
     && (pFocusEntry->aClass == aEDIT_CONTROL || (pFocusEntry->iFlags & WBDialogEntry_EDIT)))
  {
    if(pFocusEntry->iFlags & WBDialogEntry_MULTILINE)
    {
      iNoEnter = 1;
    }
    if(pFocusEntry->iFlags & WBDialogEntry_ALLCHARS)
    {
      iNoEnter = 1;
      iNoEsc = 1;
      iNoTab = 1;
    }
  }

  if(pEvent->type == KeyPress || pEvent->type == KeyRelease)
  {
    ks = XLookupKeysym((XKeyEvent *)pEvent, 0);  // always use '0' index for these

    if(iACSMask == Mod1Mask)  // alt key held down, no others
    {
      const char *pKey = XKeysymToString(ks);

      if(!pKey)
      {
        // alt key is non-printing - this code will skip it
        return 0;
      }

      WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Event | DebugSubSystem_Dialog | DebugSubSystem_Keyboard,
                     "%s - user pressed Alt+%s %d (%xH)\n",
                     __FUNCTION__, pKey, (int)ks, (int)ks);

      if(pEvent->type == KeyRelease)
      {
        // who gets this alt key?  Keystroke is ALT + *pKey
        // search everyone's caption until I find one.  Start with the control that
        // currently has the focus, then wrap around.  That way duplicate underscores
        // will bounce from one to the other in dialog order.


      }
    }
    else if(!iNoEnter
            && pEvent->type == KeyRelease
            && ((int)ks == XK_Return || (int)ks == XK_KP_Enter)  // someone pressed <ENTER>
            && iACSMask == 0)  // no modifiers
    {
      WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Event | DebugSubSystem_Dialog | DebugSubSystem_Keyboard,
                     "%s - DIALOG WINDOW - <enter> detected\n", __FUNCTION__);

      if((!(pFocusEntry->iFlags & WBDialogEntry_PUSHBUTTON) && pDefaultEntry)
         || pFocusEntry == pDefaultEntry)
      {
        XClientMessageEvent evt = {
                                    .type=ClientMessage,
                                    .serial=0,
                                    .send_event=0,
                                    .display=pDisplay,
                                    .window=pDLG->wID,
                                    .message_type=aCONTROL_NOTIFY,
                                    .format=32
                                  };
        evt.data.l[0] = aBUTTON_PRESS;
        evt.data.l[1] = pDefaultEntry->iID;
        evt.data.l[2] = 0;

        // simulate a button press of the default button
        WBPostPriorityEvent(pDLG->wID, (XEvent *)&evt);  // priority event makes it happen faster
        return 1;
      }
    }
    else if(!iNoEsc
            && pEvent->type == KeyRelease
            && ((int)ks == XK_Escape)  // someone pressed <ESC>
            && iACSMask == 0)  // no modifiers
    {
      WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Event | DebugSubSystem_Dialog | DebugSubSystem_Keyboard,
                     "%s - DIALOG WINDOW - <ESC> detected\n", __FUNCTION__);

      if((!(pFocusEntry->iFlags & WBDialogEntry_PUSHBUTTON) && pCancelEntry)
         || pFocusEntry->aClass == aCANCELBUTTON_CONTROL)
      {
        XClientMessageEvent evt = {
                                    .type=ClientMessage,
                                    .serial=0,
                                    .send_event=0,
                                    .display=pDisplay,
                                    .window=pDLG->wID,
                                    .message_type=aCONTROL_NOTIFY,
                                    .format=32
                                  };
        evt.data.l[0] = aBUTTON_PRESS;
        evt.data.l[1] = pCancelEntry->iID;
        evt.data.l[2] = 0;

        // simulate a button press of the default button
        WBPostPriorityEvent(pDLG->wID, (XEvent *)&evt);  // priority event makes it happen faster
        return 1;
      }
    }
    else if(!iNoTab
            && pEvent->type == KeyRelease
            && ((int)ks == XK_Tab || (int)ks == XK_KP_Tab)  // someone pressed <TAB>
            && (iACSMask == 0 || iACSMask == ShiftMask))      // either a tab or back-tab
    {
      XClientMessageEvent evt = {
                                  .type=ClientMessage,
                                  .serial=0,
                                  .send_event=0,
                                  .display=pDisplay,
                                  .window=pDLG->wID,
                                  .message_type=aDLG_FOCUS,
                                  .format=32
                                };
      evt.data.l[0] = iACSMask == 0 ? 1 : -1;
      evt.data.l[1] = 0;

      WBPostPriorityEvent(pDLG->wID, (XEvent *)&evt);  // priority event makes it happen faster
      return 1;
    }
    else if(pEvent->type == KeyRelease)
    {
//      fprintf(stderr, "TEMPORARY:  user pressed %s (%d,%d) and the state is %d (%08xH)\n",
//              tbuf, tbuf[0], ((XKeyEvent *)pEvent)->keycode,
//              ((XKeyEvent *)pEvent)->state,((XKeyEvent *)pEvent)->state );
    }
  }
  else
  {
    WB_WARN_PRINT("%s - calling DLGProcessHotKey and it's not a key event\n", __FUNCTION__);
  }

  return 0;
}







// creating child windows

enum
{
  x__BEGIN_DIALOG=0,
  x__END_DIALOG,
  x__FONT,
  x__CONTROL,
  x__ID,
  x__X,
  x__Y,
  x__WIDTH,
  x__HEIGHT,
  x__VISIBLE,
  x__TITLE,
  x__VATOP,
  x__VABOTTOM,
  x__VACENTER,
  x__HALEFT,
  x__HARIGHT,
  x__HACENTER,
  x__VRESIZE,
  x__HRESIZE
};

static const char * const aszKeywords[]={ "BEGIN_DIALOG","END_DIALOG","FONT","CONTROL","ID","X","Y","WIDTH","HEIGHT","VISIBLE","TITLE",
                                          "VALIGN_BOTTOM","VALIGN_TOP","VALIGN_CENTER","HALIGN_LEFT","HALIGN_RIGHT","HALIGN_CENTER",
                                          "VRESIZE","HRESIZE",
                                          NULL };

static const char * const aszSymbols[]={ "IDOK", "IDCANCEL", "IDYES", "IDNO", "IDRETRY", "IDABORT", "IDIGNORE", "IDSTATIC", "IDNONE", NULL };
static const int iIDSymbols[]={ IDOK, IDCANCEL, IDYES, IDNO, IDRETRY, IDABORT, IDIGNORE, IDSTATIC, IDNONE, -1 };

static int InternalCreateChildWindowsSub(DIALOG_WINDOW *pDlg, const char **pszDialogResource);

static int InternalCreateChildWindows(DIALOG_WINDOW *pDlg, const char *szDialogResource)
{
const char *p1, *p2;
int iRval;

  if(!szDialogResource || !*szDialogResource)
  {
    return 0;  // don't allow it
  }

  p1 = szDialogResource;
  while(*p1 && *p1 <= ' ')
    p1++;

  p2 = p1;
  while(*p1 && *p1 > ' ')
    p1++;

  // must be 'BEGIN_DIALOG'
  if((p1 - p2) != strlen(aszKeywords[x__BEGIN_DIALOG]) ||
     memcmp(p2, aszKeywords[x__BEGIN_DIALOG], (p1 - p2)) != 0)
  {
    WB_WARN_PRINT("%s - dialog box resource missing 'BEGIN_DIALOG'\n", __FUNCTION__);
    return 0;
  }

  while(*p1 && *p1 <= ' ')
    p1++;

  iRval = InternalCreateChildWindowsSub(pDlg, &p1);
  if(!iRval)
  {
    WB_ERROR_PRINT("%s - InternalCreateChildWindowsSub failure at \"%-.30s\"\n", __FUNCTION__, p1);
  }

  return iRval;
}

static int get_id_val(const char *szVal, int iLen)
{
// NOTE:  if I need a different list for dialog control ID symbols, put it "up there" with aszSymbols (etc.)
int i1;
char tbuf[256];


  if(iLen > 0)
  {
    if(iLen >= sizeof(tbuf))
      iLen = sizeof(tbuf) - 1;

    memcpy(tbuf, szVal, iLen);
  }

  if(iLen < 0)
    iLen = 0;

  tbuf[iLen] = 0;

  if(!tbuf[0])
    return 0;

  WBDeQuoteString(tbuf);

  if(tbuf[0] >= '0' && tbuf[0] <= '9')
  {
    return atoi(tbuf);
  }

  // check for well-known alpha-numeric values

  for(i1=0; aszSymbols[i1]; i1++)
  {
    if(!strcmp(tbuf, aszSymbols[i1]))
      return iIDSymbols[i1];
  }

  // TODO:  registered list of symbol names

  // now assume it's an atom, and return that

  return XInternAtom(WBGetDefaultDisplay(), tbuf, 0);
}



static int InternalCreateChildWindowsSub(DIALOG_WINDOW *pDlg, const char **pszDialogResource)
{
const char *p1, *p2, *p3;
int i1, iKW, nKids = 0, iRval = 0;
unsigned int iCurSize = 0, iCurContentSize = 0;
struct _KIDS_
{
  Atom aClass;  // atom 'class' for control entry
  int iID;      // ID for control entry
  int iX, iY, iWidth, iHeight;  // that too
  int iFlags;
  char *szTitle;  // pointer to malloc'd string with title
  char *szProp;   // pointer to malloc'd string with additional properties
} *pKids = NULL;
char tbuf[256];


  p1 = p2 = *pszDialogResource;

  while(*p1)
  {
    p2 = p1;
    while(*p1 && *p1 > ' ')
    {
      if(*p1 == '"' || *p1 == '\'')
      {
        // we allow embedded quoted strings preceded by non-quotes
        char c = *(p1++);

        while(*p1 &&
              (*p1 != c || p1[1] == c))
        {
          if(*p1 == c)
            p1++;

          if(*p1 == '\n' || *p1 == '\r') // not allowed
          {
            WB_WARN_PRINT("%s - Illegal newline/return character in embedded string within dialog resource\n",
                          __FUNCTION__);
            *pszDialogResource = p2;
            return 0;
          }

          p1++;
        }

        if(*p1 == c)
          p1++;
      }
      else
      {
        p1++;
      }
    }

    for(iKW=0; aszKeywords[iKW]; iKW++)
    {
      i1 = strlen(aszKeywords[iKW]);
      if(i1 <= (p1 - p2) &&  // keyword length shorter than 'term' or equal in size
         (p2[i1] <= ' ' || p2[i1] == ':') &&
         !memcmp(p2, aszKeywords[iKW], i1))
      {
        p3 = p2 + i1;

        if(*p3 == ':')
          p3++;

        break;
      }
    }

    if(!aszKeywords[iKW])
    {
      WB_WARN_PRINT("%s - NULL in aszKeywords in InternalCreateChildWindowsSub within dialog resource\n", __FUNCTION__);
      // TODO:  do I handle this as a custom property for a control?
      *pszDialogResource = p2;
      return 0;
    }

    if(iKW == x__END_DIALOG)
    {
      if(!pKids)
      {
        pKids = malloc(sizeof(*pKids));  // because it can't be NULL
        nKids = 0;
      }

      break;
    }

    if(iKW == x__BEGIN_DIALOG)
    {
      WB_WARN_PRINT("%s - nested dialogs not supported (yet)\n", __FUNCTION__);

      *pszDialogResource = p2;
      return 0;
    }

    switch(iKW)
    {
      case   x__CONTROL:
//        fprintf(stderr, "TEMPORARY:  control definition %-.20s\n", p3);

        if(!pKids)
        {
          pKids = malloc(iCurSize = (256 * sizeof(*pKids)));
          if(!pKids)
          {
            WB_ERROR_PRINT("%s - not enough memory for controls\n", __FUNCTION__);
            iKW = -1;
            break;
          }

#ifdef HAVE_MALLOC_USABLE_SIZE
          iCurSize = malloc_usable_size(pKids); // re-evaluate actual size
#endif // HAVE_MALLOC_USABLE_SIZE

          nKids = 1;
        }
        else if((nKids + 1) * sizeof(*pKids) > iCurSize)
        {
          int iNewSize = (nKids + 128) * sizeof(*pKids);
          void *p0 = realloc(pKids, iNewSize);
          if(!p0)
          {
            WB_ERROR_PRINT("%s - not enough memory for all controls\n", __FUNCTION__);
            iKW = -1;
            break;
          }

#ifdef HAVE_MALLOC_USABLE_SIZE
          iCurSize = malloc_usable_size(p0); // re-evaluate actual size
#else  // HAVE_MALLOC_USABLE_SIZE
          iCurSize = iNewSize;
#endif // HAVE_MALLOC_USABLE_SIZE

          pKids = (struct _KIDS_ *)p0;
          nKids++;
        }
        else
        {
          nKids++;
        }

        memset(pKids + nKids - 1, 0, sizeof(*pKids));

        // get the correct atom for the control name

        if(p1 <= p3)
        {
          WB_WARN_PRINT("%s - Invalid control name %-.20s\n", __FUNCTION__, p3);
          iKW = -1;
          break;
        }

        memcpy(tbuf, p3, p1 - p3);
        tbuf[p1 - p3] = 0;

        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Dialog,
                       "%s - control %s\n", __FUNCTION__, tbuf);

        pKids[nKids - 1].aClass = XInternAtom(WBGetDefaultDisplay(), tbuf, 0);

        break;

      case   x__ID:
        if(!nKids) // ID applied to dialog box is ignored
        {
          WB_WARN_PRINT("%s - Ignoring ID for dialog box, %.20s\n", __FUNCTION__, p3);
        }
        else
        {
          pKids[nKids - 1].iID = get_id_val(p3, p1 - p3);
        }

        break;

      case   x__X:
        if(!nKids) // X applied to dialog box is ignored
        {
          WB_WARN_PRINT("%s - Ignoring X for dialog box, %.20s\n", __FUNCTION__, p3);
        }
        else
        {
          pKids[nKids - 1].iX = get_id_val(p3, p1 - p3);
        }

        break;

      case   x__Y:
        if(!nKids) // Y applied to dialog box is ignored
        {
          WB_WARN_PRINT("%s - Ignoring Y for dialog box, %.20s\n", __FUNCTION__, p3);
        }
        else
        {
          pKids[nKids - 1].iY = get_id_val(p3, p1 - p3);
        }

        break;

      case   x__WIDTH:
        if(!nKids)
        {
          pDlg->wbDLG.iClientWidth = get_id_val(p3, p1 - p3);
        }
        else
        {
          pKids[nKids - 1].iWidth = get_id_val(p3, p1 - p3);
        }

        break;

      case   x__HEIGHT:
        if(!nKids)
        {
          pDlg->wbDLG.iClientHeight = get_id_val(p3, p1 - p3);
        }
        else
        {
          pKids[nKids - 1].iHeight = get_id_val(p3, p1 - p3);
        }

        break;

      case   x__VATOP:
        if(!nKids) // visible applied to dialog box is ignored
        {
          WB_WARN_PRINT("%s - RESERVED:  'top aligned' property on dialog box\n", __FUNCTION__);
        }
        else
        {
          pKids[nKids - 1].iFlags &= ~WBDialogEntry_VAlignMask;
          pKids[nKids - 1].iFlags |= WBDialogEntry_VAlignTop;
        }

        break;

      case   x__VABOTTOM:
        if(!nKids) // visible applied to dialog box is ignored
        {
          WB_WARN_PRINT("%s - RESERVED:  'top aligned' property on dialog box\n", __FUNCTION__);
        }
        else
        {
          pKids[nKids - 1].iFlags &= ~WBDialogEntry_VAlignMask;
          pKids[nKids - 1].iFlags |= WBDialogEntry_VAlignBottom;
        }

        break;

      case   x__VACENTER:
        if(!nKids) // visible applied to dialog box is ignored
        {
          WB_WARN_PRINT("%s - RESERVED:  'top aligned' property on dialog box\n", __FUNCTION__);
        }
        else
        {
          pKids[nKids - 1].iFlags &= ~WBDialogEntry_VAlignMask;
          pKids[nKids - 1].iFlags |= WBDialogEntry_VAlignCenter;
        }

        break;

      case   x__HALEFT:
        if(!nKids) // visible applied to dialog box is ignored
        {
          WB_WARN_PRINT("%s - RESERVED:  'top aligned' property on dialog box\n", __FUNCTION__);
        }
        else
        {
          pKids[nKids - 1].iFlags &= ~WBDialogEntry_HAlignMask;
          pKids[nKids - 1].iFlags |= WBDialogEntry_HAlignLeft;
        }

        break;

      case   x__HARIGHT:
        if(!nKids) // visible applied to dialog box is ignored
        {
          WB_WARN_PRINT("%s - RESERVED:  'top aligned' property on dialog box\n", __FUNCTION__);
        }
        else
        {
          pKids[nKids - 1].iFlags &= ~WBDialogEntry_HAlignMask;
          pKids[nKids - 1].iFlags |= WBDialogEntry_HAlignRight;
        }

        break;

      case   x__HACENTER:
        if(!nKids) // visible applied to dialog box is ignored
        {
          WB_WARN_PRINT("%s - RESERVED:  'top aligned' property on dialog box\n", __FUNCTION__);
        }
        else
        {
          pKids[nKids - 1].iFlags &= ~WBDialogEntry_HAlignMask;
          pKids[nKids - 1].iFlags |= WBDialogEntry_HAlignCenter;
        }

        break;

      case   x__HRESIZE:
        if(!nKids)
        {
          pDlg->wbDLG.iFlags |= WBDialogEntry_HResize;
        }
        else
        {
          WB_WARN_PRINT("%s - WARNING:  'HRESIZE' property on dialog control (ignored)\n", __FUNCTION__);
        }

        break;

      case   x__VRESIZE:
        if(!nKids)
        {
          pDlg->wbDLG.iFlags |= WBDialogEntry_VResize;
        }
        else
        {
          WB_WARN_PRINT("%s - WARNING:  'VRESIZE' property on dialog control (ignored)\n", __FUNCTION__);
        }

        break;

      case   x__TITLE:
        if(!nKids)
        {
          if(pDlg->szTitle)
            free(pDlg->szTitle);

          pDlg->szTitle = malloc(p1 - p3 + 1);
          if(!pDlg->szTitle)
          {
            WB_WARN_PRINT("%s - Not enough memory for dialog box title %-.20s\n", __FUNCTION__, p3);
            iKW = -1;
            break;
          }

          memcpy(pDlg->szTitle, p3, p1 - p3);
          pDlg->szTitle[p1 - p3] = 0;

          WBDeQuoteString(pDlg->szTitle);
        }
        else
        {
          struct _KIDS_ *pKid = pKids + nKids - 1;

          if(pKid->szTitle)
            free(pKid->szTitle);

          pKid->szTitle = malloc(p1 - p3 + 1);
          if(!pKid->szTitle)
          {
            WB_WARN_PRINT("%s - Not enough memory for control title %-.20s\n", __FUNCTION__, p3);
            iKW = -1;
            break;
          }

          memcpy(pKid->szTitle, p3, p1 - p3);
          pKid->szTitle[p1 - p3] = 0;

          WBDeQuoteString(pKid->szTitle);
        }

        break;

      case   x__FONT:
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Dialog,
                       "%s - font definition %-.20s\n", __FUNCTION__, p3);
        // TODO:  only valid for dialog box at this time?
        break;

      case   x__VISIBLE:
        if(!nKids) // visible applied to dialog box is ignored
        {
          WB_WARN_PRINT("%s - RESERVED:  'visible' property on dialog box\n", __FUNCTION__);
        }
        else
        {
          pKids[nKids - 1].iFlags |= WBDialogEntry_VISIBLE;
        }

        break;
    }

    if(iKW < 0)  // error in control list
    {
      if(pKids)
      {
        for(i1=0; i1 < nKids; i1++)
        {
          if(pKids[i1].szTitle)
          {
            free(pKids[i1].szTitle);
          }
          if(pKids[i1].szProp)
          {
            free(pKids[i1].szProp);
          }
        }

        free(pKids);
        pKids = NULL;  // my error flag below
      }

      break;  // error flag from above
    }

    while(*p1 && *p1 <= ' ')
      p1++;
  }

  if(!pKids)
  {
    WB_ERROR_PRINT("%s - NULL 'pKids' in InternalCreateChildWindowsSub\n", __FUNCTION__);
    *pszDialogResource = p2;  // point of error

    return 0;
  }

  if(!pDlg->pwContents)  // normally THIS will be the case
  {
    iCurContentSize = ((nKids + 384) & 0xffffff00L)
                    * sizeof(*(pDlg->pwContents));
    pDlg->pwContents = (WBDialogEntry *)malloc(iCurContentSize);

    if(!pDlg->pwContents)
    {
      iCurContentSize = 0;

      WB_ERROR_PRINT("%s - NULL 'pwContents' in InternalCreateChildWindowsSub\n", __FUNCTION__);

      for(i1=0; i1 < nKids; i1++)
      {
        if(pKids[i1].szTitle)
        {
          free(pKids[i1].szTitle);
        }
        if(pKids[i1].szProp)
        {
          free(pKids[i1].szProp);
        }
      }

      free(pKids);

      *pszDialogResource = p1;  // point of error

      return 0;
    }

#ifdef HAVE_MALLOC_USABLE_SIZE
    iCurContentSize = malloc_usable_size(pDlg->pwContents); // re-evaluate actual size
#endif // HAVE_MALLOC_USABLE_SIZE

    pDlg->nContents = 0;  // force it

    // calculate 'nMaxContents' from actual memory block size
    pDlg->nMaxContents = iCurContentSize
                       / sizeof(*(pDlg->pwContents));
  }
  else if((pDlg->nContents + nKids) > pDlg->nMaxContents) // unlikely but maybe later?
  {
    int iNewSize = (pDlg->nContents + nKids + 128) * sizeof(*(pDlg->pwContents));
    void *p0 = realloc(pDlg->pwContents, iNewSize);

    if(!p0)
    {
      WB_ERROR_PRINT("%s - NULL 'pwContents' (re-alloc) in InternalCreateChildWindowsSub\n", __FUNCTION__);
      for(i1=0; i1 < nKids; i1++)
      {
        if(pKids[i1].szTitle)
        {
          free(pKids[i1].szTitle);
        }
        if(pKids[i1].szProp)
        {
          free(pKids[i1].szProp);
        }
      }

      free(pKids);

      *pszDialogResource = p1;  // point of error

      return 0;
    }

#ifdef HAVE_MALLOC_USABLE_SIZE
    iCurContentSize = malloc_usable_size(p0); // re-evaluate actual size
#else  // HAVE_MALLOC_USABLE_SIZE
    iCurContentSize = iNewSize;
#endif // HAVE_MALLOC_USABLE_SIZE

    pDlg->pwContents = (WBDialogEntry *)p0;
    // calculate 'nMaxContents' from actual memory block size
    pDlg->nMaxContents = iCurContentSize
                       / sizeof(*(pDlg->pwContents));
  }

//  fprintf(stderr, "TEMPORARY:  dialog has %d controls\n", nKids);

  // load up the structure but don't create the windows (yet)

  for(i1=0, iRval = 1; i1 < nKids; i1++)
  {
    WBDialogControl *pCtrl = NULL;
    WBDialogEntry *pEntry = pDlg->pwContents + pDlg->nContents + i1;

    pEntry->ulTag = DIALOG_ENTRY_TAG;
    pEntry->aClass = pKids[i1].aClass;
    pEntry->iID = pKids[i1].iID;
    pEntry->iX = pKids[i1].iX;
    pEntry->iY = pKids[i1].iY;
    pEntry->iWidth = pKids[i1].iWidth;
    pEntry->iHeight = pKids[i1].iHeight;

    pEntry->iFlags = pKids[i1].iFlags;
    pEntry->wID = -1;  // not assigned yet

    // structure entry complete - create the control
    pCtrl = WBDialogControlCreate(pEntry->aClass, (WBDialogWindow *)pDlg, pEntry,
                                  pEntry->iX, pEntry->iY, pEntry->iWidth, pEntry->iHeight,
                                  pKids[i1].szTitle, pKids[i1].szProp);

    if(!pCtrl)
    {
      WB_ERROR_PRINT("%s - Unable to create control %d via WBDialogControlCreate\n", __FUNCTION__, i1);
      WB_WARN_PRINT("%s - class: %s  title: %s  id: %d\n", __FUNCTION__,
                    XGetAtomName(WBGetDefaultDisplay(), pEntry->aClass), pKids[i1].szTitle,
                    pKids[i1].iID);
      iRval = 0;
      break;
    }

    pEntry->wID = pCtrl->wID;  // assign it now
  }

  pDlg->nContents += nKids;

  // final cleanup

  for(i1=0; i1 < nKids; i1++)
  {
    if(pKids[i1].szTitle)
    {
      free(pKids[i1].szTitle);
    }
    if(pKids[i1].szProp)
    {
      free(pKids[i1].szProp);
    }
  }

  free(pKids);   // not needed now

  *pszDialogResource = p1;

  return iRval;
}

