/////////////////////////////////////////////////////////////////////
//        _     _ _     _      __                                  //
//    ___| |__ (_) | __| |    / _|_ __ __ _ _ __ ___   ___   ___   //
//   / __| '_ \| | |/ _` |   | |_| '__/ _` | '_ ` _ \ / _ \ / __|  //
//  | (__| | | | | | (_| |   |  _| | | (_| | | | | | |  __/| (__   //
//   \___|_| |_|_|_|\__,_|___|_| |_|  \__,_|_| |_| |_|\___(_)___|  //
//                      |_____|                                    //
//                                                                 //
//        a window that exists as a tab in a frame window          //
//                                                                 //
//           (part of the 'frame window' support API)              //
//                                                                 //
/////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2016 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.
               Any claims to alleged functionality or features should be
               considered 'preliminary', and might not function as advertised.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/


#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>

#include "window_helper.h"
#include "font_helper.h"
#include "child_frame.h"
#include "draw_text.h"
#include "menu_popup.h"


static int ChildFrameEditCutHandler(XClientMessageEvent *);
static int ChildFrameEditCopyHandler(XClientMessageEvent *);
static int ChildFrameEditPasteHandler(XClientMessageEvent *);
static int ChildFrameEditDeleteHandler(XClientMessageEvent *);
static int ChildFrameEditSelectAllHandler(XClientMessageEvent *);
static int ChildFrameEditSelectNoneHandler(XClientMessageEvent *);
static int ChildFrameEditCutUIHandler(WBMenu *pMenu, WBMenuItem *pMenuItem);
static int ChildFrameEditCopyUIHandler(WBMenu *pMenu, WBMenuItem *pMenuItem);
static int ChildFrameEditPasteUIHandler(WBMenu *pMenu, WBMenuItem *pMenuItem);
static int ChildFrameEditDeleteUIHandler(WBMenu *pMenu, WBMenuItem *pMenuItem);
static int ChildFrameEditSelectAllUIHandler(WBMenu *pMenu, WBMenuItem *pMenuItem);
static int ChildFrameEditSelectNoneUIHandler(WBMenu *pMenu, WBMenuItem *pMenuItem);

/** \ingroup child_window
  * \variable aChildFrameMenuHandler
  * \brief Automatic menu handler for Child Frame windows
  *
  * whenever you declare a menu for a Child Frame window, the standard 'Edit Menu' items
  * are automatically handled.  If the menu you specify contains these items, the default menu
  * handler can process them for you.  If you override them in your own menu handler structure,
  * the override versions will be used instead.
**/
FW_MENU_HANDLER_BEGIN(aChildFrameMenuHandler)

  FW_MENU_HANDLER_ENTRY(FW_EDIT_CUT_MENU, ChildFrameEditCutHandler, ChildFrameEditCutUIHandler)
  FW_MENU_HANDLER_ENTRY(FW_EDIT_COPY_MENU, ChildFrameEditCopyHandler, ChildFrameEditCopyUIHandler)
  FW_MENU_HANDLER_ENTRY(FW_EDIT_PASTE_MENU, ChildFrameEditPasteHandler, ChildFrameEditPasteUIHandler)
  FW_MENU_HANDLER_ENTRY(FW_EDIT_DELETE_MENU, ChildFrameEditDeleteHandler, ChildFrameEditDeleteUIHandler)
  FW_MENU_HANDLER_ENTRY(FW_EDIT_SELECT_ALL_MENU, ChildFrameEditSelectAllHandler, ChildFrameEditSelectAllUIHandler)
  FW_MENU_HANDLER_ENTRY(FW_EDIT_SELECT_NONE_MENU, ChildFrameEditSelectNoneHandler, ChildFrameEditSelectNoneUIHandler)

FW_MENU_HANDLER_END



static int ChildFrameDoPointerEvent(XClientMessageEvent *pEvent, Display *pDisplay,
                                    Window wID, WBChildFrame *pC, WBChildFrameUI *pUI);

static int ChildFrameDoCharEvent(XClientMessageEvent *pEvent, Display *pDisplay,
                                 Window wID, WBChildFrame *pC, WBChildFrameUI *pUI);

static WBChildFrame *pChildFrames = NULL;  // pointer to linked list of 'Child Frame' windows


int FWInitChildFrame(WBChildFrame *pChildFrame, WBFrameWindow *pOwner, XFontSet rFontSet,
                     const char *szFocusMenu, const WBFWMenuHandler *pHandlerArray,
                     WBWinEvent pUserCallback, int fFlags)
{
WBChildFrame *pC;
XSetWindowAttributes xswa;  /* Temporary Set Window Attribute struct */
Display *pDisplay = WBGetDefaultDisplay();
int iRval = -1;


  if(!pChildFrame || !pOwner || pOwner->wID == None)
  {
    // TODO:  validate 'pOwner' as a valid WBFrameWindow ??

    WB_ERROR_PRINT("%s - invalid pointers or owner window does not exist\n", __FUNCTION__);

    return -1;
  }

  // zero out entire structure beforehand
  bzero(pChildFrame, sizeof(*pChildFrame));


  // FIRST, attach the child frame to my list o' child frames, making sure
  // that it is not already there [if it is assume this was called twice]
  // while I'm at it, zero out the structure BEFORE I assign 'pNext'

  if(!pChildFrames)
  {
    pChildFrames = pChildFrame;
    pChildFrame->pNext = NULL; // make sure
  }
  else
  {
    pC = pChildFrames;

    while(pC->pNext)
    {
      if(pC == pChildFrame) // just in case
      {
        WB_ERROR_PRINT("%s - unexpected error condition, did you call this function before?\n", __FUNCTION__);

        return -2;
      }

      pC = pC->pNext;
    }

    if(pC)
    {
      // zero out entire structure beforehand
      bzero(pChildFrame, sizeof(*pChildFrame));

      pC->pNext = pChildFrame;
      pChildFrame->pNext = NULL;
    }
    else
    {
      // internal error, flag it for now and return "fail"
      WB_ERROR_PRINT("%s - unexpected condition, returning error\n", __FUNCTION__);

      return -3;
    }
  }

  // if the owner is valid, but NOT tabbed, and it already has
  // a WBChildFrame, then I fail to create this one.

  if((WBFrameWindow_NO_TABS & pOwner->iFlags)) // window has NO tabs
  {
    if(FWGetNumContWindows(pOwner)) // error *OR* > 0, doesn't matter, can ONLY have one tab in the frame
    {
      FWDestroyChildFrame(pChildFrame); // this unhooks everything (alloc'd things are zero'd by bzero)

      return -4; // can't create, SDI
    }
  }


  // NEXT, set up all of the various 'things' in the structure that are simple assignments
  pChildFrame->ulTag = CHILD_FRAME_TAG;
  pChildFrame->destructor = NULL; // make sure

  if(rFontSet == None)
  {
    pChildFrame->rFontSet = None;
  }
  else
  {
    pChildFrame->rFontSet = WBCopyModifyFontSet(pDisplay, rFontSet, 0, 0);
  }

  if(szFocusMenu)
  {
    pChildFrame->pszMenuResource = WBCopyString(szFocusMenu);

    if(!pChildFrame->pszMenuResource)
    {
      FWDestroyChildFrame(pChildFrame); // this unhooks everything (alloc'd things are zero'd by bzero)
      return -5; // not enough memory
    }
  }
  else
  {
    pChildFrame->pszMenuResource = NULL;
  }

  if(pHandlerArray)
  {
    const WBFWMenuHandler *pH;
    int iN;

    // count the number of entries in the menu handler
    for(iN=0, pH = pHandlerArray; pH->lMenuID || pH->callback || pH->UIcallback; iN++, pH++)
    {
      // NOTHING inside the loop.  just count.
    }

    // allocate space and make a copy

    pChildFrame->pMenuHandler = (WBFWMenuHandler *)WBAlloc(sizeof(WBFWMenuHandler)
                                                           * (iN + 1
                                                              + sizeof(aChildFrameMenuHandler)
                                                                / sizeof(aChildFrameMenuHandler[0])
                                                              )
                                                           );

    if(pChildFrame->pMenuHandler)
    {
      if(iN > 0)
      {
        memcpy(pChildFrame->pMenuHandler, pHandlerArray,
               sizeof(WBFWMenuHandler) * iN);
      }

      memcpy(pChildFrame->pMenuHandler + iN,
             aChildFrameMenuHandler,
             sizeof(aChildFrameMenuHandler)); // this includes the NULL entry at the end
    }
    else
    {
      FWDestroyChildFrame(pChildFrame); // this unhooks everything (alloc'd things are zero'd by bzero)
      return -5; // not enough memory
    }
  }

  // Next, I need to create the window via 'WBCreateWindow()'

  bzero(&xswa, sizeof(xswa));

  xswa.border_pixel = FWGetDefaultBD().pixel;
  xswa.background_pixel = FWGetDefaultBG().pixel;  // typically a 'grey' color
  xswa.colormap = DefaultColormap(pDisplay, DefaultScreen(pDisplay));
  xswa.bit_gravity = CenterGravity;

  pChildFrame->wID = WBCreateWindow(pDisplay, pOwner->wID, FWChildFrameEvent, "ChildFrame",
                                    pOwner->iClientX, pOwner->iClientY,
                                    pOwner->iClientWidth - 2, pOwner->iClientHeight - 2, // border is 1 pixel, so subtract 2
                                    1, InputOutput,
                                    CWBorderPixel | CWBackPixel | CWColormap | CWBitGravity,
                                    &xswa);

  if(pChildFrame->wID == None)
  {
    FWDestroyChildFrame(pChildFrame);
    return -6; // could not create the window
  }

  // immediately identify this window's data struct using window data
  WBSetWindowData(pChildFrame->wID, 0, (void *)pChildFrame); // window data is pointer to this struct
  pChildFrame->pUserCallback = pUserCallback;


  // create the default graphics context using the frame's color info
  WBCreateWindowDefaultGC(pChildFrame->wID, FWGetDefaultFG().pixel, FWGetDefaultBG().pixel);

  // now allow specific kinds of input messages.  I won't need 'structure notify' as they won't work
  // anyway.  those end up going to the frame window, and it passes them (as needed) to me.
  XSelectInput(pDisplay, pChildFrame->wID,
               WB_STANDARD_INPUT_MASK | WB_MOUSE_INPUT_MASK | WB_KEYBOARD_INPUT_MASK);


  // FINALLY, inform the frame window, which will set up some other stuff for me

  pChildFrame->pOwner = pOwner;
  iRval = FWAddContainedWindow(pOwner, pChildFrame); // TODO:  make THIS assign the owner pointer?

  if(iRval < 0) // error? (returns negative on error, otherwise the tab index)
  {
    FWDestroyChildFrame(pChildFrame); // this frees up all of the resources (but does not free the mem block)
  }

  // TODO:  other things

  return iRval;
}

void FWDestroyChildFrame(WBChildFrame *pChildFrame)
{
WBChildFrame *pC, *pC2;
Window wID;


  if(!pChildFrame)
  {
    WB_ERROR_PRINT("ERROR:  %s - pChildFrame not valid\n", __FUNCTION__);

    return;
  }

  wID = pChildFrame->wID; // make a copy of it

  // FIRST, tell the owner to remove me from the list

  if(pChildFrame->pOwner)
  {
    FWRemoveContainedWindow(pChildFrame->pOwner, pChildFrame);

    if(pChildFrame->pOwner != NULL)
    {
      WB_ERROR_PRINT("ERROR:  %s - owner pointer was nut 'NULL'd out\n", __FUNCTION__);
    }

    pChildFrame->pOwner = NULL;
  }

  // NOW, free up any resources that were WBAlloc'd - they must also be free'd

  if(pChildFrame->szDisplayName)
  {
    WBFree(pChildFrame->szDisplayName);
    pChildFrame->szDisplayName = NULL;
  }

  if(pChildFrame->rFontSet)
  {
    XFreeFontSet(WBGetDefaultDisplay(), pChildFrame->rFontSet);
    pChildFrame->rFontSet = None;
  }

  if(pChildFrame->pMenuHandler)
  {
    WBFree(pChildFrame->pMenuHandler);
    pChildFrame->pMenuHandler = NULL;
  }

  if(pChildFrame->szStatusText)
  {
    WBFree(pChildFrame->szStatusText);
    pChildFrame->szStatusText = NULL;
  }

  if(pChildFrame->pszMenuResource)
  {
    WBFree(pChildFrame->pszMenuResource);
    pChildFrame->pszMenuResource = NULL;
  }

  // And, NOW, destroy the window itself [if it's valid]
  //
  // NOTE:  to prevent recursion problems, a 'DestroyNotify' would mark the window ID 'None'
  //        before calling this function.  this will happen within my OWN proc, if the superclass doesn't do it

  if(pChildFrame->wID != None) // if there's a chance of recursion, I detect it here
  {
    WBDestroyWindow(pChildFrame->wID);
    pChildFrame->wID = None; // make sure
  }

  // FINALLY, unlink this object from the child frame list.  Do it by walking the list, looking for
  // this entry in the list.  If I find it, I unlink it [otherwise, the 'pNext' link might be *stale*]

  if(pChildFrames) // just in case, walk the list - do not rely on possibly stale pointers
  {
    pC2 = NULL;
    pC = pChildFrames;

    while(pC)
    {
      if(pC == pChildFrame) // just in case
      {
        if(pC2)
        {
          pC2->pNext = pC->pNext; // remove from link list
        }
        else
        {
          pChildFrames = pC->pNext; // it was the head of the chain
        }

        pC->pNext = NULL;

        break;
      }

      pC2 = pC;
      pC = pC->pNext;
    }
  }

  pChildFrame->pNext = NULL; // make sure it's not a pointer someplace that can cause problems

  // if the 'superclass' destructor was specified, call it NOW.

  if(pChildFrame->destructor)
  {
    // at this point, we ALWAYS destroy the callback function.
    // "it is assumed" that I won't be needing 'DestroyNotify' to
    // trigger any destruction.  That happens *AFTER* the window was
    // destroyed, and happens asynchronously, typically before the
    // frame window was destroyed.

    // so, to make sure that I don't get an event callback that references
    // the window object after it's free'd, I need to remove the callback.

    if(wID != None)
    {
      WBUnregisterWindowCallback(wID); // no more event handling
      WBSetWindowData(wID, 0, (void *)NULL); // window data is no longer pointing here
    }

    // and THEN, it's safe to call the destructor on the original object.
    pChildFrame->destructor(pChildFrame); // this should auto-delete as well
  }
  else
  {
    // TODO:  should I perform a 'Destroy Notify' callback of my own?

    // NOTE:  NOT calling 'WBunregisterWindowCallback()' so 'Destroy Notify' does its job.  hopefully.
  }

  // NOTE:  I have to leave the tag alone at this point, to validate that it's
  //        a 'Child Frame' structure.  But everything else needs to be zero'd out
  //        (I used to use 'bzero' but I'm just commenting it here, for reference)
  //        so... make sure everything that's free'd gets ZERO'd as well.  this is
  //        because a 'DestroyNotify' handler that frees up the memory (and destroys
  //        any 'superclass') will probably call this function again, and it might
  //        happen asynchronously.  In fact, it probably WILL happen asynchronously.

  //  bzero(pChildFrame, sizeof(*pChildFrame)); // zero it out (as a matter of course)

  // note that I do *NOT* free the WBChildFrame HERE - this simply releases all resources for it.
  // If there is NO DESTRUCTOR, the 'Destroy Notify' handler needs to do that, or at least SOMETHING.
  // *NOT* handling this properly can result in 'use after free' problems.
}

void FWSetChildFrameMenu(WBChildFrame *pChildFrame, const char *szFocusMenu)
{
  if(!pChildFrame || pChildFrame->ulTag != CHILD_FRAME_TAG)
  {
    WB_ERROR_PRINT("ERROR:  %s - pChildFrame not valid\n", __FUNCTION__);

    return;
  }

  if(pChildFrame->pszMenuResource)
  {
    WBFree(pChildFrame->pszMenuResource);
  }

  if(szFocusMenu)
  {
    pChildFrame->pszMenuResource = WBCopyString(szFocusMenu);
  }
  else
  {
    pChildFrame->pszMenuResource = NULL;
  }

}

void FWSetChildFrameMenuHandlers(WBChildFrame *pChildFrame, const WBFWMenuHandler *pHandlerArray)
{
  if(!pChildFrame || pChildFrame->ulTag != CHILD_FRAME_TAG)
  {
    WB_ERROR_PRINT("ERROR:  %s - pChildFrame not valid\n", __FUNCTION__);

    return;
  }

  if(pChildFrame->pMenuHandler)
  {
    WBFree(pChildFrame->pMenuHandler);
  }

  if(pHandlerArray)
  {
    const WBFWMenuHandler *pH;
    int iN;

    // count the number of entries in the menu handler
    for(iN=0, pH = pHandlerArray; pH->lMenuID || pH->callback || pH->UIcallback; iN++, pH++)
    {
      // NOTHING inside the loop.  just count.
    }

    // allocate space and make a copy

    pChildFrame->pMenuHandler = (WBFWMenuHandler *)WBAlloc(sizeof(WBFWMenuHandler)
                                                           * (iN + 1
                                                              + sizeof(aChildFrameMenuHandler)
                                                                / sizeof(aChildFrameMenuHandler[0])
                                                              )
                                                           );

    if(pChildFrame->pMenuHandler)
    {
      if(iN > 0)
      {
        memcpy(pChildFrame->pMenuHandler, pHandlerArray,
               sizeof(WBFWMenuHandler) * iN);
      }

      // this adds MY menu default handlers to the end of the list
      // so it's possible to override them, if the owner wants to

      memcpy(pChildFrame->pMenuHandler + iN,
             aChildFrameMenuHandler,
             sizeof(aChildFrameMenuHandler)); // this includes the NULL entry at the end
    }
  }
  else
  {
    pChildFrame->pMenuHandler = NULL;
  }
}

void FWSetChildFrameDisplayName(WBChildFrame *pChildFrame, const char *szDisplayName)
{
  if(!pChildFrame || pChildFrame->ulTag != CHILD_FRAME_TAG)
  {
    WB_ERROR_PRINT("ERROR:  %s - pChildFrame not valid\n", __FUNCTION__);

    return;
  }

  if(pChildFrame->szDisplayName)
  {
    WBFree(pChildFrame->szDisplayName);
  }

  if(!szDisplayName)
  {
    return;
  }

  pChildFrame->szDisplayName = WBCopyString(szDisplayName);
}

void FWSetChildFrameImageAtom(WBChildFrame *pChildFrame, Atom aImage)
{
  if(!pChildFrame || pChildFrame->ulTag != CHILD_FRAME_TAG)
  {
    WB_ERROR_PRINT("ERROR:  %s - pChildFrame not valid\n", __FUNCTION__);

    return;
  }

  pChildFrame->aImageAtom = aImage;
}

void FWSetChildFrameExtent(WBChildFrame *pChildFrame, int iXExtent, int iYExtent)
{
  if(!pChildFrame || pChildFrame->ulTag != CHILD_FRAME_TAG)
  {
    WB_ERROR_PRINT("ERROR:  %s - pChildFrame not valid\n", __FUNCTION__);

    return;
  }




  // NOTE:  see (and maybe call) FWChildFrameRecalcLayout, below

  FWChildFrameRecalcLayout(pChildFrame); // for now, do it [later change mind?]
}


void FWSetChildFrameScrollInfo(WBChildFrame *pChildFrame, int iRow, int iMaxRow, int iCol, int iMaxCol,
                               int iRowHeight, int iColWidth)
{
  if(!pChildFrame || pChildFrame->ulTag != CHILD_FRAME_TAG)
  {
    WB_ERROR_PRINT("ERROR:  %s - pChildFrame not valid\n", __FUNCTION__);

    return;
  }

  // NOTE:  this function must *NOT* call FWChildFrameRecalcLayout, nor FWSetChildFrameExtent, in
  //        order to prevent problems with recursion.  Instead, it must 'nuke out' (aka 'derive')
  //        all of those things, independently.

  WB_ERROR_PRINT("TODO:  %s - implement.  %p %u (%08xH)  %d, %d, %d, %d, %d, %d\n", __FUNCTION__,
                 pChildFrame, (int)pChildFrame->wID, (int)pChildFrame->wID,
                 iRow, iMaxRow, iCol, iMaxCol, iRowHeight, iColWidth);

}


void FWChildFrameRecalcLayout(WBChildFrame *pChildFrame)
{
WBFrameWindow *pOwner;
Display *pDisplay;
int iL, iT, iW, iH;


  if(!pChildFrame || pChildFrame->ulTag != CHILD_FRAME_TAG)
  {
    WB_ERROR_PRINT("ERROR:  %s - pChildFrame not valid\n", __FUNCTION__);

    return;
  }


  pDisplay = WBGetWindowDisplay(pChildFrame->wID);
  pOwner = pChildFrame->pOwner;

  if(!pOwner) // irrelevant if NULL.  TODO:  properly validate this (anal retentive if DEBUG build)
  {
    WB_ERROR_PRINT("ERROR:  %s - pOwner is NULL for Child Frame\n", __FUNCTION__);

    return;
  }

  iL = pOwner->iClientX;
  iT = pOwner->iClientY;
  iW = pOwner->iClientWidth;
  iH = pOwner->iClientHeight;

  // resize the window accordingly
  XMoveWindow(pDisplay, pChildFrame->wID, iL, iT);
  XResizeWindow(pDisplay, pChildFrame->wID, iW - 2, iH - 2); // allow 1 pixel for border

  // calculate new client 'geom', backing out 2 additional pixels in all 4 directions

  pChildFrame->geom.x = 2;
  pChildFrame->geom.y = 2;
  pChildFrame->geom.width = iW - 6;
  pChildFrame->geom.height = iH - 6;  // the new width/height of client area


  // TODO:  anything ELSE that I need to do when re-calculating the layout, scrollbars, whatever
  //        just apply that to geom so that it reflects the correct viewpoirt in pixels
  //        minus any border, decorations, scrollbars, whatever, with 0,0 being top,left
  //        for the window [in this case, border is 1 pixel already]



  // TODO:  if I need to show scrollbars, subtract height/width of bar (plus border) from
  //        the geometry width and height, as needed


//  pChildFrame->iLeft = iL converted to correct units and scrolled;
//  pChildFrame->iTop = iT converted to correct units and scrolled;
//  pChildRrame->iWidth = iW converted to correct units;
//  pChildFrame->iHeight = iH converted to correct units;



  // NOW, tell the user callback function (if any) what's happening.
  // I must assume that the owning frame is valid and has already re-calc'd its layout

  if(pChildFrame->pUserCallback)
  {
    Display *pDisplay;
    XClientMessageEvent evt;

    pDisplay = WBGetWindowDisplay(pChildFrame->wID);

    bzero(&evt, sizeof(evt));
    evt.type = ClientMessage;

    evt.display = pDisplay;
    evt.window = pChildFrame->wID;
    evt.message_type = aRESIZE_NOTIFY;
    evt.format = 32;  // always
    evt.data.l[0] = pChildFrame->geom.x;                            // left
    evt.data.l[1] = pChildFrame->geom.y;                            // top
    evt.data.l[2] = pChildFrame->geom.x + pChildFrame->geom.width;  // right
    evt.data.l[3] = pChildFrame->geom.y + pChildFrame->geom.height; // bottom

    // required implementation.  superclass must process this and fix up scroll info
    pChildFrame->pUserCallback(evt.window, (XEvent *)&evt);
  }


  // TODO:  fix the scrollbars and invalidate rectangles

}

void FWChildFrameStatusChanged(WBChildFrame *pChildFrame)
{
  if(!pChildFrame || pChildFrame->ulTag != CHILD_FRAME_TAG)
  {
    WB_ERROR_PRINT("ERROR:  %s - pChildFrame not valid\n", __FUNCTION__);

    return;
  }

  // for now, don't mess with the tabs, just set the text
  // later, I may need to store the tab info.

  FWSetStatusText(pChildFrame->pOwner, pChildFrame->szStatusText);
}


int FWChildFrameQueryClose(WBChildFrame *pChildFrame)
{
Display *pDisplay;
XClientMessageEvent evt;


  if(!pChildFrame || pChildFrame->ulTag != CHILD_FRAME_TAG)
  {
    WB_ERROR_PRINT("ERROR:  %s - pChildFrame not valid\n", __FUNCTION__);

    return -1; // an error
  }

  if(!pChildFrame->pUserCallback)
  {
    return 0; // return 'ok to close' when there's no 'user callback' function to query
  }

  pDisplay = WBGetWindowDisplay(pChildFrame->wID);

  bzero(&evt, sizeof(evt));
  evt.type = ClientMessage;

  evt.display = pDisplay;
  evt.window = pChildFrame->wID;
  evt.message_type = aQUERY_CLOSE;
  evt.format = 32;  // always

  return pChildFrame->pUserCallback(evt.window, (XEvent *)&evt);
}


// DEFAULT WINDOW EVENT HANDLER FOR CHILD FRAME

int FWChildFrameEvent(Window wID, XEvent *pEvent)
{
int iRval = 0;
WBChildFrame *pC;
WBFrameWindow *pFW;
#ifndef NO_DEBUG
char tbuf[32]; // for keyboard input
int nChar = sizeof(tbuf);
#endif // NO_DEBUG


  pC = FWGetChildFrameStruct(wID);

  if(!pC)
  {
#ifndef NO_DEBUG
    WB_ERROR_PRINT("ERROR:  %s - no child frame structure, window data is %p\n", __FUNCTION__, WBGetWindowData(wID, 0));

    WBDebugDumpEvent(pEvent);
#endif // NO_DEBUG

    return 0;
  }

  pFW = pC->pOwner; // make sure I know my owning frame window


  // TODO:  messages I handle myself, before any user callbacks
  //        (and perhaps messages that I don't pass to the callback at all)

  if(pC->pUserCallback)
  {
    iRval = pC->pUserCallback(wID, pEvent);
  }


  // TODO:  menu and menu UI handler?  For now, no.  rely on frame window.

  if(pEvent->type == ClientMessage &&
     (pEvent->xclient.message_type == aMENU_COMMAND ||
      pEvent->xclient.message_type == aMENU_UI_COMMAND))
  {
    // TODO:  special handling?

    return iRval;  // default behavior for these
  }


  // regardless, for a 'DestroyNotify, assign wID to 'None' in the ChildFrame class

  if(!iRval)
  {
    // TODO:  default handling of messages NOT handled by user callback

    switch(pEvent->type)
    {
      case KeyPress:
        {
#ifndef NO_DEBUG
          int iACS = 0;
          int iKey = WBKeyEventProcessKey((XKeyEvent *)pEvent, tbuf, &nChar, &iACS);

          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame | DebugSubSystem_Keyboard,
                         "%s KEY PRESS for KEY %d KEYCODE %d MASK=%d (%xH)\n",
                           __FUNCTION__, iKey, ((XKeyEvent *)pEvent)->keycode,
                           ((XKeyEvent *)pEvent)->state, ((XKeyEvent *)pEvent)->state);
#endif // NO_DEBUG

          // check for menu and hotkey activation.
//          if(nChar > 0) // only for "real" characters (i.e. not just the ALT key)
          if(pFW)
          {
            WBMenuBarWindow *pMenuBar = MBGetMenuBarWindowStruct(WBGetMenuWindow(pFW->wID));

            if(pMenuBar)  // menu bar exists?
            {
              WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Menu | DebugSubSystem_Frame | DebugSubSystem_Keyboard,
                             "%s call to MBMenuProcessHotKey for menu window %d (%08xH)\n",
                             __FUNCTION__, (int)pMenuBar->wSelf, (int)pMenuBar->wSelf);

              iRval = MBMenuProcessHotKey(pMenuBar->pMenu, (XKeyEvent *)pEvent);
            }
          }
        }
        break;

      case KeyRelease:
        {
          // KeyRelease
#ifndef NO_DEBUG
          int iACS = 0, iKey = WBKeyEventProcessKey((XKeyEvent *)pEvent, tbuf, &nChar, &iACS);

          if(nChar > 0)
          {
            WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame | DebugSubSystem_Keyboard,
                           "%s KEY RELEASE for KEY %d KEYCODE %d  MASK=%d (%xH)\n",
                           __FUNCTION__, iKey, ((XKeyEvent *)pEvent)->keycode,
                           ((XKeyEvent *)pEvent)->state, ((XKeyEvent *)pEvent)->state);

          }
#endif // NO_DEBUG

        }

        break;

      case ClientMessage:
        if(pEvent->xclient.message_type == aWM_CHAR) // generated by WBDefault
        {
          if(pC->pUI)
          {
            iRval = ChildFrameDoCharEvent(&pEvent->xclient, WBGetWindowDisplay(wID), wID, pC, pC->pUI);
          }
//          else
//          {
//            WB_ERROR_PRINT("TEMPORARY:  %s - WM_CHAR, no UI\n", __FUNCTION__);
//            WBDebugDumpEvent((XEvent *)pEvent);
//          }
        }
        else if(pEvent->xclient.message_type == aWM_POINTER) // generated by WBDefault
        {
          if(pC->pUI)
          {
            iRval = ChildFrameDoPointerEvent(&pEvent->xclient, WBGetWindowDisplay(wID), wID, pC, pC->pUI);
          }
//          else
//          {
//            WB_ERROR_PRINT("TEMPORARY:  %s - WM_POINTER, no UI\n", __FUNCTION__);
//            WBDebugDumpEvent((XEvent *)pEvent);
//          }
        }

        break;
    }
  }


  if(pEvent->type == DestroyNotify &&
     pEvent->xdestroywindow.window == wID)
  {
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_Frame,
                   "%s - DestroyNotify\n", __FUNCTION__);

    if(!iRval)
    {
      WB_ERROR_PRINT("TEMPORARY:  %s - DestroyNotify *NOT* handled by superclass\n", __FUNCTION__);
    }

    pC = FWGetChildFrameStruct(wID); // re-get the structure (it may have been deleted, probably SHOULD have been)

    if(pC && pC->wID != None) // haven't called FWDestroyChildFrame yet?
    {
      // mark window ID 'None', then call FWDestroyChildFrame from here
      // by design it's safe to do that...

      pC->wID = None; // since window already 'destroyed' - I'm getting the notification after all

      // set the window callback to NULL - this disconnects me from the message processor also
      // as well as freeing up everything

      FWDestroyChildFrame(pC); // make sure it's destroyed, unlinked, etc. (pointer may not be valid now)

      WB_ERROR_PRINT("TEMPORARY:  %s - DestroyNotify handled by Child Window base class\n", __FUNCTION__);
    }

    WBUnregisterWindowCallback(wID); // prevents any more messages from being dispatched to this function

    WB_DEBUG_PRINT(DebugLevel_ERROR/*DebugLevel_Verbose | DebugSubSystem_Event | DebugSubSystem_Frame*/,
                   "%s - child frame window destroyed\n", __FUNCTION__);
    return 1;
  }


  return iRval;
}



static int ChildFrameDoPointerEvent(XClientMessageEvent *pEvent, Display *pDisplay,
                                    Window wID, WBChildFrame *pC, WBChildFrameUI *pUI)
{
int iACS;
int iX, iY;
int iButtonMask;


  if(wID == None || !pC || !pUI ||
     pEvent->type != ClientMessage ||
     pEvent->message_type != aWM_POINTER)
  {
    return 0; // sanity check (temporary?)
  }

#ifndef NO_DEBUG
  WB_ERROR_PRINT("TEMPORARY:  %s - WM_POINTER\n", __FUNCTION__);
  WBDebugDumpEvent((XEvent *)pEvent);
#endif // NO_DEBUG


  // left-click - position cursor, cancel selection
  // shift-left-click - select from cursor to THIS point
  // (other modifiers, ignore the modifier key)
  // right-click - drop-down edit menu
  // middle click - select word? paste?
  // scroll wheel up/down - should be handled by scrollbar thingy
  // left-drag - select from starting position
  // right-drag - drag/drop?
  // middle-drag - ?

  iButtonMask = pEvent->data.l[1];  // WB_POINTER_BUTTON1 through WB_POINTER_BUTTON5 (bitmask)

  iACS = pEvent->data.l[2];

  iX = pEvent->data.l[3];
  iY = pEvent->data.l[4];

  switch(pEvent->data.l[0])
  {
    case WB_POINTER_CLICK:
      if(pUI->mouse_click)
      {
        pUI->mouse_click(pC, iX, iY, iButtonMask, iACS);
        return 1; // handled
      }

      break;

    case WB_POINTER_DBLCLICK:
      if(pUI->mouse_dblclick)
      {
        pUI->mouse_dblclick(pC, iX, iY, iButtonMask, iACS);
        return 1; // handled
      }

      break;

    case WB_POINTER_DRAG:
      if(pUI->mouse_drag)
      {
        pUI->mouse_drag(pC, iX, iY, iButtonMask, iACS);

        return wID; // do this to support pointer drag (it sets up a few things correctly)
        // NOTE:  if the function isn't NULL it's expected to perform the correct operation
        //        and if there's an error, it can post a 'DRAG CANCEL' request
      }

      break;

    case WB_POINTER_DROP:
      if(pUI->mouse_drop)
      {
        pUI->mouse_drop(pC, iX, iY, iButtonMask, iACS);
        return 1; // handled
      }

      break;

    case WB_POINTER_MOVE:
      if(pUI->mouse_move)
      {
        pUI->mouse_move(pC, iX, iY); // assumes button/flags haven't changed since last time (useful only for drags)
        return 1; // handled
      }

      break;

    case WB_POINTER_CANCEL:
      if(pUI->mouse_cancel)
      {
        pUI->mouse_cancel(pC);
        return 1; // handled
      }

      break;

    case WB_POINTER_SCROLLUP:
      if(pUI->mouse_scrollup)
      {
        pUI->mouse_scrollup(pC, iX, iY, iButtonMask, iACS);
        return 1; // handled
      }

      break;

    case WB_POINTER_SCROLLDOWN:
      if(pUI->mouse_scrollup)
      {
        pUI->mouse_scrolldown(pC, iX, iY, iButtonMask, iACS);
        return 1; // handled
      }

      break;


    default:

      WB_ERROR_PRINT("TEMPORARY - %s - unhandled mousie message\n", __FUNCTION__);
      WBDebugDumpEvent((XEvent *)pEvent);

      break;
  }

  return 0; // must indicate 'did not handle' if I get here
}

static int ChildFrameDoCharEvent(XClientMessageEvent *pEvent, Display *pDisplay,
                                 Window wID, WBChildFrame *pC, WBChildFrameUI *pUI)
{
int iKey, iACS, nChar;
char *pBuf;
int iRval = 0;


  if(wID == None || !pC || !pUI ||
     pEvent->type != ClientMessage ||
     pEvent->message_type != aWM_CHAR)
  {
    return 0; // sanity check (temporary?)
  }

//#ifndef NO_DEBUG
//  WB_ERROR_PRINT("TEMPORARY:  %s - WM_CHAR\n", __FUNCTION__);
//  WBDebugDumpEvent((XEvent *)pEvent);
//#endif // NO_DEBUG

  iKey = pEvent->data.l[0];  // result from WBKeyEventProcessKey()
  iACS = pEvent->data.l[1];
  nChar = pEvent->data.l[2];
  pBuf = (char *)&(pEvent->data.l[3]);


  if(nChar > 0) // normal ASCII characters
  {
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                   "%s KEY RELEASE for KEY %d KEYCODE %d  MASK=%d (%xH)\n",
                   __FUNCTION__, iKey, ((XKeyEvent *)pEvent)->keycode,
                   ((XKeyEvent *)pEvent)->state, ((XKeyEvent *)pEvent)->state);

    if(iKey == 8) // backspace
    {
      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                     "%s - BACKSPACE key pressed, iACS=%d (%xH)\n", __FUNCTION__, iACS, iACS);

      if(pUI->bkspace)
      {
        pUI->bkspace(pC, iACS);
      }
      else
      {
        XBell(pDisplay, -100);
      }

      iRval = 1;
    }
    else if(iKey == 13)               // CR
    {
      if(pUI->enter)
      {
        pUI->enter(pC, iACS);
      }
      else if(pUI->do_char)
      {
        pUI->do_char(pC, pEvent);
      }
      else
      {
        XBell(pDisplay, -100);
      }

      iRval = 1;
    }
    else if(iKey == 10)               // LF
    {
      if(pUI->do_char)
      {
        pUI->do_char(pC, pEvent);
      }
      else if(pUI->enter) // just in case, allow 'LF' to be 'ENTER' if no char handler
      {
        pUI->enter(pC, iACS);
      }
      else
      {
        XBell(pDisplay, -100);
      }

      iRval = 1;
    }
    else if(iKey == 9)                // tab
    {
      if(pUI->tab)
      {
        pUI->tab(pC, iACS);
      }
      else if(pUI->do_char)
      {
        pUI->do_char(pC, pEvent); // treat tab like normal char
      }
      else
      {
        XBell(pDisplay, -100);
      }

      iRval = 1;
    }
    else if(iKey == 1)  // CTRL+A
    {
      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                     "%s - CTRL+A key pressed, iACS=%d (%xH)\n", __FUNCTION__, iACS, iACS);

      if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL)       // control key will always be pressed, but no shift
      {
        if(pUI->select_all)
        {
          pUI->select_all(pC);
        }
        else
        {
          XBell(pDisplay, -100);
        }

        iRval = 1;
      }
      else
      {
        if(pUI->do_char)
        {
          pUI->do_char(pC, pEvent); // normal 'A' character

          iRval = 1;
        }
      }
    }
    else if(iKey == 3)  // CTRL+C
    {
      if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL)       // control key will always be pressed, but no shift
      {
        if(pUI->has_selection && pUI->copy_to_cb && pUI->has_selection(pC))
        {
          WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                         "%s - CTRL+C key pressed, iACS=%d (%xH)\n", __FUNCTION__, iACS, iACS);

          pUI->copy_to_cb(pC);
        }
        else
        {
          XBell(pDisplay, -100);
          WB_ERROR_PRINT("TEMPORARY - %s - no selection, can't 'COPY'\n", __FUNCTION__);
        }

        iRval = 1;
      }
      else
      {
        if(pUI->do_char)
        {
          pUI->do_char(pC, pEvent); // normal 'C' character

          iRval = 1;
        }
      }
    }
    else if(iKey == 22) // CTRL+V
    {
      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                     "%s - CTRL+V key pressed, iACS=%d (%xH)\n", __FUNCTION__, iACS, iACS);

      if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL)       // control key will always be pressed, but no shift
      {
        // TODO:  check for valid clipboard selection - see if there's a clipboard owner maybe?

        if(pUI->paste_from_cb)
        {
          pUI->paste_from_cb(pC);
        }

        iRval = 1;
      }
      else
      {
        if(pUI->do_char)
        {
          pUI->do_char(pC, pEvent); // normal 'V' character

          iRval = 1;
        }
      }
    }
    else if(iKey == 24) // CTRL+X
    {
      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                     "%s - CTRL+X key pressed, iACS=%d (%xH)\n", __FUNCTION__, iACS, iACS);

      if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL)       // control key will always be pressed, but no shift
      {
        if(pUI->has_selection && pUI->cut_to_cb && pUI->has_selection(pC))
        {
          pUI->cut_to_cb(pC);
        }
        else
        {
          XBell(pDisplay, -100);
        }

        iRval = 1;
      }
      else
      {
        if(pUI->do_char)
        {
          pUI->do_char(pC, pEvent); // normal 'X' character

          iRval = 1;
        }
      }
    }
    else if(iKey == 26) // ctrl+Z
    {
      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                     "%s - CTRL+Z key pressed, iACS=%d (%xH)\n", __FUNCTION__, iACS, iACS);

      if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL)       // control key will always be pressed, but no shift
      {
        if(pUI->can_undo && pUI->undo && pUI->can_undo(pC))
        {
          pUI->undo(pC);
        }
        else
        {
          XBell(pDisplay, -100);
        }

        iRval = 1;
      }
      else if((iACS & WB_KEYEVENT_ACSMASK) == (WB_KEYEVENT_CTRL | WB_KEYEVENT_SHIFT)) // ctrl+shift, no alt
      {
        if(pUI->can_redo && pUI->redo && pUI->can_redo(pC))
        {
          pUI->redo(pC);
        }
        else
        {
          XBell(pDisplay, -100);
        }

        iRval = 1;
      }
      else
      {
        if(pUI->do_char)
        {
          pUI->do_char(pC, pEvent); // normal 'Z' character

          iRval = 1; // "handled"
        }

        // ONLY assign 'iRval' if the character was processed
      }

      // NOT assigning 'iRval' for all conditions here...
    }
    else if(iKey == '\x1b') // ESC
    {
      WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                     "%s - ESC key pressed, iACS=%d (%xH)\n", __FUNCTION__, iACS, iACS);

      // cancel mousie things and 'select none'

      if(pUI->mouse_cancel)
      {
        pUI->mouse_cancel(pC);
      }

      if(pUI->select_none)
      {
        pUI->select_none(pC);
      }

      if(!pUI->select_none && !pUI->mouse_cancel)
      {
        XBell(pDisplay, -100);
      }

      iRval = 1;
    }
    else
    {
      if(pUI->do_char)
      {
        pUI->do_char(pC, pEvent);

        iRval = 1; // "handled"
      }

      // NOTE:  don't call 'XBell' if I don't return "handled", and no 'do_char' means "not handled"
    }
  }
  else // SPECIAL characters.
  {
    if(iACS & WB_KEYEVENT_KEYSYM)
    {
      // TODO:  international, 'dead' and other KEYSYM key assignments
#define KEYSYM_MATCH_CURSOR_NAME(X) (iKey == XK_##X || iKey == XK_KP_##X)

      if(KEYSYM_MATCH_CURSOR_NAME(Home))
      {
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Home key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if(pUI->home)
        {
          pUI->home(pC, iACS);
        }

        iRval = 1;
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(End))
      {
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - End key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if(pUI->end)
        {
          pUI->end(pC, iACS);
        }

        iRval = 1;
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Left))
      {
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Left key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if(pUI->leftarrow)
        {
          pUI->leftarrow(pC, iACS);
        }

        iRval = 1;
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Right))
      {
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Right key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if(pUI->rightarrow)
        {
          pUI->rightarrow(pC, iACS);
        }

        iRval = 1;
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Up))
      {
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Up key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if(pUI->uparrow)
        {
          pUI->uparrow(pC, iACS);
        }

        iRval = 1;
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Down))
      {
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Down key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if(pUI->downarrow)
        {
          pUI->downarrow(pC, iACS);
        }
        else
        {
          XBell(pDisplay, -100);
        }

        iRval = 1;
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Page_Up))
      {
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Page Up key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if(iACS & WB_KEYEVENT_CTRL) // page left
        {
          if(pUI->pgleft)
          {
            pUI->pgleft(pC, iACS /* & ~WB_KEYEVENT_CTRL */); // TODO:  turn off 'ctrl' bit?
          }
          else
          {
            XBell(pDisplay, -100);
          }

          iRval = 1;
        }
        else
        {
          if(pUI->pgup)
          {
            pUI->pgup(pC, iACS);
          }
          else
          {
            XBell(pDisplay, -100);
          }

          iRval = 1;
        }
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Page_Down))
      {
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Page Down key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if(iACS & WB_KEYEVENT_CTRL) // page right
        {
          if(pUI->pgright)
          {
            pUI->pgright(pC, iACS /* & ~WB_KEYEVENT_CTRL */); // TODO:  turn off 'ctrl' bit?
          }
          else
          {
            XBell(pDisplay, -100);
          }

          iRval = 1;
        }
        else
        {
          if(pUI->pgdown)
          {
            pUI->pgdown(pC, iACS);
          }
          else
          {
            XBell(pDisplay, -100);
          }

          iRval = 1;
        }
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Begin)) // beginning of current line
      {
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Beginning Of Line key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        // treat this as 'home' key

        if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift
        {
          if(pUI->home)
          {
            pUI->home(pC, WB_KEYEVENT_SHIFT);
          }
          else
          {
            XBell(pDisplay, -100);
          }

          iRval = 1;
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == 0) // normal
        {
          if(pUI->home)
          {
            pUI->home(pC, iACS);
          }
          else
          {
            XBell(pDisplay, -100);
          }

          iRval = 1;
        }
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Insert)) // toggle 'insert' mode, copy, or paste
      {
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Insert key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if((iACS & WB_KEYEVENT_ACSMASK) == 0) // normal
        {
          if(pUI->toggle_ins_mode)
          {
            pUI->toggle_ins_mode(pC);

            // TODO:  update status bar text
          }
          else
          {
            XBell(pDisplay, -100);
          }

          iRval = 1;
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // SHIFT+insert (paste)
        {
          if(pUI->paste_from_cb)
          {
            pUI->paste_from_cb(pC);
          }
          else
          {
            XBell(pDisplay, -100);
          }

          iRval = 1;
        }
        else if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL) // CTRL+insert (copy)
        {
          if(pUI->has_selection && pUI->copy_to_cb && pUI->has_selection(pC))
          {
            pUI->copy_to_cb(pC);
          }
          else
          {
            XBell(pDisplay, -100);
          }

          iRval = 1;
        }
      }
      else if(KEYSYM_MATCH_CURSOR_NAME(Delete)) // delete key (keypad may use this)
      {
        WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                       "%s - Delete key pressed iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

        if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift+del (cut)
        {
          if(pUI->has_selection && pUI->cut_to_cb && pUI->has_selection(pC))
          {
            pUI->cut_to_cb(pC);
          }
          else
          {
            XBell(pDisplay, -100);
          }

          iRval = 1;
        }
        else if(iACS & WB_KEYEVENT_CTRL) // ctrl+del (??)  alt+del (??) any other combo?
        {
          WB_ERROR_PRINT("TEMPORARY:  %s - Delete key pressed with iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

          if(pUI->del)
          {
            pUI->del(pC, iACS);
          }
          else
          {
            XBell(pDisplay, -100);
          }

          iRval = 1; // for now handle it THIS way
        }
        else // if((iACS & WB_KEYEVENT_ACSMASK) == 0) // normal or "other flags"
        {
          if(pUI->del)
          {
            pUI->del(pC, iACS);
          }
          else
          {
            XBell(pDisplay, -100);
          }

          iRval = 1;
        }
      }
#undef KEYSYM_MATCH_CURSOR_NAME
      else
      {
        if(pUI->scancode)
        {
          pUI->scancode(pC, pEvent);

          iRval = 1; // handled
        }
        else
        {
          // is it an unknown cursor key?  let's find out (dump it)
          WB_DEBUG_PRINT(DebugLevel_WARN | DebugSubSystem_Event | DebugSubSystem_DialogCtrl | DebugSubSystem_Keyboard,
                         "%s - CURSOR KEY? %d (%08xH)  %d (%08xH)\n",
                         __FUNCTION__, iKey, iKey, iACS, iACS);

          // 'iRval' left at 0 for "not handled"
        }
      }
    }
  }

  return 0; // "not handled"
}



static int ChildFrameEditCutHandler(XClientMessageEvent *pEvent)
{
WBChildFrame *pChildFrame;

  if(!pEvent || pEvent->window == None)
  {
    return -1; // an error
  }

  pChildFrame = FWGetChildFrameStruct(pEvent->window);

  if(!pChildFrame)
  {
    return -1; // an error
  }

  if(pChildFrame->pUI && pChildFrame->pUI->has_selection && pChildFrame->pUI->cut_to_cb)
  {
    if(pChildFrame->pUI->has_selection(pChildFrame))
    {
      pChildFrame->pUI->cut_to_cb(pChildFrame);

      return 1; // HANDLED
    }
  }

  return 0; // NOT handled (but not an error)
}

static int ChildFrameEditCopyHandler(XClientMessageEvent *pEvent)
{
WBChildFrame *pChildFrame;

  if(!pEvent || pEvent->window == None)
  {
    return -1; // an error
  }

  pChildFrame = FWGetChildFrameStruct(pEvent->window);

  if(!pChildFrame)
  {
    return -1; // an error
  }

  if(pChildFrame->pUI && pChildFrame->pUI->has_selection && pChildFrame->pUI->copy_to_cb)
  {
    if(pChildFrame->pUI->has_selection(pChildFrame))
    {
      pChildFrame->pUI->copy_to_cb(pChildFrame);

      return 1; // HANDLED
    }
  }

  return 0; // NOT handled (but not an error)
}

static int ChildFrameEditPasteHandler(XClientMessageEvent *pEvent)
{
WBChildFrame *pChildFrame;

  if(!pEvent || pEvent->window == None)
  {
    return -1; // an error
  }

  pChildFrame = FWGetChildFrameStruct(pEvent->window);

  if(!pChildFrame)
  {
    return -1; // an error
  }

  if(pChildFrame->pUI && pChildFrame->pUI->paste_from_cb)
  {
    // TODO:  check for valid clipboard contents first??  or assume 'NULL' is ok?

    pChildFrame->pUI->paste_from_cb(pChildFrame);

    return 1; // HANDLED
  }

  return 0; // NOT handled (but not an error)
}

static int ChildFrameEditDeleteHandler(XClientMessageEvent *pEvent)
{
WBChildFrame *pChildFrame;

  if(!pEvent || pEvent->window == None)
  {
    return -1; // an error
  }

  pChildFrame = FWGetChildFrameStruct(pEvent->window);

  if(!pChildFrame)
  {
    return -1; // an error
  }

  if(pChildFrame->pUI && pChildFrame->pUI->has_selection && pChildFrame->pUI->delete_sel)
  {
    if(pChildFrame->pUI->has_selection(pChildFrame))
    {
      pChildFrame->pUI->delete_sel(pChildFrame);

      return 1; // HANDLED
    }
  }

  return 0; // NOT handled (but not an error)
}

static int ChildFrameEditSelectAllHandler(XClientMessageEvent *pEvent)
{
WBChildFrame *pChildFrame;

  if(!pEvent || pEvent->window == None)
  {
    return -1; // an error
  }

  pChildFrame = FWGetChildFrameStruct(pEvent->window);
  if(!pChildFrame)
  {
    return -1; // an error
  }

  if(pChildFrame->pUI && pChildFrame->pUI->select_all)
  {
    pChildFrame->pUI->select_all(pChildFrame);

    return 1; // HANDLED
  }

  return 0; // NOT handled (but not an error)
}

static int ChildFrameEditSelectNoneHandler(XClientMessageEvent *pEvent)
{
WBChildFrame *pChildFrame;

  if(!pEvent || pEvent->window == None)
  {
    return -1; // an error
  }

  pChildFrame = FWGetChildFrameStruct(pEvent->window);
  if(!pChildFrame)
  {
    return -1; // an error
  }

  if(pChildFrame->pUI && pChildFrame->pUI->select_none)
  {
    pChildFrame->pUI->select_none(pChildFrame);

    return 1; // HANDLED
  }

  return 0; // NOT handled (but not an error)
}

static int ChildFrameEditCutUIHandler(WBMenu *pMenu, WBMenuItem *pMenuItem)
{
Window wID;
WBChildFrame *pChildFrame;
WBFrameWindow *pFrame;
WBMenuPopupWindow *pPopup;


  // pMenu essentially belongs to the frame window.  determine which tab has focus, and whether
  // or not there's anything selected.  if there is something selected, enable the menu.
  //
  // NOTE:  this is called by the popup menu window itself, and so the pointer will not
  //        be asynchronously destroyed when I call MBFindMenuPopupWindow(), nor will
  //        the owning frame window be destroyed, either (unless someone seriously
  //        violated the way these things are supposed to work).

  pPopup = MBFindMenuPopupWindow(pMenu);

  if(pPopup)
  {
    wID = pPopup->wOwner;

    if(wID != None)
    {
      pFrame = FWGetFrameWindowStruct(wID);

      if(pFrame)
      {
        pChildFrame = FWGetContainedWindowByIndex(pFrame, -1); // current focus window

        if(pChildFrame && pChildFrame->pUI && pChildFrame->pUI->has_selection)
        {
          if(pChildFrame->pUI->has_selection(pChildFrame))
          {
            return 1; // select this
          }
        }
      }
    }
  }

  return -1; // disable this menu
}

static int ChildFrameEditCopyUIHandler(WBMenu *pMenu, WBMenuItem *pMenuItem)
{
Window wID;
WBChildFrame *pChildFrame;
WBFrameWindow *pFrame;
WBMenuPopupWindow *pPopup;


  // pMenu essentially belongs to the frame window.  determine which tab has focus, and whether
  // or not there's anything selected.  if there is something selected, enable the menu.
  //
  // NOTE:  this is called by the popup menu window itself, and so the pointer will not
  //        be asynchronously destroyed when I call MBFindMenuPopupWindow(), nor will
  //        the owning frame window be destroyed, either (unless someone seriously
  //        violated the way these things are supposed to work).

  pPopup = MBFindMenuPopupWindow(pMenu);

  if(pPopup)
  {
    wID = pPopup->wOwner;

    if(wID != None)
    {
      pFrame = FWGetFrameWindowStruct(wID);

      if(pFrame)
      {
        pChildFrame = FWGetContainedWindowByIndex(pFrame, -1); // current focus window

        if(pChildFrame && pChildFrame->pUI && pChildFrame->pUI->has_selection)
        {
          if(pChildFrame->pUI->has_selection(pChildFrame))
          {
            return 1; // select this
          }
        }
      }
    }
  }

  return -1; // disable this menu
}

static int ChildFrameEditPasteUIHandler(WBMenu *pMenu, WBMenuItem *pMenuItem)
{
Window wID;
WBChildFrame *pChildFrame;
WBFrameWindow *pFrame;
WBMenuPopupWindow *pPopup;
Display *pDisplay;

  // pMenu essentially belongs to the frame window.  determine which tab has focus
  // THEN, determine if there's a clipboard owner, and enable if so.  Disable if there
  // are no child frames with the focus or clipboard owners
  //
  // NOTE:  this is called by the popup menu window itself, and so the pointer will not
  //        be asynchronously destroyed when I call MBFindMenuPopupWindow(), nor will
  //        the owning frame window be destroyed, either (unless someone seriously
  //        violated the way these things are supposed to work).

  pPopup = MBFindMenuPopupWindow(pMenu);

  if(pPopup)
  {
    wID = pPopup->wOwner;

    if(wID != None)
    {
      pDisplay = WBGetWindowDisplay(wID);
      pFrame = FWGetFrameWindowStruct(wID);

      if(pFrame)
      {
        pChildFrame = FWGetContainedWindowByIndex(pFrame, -1); // current focus window

        if(pChildFrame && pChildFrame->pUI)
        {
          if(XGetSelectionOwner(pDisplay, aCLIPBOARD) != None ||
             XGetSelectionOwner(pDisplay, aPRIMARY) != None)
          {
            return 1; // there's a clipboard selection out there, waiting to be pasted
          }
        }
      }
    }
  }

  return -1; // disable this menu

}

static int ChildFrameEditDeleteUIHandler(WBMenu *pMenu, WBMenuItem *pMenuItem)
{
Window wID;
WBChildFrame *pChildFrame;
WBFrameWindow *pFrame;
WBMenuPopupWindow *pPopup;


  // pMenu essentially belongs to the frame window.  determine which tab has focus, and whether
  // or not there's anything selected.  if there is something selected, enable the menu.
  //
  // NOTE:  this is called by the popup menu window itself, and so the pointer will not
  //        be asynchronously destroyed when I call MBFindMenuPopupWindow(), nor will
  //        the owning frame window be destroyed, either (unless someone seriously
  //        violated the way these things are supposed to work).

  pPopup = MBFindMenuPopupWindow(pMenu);

  if(pPopup)
  {
    wID = pPopup->wOwner;

    if(wID != None)
    {
      pFrame = FWGetFrameWindowStruct(wID);

      if(pFrame)
      {
        pChildFrame = FWGetContainedWindowByIndex(pFrame, -1); // current focus window

        if(pChildFrame && pChildFrame->pUI && pChildFrame->pUI->has_selection)
        {
          if(pChildFrame->pUI->has_selection(pChildFrame))
          {
            return 1; // select this
          }
        }
      }
    }
  }

  return -1; // disable this menu
}

static int ChildFrameEditSelectAllUIHandler(WBMenu *pMenu, WBMenuItem *pMenuItem)
{
Window wID;
WBChildFrame *pChildFrame;
WBFrameWindow *pFrame;
WBMenuPopupWindow *pPopup;


  // pMenu essentially belongs to the frame window.  determine which tab has focus, and whether
  // or not there's anything there.  if there is something that CAN be selected, enable the menu.
  //
  // NOTE:  this is called by the popup menu window itself, and so the pointer will not
  //        be asynchronously destroyed when I call MBFindMenuPopupWindow(), nor will
  //        the owning frame window be destroyed, either (unless someone seriously
  //        violated the way these things are supposed to work).

  pPopup = MBFindMenuPopupWindow(pMenu);

  if(pPopup)
  {
    wID = pPopup->wOwner;

    if(wID != None)
    {
      pFrame = FWGetFrameWindowStruct(wID);

      if(pFrame)
      {
        pChildFrame = FWGetContainedWindowByIndex(pFrame, -1); // current focus window

        if(pChildFrame && pChildFrame->pUI)
        {
          if((pChildFrame->pUI->has_selection && pChildFrame->pUI->has_selection(pChildFrame)) ||
             (pChildFrame->pUI->is_empty && !pChildFrame->pUI->is_empty(pChildFrame)))
          {
            return 1; // select this
          }
        }
      }
    }
  }

  return -1; // disable this menu
}

static int ChildFrameEditSelectNoneUIHandler(WBMenu *pMenu, WBMenuItem *pMenuItem)
{
Window wID;
WBChildFrame *pChildFrame;
WBFrameWindow *pFrame;
WBMenuPopupWindow *pPopup;


  // pMenu essentially belongs to the frame window.  determine which tab has focus, and whether
  // or not there's anything selected.  if there is something selected, enable the menu.
  //
  // NOTE:  this is called by the popup menu window itself, and so the pointer will not
  //        be asynchronously destroyed when I call MBFindMenuPopupWindow(), nor will
  //        the owning frame window be destroyed, either (unless someone seriously
  //        violated the way these things are supposed to work).

  pPopup = MBFindMenuPopupWindow(pMenu);

  if(pPopup)
  {
    wID = pPopup->wOwner;

    if(wID != None)
    {
      pFrame = FWGetFrameWindowStruct(wID);

      if(pFrame)
      {
        pChildFrame = FWGetContainedWindowByIndex(pFrame, -1); // current focus window

        if(pChildFrame && pChildFrame->pUI && pChildFrame->pUI->has_selection)
        {
          if(pChildFrame->pUI->has_selection(pChildFrame))
          {
            return 1; // select this
          }
        }
      }
    }
  }

  return -1; // disable this menu
}

