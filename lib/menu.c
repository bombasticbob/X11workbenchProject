//////////////////////////////////////////////////////////////////////////////////////////
//                       _ __ ___    ___  _ __   _   _     ___                          //
//                      | '_ ` _ \  / _ \| '_ \ | | | |   / __|                         //
//                      | | | | | ||  __/| | | || |_| | _| (__                          //
//                      |_| |_| |_| \___||_| |_| \__,_|(_)\___|                         //
//                                                                                      //
//                                                                                      //
//                        generic menu resource implementation                          //
//                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2016 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.
               Any claims to alleged functionality or features should be
               considered 'preliminary', and might not function as advertised.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

/** \file menu.c
  * \brief Implementation file for menus
  *
  * This is the implementation file for menus, their interpretation, construction,
  * manipulation, and destruction
*/



#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <signal.h>
#include <time.h>
#include <ctype.h>
#include <X11/cursorfont.h>

#ifndef XK_Delete /* moslty for interix */
#define XK_MISCELLANY /* mostly for interix */
#include <X11/keysymdef.h> // some platforms don't automatically include this with X headers
#endif // XK_Delete

#include "window_helper.h"
#include "pixmap_helper.h"  // pixmap helpers, including pre-defined icons
#include "frame_window.h"
#include "menu.h"
#include "conf_help.h"


// sample menu resource format
//
// 1\n
// _File\tpopup\t2\n
// \tseparator\n
// _Help\t100\tHelp\tF1\n
//
// 2\tpopup\n
// _Open\t102\tOpen File\tCtrl+O\n
// _Save\t103\tSave File\tCtrl+S\n
// \tseparator\n
// E_xit\t104\Close Application\tAlt+F4\n
//
// this describes 2 separate menu resource strings.  The first has ID 1, the 2nd has ID 2.
// The ID values are relative only to the menu itself.

// generic description of format:
// <menu ID>[<tab>popup]<newline>
// <menu text><tab>[separator|popup<tab><submenu ID>|<notify ID>[<ToolTip>[<Hotkey>]]<newline>
// <menu text><tab>[separator|popup<tab><submenu ID>|<notify ID>[<ToolTip>[<Hotkey>]]<newline>
// (etc.)
//

static int InternalPopulateMenuFromResource(WBMenu *pMenu, int iID, const char *pszResource);
  // parsing a menu resource

WBMenu *MBCreateMenu(int iID, int iPopup, const char *pszResource, int iReserveSpace)
{
  WBMenu *pRval;
  unsigned char *pEnd;
  const char *p1, *p2;

  pRval = (WBMenu *)WBAlloc(sizeof(WBMenu) + iReserveSpace);  // for now just do this

  if(!pRval)
  {
    return NULL;
  }

  bzero(pRval, sizeof(WBMenu) + iReserveSpace);  // make sure
  pRval->uiTag = WBMENU_TAG;

  pEnd = (unsigned char *)(pRval + 1);

  pRval->ppItems = (WBMenuItem **)pEnd;
  pRval->nMaxItems = iReserveSpace / (2 * sizeof(WBMenuItem **));

  pEnd += iReserveSpace / 2;

  pRval->ppPopups = (WBMenu **)pEnd;
  pRval->nMaxPopups = iReserveSpace / (2 * sizeof(WBMenu **));

  if(!pszResource) // no resource?
    return pRval;  // for now, do this (later do I cough?)

  // now that the memory block has been correcty prepared, parse out the entries

  if(iID == -1)  // which means I'm parsing the entire resource
  {
    char tbuf[16];

    // the menu resource should start with an id as the only entry on a line.
    // look for the first ID, then create menu entries for it

    p1 = pszResource;
    while(*p1 && *p1 <= ' ')
      p1++;

    p2 = p1;
    while(*p1 && *p1 > ' ')
      p1++;

    bzero(tbuf, sizeof(tbuf));
    if(p2 < p1)
      memcpy(tbuf, p2, sizeof(tbuf) - 1 < (p1 - p2) ? sizeof(tbuf) - 1 : p1 - p2);

    while(*p1 && *p1 != '\n')
    {
      if(*p1 > ' ') // a syntax error
      {
        MBDestroyMenu(pRval);
        return NULL;
      }
      p1++;
    }

    if(!*tbuf || *p1 != '\n' ||   // required to end in \n and be a valid #
       (iID = atoi(tbuf)) <= 0)
    {
      MBDestroyMenu(pRval);
      return NULL;
    }

    iPopup = 0;  //for now force it
  }

  pRval->iMenuID = iID; // store menu's ID at this time
  if(iPopup)
    pRval->iMenuID |= WBMENU_POPUP_HIGH_BIT;  // mark as popup

  if(!InternalPopulateMenuFromResource(pRval,iID,pszResource))
  {
    MBDestroyMenu(pRval);
    return NULL;
  }

  return pRval;
}

void MBDestroyMenu(WBMenu *pMenu)
{
int i1;

  if(!MBIsMenuValid(pMenu))
  {
    WB_ERROR_PRINT("ERROR:  %s - invalid menu pointer %p\n", __FUNCTION__, pMenu);
    return;
  }

  if(pMenu->ppItems) // part of 'pMenu' memory block
  {
    for(i1=0; i1 < pMenu->nItems; i1++)
    {
      MBDestroyMenuItem(pMenu->ppItems[i1]);
    }
  }

  if(pMenu->ppPopups) // part of 'pMenu' memory block
  {
    for(i1=0; i1 < pMenu->nPopups; i1++)
    {
      MBDestroyMenu(pMenu->ppPopups[i1]);
    }
  }

  WBFree(pMenu);
}

int MBIsMenuValid(const WBMenu *pMenu)
{
  // first check to see that the menu pointer is valid memory

  if(!pMenu)
  {
    return 0;
  }

  // For now, we MUST assume that a WBMenu was allocated using MBCreateMenu()
  // or else this next part will not work properly

  if(WBAllocUsableSize((void *)pMenu) < sizeof(WBMenu))
  {
    WB_ERROR_PRINT("ERROR:  %s - invalid WBMenu pointer %p\n", __FUNCTION__, pMenu);
    return 0;
  }

  // for now, just validate the tag

  return pMenu->uiTag == WBMENU_TAG;
}

int MBIsMenuItemValid(const WBMenuItem *pMenuItem)
{
  // first check to see that the menu pointer is valid memory

  if(!pMenuItem)
  {
    return 0;
  }

  // For now, we MUST assume that a WBMenuItem was allocated using MBCreateMenuItem()
  // or else this next part will not work properly

  if(WBAllocUsableSize((void *)pMenuItem) < sizeof(WBMenuItem))
  {
    WB_ERROR_PRINT("ERROR:  %s - invalid WBMenuItem pointer %p\n", __FUNCTION__, pMenuItem);
    return 0;
  }

  // for now, just validate the tag

  return pMenuItem->uiTag == WBMENUITEM_TAG;
}

void MBDestroyMenuItem(WBMenuItem *pMenuItem)
{
  if(!MBIsMenuItemValid(pMenuItem))
  {
    WB_ERROR_PRINT("ERROR:  %s - invalid menu item pointer %p\n", __FUNCTION__, pMenuItem);
    return;
  }

  WBFree(pMenuItem);
}

int MBAddMenuItem(WBMenu *pMenu, const WBMenuItem *pItem, int iPos)
{
  if(!MBIsMenuValid(pMenu))
  {
    WB_ERROR_PRINT("ERROR:  %s - invalid menu pointer %p\n", __FUNCTION__, pMenu);
    return -1;
  }

  if(!MBIsMenuItemValid(pItem))
  {
    WB_ERROR_PRINT("ERROR:  %s - invalid menu item pointer %p\n", __FUNCTION__, pItem);
    return -1;
  }

  return -1;
}

void MBRemoveMenuItem(WBMenu *pMenu, int iPos)
{
  if(!MBIsMenuValid(pMenu))
  {
    WB_ERROR_PRINT("ERROR:  %s - invalid menu pointer %p\n", __FUNCTION__, pMenu);
    return;
  }

}

int MBAddPopupMenu(WBMenu *pMenu, const WBMenu *pPopupMenu)
{
  if(!MBIsMenuValid(pMenu))
  {
    WB_ERROR_PRINT("ERROR:  %s - invalid menu pointer %p\n", __FUNCTION__, pMenu);
    return -1;
  }

  if(!MBIsMenuValid(pPopupMenu))
  {
    WB_ERROR_PRINT("ERROR:  %s - invalid menu pointer %p\n", __FUNCTION__, pPopupMenu);
    return -1;
  }

  // TODO:  implement this

  return -1;
}

WBMenu *MBFindPopupMenu(WBMenu *pMenu, int idPopup)
{
  if(!MBIsMenuValid(pMenu))
  {
    WB_ERROR_PRINT("ERROR:  %s - invalid menu pointer %p\n", __FUNCTION__, pMenu);
    return NULL;
  }

  // TODO:  implement this

  return NULL;
}

void MBRemovePopupMenu(WBMenu *pMenu, int idPopup)
{
  if(!MBIsMenuValid(pMenu))
  {
    WB_ERROR_PRINT("ERROR:  %s - invalid menu pointer %p\n", __FUNCTION__, pMenu);
    return;
  }

  // TODO:  implement this
}

WBMenu *MBCopyMenu(const WBMenu *pMenu, int iReserveSpace)
{
  // TODO:  make a copy of the main structure, the individual WBMenuItem structures,
  //        and recursively copy the 'popup' WBMenu structures

  if(!MBIsMenuValid(pMenu))
  {
    WB_ERROR_PRINT("ERROR:  %s - invalid menu pointer %p\n", __FUNCTION__, pMenu);
    return NULL;
  }

  // TODO:  implement this

  return NULL;
}


#define NEXT_LINE(X,Y) { while(*X && *X <= ' ' && *X != '\t' && *X != '\n') X++; Y=X; while(*X && *X != '\n') X++; if(*X=='\n') X++; }
#define NEXT_COL(X,Y,Z) { while(*X && *X <= ' ' && *X != '\t' && *X != '\n' && X < Z) X++; \
                          Y=X; while(*X && *X != '\t' && *X != '\n' && X < Z) X++; if(*X == '\t' || *X == '\n') X++; }

static void InternalLocateMenuInResource(const char *pszResource, int *piID,
                                         const char **ppStart, const char **ppEnd)
{
  char tbuf[16];
  const char *p1, *p2, *p3;
  char *p4;
  int i1;

  p1 = pszResource;

  while(*p1)
  {
    NEXT_LINE(p1, p2);

//    fprintf(stderr, "found line %-.*s\n", (int)(p1 - p2), p2);

    p3 = p2;
    while(p3 < p1 && *p3 != '\n' && *p3 != '\t')
    {
      p3++;
    }

    if(*p3 == '\t')  // line contains a tab
    {
      continue;
    }

    bzero(tbuf, sizeof(tbuf));
    memcpy(tbuf, p2, (sizeof(tbuf) - 1) < (p1 - p2) ? sizeof(tbuf) - 1 : (p1 - p2));

    p4 = tbuf + strlen(tbuf);

    while(p4 > tbuf && *(p4 - 1) <= ' ')
    {
      *(--p4) = 0;  // trim trailing white space
    }

    i1 = atoi(tbuf);

    if(i1 <= 0)
    {
      continue;
    }

    if(*piID == -1)
    {
      *piID = i1;  // keep track of what I actually found
      break;
    }

    if(*piID == i1) // a match
    {
      break;
    }
  }

  *ppStart = p1;  // this will be the beginning of the next line after the ID
  if(!*p1)
  {
    *ppEnd = p1;
    return;
  }

  // next, find the end of the menu resource

  while(*p1)
  {
    NEXT_LINE(p1, p2);

//    fprintf(stderr, "(b) found line %-.*s\n", (int)(p1 - p2), p2);

    p3 = p2;
    while(p3 < p1 && *p3 != '\n' && *p3 != '\t')
    {
      p3++;
    }

    if(*p3 == '\t')  // line contains a tab
    {
      continue;
    }

    bzero(tbuf, sizeof(tbuf));
    memcpy(tbuf, p2, (sizeof(tbuf) - 1) < (p1 - p2) ? sizeof(tbuf) - 1 : (p1 - p2));

    p4 = tbuf + strlen(tbuf);

    while(p4 > tbuf && *(p4 - 1) <= ' ')
    {
      *(--p4) = 0;  // trim trailing white space
    }

    i1 = atoi(tbuf);

    if(i1 <= 0)
    {
      continue;
    }

    p1 = p2;  // point back at the beginning of the line
    p2 = *ppStart;  // start of section

    while(p1 > p2 && *(p1 - 1) != '\n')
    {
      p1--;  // find newline prior to where I'm at right now
    }

    break;  // and that's it - p1 points to end of section
  }

  *ppEnd = p1;

}

static int InternalPopulateMenuFromResource(WBMenu *pMenu, int iID, const char *pszResource)
{
const char *p1, *p2; //, *p3;
int i1;

  p1 = pszResource;

  // Owning menu will be 'iID' so I need that section first

  InternalLocateMenuInResource(pszResource, &iID, &p1, &p2);
  if(p1 == p2)  // not found
  {
    return 0;
  }

  // parse out the menu resource and build my structure
  // (assume it's empty when I begin)

  while(p1 < p2)
  {
    WBMenuItem *pItem;

    pItem = MBCreateMenuItem(&p1);
    if(!pItem)
    {
      continue;
    }

    pMenu->ppItems[(pMenu->nItems)++] = pItem;

    if(pMenu->nItems >= pMenu->nMaxItems)
    {
      break;
    }

    while(p1 < p2 && *p1 <= ' ' && *p1 != '\t')
    {
      p1++;  // skip any blank lines and leading white space I might find, excluding tabs
    }
  }

  // Finally, create menus for all of the popups and populate my structure with pointers to them.

  for(i1=0; i1 < pMenu->nItems; i1++)
  {
    if(!pMenu->ppItems[i1] || // just in case
       pMenu->ppItems[i1]->iAction == WBMENU_SEPARATOR)
    {
      // separator (so I don't try and create a popup for it)
    }
    else if(pMenu->ppItems[i1]->iAction & WBMENU_DYNAMIC_HIGH_BIT)
    {
      // dynamic menu entry - no popups created, and menu display is created 'on the fly'
    }
    else if(pMenu->ppItems[i1]->iAction & WBMENU_POPUP_HIGH_BIT)
    {
      WBMenu *pPopup;

//      fprintf(stderr, "INFO - searching for popup %d\n", pMenu->ppItems[i1]->iAction & WBMENU_POPUP_MASK);

      pPopup = MBCreateMenu(pMenu->ppItems[i1]->iAction & WBMENU_POPUP_MASK, 1,
                            pszResource, WBMENU_RESERVE_DEFAULT);
      if(pPopup)
      {
        pMenu->ppPopups[(pMenu->nPopups)++] = pPopup;

        if(pMenu->nPopups >= pMenu->nMaxPopups)
        {
          break;
        }
      }
      else
      {
        WB_WARN_PRINT("%s - WARNING: Unable to create popup for %d\n",
                      __FUNCTION__, pMenu->ppItems[i1]->iAction & WBMENU_POPUP_MASK);
      }
    }
  }

  return 1;  // for now...
}

#define ALT_HOTKEY 0x80000000L
#define CTRL_HOTKEY 0x40000000L
#define SHIFT_HOTKEY 0x20000000L

static int TranslateHotKeyText(const char *szText) // translate key or return UTF-8 char
{
  if((szText[0] == 'F' || szText[0] == 'f') &&
     szText[1] >= '1' && szText[1] <= '9')
  {
    int iF = szText[1] - '0';
    if(szText[2] >= '0' && szText[2] <= '9')
    {
      iF = iF * 10 + (szText[2] - '0');
    }
    // function keys iF=1 through 35 are supported.  Anything else is a bug/feature
    return (XK_F1 + iF - 1);
  }
  else if(!strncasecmp(szText, "home", 4))
  {
    return XK_Home;
  }
  else if(!strncasecmp(szText, "end", 3))
  {
    return XK_End;
  }
  else if(!strncasecmp(szText, "left", 4))
  {
    return XK_Left;
  }
  else if(!strncasecmp(szText, "right", 5))
  {
    return XK_Right;
  }
  else if(!strncasecmp(szText, "up", 2))
  {
    return XK_Up;
  }
  else if(!strncasecmp(szText, "down", 4))
  {
    return XK_Down;
  }
  else if(!strncasecmp(szText, "pgup", 4) || !strncasecmp(szText, "prior", 5))
  {
    return XK_Page_Up;
  }
  else if(!strncasecmp(szText, "pgdown", 6) || !strncasecmp(szText, "next", 4))
  {
    return XK_Page_Down;
  }
  else if(!strncasecmp(szText, "del", 3))
  {
    return XK_Delete;
  }
  else if(!strncasecmp(szText, "ins", 3))
  {
    return XK_Insert;
  }

  return *szText;  // for now (later do UTF-8 translation)
}

static int ProcessHotKeyText(const char *szText)
{
  // format:  'n' or 'N' or 'Modifier[+Modifier...]+[n|N]'
  //          'n' is the case-sensitive ASCII code for the keystroke
  //          'Modifier' is Ctrl, Alt, Shift, or Meta [Meta is usually the same as 'Alt']


  const char *p1 = strchr(szText, '+');
  int iBits = 0;

  while(p1)
  {
    int iLen = p1 - szText;
    if(iLen)  // extremely forgiving
    {
      if((!strncasecmp(szText, "alt", 3) && iLen == 3) ||
         (!strncasecmp(szText, "meta", 4) && iLen == 4))
      {
        iBits |= ALT_HOTKEY;
      }
      else if((!strncasecmp(szText, "ctrl", 4) && iLen == 4) ||
              (!strncasecmp(szText, "control", 7) && iLen == 7))
      {
        iBits |= CTRL_HOTKEY;
      }
      else if(!strncasecmp(szText, "shift", 5) && iLen == 5)
      {
        iBits |= SHIFT_HOTKEY;
      }
      else
      {
        WB_WARN_PRINT("%s - Hotkey description %*s not defined\n", __FUNCTION__, iLen, szText);
      }
    }

    szText = p1 + 1; // point just past '+'
    p1 = strchr(szText, '+'); // location of new '+'
  }

  return TranslateHotKeyText(szText) | iBits;
}

WBMenuItem *MBCreateMenuItem(const char **ppszResource)
{
char tbuf[256];
const char *p1, *p2, *p3, *p5;
char *p4;
int i1;
WBMenuItem *pRval = NULL;

  p2 = *ppszResource;
  NEXT_LINE(p2, p1);
//  fprintf(stderr, "   LINE:  %-.*s\n", (int)(p2 - p1), p1);

  i1 = 0;
  while(p1 < p2)
  {
    NEXT_COL(p1, p3, p2);  // menu text

    if(p1 > p3)
    {
      i1 += (p1 - p3) + 2;
    }

    if(p1 >= p2)
    {
      break;
    }

    NEXT_COL(p1, p3, p2);  // message ID, 'popup', or 'separator', or 'dynamic'

    if(p1 >= p2)
    {
      break;
    }

    NEXT_COL(p1, p3, p2);  // toolhelp text

    if(p1 > p3)
    {
      i1 += (p1 - p3) + 2;
    }

    if(p1 >= p2)
    {
      break;
    }

    NEXT_COL(p1, p3, p2);  // reserved text

    if(p1 > p3)
    {
      i1 += (p1 - p3) + 2;
    }
  }

  pRval = (WBMenuItem *)WBAlloc(sizeof(WBMenuItem) + i1);
  if(!pRval)
  {
    return NULL;  // bummer (no memory)
  }

  bzero(pRval, sizeof(WBMenuItem) + i1);  // make sure
  pRval->uiTag = WBMENUITEM_TAG;

  pRval->iMenuItemText = -1; // "none"
  pRval->iUnderscore = -1;   // "none"
  pRval->iTooltipText = -1;  // "none"
  pRval->iHotKey = -1;       // "none"
  pRval->iAction = 0;
  pRval->nHotKey = 0;        // "none"
  pRval->iTextWidth = -1;    // "calculate it"
  pRval->iPosition = -1;     // "calculate it"
  pRval->nDataSize = i1 + sizeof(pRval->data);  // total size of data

  p2 = *ppszResource;
  NEXT_LINE(p2, p1);  // one more time!
  *ppszResource = p2;  // end of line pointer, start of next line

  p4 = (char *)pRval->data; // this is the output buffer where I store copies of the information as text

  while(p1 < p2)
  {
    NEXT_COL(p1, p3, p2);  // menu text

    if(p1 > p3)
    {
      pRval->iMenuItemText = (p4 - pRval->data);
      p5 = p4; // hold onto the position of the menu text in the output buffer
      // to find the end of this item's descriptive text, look for tab or newline
      if(p1 > p3 && (*(p1 - 1) == '\t' || *(p1 - 1) == '\n'))
      {
        memcpy(p4, p3, (p1 - p3) - 1);
        p4 += (p1 - p3) - 1;
      }
      else if(p1 > p3)
      {
        memcpy(p4, p3, p1 - p3);
        p4 += (p1 - p3);
      }

      *(p4++) = 0;

      while(*p5 && *p5 != '_')
      {
        p5++;  // find underscore or end of string
      }
      if(*p5 == '_')
      {
        pRval->iUnderscore = (p5 - pRval->data);
      }
      else
      {
        pRval->iUnderscore = -1;  // to enforce "no underscore" later
      }
    }

    if(p1 >= p2) // checking that I parsed past the end of the string
    {
      break;
    }

    NEXT_COL(p1, p3, p2);  // message ID, 'popup', or 'separator', or 'dynamic'

    if(p1 > p3) // parse similar to the menu text, store offsets and other info
    {
      bzero(tbuf, sizeof(tbuf));
      memcpy(tbuf, p3, (p1 - p3) > (sizeof(tbuf) - 1) ? sizeof(tbuf) - 1 : p1 - p3);

      // trim any trailing white space (like line feeds, tabs, ???)
      i1 = strlen(tbuf);
      while(i1 > 0 && tbuf[i1 - 1] <= ' ')
      {
        tbuf[--i1] = 0;
      }

      if(!strcasecmp(tbuf, "separator"))
      {
        pRval->iAction = WBMENU_SEPARATOR;
      }
      else if(!strcasecmp(tbuf, "dynamic"))
      {
        pRval->iAction = WBMENU_DYNAMIC_HIGH_BIT;
      }
      else if(!strcasecmp(tbuf, "popup"))
      {
        pRval->iAction = WBMENU_POPUP_HIGH_BIT;
      }
      else
      {
        i1 = atoi(tbuf);

        if(i1 > 0)
        {
          pRval->iAction = i1;
        }
        else
        {
          // assume it's an atom, and get its value as an integer (or allocate if not there)
          pRval->iAction = (int)WBGetAtom(WBGetDefaultDisplay(), tbuf);

          if(pRval->iAction == (int)None)
          {
            WB_WARN_PRINT("%s - WARNING:  cannot find menu message atom %s\n", __FUNCTION__, tbuf);
          }
        }
      }
    }

    if(p1 >= p2)
    {
      break;
    }

    NEXT_COL(p1, p3, p2);  // toolhelp text or popup menu ID, or menu ID for 'dynamic'
    if(p1 > p3)
    {
      if(pRval->iAction == WBMENU_POPUP_HIGH_BIT ||
         pRval->iAction == WBMENU_DYNAMIC_HIGH_BIT)
      {
        bzero(tbuf, sizeof(tbuf));
        memcpy(tbuf, p3, (p1 - p3) > (sizeof(tbuf) - 1) ? sizeof(tbuf) - 1 : p1 - p3);

        while(tbuf[0] && tbuf[strlen(tbuf) - 1] <= ' ')
        {
          tbuf[strlen(tbuf) - 1] = 0;  // right trim
        }

        if(pRval->iAction == WBMENU_POPUP_HIGH_BIT)
        {
          pRval->iAction |= atoi(tbuf);
        }
        else // dynamic menu action
        {
          pRval->iAction |= (int)WBGetAtom(WBGetDefaultDisplay(), tbuf);
        }
      }
      else
      {
        pRval->iTooltipText = (p4 - pRval->data);
        if(p1 > p3 && *(p1 - 1) == '\t')
        {
          memcpy(p4, p3, (p1 - p3) - 1);
          p4[p1 - p3 - 1] = 0;  // terminate string
        }
        else
        {
          if(p1 > p3)
            memcpy(p4, p3, p1 - p3);
          p4[p1 - p3] = 0;  // terminate string
        }

        // next, trim the string as much as I can
        i1=strlen(p4);
        while(i1 > 0 && p4[i1 - 1] <= ' ')
          p4[--i1] = 0;

        p4 += i1 + 1;
      }
    }

    if(p1 >= p2)
    {
      break;
    }

    NEXT_COL(p1, p3, p2);  // hotkey (non-popup) or toolhelp text (popup)
    if(p1 > p3)
    {
      if(pRval->iAction & WBMENU_POPUP_HIGH_BIT)
      {
        pRval->iTooltipText = (p4 - pRval->data);

        if(p1 > p3 && *(p1 - 1) == '\t')
        {
          memcpy(p4, p3, (p1 - p3) - 1);

          p4[p1 - p3 - 1] = 0;  // terminate string
        }
        else
        {
          if(p1 > p3)
          {
            memcpy(p4, p3, p1 - p3);
          }

          p4[p1 - p3] = 0;  // terminate string
        }

        // next, trim the string as much as I can
        i1=strlen(p4);

        while(i1 > 0 && p4[i1 - 1] <= ' ')
        {
          p4[--i1] = 0;
        }

        p4 += i1 + 1;
      }
      else if(pRval->iAction & ~(WBMENU_POPUP_MASK)) // only for "other than 'regular' menu items"
      {
        // TODO: any special thing for these, dynamics, etc.
      }
      else
      {
        pRval->iHotKey = (p4 - pRval->data);

        if(p1 > p3 && *(p1 - 1) == '\t')
        {
          memcpy(p4, p3, (p1 - p3) - 1);
          p4[p1 - p3 - 1] = 0;  // terminate string
        }
        else
        {
          if(p1 > p3)
          {
            memcpy(p4, p3, p1 - p3);
          }

          p4[p1 - p3] = 0;  // terminate string
        }

        // next, trim the string as much as I can
        i1=strlen(p4);

        while(i1 > 0 && p4[i1 - 1] <= ' ')
        {
          p4[--i1] = 0;
        }

        if(*p4)
        {
          pRval->nHotKey = ProcessHotKeyText(p4);
        }
        else
        {
          pRval->nHotKey = -1;  // force NONE
        }

        p4 += i1 + 1;
      }
    }

    if(p1 >= p2)
    {
      break;
    }

    NEXT_COL(p1, p3, p2);  // reserved text

    if(p1 > p3)
    {
      if(p1 > p3 && *(p1 - 1) == '\t')
      {
        memcpy(p4, p3, (p1 - p3) - 1);
        p4[p1 - p3 - 1] = 0;  // terminate string
      }
      else
      {
        if(p1 > p3)
        {
          memcpy(p4, p3, p1 - p3);
        }

        p4[p1 - p3] = 0;  // terminate string
      }

      // next, trim the string as much as I can
      i1=strlen(p4);

      while(i1 > 0 && p4[i1 - 1] <= ' ')
      {
        p4[--i1] = 0;
      }

      p4 += i1 + 1;
    }
  }

#ifndef NO_DEBUG
  if((WBGetDebugLevel() & DebugLevel_MASK) >= DebugLevel_Chatty ||
     (WBGetDebugLevel() & DebugSubSystem_Menu))
  {
    if(pRval->iAction == WBMENU_SEPARATOR)
    {
      WBDebugPrint("  MENU ITEM SEPARATOR\n");
    }
    else if(pRval->iAction & WBMENU_DYNAMIC_HIGH_BIT)
    {
      p4 = WBGetAtomName(WBGetDefaultDisplay(), pRval->iAction & WBMENU_POPUP_MASK);
      WBDebugPrint("  DYNAMIC MENU ITEM %d \"%s\"\n",
                   pRval->iAction & WBMENU_POPUP_MASK, p1);
      if(p4)
      {
        WBFree(p4);
        p4 = NULL;
      }
    }
    else if(pRval->iAction & WBMENU_POPUP_HIGH_BIT)
    {
      p4 = WBGetAtomName(WBGetDefaultDisplay(), pRval->iAction & WBMENU_POPUP_MASK);

      if(pRval->iHotKey == -1)
      {
        WBDebugPrint("  POPUP MENU \"%s\" %d \"%s\"   \"%s\" %-.2s\n",
                     pRval->data + pRval->iMenuItemText,
                     pRval->iAction & WBMENU_POPUP_MASK, p4,
                     pRval->iTooltipText >= 0 ? pRval->data + pRval->iTooltipText : "",
                     pRval->iUnderscore >= 0 ? pRval->data + pRval->iUnderscore : "");
      }
      else
      {
        WBDebugPrint("  POPUP MENU \"%s\" %d \"%s\"  \"%s\" \"%s\"(%xH) %-.2s\n",
                     pRval->data + pRval->iMenuItemText,
                     pRval->iAction & WBMENU_POPUP_MASK, p4,
                     pRval->iTooltipText >= 0 ? pRval->data + pRval->iTooltipText : "",
                     pRval->iHotKey >= 0 ? pRval->data + pRval->iHotKey : "",
                     pRval->nHotKey,
                     pRval->iUnderscore >= 0 ? pRval->data + pRval->iUnderscore : "");
      }

      if(p4)
      {
        WBFree(p4);
        p4 = NULL;
      }
    }
    else
    {
      p4 = WBGetAtomName(WBGetDefaultDisplay(), pRval->iAction & WBMENU_POPUP_MASK);

      if(pRval->iHotKey == -1)
      {
        WBDebugPrint("  MENU ITEM \"%s\" %d \"%s\"   \"%s\" %-.2s\n",
                     pRval->data + pRval->iMenuItemText,
                     pRval->iAction & WBMENU_POPUP_MASK, p4,
                     pRval->iTooltipText >= 0 ? pRval->data + pRval->iTooltipText : "",
                     pRval->iUnderscore >= 0 ? pRval->data + pRval->iUnderscore : "");
      }
      else
      {
        WBDebugPrint("  MENU ITEM \"%s\" %d \"%s\"  \"%s\" \"%s\"(%xH) %-.2s\n",
                     pRval->data + pRval->iMenuItemText,
                     pRval->iAction & WBMENU_POPUP_MASK, p4,
                     pRval->iTooltipText >= 0 ? pRval->data + pRval->iTooltipText : "",
                     pRval->iHotKey >= 0 ? pRval->data + pRval->iHotKey : "",
                     pRval->nHotKey,
                     pRval->iUnderscore >= 0 ? pRval->data + pRval->iUnderscore : "");
      }

      if(p4)
      {
        WBFree(p4);
        p4 = NULL;
      }
    }
  }
#endif // NO_DEBUG

  return pRval;
}


///////////////////////////////////////////////////////////////////////////////////////
//   _   _       _   _                ____                              _
//  | | | | ___ | |_| | _____ _   _  |  _ \ _ __ ___   ___ ___  ___ ___(_)_ __   __ _
//  | |_| |/ _ \| __| |/ / _ \ | | | | |_) | '__/ _ \ / __/ _ \/ __/ __| | '_ \ / _` |
//  |  _  | (_) | |_|   <  __/ |_| | |  __/| | | (_) | (_|  __/\__ \__ \ | | | | (_| |
//  |_| |_|\___/ \__|_|\_\___|\__, | |_|   |_|  \___/ \___\___||___/___/_|_| |_|\__, |
//                            |___/                                             |___/
///////////////////////////////////////////////////////////////////////////////////////

// hot key message processing
//include files placed here for possible re-location to different file
#include "menu_bar.h"
#include "menu_popup.h"

static void __PostMenuActivateEvent(WBMenu *pMenu, WBMenuItem *pItem, int iIndex, int iIsPopup)
{
XClientMessageEvent evt;

  if(!iIsPopup)
  {
    WBMenuBarWindow *pMB = MBFindMenuBarWindow(pMenu);

    if(pMB)
    {
      // post a high-priority message to the menu bar or popup window to activate the menu

      bzero(&evt, sizeof(evt));
      evt.type = ClientMessage;
      evt.display = WBGetWindowDisplay(pMB->wSelf);
      evt.window = pMB->wSelf;
      evt.message_type = aMENU_ACTIVATE;
      evt.format = 32;
#warning this is potentially dangerous code.  find another way to pass a pointer, if I even need it
      evt.data.l[0] = (long)pItem;
      evt.data.l[1] = iIndex; // index for menu item

      WBPostPriorityEvent(pMB->wSelf, (XEvent *)&evt);

      WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_Menu | DebugSubSystem_Keyboard,
                      "%s - FOUND '%s', posting client event to menu bar\n",
                      __FUNCTION__, &(pItem->data[pItem->iMenuItemText]));
    }
    else
    {
      // TODO:  post to event owner?
      WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_Menu | DebugSubSystem_Keyboard,
                      "%s - FOUND '%s', NOT posting client event to menu bar\n",
                      __FUNCTION__, &(pItem->data[pItem->iMenuItemText]));
    }
  }
  else
  {
    WBMenuPopupWindow *pMP = MBFindMenuPopupWindow(pMenu);

    if(pMP)
    {
      // post a high-priority message to the menu bar or popup window to activate the menu

      bzero(&evt, sizeof(evt));
      evt.type = ClientMessage;
      evt.display = WBGetWindowDisplay(pMP->wSelf);
      evt.window = pMP->wSelf;
      evt.message_type = aMENU_ACTIVATE;
      evt.format = 32;
#warning this is potentially dangerous code.  find another way to pass a pointer, if I even need it
      evt.data.l[0] = (long)pItem;
      evt.data.l[1] = iIndex; // index for menu item

      WBPostPriorityEvent(pMP->wSelf, (XEvent *)&evt);

      WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_Menu | DebugSubSystem_Keyboard,
                      "%s - FOUND '%s', posting client event to popup\n",
                      __FUNCTION__, &(pItem->data[pItem->iMenuItemText]));
    }
    else
    {
      // TODO:  post to event owner?
      WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_Menu | DebugSubSystem_Keyboard,
                      "%s - FOUND '%s', NOT posting client event to popup\n",
                      __FUNCTION__, &(pItem->data[pItem->iMenuItemText]));
    }
  }
}

//  pItem = __HotKeySearch(pMenu, iHotkey0, iIsPopup, &i1);  // recursive hotkey search
static WBMenuItem * __HotKeySearchRecurse(WBMenu *pMenu, int iHotKey, int *piIndex, int iLevel)
{
WBMenuItem *pRval = NULL;
int i1;

  for(i1=0; i1 < pMenu->nItems; i1++)
  {
    WBMenuItem *pItem = pMenu->ppItems[i1];

    if(pItem->iHotKey < 0)
    {
      continue;  // no hotkey
    }

    WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Menu | DebugSubSystem_Keyboard,
                    "%s - comparing %x to %x '%s' for %s\n",
                    __FUNCTION__, iHotKey, pItem->nHotKey,
                    &(pItem->data[pItem->iHotKey]), &(pItem->data[pItem->iMenuItemText]));

    if(pItem->nHotKey == iHotKey)
    {
      *piIndex = i1;

      if(!iLevel || !(pItem->iAction & WBMENU_POPUP_HIGH_BIT))
      {
        return pItem;
      }

      return NULL;  // popups can't be returned except for level 0
    }
  }

  // now recurse all of the popups
  for(i1=0; i1 < pMenu->nPopups; i1++)
  {
    pRval = __HotKeySearchRecurse(pMenu->ppPopups[i1], iHotKey, piIndex, iLevel + 1);

    if(pRval || *piIndex >= 0) // piIndex >= 0 if found, but pRval will be NULL if popup
    {
      return pRval;
    }
  }

  return NULL;  // not found
}

static WBMenuItem * __HotKeySearch(WBMenu *pMenu, int iHotKey, int *piIndex)
{
  *piIndex = -1;  // necessary

  return __HotKeySearchRecurse(pMenu, iHotKey, piIndex, 0);
}

int MBMenuProcessHotKey(WBMenu *pMenu, XKeyEvent *pEvent)
{
int iACS = 0, iKey, i1, iIsPopup, nChar;
char tbuf[64];
int iHotKey0;
WBMenuItem *pItem;


  if(!MBIsMenuValid(pMenu))
  {
    WB_ERROR_PRINT("ERROR:  %s - invalid menu pointer %p\n", __FUNCTION__, pMenu);
    return 0;
  }


  // check for hotkey and process (called by KeyEvent processing for frame, etc.)

  // menus use "key press"
  if(pEvent->type != KeyPress /* && pEvent->type != KeyRelease */)
  {
    WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Event | DebugSubSystem_Menu | DebugSubSystem_Keyboard,
                   "%s - event not KeyPress\n", __FUNCTION__);
    return 0;
  }

  nChar = sizeof(tbuf);
  iKey = WBKeyEventProcessKey((XKeyEvent *)pEvent, tbuf, &nChar, &iACS);

  // pressing or releasing shift, ctrl, alt, or 'meta' must not
  // generate an event.  Fortunately these are all within a range

  if(iKey >= XK_Shift_L && iKey <= XK_Hyper_R)
  {
    WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Event | DebugSubSystem_Menu | DebugSubSystem_Keyboard,
                   "%s - Key %d (%xH) within 'modifier key' range\n", __FUNCTION__, iKey, iKey);

    return 0;  // these must be ignored (basically, it's noise)
  }

  // check for ascii, check for lower case
  // TODO:  correct upper case translation for UTF-8 ?

  if((unsigned int)iKey >= ' ' && (unsigned int)iKey <= 0x7f)
  {
    register int iKOld = iKey;

    iKey = toupper(iKOld);  // should compile efficiently this way

    if(iKOld != iKey)
    {
      WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Event | DebugSubSystem_Menu | DebugSubSystem_Keyboard,
                     "%s - Converting Key %d (%xH) to %d (%xH)\n", __FUNCTION__, iKOld, iKOld, iKey, iKey);
    }
  }

  WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Menu | DebugSubSystem_Keyboard,
                 "%s - POSSIBLE MENU KEY PRESS for KEY %d (%xH) KEYCODE %d ACS=%xH\n",
                 __FUNCTION__, iKey, iKey, ((XKeyEvent *)pEvent)->keycode, iACS);

  // there are 3 types of hotkeys:
  // first is ALT+'underscore' on a menu name (1st level, likely to have 'POPUP' bit set but not required)
  // second is a hotkey defined by an underscore on a member of the popup menu (only when popup is displayed)
  // (the second can only happen when a popup is visible, handled by menu_popup)
  // third is a popup menu defined by a special key combination (always active)

  iIsPopup = pMenu->iMenuID & WBMENU_POPUP_HIGH_BIT; // popup menus will accept keystrokes without modifiers


  if(!iIsPopup && !(iACS & WB_KEYEVENT_ALT)) // NOT alt and not a popup (main menu ONLY uses 'alt' keys)
  {
    WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Event | DebugSubSystem_Menu | DebugSubSystem_Keyboard,
                   "%s - Key %d (%xH) ACS=%xH not valid for non-popup menu\n", __FUNCTION__, iKey, iKey, iACS);

    // don't exit for cursors or ctrl+
    if(!(iACS & WB_KEYEVENT_CTRL) &&      // ctrl key wasn't pressed
       (iKey < 0xfd00 || iKey > 0xffff))  // overly simple test for non-printing characters like cursors and F keys
    {
      // TODO:  for 'dead' keys, braille dots, and a number of other 'mode switch' keys the
      //        simplified range won't prevent them from going through the rest of this code
      //        so a slightly more comprehensive test may need to be done for best efficiency

      return 0;  // reject something that can't be a hotkey (like JUST pressing an alpha key)
    }
  }

  /////////////////////////////////////////////////////////////////////
  // TODO:  soft-match of XK_KP_* vs XK_* for numbers, cursors, etc.
  /////////////////////////////////////////////////////////////////////

  // step 1:  check for top-level menu accelerators (underscores on menu names)
  //          for either the current 'top level' menu, or the visible popup menu

  if(!iIsPopup || // i.e. it's a MAIN menu (so I always do an ALT+'underscore char' hotkey)
     !iACS)       // no ctrl/alt/shift - i'm typing in stuff after displaying a popup, so does char match underscore char?
  {
    WB_DEBUG_PRINT(DebugLevel_Excessive | DebugSubSystem_Menu | DebugSubSystem_Keyboard,
                   "%s - menu has %d items\n", __FUNCTION__, pMenu->nItems);

    for(i1=0; i1 < pMenu->nItems; i1++)
    {
      pItem = pMenu->ppItems[i1];

      if(pItem->iAction == WBMENU_SEPARATOR)  // separator{
      {
        continue;
      }
      else if(pItem->iAction & WBMENU_DYNAMIC_HIGH_BIT)
      {
        // dynamic menu items are created on-the-fly

        ////////////////////////////////////////////////
        // TODO:  hotkey search of dynamic menu
        ////////////////////////////////////////////////

        WB_ERROR_PRINT("TODO:  %s - dynamic menu hotkey search not implemented\n", __FUNCTION__);

        // it would PROBABLY be a good idea to cache the latest hotkeys, instead of re-building
        // the dynamic menu every! stinking! time!, or else have the UI handler do the hotkey search
        // (the alternative, and simpler way, would be to NOT allow hotkeys in dynamic menus, but
        //  force the application to handle them on its own instead... i.e. pass the burden BACK)

        continue;
      }
      else if(pItem->iUnderscore < 0)          // no underscore
      {
        continue;
      }

      if(toupper(pItem->data[pItem->iUnderscore + 1])
         == iKey) // it's a match?
      {

        __PostMenuActivateEvent(pMenu, pItem, i1, iIsPopup);

        return 1;
      }

      // TODO:  XK_KP_* matches to XK_* for numbers, etc.
    }
  }


  // next search for hotkeys defined as part of the menu by first building
  // a matching hotkey designation, then recursively checking popup menus
  // for "non-popup" items that match, and checking single layer for a
  // matching popup menu item (for existing popup menus only).

  iHotKey0 = iKey;

  if(iACS & WB_KEYEVENT_ALT)
  {
    iHotKey0 |= ALT_HOTKEY;
  }
  if(iACS & WB_KEYEVENT_CTRL)
  {
    if(iHotKey0 > 0 && iHotKey0 < 0x1f) // control keys were translated
    {
      iHotKey0 += 0x40;  // convert back to 'alpha'
    }

    iHotKey0 |= CTRL_HOTKEY;
  }
  if(iACS & WB_KEYEVENT_SHIFT)
  {
    iHotKey0 |= SHIFT_HOTKEY;
  }

  i1 = -1;
  pItem = __HotKeySearch(pMenu, iHotKey0, &i1);  // recursive hotkey search

  if(!pItem)
  {
    return 0;  // not handled (done this way for optimization)
  }

  // at this point the hotkey has been identified, so take action on it
  // and then return a '1' value indicating that I 'handled' the notification

  if(pItem->iAction & WBMENU_POPUP_HIGH_BIT)
  {
    // display popup menu corresponding to hotkey
    __PostMenuActivateEvent(pMenu, pItem, i1, iIsPopup);
  }
  else
  {
    XClientMessageEvent evt;
    Window wIDBar, wIDOwner;
    Display *pDisplay;

    if(!iIsPopup)
    {
      WBMenuBarWindow *pMB = MBFindMenuBarWindow(pMenu);

      if(!pMB)
      {
        WB_WARN_PRINT("%s - menu bar window NULL, hotkey eaten\n", __FUNCTION__);
        return 1;  // "handled" though I can't do anything with it
      }

      wIDBar = pMB->wSelf;
      wIDOwner = pMB->wOwner;
    }
    else
    {
      WBMenuPopupWindow *pMP = MBFindMenuPopupWindow(pMenu);

      if(!pMP)
      {
        WB_WARN_PRINT("%s - menu popup window NULL, hotkey eaten\n", __FUNCTION__);
        return 1;  // "handled" though I can't do anything with it
      }

      wIDBar = pMP->wBar;
      wIDOwner = pMP->wOwner;
    }

    pDisplay = WBGetWindowDisplay(wIDOwner);

    bzero(&evt, sizeof(evt));
    evt.type = ClientMessage;

    evt.display = pDisplay;
    evt.window = wIDOwner;
    evt.message_type = aMENU_COMMAND;
    evt.format = 32;  // always
    evt.data.l[0] = pItem->iAction;  // menu command message ID
#warning this is potentially unsafe code - consider a BETTER way of passing a 'pMenu' pointer
    evt.data.l[1] = (long)pMenu;     // pointer to menu object
    evt.data.l[2] = wIDBar;          // window ID of menu bar

    WBPostEvent(wIDOwner, (XEvent *)&evt);

    WB_DEBUG_PRINT(DebugLevel_WARN | DebugSubSystem_Menu | DebugSubSystem_Event,
                  "%s - Post Event: %08xH %08xH %pH %08xH\n", __FUNCTION__,
                  (int)aMENU_COMMAND, (int)pItem->iAction,
                  pMenu, (int)wIDBar);
  }

  // return "that I handled the thing" to caller

  return 1;
}


