//////////////////////////////////////////////////////////////////////////////////////////
//                  _  _  _                 _             _                             //
//         ___   __| |(_)| |_    __      __(_) _ __    __| |  ___ __      __  ___       //
//        / _ \ / _` || || __|   \ \ /\ / /| || '_ \  / _` | / _ \\ \ /\ / / / __|      //
//       |  __/| (_| || || |_     \ V  V / | || | | || (_| || (_) |\ V  V /_| (__       //
//        \___| \__,_||_| \__|_____\_/\_/  |_||_| |_| \__,_| \___/  \_/\_/(_)\___|      //
//                           |_____|                                                    //
//                                                                                      //
//                     a window into which you can type text                            //
//                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2016 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no waranties, either implied or explicit.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/


#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>

#include "window_helper.h"
#include "edit_window.h"
#include "conf_help.h"


int FWEditWindowEvent(Window wID, XEvent *pEvent);
static void InternalEditWindowDestructor(WBChildFrame *pC);
static void InternalEditWindowDestroy(WBEditWindow *pEditWindow);

static XColor clrFG, clrBG, clrAFG, clrABG;
static int iInitColorFlag = 0;

#define LOAD_COLOR0(X,Y) if(CHGetResourceString(WBGetDefaultDisplay(), X, Y, sizeof(Y)) > 0) {  }
#define LOAD_COLOR(X,Y,Z) if(CHGetResourceString(WBGetDefaultDisplay(), X, Y, sizeof(Y)) <= 0){ WB_WARN_PRINT("%s - WARNING:  can't find color %s, using default value %s\n", __FUNCTION__, X, Z); strcpy(Y,Z); }

static void InternalCheckEWColors(void)
{
  Colormap colormap;

  // *Frame.background, *Frame.foreground, *WmFrame.background, *WmFrame.foreground,
  // *Form.background, *Form.foreground, *background, *foreground

  if(!iInitColorFlag)
  {
    char szFG[16], szBG[16], szAFG[16], szABG[16]; // note colors can typically be up to 13 characters + 0 byte

    colormap = DefaultColormap(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));

    // (these color names and standards have changed *WAY* too many times...)

    LOAD_COLOR0("*Text.foreground",szFG) else LOAD_COLOR0("*Edit.foreground", szFG)
     else LOAD_COLOR("*foreground", szFG, "#000000");
    LOAD_COLOR0("*Text.background",szBG) else LOAD_COLOR0("*Edit.background", szBG)
     else LOAD_COLOR("*background", szBG, "white"); // pure white background by default

    LOAD_COLOR("selected_bg_color", szABG, "#0040FF"); // a slightly greenish blue for the 'selected' BG color
    LOAD_COLOR("selected_fg_color", szAFG, "white");   // white FG when selected

    WB_ERROR_PRINT("TEMPORARY:  %s - edit window colors:  FG=%s BG=%s AFG=%s ABG=%s\n", __FUNCTION__,
                   szFG, szBG, szAFG, szABG);

    XParseColor(WBGetDefaultDisplay(), colormap, szFG, &clrFG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrFG);
    XParseColor(WBGetDefaultDisplay(), colormap, szBG, &clrBG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrBG);
    XParseColor(WBGetDefaultDisplay(), colormap, szAFG, &clrAFG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrAFG);
    XParseColor(WBGetDefaultDisplay(), colormap, szABG, &clrABG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrABG);

    iInitColorFlag = 1;
  }
}


WBEditWindow *WBCreateEditWindow(WBFrameWindow *pOwner, XFontStruct *pFont,
                                 const char *szFocusMenu, const WBFWMenuHandler *pHandlerArray,
                                 int fFlags)
{
WBEditWindow *pRval;


  InternalCheckEWColors();

  pRval = (WBEditWindow *)malloc(sizeof(*pRval));

  if(!pRval)
  {
    WB_ERROR_PRINT("ERROR:  %s - not enough memory\n", __FUNCTION__);
    return NULL;
  }

  bzero(pRval, sizeof(*pRval));

  pRval->szFileName = NULL;  // explicitly do this, though the bzero would've
  pRval->nTextObjects = 0;
  pRval->nMaxTextObjects = 0;
  pRval->pTextObjects = NULL;


  if(0 > FWInitChildFrame(&(pRval->childframe), pOwner, pFont, szFocusMenu, pHandlerArray,
                          FWEditWindowEvent, fFlags))
  {
    WB_ERROR_PRINT("ERROR:  %s - unable to initialize child frame\n", __FUNCTION__);

    free(pRval);

    return NULL;
  }                    

  // assign my 'destructor', which will be called by FWDestroyChildFrame
  // THIS must be done LAST, since 'FWInitChildFrame' might call FWDestroyChildFrame on error
  // and I don't want to call the 'destructor' yet.
  pRval->childframe.destructor = InternalEditWindowDestructor;


  // TODO:  any other initialization belongs HERE.  if error, call FWDestroyChildFrame() and return
  //        a NULL immediately (since that would destroy the child frame AND the Edit Window stuff)


  return pRval;
}

// this function destroys any allocated objects in the WBEditWindow, but doesn't free the pointer
static void InternalEditWindowDestroy(WBEditWindow *pEditWindow)
{
  // these next 'things' are private to this particular 'class'

  if(pEditWindow->szFileName)
  {
    free(pEditWindow->szFileName);
    pEditWindow->szFileName = NULL;
  }

  if(pEditWindow->pTextObjects)
  {
    // TODO:  destroy them individually

    free(pEditWindow->pTextObjects);
    pEditWindow->pTextObjects = NULL;
  }
}

static void InternalEditWindowDestructor(WBChildFrame *pC)
{
  WBEditWindow *pEW = (WBEditWindow *)pC;

//  WB_ERROR_PRINT("TEMPORARY:  %s - destroying edit window %p\n", __FUNCTION__, pEW);

  InternalEditWindowDestroy(pEW);
  
  bzero(pEW, sizeof(*pEW)); // in case anything else 'stale' is there

  free(pEW);  

//  WB_ERROR_PRINT("TEMPORARY:  %s - destroyed edit window %p\n", __FUNCTION__, pEW);
}

void WBDestroyEditWindow(WBEditWindow *pEditWindow)
{
Window wID;

  if(pEditWindow->childframe.pUserCallback == FWEditWindowEvent)
  {
    pEditWindow->childframe.pUserCallback = NULL;  // prevents any kind of recursion from messages (unlikely)
  }

  if(pEditWindow->childframe.destructor == NULL)
  {
    WB_ERROR_PRINT("ERROR:  %s - destructor is NULL - pointer will not be free'd\n");    

    InternalEditWindowDestroy(pEditWindow); // perform the necessary destruction *ANYWAY* but don't free the pointer

    // TODO:  assign the destructor to NULL and call it directly after calling FWDestroyChildFrame() ?
  }

  FWDestroyChildFrame(&(pEditWindow->childframe)); // destroy window, free up all resources, call destructor (if not NULL)
}

WBEditWindow *WBEditWindowFromWindowID(Window wID)
{
  return (WBEditWindow *)FWGetChildFrameStruct(wID); // for now; later, use a tag to verify
}

int FWEditWindowEvent(Window wID, XEvent *pEvent)
{
WBEditWindow *pE;
GC gc;
WB_GEOM geom;
Display *pDisplay = WBGetWindowDisplay(wID);


  pE = WBEditWindowFromWindowID(wID);
  if(!pE)
  {
    return 0;
  }

  switch(pEvent->type)
  {
    case Expose:
//      WB_ERROR_PRINT("TEMPORARY:  %s - expose event\n", __FUNCTION__);
      geom.x = pEvent->xexpose.x;
      geom.y = pEvent->xexpose.y;
      geom.width = pEvent->xexpose.width;
      geom.height = pEvent->xexpose.height;

      // TEMPORARY - just erase the background, for now...
      gc = WBBeginPaintGeom(wID, &geom);

      XSetForeground(pDisplay, gc, clrBG.pixel);
      XSetBackground(pDisplay, gc, clrBG.pixel);
      XFillRectangle(pDisplay, wID, gc, geom.x, geom.y, geom.width - 2, geom.height - 2);

      WBEndPaint(wID, gc);
      
      return 1; // "handled"

    case DestroyNotify:
      // if I'm destroying ME, then I must free up the structure.
      // if this callback is being called, assume NOT recursive.

      if(pEvent->xdestroywindow.window == wID)
      {
        pE->childframe.wID = None; // assign 'none' as the window ID, since I already destroyed it.  don't re-destroy it.

        WBDestroyEditWindow(pE);  // this should fix everything else.
        
        return 1; // handled
      }

      break;
  }
  
  return 0; // for now, NONE are handled
}

