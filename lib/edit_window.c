//////////////////////////////////////////////////////////////////////////////////////////
//                  _  _  _                 _             _                             //
//         ___   __| |(_)| |_    __      __(_) _ __    __| |  ___ __      __  ___       //
//        / _ \ / _` || || __|   \ \ /\ / /| || '_ \  / _` | / _ \\ \ /\ / / / __|      //
//       |  __/| (_| || || |_     \ V  V / | || | | || (_| || (_) |\ V  V /_| (__       //
//        \___| \__,_||_| \__|_____\_/\_/  |_||_| |_| \__,_| \___/  \_/\_/(_)\___|      //
//                           |_____|                                                    //
//                                                                                      //
//                  a window into which you can type (and edit) text                    //
//                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2019 by Bob Frazier (aka 'Big Bad Bombastic Bob')


  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.
               Any claims to alleged functionality or features should be
               considered 'preliminary', and might not function as advertised.

  MIT-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  MIT-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>

#define _EDIT_WINDOW_C_IMPLEMENTED_

#include "window_helper.h"
#include "edit_window.h"
#include "conf_help.h"
#include "file_help.h"
#include "draw_text.h"

#include "dialog_window.h" // for message boxen
#include "dialog_controls.h" // for 'aDIALOG_INIT'


#if 0 // assign to 0 to disable this trace-style debugging ALL of the time
#define CALLBACK_TRACKER WBDebugPrint("TEMPORARY - edit_window.c:  %s - callback tracker\n", __FUNCTION__);
#else //
#define CALLBACK_TRACKER WB_DEBUG_PRINT((DebugLevel_Heavy | DebugSubSystem_EditWindow), "edit_window.c:  %s - callback tracker\n", __FUNCTION__);
#endif // 0,1

#define  EDIT_WINDOW_LINE_SPACING 4  /* 4 spaces between each line */

#define CALLBACK_CHECK_NULL(X) if(X) (X)
#define CALLBACK_CHECK_NULL2(X) (X) ? (X)


struct _PROPERTY_DLG_
{
  WBEditWindow *pEditWindow;
};




int FWEditWindowEvent(Window wID, XEvent *pEvent);
static void InternalEditWindowDestructor(WBChildFrame *pC);
static void InternalEditWindowDestroy(WBEditWindow *pEditWindow);

// UI callbacks for WBChildFrameUI

static void internal_do_char(WBChildFrame *, XClientMessageEvent *);   // handler for regular WB_CHAR Client Messages (WBChildFrame *, typed-in characters)
static void internal_scancode(WBChildFrame *, XClientMessageEvent *);  // handler for 'other scan code' WB_CHAR Client Messages (WBChildFrame *, typed-in characters)
static void internal_bkspace(WBChildFrame *, int iACS);                // 'backspace' delete character (WBChildFrame *, backspace equivalent).  'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
static void internal_del(WBChildFrame *, int iACS);                    // 'delete' char under cursor (WBChildFrame *, delete equivalent).  'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
static void internal_tab(WBChildFrame *, int iACS);                    // 'tab' char, or tab navigation.  'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
static void internal_enter(WBChildFrame *, int iACS);                  // 'enter' char, or 'enter' for navigation.  'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
static void internal_properties(WBChildFrame *);                       // display the property sheet for the displayed document (optional)
static void internal_uparrow(WBChildFrame *, int iACS);                // 'up' arrow navigation.  'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
static void internal_downarrow(WBChildFrame *, int iACS);              // 'down' arrow navigation.  'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
static void internal_leftarrow(WBChildFrame *, int iACS);              // 'left' arrow navigation.  'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
static void internal_rightarrow(WBChildFrame *, int iACS);             // 'right' arrow navigation.  'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
static void internal_home(WBChildFrame *, int iACS);                   // 'home' arrow navigation.  'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
static void internal_end(WBChildFrame *, int iACS);                    // 'end' arrow navigation.  'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
static void internal_pgup(WBChildFrame *, int iACS);                   // 'page up' navigation.  'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
static void internal_pgdown(WBChildFrame *, int iACS);                 // 'page down' navigation.  'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
static void internal_pgleft(WBChildFrame *, int iACS);                 // 'page left' navigation.  'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
static void internal_pgright(WBChildFrame *, int iACS);                // 'page right' navigation.  'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
static void internal_help(WBChildFrame *, int iACS);                   // 'help' context (WBChildFrame *, F1).  'iACS' is the Alt/Ctrl/Shift flags. \sa aWB_CHAR
static void internal_hover_notify(WBChildFrame *, int x, int y);       // 'mouse hover' notification (WBChildFrame *, x and y are pixel coords with respect to upper left corner)
static void internal_hover_cancel(WBChildFrame *);                     // 'mouse hover' cancel notification (WBChildFrame *, cancel any 'hover' action)
static int internal_is_ins_mode(WBChildFrame *);                       // returns non-zero if in 'insert' mode, 0 for 'overwrite'
static void internal_toggle_ins_mode(WBChildFrame *);                  // toggles insert mode on/off (WBChildFrame *, press 'INS' key)
static void internal_copy_to_cb(WBChildFrame *);                       // copy selection to clipboard
static void internal_paste_from_cb(WBChildFrame *);                    // paste from clipboard
static void internal_cut_to_cb(WBChildFrame *);                        // delete selection, copying to clipboard first
static void internal_delete_sel(WBChildFrame *);                       // delete selection only
static void internal_select_all(WBChildFrame *);                       // select all
static void internal_select_none(WBChildFrame *);                      // select none
static void internal_save(WBChildFrame *, const char *szFileName);     // save to specified file name (WBChildFrame *, NULL to keep same file name)
static WB_PCSTR internal_get_file_name(WBChildFrame *);                // get (const) pointer to file name string
static void internal_mouse_click(WBChildFrame *, int iX, int iY,
                                 int iButtonMask, int iACS);           // 'mouse click' notification.  \sa aWB_POINTER
static void internal_mouse_dblclick(WBChildFrame *, int iX, int iY,
                                    int iButtonMask, int iACS);        // 'mouse double click' notification.  \sa aWB_POINTER
static void internal_mouse_drag(WBChildFrame *, int iX, int iY,
                                int iButtonMask, int iACS);            // 'mouse drag' (begin) notification.  \sa aWB_POINTER
static void internal_mouse_drop(WBChildFrame *, int iX, int iY,
                                int iButtonMask, int iACS);            // 'mouse drop' (drag end) notification.  \sa aWB_POINTER
static void internal_mouse_move(WBChildFrame *, int iX, int iY);       // 'mouse motion' notification.  \sa aWB_POINTER
static void internal_scroll_vert(WBChildFrame *, int iMode, int iValue);  // 'scroll vertical' notification.  \details A higher-level scrolling notification.  'iMode' is 0 for absolute, 1 for relative.  'iValue' is the absolute (or relative) new vertical scroll position to assign  \sa aSCROLL_NOTIFY
static void internal_scroll_horiz(WBChildFrame *, int iMode, int iValue); // 'scroll vertical' notification.  \details A higher-level scrolling notification.  'iMode' is 0 for absolute, 1 for relative.  'iValue' is the absolute (or relative) new horizontal scroll position to assign  \sa aSCROLL_NOTIFY

static void internal_mouse_cancel(WBChildFrame *);                     // 'mouse cancel' notification (cancel 'drag', etc.).  \sa aWB_POINTER
static void internal_get_row_col(WBChildFrame *pC, int *piR, int *piC);// get row/col (etc.)
static int internal_has_selection(WBChildFrame *pC);                   // returns non-zero value if there is a selection
static void internal_undo(WBChildFrame *);                             // perform an undo
static void internal_redo(WBChildFrame *);                             // perform a re-do
static int internal_can_undo(WBChildFrame *);                          // returns non-zero value if 'can undo'
static int internal_can_redo(WBChildFrame *);                          // returns non-zero value if 'can redo'
static int internal_is_empty(WBChildFrame *);                          // returns non-zero value if 'empty'


static void internal_update_status_text(WBEditWindow *); // called whenever status text should change
static void internal_new_cursor_pos(WBEditWindow *); // called whenever cursor position changes.

static int PropertyDialogCallback(Window wID, XEvent *pEvent);



static XColor clrFG, clrBG, clrAFG, clrABG;
static int iInitColorFlag = 0;


static WBChildFrameUI internal_CFUI =
{
  CHILD_FRAME_UI_TAG,
  internal_do_char,         internal_scancode,     internal_bkspace,        internal_del,
  internal_tab,             internal_enter,        internal_properties,
  internal_uparrow,         internal_downarrow,
  internal_leftarrow,       internal_rightarrow,   internal_home,           internal_end,
  internal_pgup,            internal_pgdown,       internal_pgleft,         internal_pgright,
  internal_help,            internal_hover_notify, internal_hover_cancel,   internal_is_ins_mode,
  internal_toggle_ins_mode, internal_copy_to_cb,   internal_paste_from_cb,  internal_cut_to_cb,
  internal_delete_sel,      internal_select_all,   internal_select_none,    internal_save,
  internal_get_file_name,   internal_mouse_click,  internal_mouse_dblclick, internal_mouse_drag,
  internal_mouse_drop,      internal_mouse_move,   internal_scroll_vert,    internal_scroll_horiz,
  internal_mouse_cancel,    internal_get_row_col,  internal_has_selection,  internal_undo,
  internal_redo,            internal_can_undo,     internal_can_redo,       internal_is_empty
};



/** \ingroup edit_window
  * \hideinitializer
  * \brief Hover notification to user-callback, sent via ClientMessage event
  *
  * EW_HOVER_NOTIFY message format (relative to XEvent.xclient)\n
  * type == ClientMessage\n
  * message_type == aEW_HOVER_NOTIFY\n
  * format == 32 (always)\n
  * data.l[0] A value of 1 to indicate 'hover notify', zero to indicate 'hover cancel'\n
  * data.l[1] The current row (0-based) (hover notify only)\n
  * data.l[2] The current column (0-based) (hover notify only)\n
  *
  * The Edit Window sends this event directly to the callback specified by WBEditWindowRegisterCallback()
  * whenever the Edit Window receives a hover notification.  If no user callback is specified (i.e. it is NULL)
  * no such event will be generated the window itself.
**/
Atom aEW_HOVER_NOTIFY=None;

/** \ingroup edit_window
  * \hideinitializer
  * \brief 'Edit Change' notification to user-callback, sent via ClientMessage event
  *
  * EW_EDIT_CHANGE message format (relative to XEvent.xclient)\n
  * type == ClientMessage\n
  * message_type == aEW_EDIT_CHANGE\n
  * format == 32 (always)\n
  * data.l[0] A value of 1 to indicate text added or deleted, 2 for a 're-do', or 0 for an un-do operation\n"
  * data.l[1] The current row (0-based) (hover notify only)\n
  * data.l[2] The current column (0-based) (hover notify only)\n
  *
  * The Edit Window sends this event directly to the callback specified by WBEditWindowRegisterCallback()
  * whenever the Edit Window text has been modified due to UI interaction.  If no user callback is specified (i.e. it is NULL)
  * no such event will be generated the window itself.
**/
Atom aEW_EDIT_CHANGE=None;




#define LOAD_COLOR0(X,Y) if(CHGetResourceString(WBGetDefaultDisplay(), X, Y, sizeof(Y)) > 0) {  }
#define LOAD_COLOR(X,Y,Z) if(CHGetResourceString(WBGetDefaultDisplay(), X, Y, sizeof(Y)) <= 0){ WB_WARN_PRINT("%s - WARNING:  can't find color %s, using default value %s\n", __FUNCTION__, X, Z); strcpy(Y,Z); }

static void InternalCheckEWColorsAndAtoms(void)
{
  Colormap colormap;

  // *Frame.background, *Frame.foreground, *WmFrame.background, *WmFrame.foreground,
  // *Form.background, *Form.foreground, *background, *foreground

  if(aEW_EDIT_CHANGE == None)
  {
    aEW_EDIT_CHANGE = WBGetAtom(WBGetDefaultDisplay(), "EW_EDIT_CHANGE");
  }

  if(aEW_HOVER_NOTIFY == None)
  {
    aEW_HOVER_NOTIFY = WBGetAtom(WBGetDefaultDisplay(), "EW_HOVER_NOTIFY");
  }

  if(!iInitColorFlag)
  {
    char szFG[16], szBG[16], szAFG[16], szABG[16]; // note colors can typically be up to 13 characters + 0 byte

    colormap = DefaultColormap(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));

    // (these color names and standards have changed *WAY* too many times...)

    LOAD_COLOR0("*Text.foreground",szFG) else LOAD_COLOR0("*Edit.foreground", szFG)
     else LOAD_COLOR("*foreground", szFG, "#000000");
    LOAD_COLOR0("*Text.background",szBG) else LOAD_COLOR0("*Edit.background", szBG)
     else LOAD_COLOR("*background", szBG, "white"); // pure white background by default

    LOAD_COLOR("selected_bg_color", szABG, "#0040FF"); // a slightly greenish blue for the 'selected' BG color
    LOAD_COLOR("selected_fg_color", szAFG, "white");   // white FG when selected

    WB_ERROR_PRINT("TEMPORARY:  %s - edit window colors:  FG=%s BG=%s AFG=%s ABG=%s\n", __FUNCTION__,
                   szFG, szBG, szAFG, szABG);

    XParseColor(WBGetDefaultDisplay(), colormap, szFG, &clrFG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrFG);
    XParseColor(WBGetDefaultDisplay(), colormap, szBG, &clrBG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrBG);
    XParseColor(WBGetDefaultDisplay(), colormap, szAFG, &clrAFG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrAFG);
    XParseColor(WBGetDefaultDisplay(), colormap, szABG, &clrABG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrABG);

    iInitColorFlag = 1;
  }
}


WBEditWindow *WBCreateEditWindow(WBFrameWindow *pOwner, WB_FONT pFont,
                                 const char *szFocusMenu, const WBFWMenuHandler *pHandlerArray,
                                 int fFlags)
{
WBEditWindow *pRval;
Display *pDisplay;
int iRet;


  CALLBACK_TRACKER;

  InternalCheckEWColorsAndAtoms();

  if(!pOwner)
  {
    return NULL;
  }

  pDisplay = WBGetWindowDisplay(pOwner->wID);

  pRval = (WBEditWindow *)WBAlloc(sizeof(*pRval));

  if(!pRval)
  {
    WB_ERROR_PRINT("ERROR:  %s - not enough memory\n", __FUNCTION__);
    return NULL;
  }

  bzero(pRval, sizeof(*pRval));

  pRval->ulTag = EDIT_WINDOW_TAG;
  pRval->szFileName = NULL;  // explicitly do this, though the bzero would've
  pRval->pUserCallback = NULL; // explicitly do this, too

  WBInitializeInPlaceTextObject(&(pRval->xTextObject), None);
  pRval->xTextObject.vtable->set_linefeed(&(pRval->xTextObject), LineFeed_DEFAULT);

//  pRval->xTextObject.vtable->set_col(&(pRval->xTextObject), 0);
//  pRval->xTextObject.vtable->set_row(&(pRval->xTextObject), 0);


  // create the actual window.

  iRet = FWInitChildFrame(&(pRval->childframe), pOwner, pFont, // NOTE:  a copy of pFont will be in 'childframe.pFont'
                          szFocusMenu, pHandlerArray,
                          FWEditWindowEvent, fFlags);

  if(iRet < 0)
  {
    WB_ERROR_PRINT("ERROR:  %s - unable to initialize child frame\n", __FUNCTION__);

    WBFree(pRval);

    return NULL;
  }


  pRval->xTextObject.wIDOwner = pRval->childframe.wID; // TODO:  make assigning this an API function?


  // assign my 'UI' vtable pointer, which will be (intelligently) called by the 'Child Frame' event handler
  // this standardizes the various UI methods and makes coding a complex UI quite a bit easier
  pRval->childframe.pUI = &internal_CFUI; // Child Frame UI function vtable

  // assign my 'destructor', which will be called by FWDestroyChildFrame
  // THIS must be done LAST, since 'FWInitChildFrame' might call FWDestroyChildFrame on error
  // and I don't want to call the 'destructor' yet.
  pRval->childframe.destructor = InternalEditWindowDestructor;


  // TODO:  any other initialization belongs HERE.  if error, call FWDestroyChildFrame() and return
  //        a NULL immediately (since that would destroy the child frame AND the Edit Window stuff)


  internal_update_status_text(pRval); // update status text now.

  CreateTimer(WBGetWindowDisplay(pRval->childframe.wID), pRval->childframe.wID,
              333333, 1, 1);      // TODO:  use #define for timer ID and period (1/3 second for now))
  // NOTE:  when I unregister the window callback, the timer will be deleted automatically

  return pRval;
}

// this function destroys any allocated objects in the WBEditWindow, but doesn't free the pointer
static void InternalEditWindowDestroy(WBEditWindow *pEditWindow)
{
  // these next 'things' are private to this particular 'class'

  if(pEditWindow->szFileName)
  {
    WBFree(pEditWindow->szFileName);
    pEditWindow->szFileName = NULL;
  }

  WBDestroyInPlaceTextObject(&(pEditWindow->xTextObject));

  pEditWindow->ulTag = 0; // not valid any more
}

static void InternalEditWindowDestructor(WBChildFrame *pC)
{
  WBEditWindow *pEW = (WBEditWindow *)pC;

//  WB_ERROR_PRINT("TEMPORARY:  %s - destroying edit window %p\n", __FUNCTION__, pEW);

  InternalEditWindowDestroy(pEW);

  bzero(pEW, sizeof(*pEW)); // in case anything else 'stale' is there

  WBFree(pEW);

//  WB_ERROR_PRINT("TEMPORARY:  %s - destroyed edit window %p\n", __FUNCTION__, pEW);
}

void WBDestroyEditWindow(WBEditWindow *pEditWindow)
{
  if(!WBIsValidEditWindow(pEditWindow))
  {
    WB_ERROR_PRINT("ERROR:  %s - invalid Edit Window pointer %p\n", __FUNCTION__, pEditWindow);
    return;
  }

  if(pEditWindow->pUserCallback)
  {
    // TODO:  Send an aDESTROY_NOTIFY ClientMessage 'destroy' notification (once I document it)

    // TODO:  send a 'DestroyNotify' event instead???

    pEditWindow->pUserCallback = NULL;
  }

  if(pEditWindow->childframe.pUserCallback == FWEditWindowEvent)
  {
    pEditWindow->childframe.pUserCallback = NULL;  // prevents any kind of recursion from messages (unlikely)
  }

  if(pEditWindow->childframe.destructor == NULL)
  {
    WB_ERROR_PRINT("ERROR:  %s - destructor is NULL - pointer will not be free'd\n", __FUNCTION__);

    InternalEditWindowDestroy(pEditWindow); // perform the necessary destruction *ANYWAY* but don't free the pointer

    // TODO:  ALWAYS assign the destructor to NULL, and THEN call it directly after calling FWDestroyChildFrame() ?
  }

  if(pEditWindow->childframe.wID != None)
  {
    DeleteTimer(WBGetWindowDisplay(pEditWindow->childframe.wID),
                pEditWindow->childframe.wID, 1); // the preferred method, when practical, is to delete it explicitly
  }

  // the last step destroys the child frame, which will destroy the Edit Window as well

  FWDestroyChildFrame(&(pEditWindow->childframe)); // destroy window, free up all resources, call destructor (if not NULL)
}

WBEditWindow *WBEditWindowFromWindowID(Window wID)
{
WBEditWindow *pRval = (WBEditWindow *)FWGetChildFrameStruct(wID);


  if(pRval && !WBIsValidEditWindow(pRval))
  {
    pRval = NULL;
  }

  return pRval;
}


int WBEditWindowLoadFile(WBEditWindow *pEditWindow, const char *pszFileName)
{
char *pBuf = NULL;
long cbBuf = 0;
int iRval = -1;


  CALLBACK_TRACKER;

  if(!pEditWindow || !WBIsValidEditWindow(pEditWindow)
     || !pszFileName || !*pszFileName)
  {
    WBDebugPrint("TEMPORARY:  bad parameters in %s\n", __FUNCTION__);
    return -1;
  }

  // implement 'load file'.  handle unicode files.  UTF-16 files begin with 0xff, 0xfe
  // UTF-8 files are assumed to be the same as ASCII (with no prefix).


  if(pEditWindow->szFileName)
  {
    WBFree(pEditWindow->szFileName);
  }

//  pEditWindow->xTextObject.vtable->init(&(pEditWindow->xTextObject));
  WBEditWindowClear(pEditWindow);

  pEditWindow->szFileName = WBCopyString(pszFileName);
  pEditWindow->llModDateTime = WBGetFileModDateTime(pEditWindow->szFileName);

  // load the file into a buffer

  cbBuf = (long)WBReadFileIntoBuffer(pszFileName, &pBuf);

  if(cbBuf >= 0 && pBuf)
  {
    if(cbBuf >= 2 && (unsigned char)pBuf[0] == 0xff && (unsigned char)pBuf[1] == 0xfe)
    {
      // TODO:  unicode file!
//      pEditWindow->xTextObject.vtable->set_text(&(pEditWindow->xTextObject), pBuf + 2, cbBuf - 2);
    }
    else
    {
      // TODO:  fix line endings first??
      pEditWindow->xTextObject.vtable->set_row(&(pEditWindow->xTextObject),0);
      pEditWindow->xTextObject.vtable->set_col(&(pEditWindow->xTextObject),0);

//      internal_new_cursor_pos(pE);
      pEditWindow->xTextObject.vtable->set_text(&(pEditWindow->xTextObject), pBuf, cbBuf);
//      pEditWindow->xTextObject.vtable->ins_chars(&(pEditWindow->xTextObject), pBuf, cbBuf);

      pEditWindow->xTextObject.vtable->set_row(&(pEditWindow->xTextObject),0);
      pEditWindow->xTextObject.vtable->set_col(&(pEditWindow->xTextObject),0);
    }

    iRval = 0; // for now; later, check for error state
  }
  else
  {
    iRval = -1;
  }

  if(pBuf)
  {
    WBFree(pBuf);
  }

  FWChildFrameRecalcLayout(&(pEditWindow->childframe));

  if(pEditWindow->pUserCallback)
  {
    XClientMessageEvent evt;

    bzero(&evt, sizeof(evt));

    evt.type=ClientMessage;
    evt.display=WBGetWindowDisplay(pEditWindow->childframe.wID);
    evt.window=pEditWindow->childframe.wID;
    evt.message_type=aEW_EDIT_CHANGE;
    evt.format=32;

    evt.data.l[0] = 0; // undo
    evt.data.l[1] = 0; // cursor x,y
    evt.data.l[2] = 0;

    pEditWindow->pUserCallback(pEditWindow->childframe.wID, (XEvent *)&evt);
  }

  return iRval;
}

int WBEditWindowSaveFile(WBEditWindow *pEditWindow, const char *pszFileName)
{
  if(!pEditWindow || !WBIsValidEditWindow(pEditWindow))
  {
    return -1;
  }

  if(!pszFileName || !*pszFileName)
  {
    pszFileName = pEditWindow->szFileName;
  }

  if(!pszFileName || !*pszFileName)
  {
    return -1; // error (no file name)
  }

  // TODO:  implement 'file save'

  pEditWindow->llModDateTime = WBGetFileModDateTime(pEditWindow->szFileName);



  return -1; // error
}

void WBEditWindowClear(WBEditWindow *pEditWindow)
{
  if(!pEditWindow || !WBIsValidEditWindow(pEditWindow))
  {
    return;
  }

  WBDestroyInPlaceTextObject(&(pEditWindow->xTextObject));
  WBInitializeInPlaceTextObject(&(pEditWindow->xTextObject), pEditWindow->childframe.wID);
  pEditWindow->xTextObject.vtable->set_linefeed(&(pEditWindow->xTextObject), LineFeed_DEFAULT);

  FWChildFrameRecalcLayout(&(pEditWindow->childframe));
}

void WBEditWindowRegisterCallback(WBEditWindow *pEditWindow, WBWinEvent pUserCallback)
{
  if(!pEditWindow || !WBIsValidEditWindow(pEditWindow))
  {
    return;
  }

  pEditWindow->pUserCallback = pUserCallback;
}



///////////////////////////////////////////////////////////////////////////////////
//                                                                               //
//   _____                     _     _   _                    _  _               //
//  | ____|__   __ ___  _ __  | |_  | | | |  __ _  _ __    __| || |  ___  _ __   //
//  |  _|  \ \ / // _ \| '_ \ | __| | |_| | / _` || '_ \  / _` || | / _ \| '__|  //
//  | |___  \ V /|  __/| | | || |_  |  _  || (_| || | | || (_| || ||  __/| |     //
//  |_____|  \_/  \___||_| |_| \__| |_| |_| \__,_||_| |_| \__,_||_| \___||_|     //
//                                                                               //
//                                                                               //
///////////////////////////////////////////////////////////////////////////////////



int FWEditWindowEvent(Window wID, XEvent *pEvent)
{
WBEditWindow *pE;
WBGC gc;
WB_GEOM geom;//, geom2;
Display *pDisplay = WBGetWindowDisplay(wID);


  pE = WBEditWindowFromWindowID(wID);
  if(!pE)
  {
    return 0;
  }

  switch(pEvent->type)
  {
    case Expose:
//      WB_ERROR_PRINT("TEMPORARY:  %s - expose event\n", __FUNCTION__);
      geom.x = pEvent->xexpose.x;
      geom.y = pEvent->xexpose.y;
      geom.width = pEvent->xexpose.width;
      geom.height = pEvent->xexpose.height;

      // TEMPORARY - just erase the background, for now...
      gc = WBBeginPaintGeom(wID, &geom);

      WBSetBackground(gc, clrBG.pixel);

//      WBGetWindowGeom(wID, &geom2);
//
//      // this is client geometry, not window geometry, so fix it
//      geom2.x = 1;       // 1-pixel border
//      geom2.y = 1;
//      geom2.width -= 2; // 1 pixel border on BOTH sides
//      geom2.height -= 2;
//
// NOTE:  for some reason this un-does what happens later in do_expose() ... maybe XSync after?
//      WBSetForeground(gc, clrBG.pixel);
//      WBFillRectangle(pDisplay, wID, gc, geom2.x, geom2.y, geom2.width, geom2.height);

      WBSetForeground(gc, clrFG.pixel);

      // TODO:  'split' handling - 2 different sections must be painted separately

      CALLBACK_CHECK_NULL(pE->xTextObject.vtable->do_expose)(&(pE->xTextObject), pDisplay, wID, gc,
                                                             &geom, // the GEOM to 'paint to'
                                                             &(pE->childframe.geom),//NULL,//&geom2, // the GEOM bordering the window's viewport (NULL for ALL)
                                                             pE->childframe.pFont);
      WBEndPaint(wID, gc);

      return 1; // "handled"

    case DestroyNotify:
      // if I'm destroying ME, then I must free up the structure.
      // if this callback is being called, assume NOT recursive.

      if(pEvent->xdestroywindow.window == wID)
      {
        pE->childframe.wID = None; // assign 'none' as the window ID, since I already destroyed it.  don't re-destroy it.

        WBDestroyEditWindow(pE);  // this should fix everything else.

        return 1; // handled
      }

      break;

    case ClientMessage:
      if(pEvent->xclient.message_type == aRESIZE_NOTIFY ||
         pEvent->xclient.message_type == aRECALC_LAYOUT)
      {
        WB_RECT rctView;

        rctView.top = CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_row)(&(pE->xTextObject)) : 0;
        rctView.left = CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_col)(&(pE->xTextObject)) : 0;

        CALLBACK_CHECK_NULL(pE->xTextObject.vtable->get_view)(&(pE->xTextObject), &rctView);

        // TODO:  process re-calculation of the extents, etc.

        FWSetChildFrameScrollInfo(&(pE->childframe),
                                  rctView.top,
                                  CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_rows)(&(pE->xTextObject)) : 0,
                                  rctView.left,
                                  CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_cols)(&(pE->xTextObject)) : 0,
                                  WBTextObjectCalculateLineHeight(WBFontAscent(pE->childframe.pFont),
                                                                  WBFontDescent(pE->childframe.pFont)),
                                  WBFontAvgCharWidth(pE->childframe.pFont));
//                                  pE->childframe.pFont->ascent + pE->childframe.pFont->ascent + EDIT_WINDOW_LINE_SPACING,
      }
      else if(pEvent->xclient.message_type == aWB_TIMER)
      {
        static int iTimerThingy = 0;

        // only when this tab is visible do I call the callback.

        if(pE->childframe.pOwner && // just in case
           FWGetChildFrameIndex(pE->childframe.pOwner, NULL)                // focus window's tab index
            == FWGetChildFrameIndex(pE->childframe.pOwner, &(pE->childframe))) // THIS window's tab index
        {
//          WB_ERROR_PRINT("TEMPORARY:  %s - timer\n", __FUNCTION__);

          CALLBACK_CHECK_NULL(pE->xTextObject.vtable->cursor_blink)(&(pE->xTextObject), 1);

          if(iTimerThingy >= 0)
          {
            iTimerThingy ++; // again, only when I have the focus do I do this
            iTimerThingy &= 3;

            if(!iTimerThingy && pE->szFileName && pE->szFileName[0])
            {
              // see if the file was modified

              int iTemp = WBCheckFileModDateTime(pE->szFileName, pE->llModDateTime);

              if(iTemp != 0)
              {
                iTimerThingy = -1; // so I don't recursively do this

                if(iTemp > 0)
                {
                  if(DLGMessageBox(MessageBox_YesNo | MessageBox_Question, wID,
                      "File Modified", "This file has been modified on disk - reload?")
                     == IDYES)
                  {
                    // TODO:  re-load the file
do_file_reload:
                    DLGMessageBox(MessageBox_OK | MessageBox_Error, wID,
                                  "File Modified", "file re-load not (yet) implemented");
                  }
                }
                else if(iTemp < 0)
                {
                  if(DLGMessageBox(MessageBox_YesNo | MessageBox_Error, wID,
                                   "File Modified", "file mod date is OLDER than before - what happened?\n\nDo you want to reload it?")
                                   == IDYES)
                  {
                    goto do_file_reload;
                  }
                }

                pE->llModDateTime = WBGetFileModDateTime(pE->szFileName); // re-assign so I don't show 'mod' again

                iTimerThingy = 0; // so I don't eternally BLOCK this
              }
            }
          }
        }
      }
      else if(pEvent->xclient.message_type == aQUERY_CLOSE)
      {
        if(pE->pUserCallback)
        {
          int iRval = pE->pUserCallback(wID, pEvent);  // allow the user callback to determine when to close

          if(iRval)
          {
            return iRval;
          }
        }

        return 0; // for now, just return 'ok to close' whether I've saved or not
      }
  }

  return 0; // "not handled"
}



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//         _   _  ___    ____        _  _  _                   _            //
//        | | | ||_ _|  / ___| __ _ | || || |__    __ _   ___ | | __        //
//        | | | | | |  | |    / _` || || || '_ \  / _` | / __|| |/ /        //
//        | |_| | | |  | |___| (_| || || || |_) || (_| || (__ |   <         //
//         \___/ |___|  \____|\__,_||_||_||_.__/  \__,_| \___||_|\_\        //
//                                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


static void internal_update_status_text(WBEditWindow *pE) // called whenever cursor position changes.
{
WBChildFrame *pC = &(pE->childframe);
int iR, iC;
char tbuf[1024];

  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  internal_get_row_col(pC, &iR, &iC);

  if(pC->szStatusText)
  {
    WBFree(pC->szStatusText);
    pC->szStatusText = NULL;
  }

  snprintf(tbuf, sizeof(tbuf), "Row,Col: %d,%d\tlines: %d  width: %d\t%s\t",
          iR, iC,
          CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_rows)(&(pE->xTextObject)) : 0,
          CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_cols)(&(pE->xTextObject)) : 0,
          (const char *)((CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_insmode)(&(pE->xTextObject)) : 0)
                         == InsertMode_INSERT ? "INS" :
            (const char *)((CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_insmode)(&(pE->xTextObject)) : 0)
                           == InsertMode_OVERWRITE ? "OVR" : "???")));

  pC->szStatusText = WBCopyString(tbuf);

  if(!pC->szStatusText)
  {
    WB_ERROR_PRINT("ERROR:  %s - not enough memory to display status\n", __FUNCTION__);
  }

  FWChildFrameStatusChanged(pC);
}

static void internal_new_cursor_pos(WBEditWindow *pE) // called whenever cursor position changes.
{
  CALLBACK_TRACKER;

  if(WBIsValidEditWindow(pE))
  {
    internal_update_status_text(pE);

    // see if the row exceeds the viewport, and if that's the case, scroll it.



    // TODO:  other things, like messing with the display area, re-calc layout, re-paint, etc.
    //        check to see if top/bottom rows changed, invalidate old line, validate new line, see if
    //        horizontal scrolling entire window or just the cursor, etc. etc. etc.
  }
}

static void internal_notify_change(WBChildFrame *pC, int bUndo)
{
WBEditWindow *pE = (WBEditWindow *)pC;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  if(pE->pUserCallback)
  {
    XClientMessageEvent evt;

    bzero(&evt, sizeof(evt));

    evt.type=ClientMessage;
    evt.display=WBGetWindowDisplay(pC->wID);
    evt.window=pC->wID;
    evt.message_type=aEW_EDIT_CHANGE;
    evt.format=32;

    evt.data.l[0] = bUndo;
    evt.data.l[1] = CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_row)(&(pE->xTextObject)) : 0;
    evt.data.l[2] = CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_col)(&(pE->xTextObject)) : 0;

    pE->pUserCallback(pC->wID, (XEvent *)&evt);
  }
}

static void internal_do_char(WBChildFrame *pC, XClientMessageEvent *pEvent)
{
WBEditWindow *pE = (WBEditWindow *)pC;
int iKey, iACS, nChar;
char *pBuf;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  // TODO:  determine whether or not the character is printable

  iKey = pEvent->data.l[0];            // result from WBKeyEventProcessKey()
  iACS = pEvent->data.l[1];
  nChar = pEvent->data.l[2];
  pBuf = (char *)&(pEvent->data.l[3]);

  if(iACS && (iACS & WB_KEYEVENT_ACSMASK) != WB_KEYEVENT_SHIFT) // only SHIFT can be used here
  {
    // TODO:  handle non-printing chars

    XBell(WBGetWindowDisplay(pC->wID), -100); // for now give audible feedback that I'm ignoring it
    WB_ERROR_PRINT("TEMPORARY:  %s - beep\n", __FUNCTION__);
  }
  else if(CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->has_select)(&(pE->xTextObject)) : 0)
  {
//    WB_ERROR_PRINT("TEMPORARY:  %s - set text to \"%.*s\"\n", __FUNCTION__, nChar, pBuf);
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->set_text)(&(pE->xTextObject), pBuf, nChar);
    internal_notify_change(pC, 0);
  }
  else
  {
//    WB_ERROR_PRINT("TEMPORARY:  %s - inserting \"%.*s\"\n", __FUNCTION__, nChar, pBuf);
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->ins_chars)(&(pE->xTextObject), pBuf, nChar);
    internal_notify_change(pC, 0);
  }

//  {
//    char *p1 = CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_text)(&(pE->xTextObject)) : NULL;
//
//    WB_ERROR_PRINT("TEMPORARY:  %s - new text \"%s\"\n", __FUNCTION__, (const char *)(p1 ? p1 : "{null}"));
//
//    if(p1)
//    {
//      WBFree(p1);
//    }
//  }

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_scancode(WBChildFrame *pC, XClientMessageEvent *pEvent)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  // TODO:  handle things I might want, like 'indent' which might be ctrl+[ or ctrl+], or maybe
  //        ctrl+tab or ctrl+shift+tab


  XBell(WBGetWindowDisplay(pC->wID), -100); // for now give audible feedback that I'm ignoring it
}

static void internal_bkspace(WBChildFrame *pC, int iACS)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  if(iACS & WB_KEYEVENT_ACSMASK) // not handling ctrl, shift, or alt with backspace.  yet.
  {
    XBell(WBGetWindowDisplay(pC->wID), -100); // for now give audible feedback that I'm ignoring it
  }
  else
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->del_chars)(&(pE->xTextObject), -1);
    internal_notify_change(pC, 0);
  }

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_del(WBChildFrame *pC, int iACS)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  // shift+del does 'cut' behavior

  if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift+del
  {
    if(!(CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->has_select)(&(pE->xTextObject)) : 0))
    {
      // no selection, can't "cut"
      XBell(WBGetWindowDisplay(pC->wID), -100);
    }
    else
    {
      // copy selection to the clipboard, then delete - same as internal_cut_to_cb()

      char *p1 = CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_sel_text)(&(pE->xTextObject), NULL): NULL;
      if(p1)
      {
        WBSetClipboardData(WBGetWindowDisplay(pC->wID), aUTF8_STRING, 8, p1, strlen(p1) + 1);

        WBFree(p1);

        CALLBACK_CHECK_NULL(pE->xTextObject.vtable->del_select)(&(pE->xTextObject));
        internal_notify_change(pC, 0);
      }
    }
  }
  else if(CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->has_select)(&(pE->xTextObject)) : 0)
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->del_select)(&(pE->xTextObject));
    internal_notify_change(pC, 0);
  }
  else
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->del_chars)(&(pE->xTextObject), 1);
    internal_notify_change(pC, 0);
  }

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_tab(WBChildFrame *pC, int iACS)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  // if there's a selection, indent it??

  if(iACS & WB_KEYEVENT_ACSMASK) // not handling ctrl, shift, or alt with tab.  yet.
  {
    XBell(WBGetWindowDisplay(pC->wID), -100); // for now give audible feedback that I'm ignoring it
  }
  else
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->ins_chars)(&(pE->xTextObject), "\t", 1);
    internal_notify_change(pC, 0);
  }

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_enter(WBChildFrame *pC, int iACS)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  if(iACS & WB_KEYEVENT_ACSMASK) // not handling ctrl, shift, or alt with 'enter'.  yet.
  {
    XBell(WBGetWindowDisplay(pC->wID), -100); // for now give audible feedback that I'm ignoring it
  }
  else
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->ins_chars)(&(pE->xTextObject), "\n", 1);
    internal_notify_change(pC, 0);
  }

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_properties(WBChildFrame *pC)
{
WBEditWindow *pE = (WBEditWindow *)pC;
WBDialogWindow *pDlg;
int iX, iY;
WB_GEOM geomParent;
Window wIDDlg;
struct _PROPERTY_DLG_ propdlg;
static const char szPropertiesDlgBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:200 WIDTH:300 TITLE:\"Document Properties\"\n"
  "  CONTROL:Text TITLE:\"Document Properties\" X:30 Y:2 WIDTH:240 HEIGHT:17 VISIBLE HALIGN_TEXT_CENTER VALIGN_TEXT_CENTER\n"
  "  CONTROL:CheckButton ID:1001 TITLE:\"Use Hard _Tabs\" X:40 Y:38 WIDTH:80 HEIGHT:15 VISIBLE\n"
  "  CONTROL:Text TITLE:\"Line ending:\" X:10 Y:51 WIDTH:60 HEIGHT:17 VISIBLE HALIGN_TEXT_RIGHT VALIGN_TEXT_CENTER NOBORDER\n"
  "  CONTROL:FirstRadioButton ID:1002 TITLE:\"_LF\" X:70 Y:52 WIDTH:40 HEIGHT:15 VISIBLE HALIGN_TEXT_LEFT VALIGN_TEXT_CENTER CHECKED\n"
  "  CONTROL:RadioButton ID:1003 TITLE:\"C_R\" X:110 Y:52 WIDTH:40 HEIGHT:15 HALIGN_TEXT_LEFT VALIGN_TEXT_CENTER VISIBLE\n"
  "  CONTROL:RadioButton ID:1004 TITLE:\"_CR+LF\" X:150 Y:52 WIDTH:40 HEIGHT:15 HALIGN_TEXT_LEFT VALIGN_TEXT_CENTER VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDOK TITLE:Sa_ve X:80 Y:178 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:CancelButton ID:IDCANCEL TITLE:Cancel X:180 Y:178 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  // TODO:  check for owner-defined property dialog and display default if none

  WBGetWindowGeom0(pC->wID, &geomParent); // parent geometry in absolute coordinates

  iX = geomParent.x + geomParent.border + 50;
  iY = geomParent.y + geomParent.border - 50;

  propdlg.pEditWindow = pE; // custom data sent to dialog box

  pDlg = DLGCreateDialogWindow("Document Properties", szPropertiesDlgBox, iX, iY,
                               300, 200, // the values also specified in the resource
                               PropertyDialogCallback,
                               WBDialogWindow_VISIBLE, &propdlg);


  if(pDlg) // TODO:  manage this stuff as part of 'DLGCreateDialogWindow' instead
  {
    wIDDlg = pDlg->wID;

    if(pC->wID != None) // owned dialog box needs certain properties set
    {
      Atom a1;
      unsigned int ai1[3];

      DLGAssignOwner(pDlg, pC->wID);

      a1 = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE", False);
      ai1[0] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_TASKBAR", False);
      ai1[1] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_PAGER", False);

      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_ATOM, 32, PropModeReplace, (unsigned char *)ai1, 2);

      a1 = XInternAtom(WBGetWindowDisplay(wIDDlg), "WM_TRANSIENT_FOR", False);
      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_WINDOW, 32, PropModeReplace, (unsigned char *)&(pC->wID), 1);
    }

//    WBSetWindowIcon(wIDDlg, );
//    WB_ERROR_PRINT("TEMPORARY:  %s - calling WBShowModal\n", __FUNCTION__);

    if(WBShowModal(wIDDlg, 0) == IDOK)
    {
      FWChildFrameRecalcLayout(pC);
//      WBInvalidateGeom(pC->wID, NULL, 1); // invalidate and re-paint with new properties, etc. configured
    }
  }

}

static void internal_uparrow(WBChildFrame *pC, int iACS)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift-uparrow
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->begin_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->cursor_up)(&(pE->xTextObject));
  }
  else if((iACS & WB_KEYEVENT_ACSMASK) == (WB_KEYEVENT_SHIFT | WB_KEYEVENT_CTRL)) // ctrl-shift-uparrow
  {
    // select to start of paragraph?
    XBell(WBGetWindowDisplay(pC->wID), -100); // for now give audible feedback that I'm ignoring it
  }
  else if(iACS & WB_KEYEVENT_ACSMASK) // not handling ctrl, shift, or alt with 'up'.  yet.
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->end_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    XBell(WBGetWindowDisplay(pC->wID), -100); // for now give audible feedback that I'm ignoring it
  }
  else
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->end_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->cursor_up)(&(pE->xTextObject));
  }

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_downarrow(WBChildFrame *pC, int iACS)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift-downarrow
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->begin_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->cursor_down)(&(pE->xTextObject));
  }
  else if((iACS & WB_KEYEVENT_ACSMASK) == (WB_KEYEVENT_SHIFT | WB_KEYEVENT_CTRL)) // ctrl-shift-downarrow
  {
    // select to start of paragraph?
    XBell(WBGetWindowDisplay(pC->wID), -100); // for now give audible feedback that I'm ignoring it
  }
  else if(iACS & WB_KEYEVENT_ACSMASK) // not handling ctrl, shift, or alt with 'up'.  yet.
  {
    XBell(WBGetWindowDisplay(pC->wID), -100); // for now give audible feedback that I'm ignoring it
  }
  else
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->end_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->cursor_down)(&(pE->xTextObject));
  }

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_leftarrow(WBChildFrame *pC, int iACS)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift-leftarrow
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->begin_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->cursor_left)(&(pE->xTextObject));
  }
  else if((iACS & WB_KEYEVENT_ACSMASK) == (WB_KEYEVENT_SHIFT | WB_KEYEVENT_CTRL)) // ctrl-shift-leftarrow
  {
    // select to start of previous word?  end of previous word?
    XBell(WBGetWindowDisplay(pC->wID), -100); // for now give audible feedback that I'm ignoring it
  }
  else if(iACS & WB_KEYEVENT_ACSMASK) // not handling ctrl, shift, or alt with 'left'.  yet.
  {
    WB_ERROR_PRINT("TEMPORARY:  %s - iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

    XBell(WBGetWindowDisplay(pC->wID), -100); // for now give audible feedback that I'm ignoring it
  }
  else
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->end_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->cursor_left)(&(pE->xTextObject));
  }

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_rightarrow(WBChildFrame *pC, int iACS)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift-rightarrow
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->begin_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->cursor_right)(&(pE->xTextObject));
  }
  else if((iACS & WB_KEYEVENT_ACSMASK) == (WB_KEYEVENT_SHIFT | WB_KEYEVENT_CTRL)) // ctrl-shift-rightarrow
  {
    // select to end of word?  start of next word?
    XBell(WBGetWindowDisplay(pC->wID), -100); // for now give audible feedback that I'm ignoring it
  }
  else if(iACS & WB_KEYEVENT_ACSMASK) // not handling ctrl, shift, or alt with 'right'.  yet.
  {
    WB_ERROR_PRINT("TEMPORARY:  %s - iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

    XBell(WBGetWindowDisplay(pC->wID), -100); // for now give audible feedback that I'm ignoring it
  }
  else
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->end_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->cursor_right)(&(pE->xTextObject));
  }

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_home(WBChildFrame *pC, int iACS)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift-home
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->begin_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->cursor_home)(&(pE->xTextObject));
  }
  else if((iACS & WB_KEYEVENT_ACSMASK) == (WB_KEYEVENT_SHIFT | WB_KEYEVENT_CTRL)) // ctrl-shift-home
  {
    // select to start of document
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->begin_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->cursor_top)(&(pE->xTextObject));
  }
  else if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL) // control+home
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->end_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->cursor_top)(&(pE->xTextObject));
  }
  else if(iACS & WB_KEYEVENT_ACSMASK) // not handling shift, or alt with 'home'.  yet.
  {
    WB_ERROR_PRINT("TEMPORARY:  %s - iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

    XBell(WBGetWindowDisplay(pC->wID), -100); // for now give audible feedback that I'm ignoring it
  }
  else
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->end_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->cursor_home)(&(pE->xTextObject));
  }

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_end(WBChildFrame *pC, int iACS)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift-end
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->begin_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->cursor_end)(&(pE->xTextObject));
  }
  else if((iACS & WB_KEYEVENT_ACSMASK) == (WB_KEYEVENT_SHIFT | WB_KEYEVENT_CTRL)) // ctrl-shift-end
  {
    // select to end of document
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->begin_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->cursor_bottom)(&(pE->xTextObject));
  }
  else if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_CTRL) // control+end
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->end_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->cursor_bottom)(&(pE->xTextObject));
  }
  else if(iACS & WB_KEYEVENT_ACSMASK) // not handling shift, or alt with 'end'.  yet.
  {
    WB_ERROR_PRINT("TEMPORARY:  %s - iACS=%d (%08xH)\n", __FUNCTION__, iACS, iACS);

    XBell(WBGetWindowDisplay(pC->wID), -100); // for now give audible feedback that I'm ignoring it
  }
  else
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->end_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->cursor_end)(&(pE->xTextObject));
  }

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_pgup(WBChildFrame *pC, int iACS)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift-pgup
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->begin_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->page_up)(&(pE->xTextObject));
  }
  else if(iACS & WB_KEYEVENT_ACSMASK) // not handling ctrl or alt.  yet.
  {
    XBell(WBGetWindowDisplay(pC->wID), -100); // for now give audible feedback that I'm ignoring it
  }
  else
  {
//    WB_ERROR_PRINT("TEMPORARY:  %s - WBChildFrame calling 'page_up'\n", __FUNCTION__);

    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->end_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->page_up)(&(pE->xTextObject));
  }

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_pgdown(WBChildFrame *pC, int iACS)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  if((iACS & WB_KEYEVENT_ACSMASK) == WB_KEYEVENT_SHIFT) // shift-pgdown
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->begin_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->page_down)(&(pE->xTextObject));
  }
  else if(iACS & WB_KEYEVENT_ACSMASK) // not handling ctrl or alt.  yet.
  {
    XBell(WBGetWindowDisplay(pC->wID), -100); // for now give audible feedback that I'm ignoring it
  }
  else
  {
//    WB_ERROR_PRINT("TEMPORARY:  %s - WBChildFrame calling 'page_down'\n", __FUNCTION__);

    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->end_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->page_down)(&(pE->xTextObject));
  }

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_pgleft(WBChildFrame *pC, int iACS)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  if((iACS & WB_KEYEVENT_ACSMASK) == (WB_KEYEVENT_SHIFT | WB_KEYEVENT_CTRL)) // ctrl-shift-pgup
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->begin_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->page_left)(&(pE->xTextObject));
  }
  else if((iACS & WB_KEYEVENT_ACSMASK) != WB_KEYEVENT_CTRL) // not handling alt with 'pgup'.  yet.
  {
    XBell(WBGetWindowDisplay(pC->wID), -100); // for now give audible feedback that I'm ignoring it
  }
  else // CTRL-pgup
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->end_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->page_left)(&(pE->xTextObject));
  }

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_pgright(WBChildFrame *pC, int iACS)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  if((iACS & WB_KEYEVENT_ACSMASK) == (WB_KEYEVENT_SHIFT | WB_KEYEVENT_CTRL)) // ctrl-shift-pgdn
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->begin_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->page_right)(&(pE->xTextObject));
  }
  else if((iACS & WB_KEYEVENT_ACSMASK) != WB_KEYEVENT_CTRL) // not handling alt with 'pgup'.  yet.
  {
    XBell(WBGetWindowDisplay(pC->wID), -100); // for now give audible feedback that I'm ignoring it
  }
  else
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->end_highlight)(&(pE->xTextObject)); // safe to call any time, multiple times
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->page_right)(&(pE->xTextObject));
  }

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_help(WBChildFrame *pC, int iACS)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

}

static void internal_hover_notify(WBChildFrame *pC, int x, int y)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

}

static void internal_hover_cancel(WBChildFrame *pC)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

}

static int internal_is_ins_mode(WBChildFrame *pC)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return -1;
  }

  return (CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_insmode)(&(pE->xTextObject)) : InsertMode_INSERT)
         == InsertMode_INSERT;
}

static void internal_toggle_ins_mode(WBChildFrame *pC)
{
WBEditWindow *pE = (WBEditWindow *)pC;
int iInsMode;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  iInsMode = (CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_insmode)(&(pE->xTextObject)) : InsertMode_INSERT)
             == InsertMode_INSERT;
  CALLBACK_CHECK_NULL(pE->xTextObject.vtable->set_insmode)(&(pE->xTextObject), iInsMode ? InsertMode_OVERWRITE : InsertMode_INSERT);

  internal_new_cursor_pos((WBEditWindow *)pC);
  internal_update_status_text(pE);
}

static void internal_copy_to_cb(WBChildFrame *pC)
{
WBEditWindow *pE = (WBEditWindow *)pC;
char *p1;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  // copy selection to the clipboard

  if(CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->has_select)(&(pE->xTextObject)) : 0)
  {
    p1 = CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_sel_text)(&(pE->xTextObject), NULL) : NULL;

    if(p1)
    {
      WBSetClipboardData(WBGetWindowDisplay(pC->wID), aUTF8_STRING, 8, p1, strlen(p1) + 1);

      WBFree(p1);
    }
  }
  else
  {
    // no selection, can't "copy"

    XBell(WBGetWindowDisplay(pC->wID), -100);
  }
}

static void internal_paste_from_cb(WBChildFrame *pC)
{
WBEditWindow *pE = (WBEditWindow *)pC;
Atom aType = aUTF8_STRING;
int iFormat = 8;
unsigned long nData = 0;
char *p1;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  // copy selection to the clipboard, then delete - same as internal_cut_to_cb()

  p1 = (char *)WBGetClipboardData(WBGetWindowDisplay(pC->wID), &aType, &iFormat, &nData);
  if(!p1) // try regular string, not UTF8
  {
    aType = aSTRING;
    p1 = (char *)WBGetClipboardData(WBGetWindowDisplay(pC->wID), &aType, &iFormat, &nData);
  }

  if(p1 && nData > 0)
  {
    if(!p1[nData - 1])
    {
      nData--;
    }
  }


  if(p1)
  {
    // TODO:  convert to correct format (ASCII)
    if(iFormat != 8) // 16-bit unicode is assumed now
    {
      if(iFormat == 8 * sizeof(wchar_t))
      {
        char *pNew = WBAlloc(sizeof(wchar_t) * (nData + 2));
        if(pNew)
        {
          bzero(pNew, sizeof(wchar_t) * (nData + 2));
          wcstombs(pNew, (const wchar_t *)p1, sizeof(wchar_t) * (nData + 2));
        }

        WBFree(p1);
        p1 = pNew;
        nData = strlen(p1);
      }
      else
      {
        XBell(WBGetWindowDisplay(pC->wID), -100);
        WB_ERROR_PRINT("TEMPORARY - %s - clipboard format %d, can't 'PASTE'\n", __FUNCTION__, iFormat);

        WBFree(p1);
        p1 = NULL; // by convention - also, checked in next section
      }
    }

    if(p1)
    {
      WBDebugDump("Edit window 'paste'", p1, nData);

      if(CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->has_select)(&(pE->xTextObject)) : 0)
      {
        CALLBACK_CHECK_NULL(pE->xTextObject.vtable->replace_select)(&(pE->xTextObject), p1, nData);
        internal_notify_change(pC, 0);
      }
      else
      {
        CALLBACK_CHECK_NULL(pE->xTextObject.vtable->ins_chars)(&(pE->xTextObject), p1, nData);
        internal_notify_change(pC, 0);
      }

      WBFree(p1);
      p1 = NULL; // by convention
    }
  }

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_cut_to_cb(WBChildFrame *pC)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  if(!(CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->has_select)(&(pE->xTextObject)) : 0))
  {
    // no selection, can't "cut"
    XBell(WBGetWindowDisplay(pC->wID), -100);
  }
  else
  {
    // copy selection to the clipboard, then delete - same as internal_cut_to_cb()

    char *p1 = CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_sel_text)(&(pE->xTextObject), NULL) : NULL;
    if(p1)
    {
      WBSetClipboardData(WBGetWindowDisplay(pC->wID), aUTF8_STRING, 8, p1, strlen(p1) + 1);

      WBFree(p1);

      CALLBACK_CHECK_NULL(pE->xTextObject.vtable->del_select)(&(pE->xTextObject));
      internal_notify_change(pC, 0);
    }
  }

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_delete_sel(WBChildFrame *pC)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  if(!(CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->has_select)(&(pE->xTextObject)) : 0))
  {
    // no selection, can't "cut"
    XBell(WBGetWindowDisplay(pC->wID), -100);
  }
  else
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->del_select)(&(pE->xTextObject));
    internal_notify_change(pC, 0);
  }

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_select_all(WBChildFrame *pC)
{
WBEditWindow *pE = (WBEditWindow *)pC;
WB_RECT rct;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  rct.left = rct.top = 0;
  rct.right = CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_cols)(&(pE->xTextObject)) : 0;
  rct.bottom = CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_rows)(&(pE->xTextObject)) : 0;

  WB_ERROR_PRINT("TEMPORARY:  %s - selecting %d,%d,%d,%d\n", __FUNCTION__,
                 rct.left, rct.top, rct.right, rct.bottom);

  CALLBACK_CHECK_NULL(pE->xTextObject.vtable->set_select)(&(pE->xTextObject), &rct); // select 'all'

//#if 1
//  CALLBACK_CHECK_NULL(pE->xTextObject.vtable->get_select)(&(pE->xTextObject), &rct); // get selection for testing
//
//  WB_ERROR_PRINT("TEMPORARY:  %s - selected %d,%d,%d,%d\n", __FUNCTION__,
//                 rct.left, rct.top, rct.right, rct.bottom);
//#endif // 1

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_select_none(WBChildFrame *pC)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  CALLBACK_CHECK_NULL(pE->xTextObject.vtable->set_select)(&(pE->xTextObject), NULL);

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_save(WBChildFrame *pC, const char *szFileName)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  WBEditWindowSaveFile(pE, szFileName);
}

static WB_PCSTR internal_get_file_name(WBChildFrame *pC)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return NULL;
  }

  return pE->szFileName;
}

static void internal_mouse_click(WBChildFrame *pC, int iX, int iY, int iButtonMask, int iACS)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  CALLBACK_CHECK_NULL(pE->xTextObject.vtable->mouse_click)(&(pE->xTextObject), iX, iY, iButtonMask, iACS);

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_mouse_dblclick(WBChildFrame *pC, int iX, int iY, int iButtonMask, int iACS)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  // TODO:  select the current 'word'?

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_mouse_drag(WBChildFrame *pC, int iX, int iY, int iButtonMask, int iACS)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  CALLBACK_CHECK_NULL(pE->xTextObject.vtable->begin_mouse_drag)(&(pE->xTextObject));

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_mouse_drop(WBChildFrame *pC, int iX, int iY, int iButtonMask, int iACS)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  CALLBACK_CHECK_NULL(pE->xTextObject.vtable->end_mouse_drag)(&(pE->xTextObject));

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_mouse_move(WBChildFrame *pC, int iX, int iY)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  CALLBACK_CHECK_NULL(pE->xTextObject.vtable->mouse_click)(&(pE->xTextObject), iX, iY, 0, 0); // report mouse motion

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_scroll_vert(WBChildFrame *pC, int iMode, int iValue)
{
WBEditWindow *pE = (WBEditWindow *)pC;

  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  // TODO:  check scroll mode for scroll lock?

  if(iMode == 0) // absolute
  {
    if(pE->xTextObject.vtable->get_view)
    {
      WB_RECT rctView;
      WB_POINT ptScroll;

      pE->xTextObject.vtable->get_view(&(pE->xTextObject), &rctView);

      if(iValue == rctView.top) // not moving
      {
        return;
      }

      ptScroll.x = rctView.left;
      ptScroll.y = iValue;

      CALLBACK_CHECK_NULL(pE->xTextObject.vtable->set_view_orig)(&(pE->xTextObject), &ptScroll);

      FWSetChildFrameScrollInfo(pC, ptScroll.y, pC->extent.height,
                                pC->origin.x, pC->extent.width,
                                pC->iRowHeight, pC->iColWidth);
    }
  }
  else
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->scroll_vertical)(&(pE->xTextObject), iValue);

    FWSetChildFrameScrollInfo(pC,
                              CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_row)(&(pE->xTextObject))
                                                   : pC->origin.y,
                              pC->extent.height,
                              pC->origin.x, pC->extent.width,
                              pC->iRowHeight, pC->iColWidth);
  }

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_scroll_horiz(WBChildFrame *pC, int iMode, int iValue)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  // TODO:  check scroll mode for scroll lock?

  if(iMode == 0) // absolute
  {
    if(pE->xTextObject.vtable->get_view)
    {
      WB_RECT rctView;
      WB_POINT ptScroll;

      pE->xTextObject.vtable->get_view(&(pE->xTextObject), &rctView);

      if(iValue == rctView.top) // not moving
      {
        return;
      }

      ptScroll.x = iValue;
      ptScroll.y = rctView.top;

      CALLBACK_CHECK_NULL(pE->xTextObject.vtable->set_view_orig)(&(pE->xTextObject), &ptScroll);

      FWSetChildFrameScrollInfo(pC, pC->origin.y, pC->extent.height,
                                ptScroll.x, pC->extent.width,
                                pC->iRowHeight, pC->iColWidth);
    }
  }
  else
  {
    CALLBACK_CHECK_NULL(pE->xTextObject.vtable->scroll_horizontal)(&(pE->xTextObject), iValue);

    FWSetChildFrameScrollInfo(pC, pC->origin.y, pC->extent.height,
                              CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_col)(&(pE->xTextObject))
                                                   : pC->origin.x,
                              pC->extent.width,
                              pC->iRowHeight, pC->iColWidth);
  }

  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_mouse_cancel(WBChildFrame *pC)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }


  internal_new_cursor_pos((WBEditWindow *)pC);
}

static void internal_get_row_col(WBChildFrame *pC, int *piR, int *piC)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  if(piC)
  {
    *piC = CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_col)(&(pE->xTextObject)) : 0;
  }

  if(piR)
  {
    *piR = CALLBACK_CHECK_NULL2(pE->xTextObject.vtable->get_row)(&(pE->xTextObject)) : 0;
  }
}

static int internal_has_selection(WBChildFrame *pC)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return 0;
  }

  if(pE->xTextObject.vtable->get_select)
  {
    WB_RECT rctSel;

    pE->xTextObject.vtable->get_select(&(pE->xTextObject), &rctSel);

//    WB_ERROR_PRINT("TEMPORARY:  %s - selection rectangle %d,%d,%d,%d\n", __FUNCTION__,
//                   rctSel.left, rctSel.top, rctSel.right, rctSel.bottom);

    if(rctSel.left != rctSel.right || rctSel.bottom != rctSel.top) // NOT empty
    {
      return 1; // has a selection
    }
  }

  return 0; // no current selection
}

static void internal_undo(WBChildFrame *pC)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  // perform an un-do operation
}

static void internal_redo(WBChildFrame *pC)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return;
  }

  // perform a re-do operation
}

static int internal_can_undo(WBChildFrame *pC)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return 0;
  }

  return 0; // can't un-do
}

static int internal_can_redo(WBChildFrame *pC)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return 0;
  }

  return 0; // can't re-do
}


static int internal_is_empty(WBChildFrame *pC)
{
WBEditWindow *pE = (WBEditWindow *)pC;


  CALLBACK_TRACKER;

  if(!WBIsValidEditWindow(pE))
  {
    WB_ERROR_PRINT("ERROR:  %s - WBChildFrame and/or WBEditWindow not valid, %p\n", __FUNCTION__, pE);

    return -1; // return '-1' on error
  }

  // if the contents are NOT NULL, it's not 'empty'

  if((pE->xTextObject.vtable->get_rows && pE->xTextObject.vtable->get_rows(&(pE->xTextObject)) > 0) ||
     (pE->xTextObject.vtable->get_cols && pE->xTextObject.vtable->get_cols(&(pE->xTextObject)) > 0))
  {
    return 0; // NOT empty
  }

  return 1; // empty (for now; later, do I dive directly into xTextObject ???  new API for vtable?)
}



// Properties dialog

static int PropertyDialogCallback(Window wID, XEvent *pEvent)
{
WBDialogWindow *pDlg = DLGGetDialogWindowStruct(wID);
//struct _PROPERTY_DLG_ *pUserData = (struct _PROPERTY_DLG_ *)(pDlg ? pDlg->pUserData : NULL);


  if(pEvent->type == ClientMessage && pEvent->xclient.message_type == aDIALOG_INIT)
  {
    if(!pDlg)
    {
      WB_ERROR_PRINT("%s - no WBDialogWindow structure in DIALOG_INIT for %d (%08xH) %p %08xH %08xH\n", __FUNCTION__,
                     (unsigned int)wID, (unsigned int)wID, WBGetWindowData(wID, 0), DIALOG_WINDOW_TAG, ((WBDialogWindow *)WBGetWindowData(wID, 0))->ulTag);
      return 0; // can't process any messages now
    }
    else
    {
//      // assigning the correct icon
//
//      Window wIDIcon = DLGGetDialogControl(pDlg, 1000);  // ID 1000 for icon
//      WBDialogControl *pCtrl = DLGGetDialogControlStruct(wIDIcon);
//
//      if(pCtrl)
//      {
//        Pixmap pixmap2 = None;
//        Pixmap pixmap = PXM_GetIconPixmap(GetMessageBoxIconPixmapID(pUserData->iType & MessageBox_ICON_MASK),
//                                          NULL, &pixmap2);
//
//        if(pixmap != None)
//        {
//          WBDialogControlSetIconPixmap(pCtrl, pixmap, pixmap2);
//        }
//      }
    }

//    // assign the caption text to the caption window (which varies and must be assigned at run time)
//
//    DLGSetControlCaption((WBDialogWindow *)pDlg, 1001, pUserData->szMessage);

    return 1;
  }

  if(!pDlg)
  {
    WB_WARN_PRINT("MessageBoxCallback - no WBDialogWindow structure\n");
    return 0; // can't process any messages now
  }

  if(pEvent->type == ClientMessage && pEvent->xclient.message_type == aCONTROL_NOTIFY)
  {
    WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Event | DebugSubSystem_Dialog,
                   "%s - MessageBox ClientMessage CONTROL_NOTIFY\n", __FUNCTION__);

    switch(pEvent->xclient.data.l[1]) // control ID
    {
      case IDOK:
        // TODO:  save data

      case IDCANCEL:
        if(pEvent->xclient.data.l[0] == aBUTTON_PRESS)
        {
          WBEndModal(wID, pEvent->xclient.data.l[1]);
        }

        break;

      default:
        WB_WARN_PRINT("%s - MessageBox ClientMessage CONTROL_NOTIFY client id=%lx\n",
                      __FUNCTION__, pEvent->xclient.data.l[1]);
    }
  }

  return 0;
}

