//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//               _             _                        _                       _                           //
//    __      __(_) _ __    __| |  ___ __      __    __| | _ __  ___  ___  ___ (_) _ __    __ _     ___     //
//    \ \ /\ / /| || '_ \  / _` | / _ \\ \ /\ / /   / _` || '__|/ _ \/ __|/ __|| || '_ \  / _` |   / __|    //
//     \ V  V / | || | | || (_| || (_) |\ V  V /   | (_| || |  |  __/\__ \\__ \| || | | || (_| | _| (__     //
//      \_/\_/  |_||_| |_| \__,_| \___/  \_/\_/_____\__,_||_|   \___||___/|___/|_||_| |_| \__, |(_)\___|    //
//                                            |_____|                                     |___/             //
//                                                                                                          //
//                     Utilities for painting and handling standard components of windows                   //
//                                                                                                          //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2019 by Bob Frazier (aka 'Big Bad Bombastic Bob')


  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.
               Any claims to alleged functionality or features should be
               considered 'preliminary', and might not function as advertised.

  MIT-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  MIT-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

/** \file window_dressing.c Utilities for painting and handling standard components of windows */


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <errno.h>
#include <X11/Xlib.h>

#include "window_dressing.h"
#include "pixmap_helper.h"
#include "conf_help.h"
#include "draw_text.h"


static XColor clrScrollFG,  ///< foreground scroll bar color
              clrScrollBG,  ///< background scroll bar color
              clrScrollAFG, ///< active foreground scroll bar color
              clrScrollABG, ///< active background scroll bar color
              clrScrollHFG, ///< highlight foreground scroll bar color
              clrScrollHBG, ///< highlight background scroll bar color
              clrScrollBD,  ///< standard scroll bar border color
              clrScrollBD2, ///< 3D highlight scroll bar border color (light)
              clrScrollBD3; ///< 3D highlight scroll bar border color (dark)
/** \hideinitializer
  * \brief initialization flag for scroll colors.  when zero, colors not yet initialized
**/
static int iInitScrollColorFlag = 0;


/** \hideinitializer
  * \brief macro to get a color name or use default if it does not exist in settings
**/
#define COPY_COLOR_NAME(X,Y,Z) {const char *pX = X(WBGetDefaultDisplay()); if(pX) strlcpy(Y,pX,sizeof(Y)); else strlcpy(Y,Z,sizeof(Y));}

/** \brief internal utility to check and initialize scroll bar standard colors
**/
static void CheckInitScrollColors(void)
{
  // TODO:  consider freeing the colors with XFreeColors on exit
  // TODO:  consider not even bothering with 'XAllocColor' and just use PXM_RGBToPixel()

  if(!iInitScrollColorFlag)
  {
    static const char *szBorder2="#FFFFFF", *szBorder2W="#C8C6C0", *szBorder3="#9C9A94"; // for 3D borders
    char szFG[16], szBG[16], szBD[16], szHFG[16], szHBG[16], szAFG[16], szABG[16]; // must be at least 14 characters
//    static const char szFGName[]="Scrollbar.foreground";
//    static const char szBGName[]="Scrollbar.background";
//    static const char szHFGName[]="Scrollbar.highlightForeground";
//    static const char szHBGName[]="Scrollbar.highlightBackground";
//    static const char szAFGName[]="Scrollbar.activeForeground";
//    static const char szABGName[]="Scrollbar.activeBackground";
//    static const char szBDName[]="Scrollbar.border";

    Colormap colormap = DefaultColormap(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));


    COPY_COLOR_NAME(CHGetTextColor,szFG,"#000000");
//    LOAD_COLOR0(szFGName,szFG) else LOAD_COLOR0("*Dialog.foreground",szFG) else LOAD_COLOR0("*Form.foreground", szFG)
//     else LOAD_COLOR0("*WmDialogShell.foreground",szFG) else LOAD_COLOR0("*WmForm.foreground", szFG)
//     else LOAD_COLOR("*foreground", szFG, "#000000");

    COPY_COLOR_NAME(CHGetDialogBackgroundColor,szBG,"#dcdad5");
//    LOAD_COLOR0(szBGName,szBG) else LOAD_COLOR0("*Dialog.background",szBG) else LOAD_COLOR0("*Form.background", szBG)
//     else LOAD_COLOR0("*WmDialogShell.background",szBG)
//     else LOAD_COLOR("*WmForm.background", szBG, "#dcdad5"); // default for gnome is dcdad5

    COPY_COLOR_NAME(CHGetHighlightForegroundColor,szHFG,"#ffffff");
    COPY_COLOR_NAME(CHGetHighlightBackgroundColor,szHBG,"#0040ff");
    COPY_COLOR_NAME(CHGetActiveTextColor,szAFG,"#000000");
    COPY_COLOR_NAME(CHGetActiveBackgroundColor,szABG,"#dcdad5");
//    LOAD_COLOR(szHFGName,szHFG,szFG);
//    LOAD_COLOR(szHBGName,szHBG,szBG);
//    LOAD_COLOR(szAFGName,szAFG,szFG);
//    LOAD_COLOR(szABGName,szABG,szBG);

    COPY_COLOR_NAME(CHGetBorderColor,szBD,"#000000");
//     LOAD_COLOR0(szBDName,szBD) else LOAD_COLOR0("*Dialog.border",szBD) else LOAD_COLOR0("*Form.border", szBD)
//     else LOAD_COLOR0("*WmDialogShell.border",szBD) else LOAD_COLOR0("*WmForm.border", szBD)
//     else LOAD_COLOR0("*borderColor", szBD)
//     else LOAD_COLOR("*border", szBD, "black"); // default for gnome

    XParseColor(WBGetDefaultDisplay(), colormap, szFG, &clrScrollFG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollFG);
    XParseColor(WBGetDefaultDisplay(), colormap, szBG, &clrScrollBG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollBG);
    XParseColor(WBGetDefaultDisplay(), colormap, szAFG, &clrScrollAFG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollAFG);
    XParseColor(WBGetDefaultDisplay(), colormap, szABG, &clrScrollABG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollABG);
    XParseColor(WBGetDefaultDisplay(), colormap, szHFG, &clrScrollHFG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollHFG);
    XParseColor(WBGetDefaultDisplay(), colormap, szHBG, &clrScrollHBG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollHBG);
    XParseColor(WBGetDefaultDisplay(), colormap, szBD, &clrScrollBD);

    // 3D border colors for now these are hard-coded - later derive them from FG and BG colors
    if(clrScrollBG.red >= 60000 && clrScrollBG.green >= 60000 &&
       clrScrollBG.blue >= 60000) // note see man page on XColor, values 0 through 65535 for RGB
    {
      XParseColor(WBGetDefaultDisplay(), colormap, szBorder2W, &clrScrollBD2);
    }
    else
    {
      XParseColor(WBGetDefaultDisplay(), colormap, szBorder2, &clrScrollBD2);
    }

    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollBD2);
    XParseColor(WBGetDefaultDisplay(), colormap, szBorder3, &clrScrollBD3);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollBD3);

    iInitScrollColorFlag = 1;
  }
}


static void DebugDumpScrollInfo(WB_SCROLLINFO *pSI)
{

  WBDebugPrint("%s - Debug Dump of Scroll Info\n"
               "  iScrollState = %d,\n"
               "  iVScrollWidth = %d, iHScrollHeight = %d, iVBarHeight = %d, iHBarWidth = %d,\n"
               "  iHKnob = %d, iVKnob = %d, iHKnobSize = %d, iVKnobSize = %d,\n"
               "  iHMin = %d, iHMax = %d    iVMin = %d, iVMax = %d, iHPos = %d, iVPos = %d\n"
               "  geomHBar:    %d,%d,%d,%d\n"
               "  geomHLeft:   %d,%d,%d,%d\n"
               "  geomHRight:  %d,%d,%d,%d\n"
               "  geomHKnob:   %d,%d,%d,%d\n"
               "  geomVBar:    %d,%d,%d,%d\n"
               "  geomVUp:     %d,%d,%d,%d\n"
               "  geomVDown:   %d,%d,%d,%d\n"
               "  geomVKnob:   %d,%d,%d,%d\n",
               __FUNCTION__,
               pSI->iScrollState, pSI->iVScrollWidth, pSI->iHScrollHeight,
               pSI->iVBarHeight, pSI->iHBarWidth,
               pSI->iHKnob, pSI->iVKnob, pSI->iHKnobSize, pSI->iVKnobSize,
               pSI->iHMin, pSI->iHMax, pSI->iVMin, pSI->iVMax, pSI->iHPos, pSI->iVPos,
               pSI->geomHBar.x, pSI->geomHBar.y, pSI->geomHBar.width, pSI->geomHBar.height,
               pSI->geomHLeft.x, pSI->geomHLeft.y, pSI->geomHLeft.width, pSI->geomHLeft.height,
               pSI->geomHRight.x, pSI->geomHRight.y, pSI->geomHRight.width, pSI->geomHRight.height,
               pSI->geomHKnob.x, pSI->geomHKnob.y, pSI->geomHKnob.width, pSI->geomHKnob.height,
               pSI->geomVBar.x, pSI->geomVBar.y, pSI->geomVBar.width, pSI->geomVBar.height,
               pSI->geomVUp.x, pSI->geomVUp.y, pSI->geomVUp.width, pSI->geomVUp.height,
               pSI->geomVDown.x, pSI->geomVDown.y, pSI->geomVDown.width, pSI->geomVDown.height,
               pSI->geomVKnob.x, pSI->geomVKnob.y, pSI->geomVKnob.width, pSI->geomVKnob.height);
}


#if 0 /* this function not currently used.  consider removeing it in a refactor */
static char ilog2n(unsigned char y)
{
  if(y & 0x08)
    return 4;
  else if(y & 0x04)
    return 3;
  else if(y & 0x02)
    return 2;
  else if(y & 0x01)
    return 1;
  else
    return 0;
}
#endif // 0

#if 0 /* this function not currently used.  consider removeing it in a refactor */
static char ilog2c(unsigned char y)
{
  if(y & 0xf0)
    return ilog2n(y >> 4) + 4;

  return ilog2n(y);
}
#endif // 0

#if 0 /* this function not currently used.  consider removeing it in a refactor */
static int ilog2s(unsigned short y)
{
  if(y & 0xff00)
  {
    return ilog2c((unsigned char)(y >> 8)) + 8;
  }

  return ilog2c((unsigned char)y);
}
#endif // 0

#if 0 /* this function not currently used.  consider removeing it in a refactor */
static int ilog2(unsigned int y)
{
  if(y & 0xffff0000)
  {
    return ilog2s((unsigned short)(y >> 16)) + 16;
  }

  return ilog2s((unsigned short)y);
}
#endif // 0

#if 0 /* this function not currently used.  consider removeing it in a refactor */
static int ilog2ll(WB_UINT64 y)
{
  if(y & 0xffffffff00000000LL)
  {
    return ilog2((unsigned int)(y >> 32)) + 32;
  }

  return ilog2((unsigned int)y);
}
#endif // 0


int WBSetVScrollRange(WB_SCROLLINFO *pSI, int iMin, int iMax)
{
int iRval;

  iRval = pSI->iVMin < pSI->iVMax;

  // TODO:  data validation
  pSI->iVMin = iMin;
  pSI->iVMax = iMax;

  return (pSI->iVMin < pSI->iVMax) != iRval ? 1 : 0; // 'visibility' changed
}

int WBSetHScrollRange(WB_SCROLLINFO *pSI, int iMin, int iMax)
{
int iRval;

  iRval = pSI->iHMin < pSI->iHMax;

  // TODO:  data validation
  pSI->iHMin = iMin;
  pSI->iHMax = iMax;

  return (pSI->iHMin < pSI->iHMax) != iRval ? 1 : 0; // 'visibility' changed
}

void WBSetVScrollPos(WB_SCROLLINFO *pSI, int iPos)
{
  // TODO:  data validation
  pSI->iVPos = iPos;
}

void WBSetHScrollPos(WB_SCROLLINFO *pSI, int iPos)
{
  // TODO:  data validation
  pSI->iHPos = iPos;
}

static int InternalNotifySelf(Window wID, Atom aNotify, long lData0, long lData1, long lData2, long lData3, long lData4)
{
Display *pDisplay = WBGetWindowDisplay(wID);

  XClientMessageEvent evt = {
                              .type=ClientMessage,
                              .serial=0,
                              .send_event=0,
                              .display=pDisplay,
                              .window=wID,
                              .message_type=aNotify,
                              .format=32
                            };
  evt.data.l[0] = lData0;
  evt.data.l[1] = lData1;
  evt.data.l[2] = lData2;
  evt.data.l[3] = lData3;
  evt.data.l[4] = lData4;

  return WBWindowDispatch(wID, (XEvent *)&evt);
}


static void InternalCalcVScrollBar(WB_SCROLLINFO *pScrollInfo, WB_GEOM *pgeomClient, int iVScrollWidth, int iHScrollHeight)
{
int iKnobSize, iKnobPos, iBarHeight;
int i1, i2;
int nListItems;


  iBarHeight = pgeomClient->height;

  pScrollInfo->iVScrollWidth = iVScrollWidth;
  pScrollInfo->iVBarHeight = iBarHeight;

  WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Expose,
                 "%s.%d - iVScrollWidth=%d, iHScrollHeight=%d  iBarHeight=%d  geomClient=%d,%d,%d,%d border=%d\n",
                 __FUNCTION__, __LINE__, iVScrollWidth, iHScrollHeight, iBarHeight,
                 pgeomClient->x, pgeomClient->y, pgeomClient->width, pgeomClient->height, pgeomClient->border);

  if(pScrollInfo->iVPos < pScrollInfo->iVMin || pScrollInfo->iVPos > pScrollInfo->iVMax)
  {
    pScrollInfo->iVPos = -1; // for now
  }

  nListItems = pScrollInfo->iVMax - pScrollInfo->iVMin + 1;


  // knob height equals 'nListItems / nListItems!' multiplied by
  // the available knob height, for a minimum value of 'iHScrollHeight'

  iKnobSize = (iBarHeight - 4 * iHScrollHeight - 2);

  if(iKnobSize > iHScrollHeight) // / 2)
  {
    i1 = iHScrollHeight * (2 * iHScrollHeight + 1);  // 'twice scroll height' factorial
    i2 = iHScrollHeight * 2;

    while(i2 > 2 && i1 > iKnobSize) // using the above starting point get 'max factorial less than height'
    {
      i1 -= i2;
      i2--;
    }

    if(nListItems >= i2) // more than twice scroll height?
    {
      if(nListItems > iKnobSize || iKnobSize - i1 < iHScrollHeight / 2)
      {
        iKnobSize = -1;  // to fix later
      }
      else
      {
        iKnobSize -= i1;  // twice scroll height factorial
        iKnobSize -= (nListItems - iHScrollHeight * 2 + 1);
      }
    }
    else
    {
      iKnobSize -= i1  // 'twice knob height' factorial
                 - (nListItems + 1) * nListItems / 2;  // 'nListItems' factorial
    }

    if(iKnobSize < iHScrollHeight) // 3 * iHScrollHeight / 4)
    {
      iKnobSize = iHScrollHeight; // 3 * iHScrollHeight / 4;  // minimum size
    }
  }
  else
  {
    iKnobSize = iHScrollHeight; // 3 * iHScrollHeight / 4;  // worst case use this anyway
  }

  // cache these geometries because I need them for mouse handling

  pScrollInfo->iVKnobSize       = iKnobSize;

  pScrollInfo->geomVBar.x       = pgeomClient->x
                                + pgeomClient->width
                                - iVScrollWidth
                                + 2 * pgeomClient->border; // to account for the border size

  pScrollInfo->geomVBar.y       = pgeomClient->y
                                - pgeomClient->border; // to account for the border size
  pScrollInfo->geomVBar.height  = pgeomClient->height
                                + 2 * pgeomClient->border; // to account for the border size
  pScrollInfo->geomVBar.width   = iVScrollWidth;

  // is there a vertical scroll bar?  If so, I need to adjust the width
  if(pScrollInfo->iHMin < pScrollInfo->iHMax) // not '-1'
  {
    pScrollInfo->geomVBar.height -= iHScrollHeight; // make it a tad smaller
  }


  pScrollInfo->geomVUp.x        = pScrollInfo->geomVBar.x + 1;
  pScrollInfo->geomVUp.y        = pScrollInfo->geomVBar.y + 1;
  pScrollInfo->geomVUp.width    = pScrollInfo->geomVBar.width - 2;
  pScrollInfo->geomVUp.height   = pScrollInfo->geomVUp.width;

  pScrollInfo->geomVDown.x      = pScrollInfo->geomVUp.x;
  pScrollInfo->geomVDown.y      = pScrollInfo->geomVBar.y
                                + pScrollInfo->geomVBar.height
                                - pScrollInfo->geomVDown.height
                                - 1;
  pScrollInfo->geomVDown.width  = pScrollInfo->geomVUp.width;
  pScrollInfo->geomVDown.height = pScrollInfo->geomVUp.height;

  pScrollInfo->geomVKnob.x      = pScrollInfo->geomVDown.x;
  pScrollInfo->geomVKnob.width  = pScrollInfo->geomVDown.width;
  pScrollInfo->geomVKnob.height = iKnobSize;

  // now that I have a reasonable estimate of the knob size, calculate
  // the starting vertical position of the knob

  if(pScrollInfo->iVPos <= 0 || nListItems <= 0)
  {
    iKnobPos = 0;
  }
  else
  {
    int iBarScrollArea = pScrollInfo->geomVDown.y
                       - (pScrollInfo->geomVUp.y + pScrollInfo->geomVUp.height)
                       - iKnobSize
                       - 1; // inclusive value

    if(pScrollInfo->iVPos >= (nListItems - 1))
    {
      iKnobPos = iBarScrollArea;
    }
    else
    {
      iKnobPos = (WB_INT64)pScrollInfo->iVPos * (WB_INT64)iBarScrollArea
               / (WB_INT64)(nListItems - 1);
    }
  }


  pScrollInfo->geomVKnob.y = (pScrollInfo->iVKnob = iKnobPos)
                           + pScrollInfo->geomVUp.y + pScrollInfo->geomVUp.height;

  // 'fixed' (as in static) values go here
  pScrollInfo->geomVBar.border = 1;
  pScrollInfo->geomVUp.border = 0;
  pScrollInfo->geomVDown.border = 0;
  pScrollInfo->geomVKnob.border = 0;

  WB_IF_DEBUG_LEVEL(DebugLevel_Heavy | DebugSubSystem_ScrollBar)
  {
    DebugDumpScrollInfo(pScrollInfo);
  }
}


static void InternalCalcHScrollBar(WB_SCROLLINFO *pScrollInfo, WB_GEOM *pgeomClient, int iVScrollWidth, int iHScrollHeight)
{
int iKnobSize, iKnobPos, iBarWidth;
int i1, i2;
int nListItems;



  iBarWidth = pgeomClient->width;

  pScrollInfo->iHScrollHeight = iHScrollHeight;
  pScrollInfo->iHBarWidth = iBarWidth;


  WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Expose,
                 "%s.%d - iVScrollWidth=%d, iHScrollHeight=%d  iBarWidth=%d  geomClient=%d,%d,%d,%d border=%d\n",
                 __FUNCTION__, __LINE__, iVScrollWidth, iHScrollHeight, iBarWidth,
                 pgeomClient->x, pgeomClient->y, pgeomClient->width, pgeomClient->height, pgeomClient->border);


  if(pScrollInfo->iHPos < pScrollInfo->iHMin || pScrollInfo->iHPos > pScrollInfo->iHMax)
  {
    pScrollInfo->iHPos = -1; // for now
  }

  nListItems = pScrollInfo->iHMax - pScrollInfo->iHMin + 1;


  // knob height equals 'nListItems / nListItems!' multiplied by
  // the available knob height, for a minimum value of 'iHScrollHeight'

  iKnobSize = (iBarWidth - 4 * iVScrollWidth - 2);

  if(iKnobSize > iVScrollWidth) // / 2)
  {
    i1 = iVScrollWidth * (2 * iVScrollWidth + 1);  // 'twice scroll width' factorial
    i2 = iVScrollWidth * 2;

    while(i2 > 2 && i1 > iKnobSize) // using the above starting point get 'max factorial less than width'
    {
      i1 -= i2;
      i2--;
    }

    if(nListItems >= i2) // more than twice scroll height?
    {
      if(nListItems > iKnobSize || iKnobSize - i1 < iVScrollWidth / 2)
      {
        iKnobSize = -1;  // to fix later
      }
      else
      {
        iKnobSize -= i1;  // twice scroll height factorial
        iKnobSize -= (nListItems - iVScrollWidth * 2 + 1);
      }
    }
    else
    {
      iKnobSize -= i1  // 'twice knob height' factorial
                 - (nListItems + 1) * nListItems / 2;  // 'nListItems' factorial
    }

    if(iKnobSize < iVScrollWidth) // 3 * iVScrollWidth / 4)
    {
      iKnobSize = iVScrollWidth; // 3 * iVScrollWidth / 4;  // minimum size
    }
  }
  else
  {
    iKnobSize = iVScrollWidth; //3 * iVScrollWidth / 4;  // worst case use this anyway
  }

  // cache these geometries because I need them for mouse handling

  pScrollInfo->iHKnobSize      = iKnobSize;

  pScrollInfo->geomHBar.x      = pgeomClient->x
                               - pgeomClient->border; // to account for the border size
  pScrollInfo->geomHBar.y      = pgeomClient->y
                               + pgeomClient->height
                               - iHScrollHeight
                               + 2 * pgeomClient->border; // to account for the border size
  pScrollInfo->geomHBar.width  = pgeomClient->width
                               + 2 * pgeomClient->border; // to account for the border size
  pScrollInfo->geomHBar.height = iHScrollHeight;

  // is there a vertical scroll bar?  If so, I need to adjust the width
  if(pScrollInfo->iVMin < pScrollInfo->iVMax) // not '-1'
  {
    pScrollInfo->geomHBar.width -= iVScrollWidth; // make it a tad smaller
  }

  pScrollInfo->geomHLeft.x      = pScrollInfo->geomHBar.x;
  pScrollInfo->geomHLeft.y      = pScrollInfo->geomHBar.y + 1;
  pScrollInfo->geomHLeft.height = pScrollInfo->geomHBar.height - 2;
  pScrollInfo->geomHLeft.width  = pScrollInfo->geomHLeft.height;

  pScrollInfo->geomHRight.x     = pScrollInfo->geomHBar.x
                                + pScrollInfo->geomHBar.width
                                - pScrollInfo->geomHLeft.width
                                - 1;
  pScrollInfo->geomHRight.y      = pScrollInfo->geomHLeft.y;
  pScrollInfo->geomHRight.height = pScrollInfo->geomHLeft.height;
  pScrollInfo->geomHRight.width  = pScrollInfo->geomHLeft.width;

  pScrollInfo->geomHKnob.y      = pScrollInfo->geomHLeft.y;
  pScrollInfo->geomHKnob.height = pScrollInfo->geomHLeft.height;
  pScrollInfo->geomHKnob.width  = iKnobSize;

  // now that I have a reasonable estimate of the knob size, calculate
  // the starting horizontal position of the knob

  if(pScrollInfo->iHPos <= 0 || nListItems <= 0)
  {
//    WB_ERROR_PRINT("*** TEMPORARY:  iHPos=%d, nListItems=%d\n",
//                   pScrollInfo->iHPos, nListItems);
    iKnobPos = 0;
  }
  else
  {
    int iBarScrollArea = pScrollInfo->geomHRight.x
                       - (pScrollInfo->geomHLeft.x + pScrollInfo->geomHLeft.width)
                       - iKnobSize
                       - 1; // inclusive value

    if(pScrollInfo->iHPos >= (nListItems - 1))
    {
      iKnobPos = iBarScrollArea;
    }
    else
    {
      iKnobPos = (WB_INT64)pScrollInfo->iHPos * (WB_INT64)iBarScrollArea
               / (WB_INT64)(nListItems - 1);
    }

//    WB_ERROR_PRINT("*** TEMPORARY:  %d %d %d %d ==> %d   %d %d ==> %d\n",
//                   pScrollInfo->geomHRight.x, pScrollInfo->geomHLeft.x, pScrollInfo->geomHLeft.width,
//                   iKnobSize, iBarScrollArea,
//                   pScrollInfo->iHPos, nListItems, iKnobPos);
  }


  pScrollInfo->geomHKnob.x = (pScrollInfo->iHKnob = iKnobPos)
                           + pScrollInfo->geomHLeft.x + pScrollInfo->geomHLeft.width;

  // 'fixed' (as in static) values go here
  pScrollInfo->geomVBar.border = 1;
  pScrollInfo->geomVUp.border = 0;
  pScrollInfo->geomVDown.border = 0;
  pScrollInfo->geomVKnob.border = 0;

  WB_IF_DEBUG_LEVEL(DebugLevel_Heavy | DebugSubSystem_ScrollBar)
  {
    DebugDumpScrollInfo(pScrollInfo);
  }
}




void WBCalcVScrollBar(WB_SCROLLINFO *pScrollInfo, WB_GEOM *pgeomClient, int iVScrollWidth,
                      int iHScrollHeight, int nListItems, int nPos)
{
int iBarHeight, iBarWidth;


  iBarHeight = pgeomClient->height;
  iBarWidth = pgeomClient->width;

  if(pScrollInfo->iVBarHeight == iBarHeight &&
     pScrollInfo->iHBarWidth == iBarWidth &&
     pScrollInfo->iVKnob >= 0 &&
     pScrollInfo->iVKnobSize >= 0 &&
     pScrollInfo->iVPos == nPos &&
     pScrollInfo->iVMin == 0 &&
     pScrollInfo->iVMax == (nListItems - 1))
  {
    // assume it's set up correctly

//    WB_ERROR_TEXT("TEMPORARY:  short cycling calc scroll info\n");
//    return;
  }

  if(pScrollInfo->iHBarWidth != iBarWidth ||
     pScrollInfo->iVBarHeight != iBarHeight) // TODO:  do i need this???
  {
    // client size change detected
    // zero out the H Scroll info so that it forces re-calculation next time
    pScrollInfo->iHKnob = pScrollInfo->iHKnobSize = pScrollInfo->iHPos = pScrollInfo->iHMin = pScrollInfo->iHMax = 0;
  }

  WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Expose,
                 "%s.%d -  %d %d %d %d %d\n", __FUNCTION__, __LINE__,
                 iBarHeight, iVScrollWidth, iHScrollHeight, nListItems, nPos);

  pScrollInfo->iVMin = 0;
  pScrollInfo->iVMax = nListItems - 1;

  if(nPos == -1 ||
     (nPos >= pScrollInfo->iVMin && nPos <= pScrollInfo->iVMax))
  {
    pScrollInfo->iVPos = nPos;
  }
  else
  {
    pScrollInfo->iVPos = nPos = -1;
  }

  InternalCalcVScrollBar(pScrollInfo, pgeomClient, iVScrollWidth, iHScrollHeight);

  pScrollInfo->iHScrollHeight = iHScrollHeight;
  pScrollInfo->iHBarWidth = iBarWidth;

  WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Expose,
                 "%s.%d -  iHScrollHeight=%d, iBarWidth=%d\n", __FUNCTION__, __LINE__,
                 iHScrollHeight, iBarWidth);

}

void WBCalcHScrollBar(WB_SCROLLINFO *pScrollInfo, WB_GEOM *pgeomClient, int iVScrollWidth,
                      int iHScrollHeight, int nListItems, int nPos)
{
int /*iKnobSize, iKnobPos,*/ iBarHeight, iBarWidth;
//int i1, i2;

  iBarHeight = pgeomClient->height;
  iBarWidth = pgeomClient->width;

  if(pScrollInfo->iVBarHeight == iBarHeight &&
     pScrollInfo->iHBarWidth == iBarWidth &&
     pScrollInfo->iVKnob >= 0 &&
     pScrollInfo->iVKnobSize >= 0 &&
     pScrollInfo->iVPos == nPos &&
     pScrollInfo->iVMin == 0 &&
     pScrollInfo->iVMax == (nListItems - 1))
  {
    // assume it's set up correctly

//    WB_ERROR_TEXT("TEMPORARY:  short cycling calc scroll info\n");
//    return;
  }

  if(pScrollInfo->iVBarHeight != iBarHeight ||
     pScrollInfo->iHBarWidth != iBarWidth) // TODO:  do I need this??
  {
    // client size change detected
    // zero out the V Scroll info so that it forces re-calculation next time
    pScrollInfo->iVKnob = pScrollInfo->iVKnobSize = pScrollInfo->iVPos = pScrollInfo->iVMin = pScrollInfo->iVMax = 0;
  }

  WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Expose,
                 "%s.%d -  %d %d %d %d %d\n", __FUNCTION__, __LINE__,
                 iBarWidth, iVScrollWidth, iHScrollHeight, nListItems, nPos);

  pScrollInfo->iHMin = 0;
  pScrollInfo->iHMax = nListItems - 1;


  if(nPos == -1 ||
     (nPos >= 0 && nPos < nListItems))
  {
    pScrollInfo->iHPos = nPos;
  }
  else
  {
    pScrollInfo->iHPos = nPos = -1;
  }

  InternalCalcHScrollBar(pScrollInfo, pgeomClient, iVScrollWidth, iHScrollHeight);

  pScrollInfo->iVScrollWidth = iVScrollWidth;
  pScrollInfo->iVBarHeight = iBarHeight;

  WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Expose,
                 "%s.%d -  iHScrollHeight=%d, iBarWidth=%d\n", __FUNCTION__, __LINE__,
                 iVScrollWidth, iBarHeight);
}



int WBCalcVScrollDragPos(WB_SCROLLINFO *pScrollInfo, int iY)
{
  if(pScrollInfo &&
     (pScrollInfo->iVMax >= pScrollInfo->iVMin))
  {
    int nListItems = pScrollInfo->iVMax - pScrollInfo->iVMin + 1;
    int iKnobSize = pScrollInfo->geomVKnob.height;
    int iKnobPos = iY - iKnobSize / 3
                 - (pScrollInfo->geomVUp.y + pScrollInfo->geomVUp.height);

    int iBarScrollArea = pScrollInfo->geomVDown.y
                       - (pScrollInfo->geomVUp.y + pScrollInfo->geomVUp.height)
                       - iKnobSize
                       - 1; // inclusive value

    if(iBarScrollArea <= 0)
    {
      return pScrollInfo->iVMin;  // always assume 1st item's index
    }
    else
    {
      int nPos = (WB_INT64)iKnobPos * (WB_INT64)(nListItems - 1)
               / (WB_INT64)iBarScrollArea;

      WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Expose,
                     "%s.%d  iY=%d; nLI=%d  KS=%d  KP=%d  BSA=%d  nP=%d\n",
                     __FUNCTION__, __LINE__,
                     iY, nListItems, iKnobSize, iKnobPos, iBarScrollArea, nPos);

      if(nPos < pScrollInfo->iVMin)
      {
        return pScrollInfo->iVMin;
      }
      else if(nPos > pScrollInfo->iVMax)
      {
        return pScrollInfo->iVMax;
      }
      else
      {
        return nPos;
      }
    }
  }

  return -1;  // can't evaluate, so return -1
}

int WBCalcHScrollDragPos(WB_SCROLLINFO *pScrollInfo, int iX)
{
  if(pScrollInfo &&
     (pScrollInfo->iHMax >= pScrollInfo->iHMin))
  {
    int nListItems = pScrollInfo->iHMax - pScrollInfo->iHMin + 1;
    int iKnobSize = pScrollInfo->geomHKnob.width;
    int iKnobPos = iX - iKnobSize / 3
                 - (pScrollInfo->geomHLeft.x + pScrollInfo->geomHLeft.width);

    int iBarScrollArea = pScrollInfo->geomHRight.x
                       - (pScrollInfo->geomHLeft.x + pScrollInfo->geomHLeft.width)
                       - iKnobSize
                       - 1; // inclusive value

    if(iBarScrollArea <= 0)
    {
      return pScrollInfo->iHMin;  // always assume 1st item's index
    }
    else
    {
      int nPos = (WB_INT64)iKnobPos * (WB_INT64)(nListItems - 1)
               / (WB_INT64)iBarScrollArea;

      WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Expose,
                     "%s.%d  iX=%d; nLI=%d  KS=%d  KP=%d  BSA=%d  nP=%d\n",
                     __FUNCTION__, __LINE__,
                     iX, nListItems, iKnobSize, iKnobPos, iBarScrollArea, nPos);

      if(nPos < pScrollInfo->iHMin)
      {
        return pScrollInfo->iHMin;
      }
      else if(nPos > pScrollInfo->iHMax)
      {
        return pScrollInfo->iHMax;
      }
      else
      {
        return nPos;
      }
    }
  }

  return -1;  // can't evaluate, so return -1
}


void WBUpdateScrollBarGeometry(WB_SCROLLINFO *pSI, WB_FONTC pFont,
                               WB_GEOM *pgeomClient, WB_GEOM *pgeomUsable)
{
WB_GEOM geom;
int iVScrollWidth, iHScrollHeight;
XCharStruct xBounds;

  // TODO:  data validation

  if(!pFont)
  {
    pFont = WBGetDefaultFont();
  }

  geom.x = pgeomClient->x;
  geom.y = pgeomClient->y;
  geom.width = pgeomClient->width;
  geom.height = pgeomClient->height;
  geom.border = pgeomClient->border;

  xBounds = WBFontMaxBounds(pFont);

  iVScrollWidth = WBTextWidth(pFont, "X", 1) * 2 + 4; // standard width of vertical scrollbar
  iHScrollHeight = xBounds.ascent + xBounds.descent + 4;

  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_ScrollBar | DebugSubSystem_Expose,
                 "%s.%d - iVScrollWidth=%d, iHScrollHeight=%d  geom=%d,%d,%d,%d (%d)\n",
                 __FUNCTION__, __LINE__, iVScrollWidth, iHScrollHeight,
                 geom.x, geom.y, geom.width, geom.height, geom.border);

  // calculate the rectangles for the scroll bars

  if(pSI->iVMin < pSI->iVMax)
  {
//    InternalCalcVScrollBar(pSI, pgeomClient, iVScrollWidth, pScrollInfo->iVMin,
//                           pScrollInfo->iVMax, pScrollInfo->iVPos);
    InternalCalcVScrollBar(pSI, pgeomClient, iVScrollWidth, iHScrollHeight);

    geom.width -= iVScrollWidth;
  }

  if(pSI->iHMin < pSI->iHMax)
  {
//    InternalCalcHScrollBar(pSI, pgeomClient, iHScrollHeight, pScrollInfo->iHMin,
//                           pScrollInfo->iHMax, pScrollInfo->iHPos);
    InternalCalcHScrollBar(pSI, pgeomClient, iVScrollWidth, iHScrollHeight);


    geom.height -= iHScrollHeight;
  }

  if(pgeomUsable)
  {
    memcpy(pgeomUsable, &geom, sizeof(*pgeomUsable));
  }

  WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_ScrollBar | DebugSubSystem_Expose,
                 "    SCROLL INFO:  iVBarHeight = %-6d    iHBarWidth  = %d\n"
                 "                  iVKnob      = %-6d    iHKnob      = %d\n"
                 "                  iVKnobSize  = %-6d    iHKnobSize  = %d\n"
                 "                  iVPos       = %-6d    iHPos       = %d\n"
                 "                  iVMin       = %-6d    iVMin       = %d\n"
                 "                  iVMax       = %-6d    iVMax       = %d\n\n",
                 pSI->iVBarHeight, pSI->iHBarWidth,
                 pSI->iVKnob,      pSI->iHKnob,
                 pSI->iVKnobSize,  pSI->iHKnobSize,
                 pSI->iVPos,       pSI->iHPos,
                 pSI->iVMin,       pSI->iHMin,
                 pSI->iVMax,       pSI->iHMax);
}

void WBInvalidateVScrollGeom(Window wID, WB_SCROLLINFO *pScrollInfo, int bAll, int bUpdate)
{
WB_GEOM geom;

  if(wID == None || !pScrollInfo)
  {
    return;
  }

  // calculate geometry of the scrollbar minus the up/down buttons and border

  geom.border = 0;

  if(bAll)
  {
    geom.x = pScrollInfo->geomVBar.x;
    geom.y = pScrollInfo->geomVBar.y;
    geom.width = pScrollInfo->geomVBar.width;
    geom.height = pScrollInfo->geomVBar.height;
    geom.border = pScrollInfo->geomVBar.border;
  }
  else
  {
    geom.x = pScrollInfo->geomVBar.x;
    geom.y = pScrollInfo->geomVUp.y + pScrollInfo->geomVUp.height;
    geom.width = pScrollInfo->geomVBar.width;
    geom.height = pScrollInfo->geomVDown.y - geom.y;
    geom.border = pScrollInfo->geomVBar.border; // just use this one
  }

  WBInvalidateGeom(wID, &geom, bUpdate); // invalidate scroll area before notifying
}

void WBInvalidateHScrollGeom(Window wID, WB_SCROLLINFO *pScrollInfo, int bAll, int bUpdate)
{
WB_GEOM geom;

  if(wID == None || !pScrollInfo)
  {
    return;
  }

  // calculate geometry of the scrollbar minus the left/right buttons and border

  geom.border = 0;

  if(bAll)
  {
    geom.x = pScrollInfo->geomHBar.x;
    geom.y = pScrollInfo->geomHBar.y;
    geom.width = pScrollInfo->geomHBar.width;
    geom.height = pScrollInfo->geomHBar.height;
    geom.border = pScrollInfo->geomHBar.border;
  }
  else
  {
    geom.x = pScrollInfo->geomHLeft.x + pScrollInfo->geomHLeft.width;
    geom.y = pScrollInfo->geomHBar.y;
    geom.width = pScrollInfo->geomHRight.x - geom.x;
    geom.height = pScrollInfo->geomHBar.height;
    geom.border = pScrollInfo->geomHBar.border; // just use this one
  }

  WBInvalidateGeom(wID, &geom, bUpdate); // invalidate scroll area before notifying
}


int WBScrollBarEvent(Window wID, XEvent *pEvent, WB_SCROLLINFO *pScrollInfo)
{
int iRval, iX, iY, iDirection, iPosition;


  if(wID == None || !pEvent || pEvent->type != ClientMessage || !pScrollInfo)
  {
    return 0; // only client message events and valid parameters
  }

  // TODO handle mouse-up events ??
  if(pEvent->xclient.message_type == aWB_POINTER)
  {
    if(pEvent->xclient.data.l[0] == WB_POINTER_CLICK)
    {
      // TODO:  handle shift-click, ctrl-click, alt-click

      if(pEvent->xclient.data.l[1] == WB_POINTER_BUTTON1 && // left button
         !pEvent->xclient.data.l[2])
      {
        iX = pEvent->xclient.data.l[3];
        iY = pEvent->xclient.data.l[4];

        if(WB_LIKELY(pScrollInfo != NULL))
        {
          iDirection = (int)WB_SCROLL_NA;
          iPosition = 0;

          if(WBPointInGeom(iX, iY, pScrollInfo->geomVBar))
          {
            if(WBPointInGeom(iX, iY, pScrollInfo->geomVUp))
            {
              iDirection = WB_SCROLL_BACKWARD;
              WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Event,
                             "%s Mouse click in vertical scroll bar (up)\n", __FUNCTION__);
            }
            else if(WBPointInGeom(iX, iY, pScrollInfo->geomVDown))
            {
              iDirection = WB_SCROLL_FORWARD;
              WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Event,
                             "%s Mouse click in vertical scroll bar (down)\n", __FUNCTION__);
            }
            else if(WBPointInGeom(iX, iY, pScrollInfo->geomVKnob))
            {
              // ON THE KNOB - VScroll

              iDirection = WB_SCROLL_KNOB;
              iPosition = WBCalcVScrollDragPos(pScrollInfo, iY);

              if(iPosition < 0)
              {
                iPosition = pScrollInfo->iVMin; //pListInfo->nTop;
              }

              WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Event,
                             "%s Mouse click in vertical scroll bar (knob), iPosition=%d\n", __FUNCTION__, iPosition);
            }
            else if(iY >= pScrollInfo->geomVUp.y + pScrollInfo->geomVUp.height &&
                    iY < pScrollInfo->geomVKnob.y)
            {
              iDirection = WB_SCROLL_PAGEBACK;
              WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Event,
                             "%s Mouse click in vertical scroll bar (page up)\n", __FUNCTION__);
            }
            else if(iY >= pScrollInfo->geomVKnob.y + pScrollInfo->geomVKnob.height &&
                    iY < pScrollInfo->geomVDown.y)
            {
              iDirection = WB_SCROLL_PAGEFWD;
              WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Event,
                             "%s Mouse click in vertical scroll bar (page down)\n", __FUNCTION__);
            }
            else
            {
              WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Event,
                             "%s Mouse click in vertical scroll bar (unknown)\n", __FUNCTION__);
            }

            InternalNotifySelf(wID, aSCROLL_NOTIFY, WB_SCROLL_VERTICAL, iDirection, iPosition, 0, 0);

            return 1;  // handled
          }
          else if(WBPointInGeom(iX, iY, pScrollInfo->geomHBar))
          {
            if(WBPointInGeom(iX, iY, pScrollInfo->geomHLeft))
            {
              iDirection = WB_SCROLL_BACKWARD;
              WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Event,
                             "%s Mouse click in horizontal scroll bar (left)\n", __FUNCTION__);
            }
            else if(WBPointInGeom(iX, iY, pScrollInfo->geomHRight))
            {
              iDirection = WB_SCROLL_FORWARD;
              WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Event,
                             "%s Mouse click in horizontal scroll bar (right)\n", __FUNCTION__);
            }
            else if(WBPointInGeom(iX, iY, pScrollInfo->geomHKnob))
            {
              // ON THE KNOB - HScroll

              iDirection = WB_SCROLL_KNOB;
//              iPosition = pScrollInfo->iHMin; // NO!
              iPosition = WBCalcHScrollDragPos(pScrollInfo, iX);

              if(iPosition < 0)
              {
                iPosition = pScrollInfo->iHMin; //pListInfo->nTop;
              }

              WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Event,
                             "%s Mouse click in horizontal scroll bar (knob). iPosition=%d\n", __FUNCTION__, iPosition);

              // TODO:  determine position of knob
            }
            else if(iX >= pScrollInfo->geomHLeft.x + pScrollInfo->geomHLeft.width &&
                    iX < pScrollInfo->geomHKnob.x)
            {
              iDirection = WB_SCROLL_PAGEBACK;
              WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Event,
                             "%s Mouse click in horizontal scroll bar (page left)\n", __FUNCTION__);
            }
            else if(iX >= pScrollInfo->geomHKnob.x + pScrollInfo->geomHKnob.width &&
                    iX < pScrollInfo->geomHRight.x)
            {
              iDirection = WB_SCROLL_PAGEFWD;
              WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Event,
                             "%s Mouse click in horizontal scroll bar (page right)\n", __FUNCTION__);
            }
            else
            {
              WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Event,
                             "%s Mouse click in horizontal scroll bar (unknown)\n", __FUNCTION__);
            }

            InternalNotifySelf(wID, aSCROLL_NOTIFY, WB_SCROLL_HORIZONTAL, iDirection, iPosition, 0, 0);

            return 1;  // handled
          }
        }
      }
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_DBLCLICK)
    {
      if(pEvent->xclient.data.l[1] == WB_POINTER_BUTTON1 && // left button
         !pEvent->xclient.data.l[2])
      {
        iX = pEvent->xclient.data.l[3];
        iY = pEvent->xclient.data.l[4];
        // assume selection already done, so notify owner

        if(WB_LIKELY(pScrollInfo != NULL))
        {
          if(WBPointInGeom(iX, iY, pScrollInfo->geomVBar))
          {
            // if not within knob, re-post to self as single-click
            if(!WBPointInGeom(iX, iY, pScrollInfo->geomVKnob))
            {
              XClientMessageEvent evt;
              memcpy(&evt, pEvent, sizeof(evt));
              evt.data.l[0] = WB_POINTER_CLICK;

              return WBScrollBarEvent(wID, (XEvent *)&evt, pScrollInfo);
            }
          }
          else if(WBPointInGeom(iX, iY, pScrollInfo->geomHBar))
          {
            // if not within knob, re-post to self as single-click
            if(!WBPointInGeom(iX, iY, pScrollInfo->geomHKnob))
            {
              XClientMessageEvent evt;
              memcpy(&evt, pEvent, sizeof(evt));
              evt.data.l[0] = WB_POINTER_CLICK;

              return WBScrollBarEvent(wID, (XEvent *)&evt, pScrollInfo);
            }
          }
        }
      }
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_CANCEL)
    {
      // canceling drag (as appropriate)

//      if(pScrollInfo &&
//         pEvent->xclient.data.l[1] == WB_POINTER_BUTTON1 && // left button
//         !pEvent->xclient.data.l[2])
//      {
//        pScrollInfo->iScrollState &= ~WBScrollState_LDRAG;
//      }
      if((pScrollInfo->iScrollState & WBScrollState_LDRAG) ||
         (pScrollInfo->iScrollState & WBScrollState_MDRAG) ||
         (pScrollInfo->iScrollState & WBScrollState_RDRAG))
      {
        pScrollInfo->iScrollState &= ~(WBScrollState_LDRAG | WBScrollState_MDRAG | WBScrollState_RDRAG);

        return 1;  // "handled"
      }
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_DRAG ||
            pEvent->xclient.data.l[0] == WB_POINTER_MOVE)
    {
      if(pEvent->xclient.data.l[1] == WB_POINTER_BUTTON1 && // left button
         !pEvent->xclient.data.l[2])
      {
        iX = pEvent->xclient.data.l[3];
        iY = pEvent->xclient.data.l[4];

        if(WB_LIKELY(pScrollInfo != NULL))
        {
          if(!WBPointInGeom(iX, iY, pScrollInfo->geomVBar) &&
             !WBPointInGeom(iX, iY, pScrollInfo->geomHBar) &&
             (!(pScrollInfo->iScrollState & WBScrollState_LDRAG) ||
              pEvent->xclient.data.l[0] == WB_POINTER_DRAG))
          {
            // TODO:  this is for multi-select listboxes, doing a drag-select

            pScrollInfo->iScrollState &= ~WBScrollState_LDRAG; // make sure

            return 0;  // "not handled" (allow drag-select to be handled by scrollbar owner)
          }
          else if(WBPointInGeom(iX, iY, pScrollInfo->geomVKnob) ||
                  WB_LIKELY(pEvent->xclient.data.l[0] == WB_POINTER_MOVE &&
                            (pScrollInfo->iScrollState & WBScrollState_LDRAG)))
          {
            if(pEvent->xclient.data.l[0] == WB_POINTER_DRAG) // begin drag, return window ID
            {
              WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Event,
                             "%s Mouse drag in vert scroll bar (knob)\n", __FUNCTION__);

              pScrollInfo->iScrollState |= WBScrollState_LDRAG;  // set the state bit for left-drag
              return((int)wID); // enabling the drag
            }

            iPosition = WBCalcVScrollDragPos(pScrollInfo, iY);

            if(iPosition < 0)
            {
              iPosition = pScrollInfo->iVMin; //pListInfo->nTop;
            }

            // track the mouse position along the center of the knob, if possible

            WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Event,
                             "%s Mouse motion in scroll bar (knob) iPosition=%d\n", __FUNCTION__, iPosition);

            InternalNotifySelf(wID, aSCROLL_NOTIFY, WB_SCROLL_VERTICAL,
                               WB_SCROLL_KNOB, iPosition, 0, 0);

            return 1; // handled
          }
          else if(WBPointInGeom(iX, iY, pScrollInfo->geomHKnob) ||
                  WB_LIKELY(pEvent->xclient.data.l[0] == WB_POINTER_MOVE &&
                            (pScrollInfo->iScrollState & WBScrollState_HLDRAG)))
          {
            if(pEvent->xclient.data.l[0] == WB_POINTER_DRAG) // begin drag, return window ID
            {
              WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Event,
                             "%s Mouse drag in horiz scroll bar (knob)\n", __FUNCTION__);

              pScrollInfo->iScrollState |= WBScrollState_HLDRAG;  // set the state bit for left-drag
              return((int)wID); // enabling the drag (window ID cannot be 'None')
            }

            iPosition = WBCalcHScrollDragPos(pScrollInfo, iX);

            if(iPosition < 0)
            {
              iPosition = pScrollInfo->iHMin; // pListInfo->nTop;
            }

            // track the mouse position along the center of the knob, if possible

            WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Event,
                           "%s Mouse motion in scroll bar (knob) iPosition=%d\n", __FUNCTION__, iPosition);

            InternalNotifySelf(wID, aSCROLL_NOTIFY, WB_SCROLL_HORIZONTAL,
                               WB_SCROLL_KNOB, iPosition, 0, 0);

            return 1; // handled
          }
          else
          {
            WB_DEBUG_PRINT(DebugLevel_Medium | DebugSubSystem_ScrollBar | DebugSubSystem_Event,
                           "%s mouse motion in scroll bar outside of knob\n", __FUNCTION__);
          }
        }
      }
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_DROP)
    {
      if(WB_LIKELY(pScrollInfo != NULL))
      {
        if((pScrollInfo->iScrollState & WBScrollState_LDRAG) ||
           (pScrollInfo->iScrollState & WBScrollState_MDRAG) ||
           (pScrollInfo->iScrollState & WBScrollState_RDRAG))
        {
          pScrollInfo->iScrollState &= ~(WBScrollState_LDRAG | WBScrollState_MDRAG | WBScrollState_RDRAG);

          return 1;  // "handled" (just a notification anyway)
        }
      }
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_SCROLLUP)
    {
      iRval = InternalNotifySelf(wID, aSCROLL_NOTIFY, WB_SCROLL_VERTICAL, WB_SCROLL_BACKWARD, 0, 0, 0);

      if(iRval)
      {
        return iRval; // to indicate it was handled
      }
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_SCROLLDOWN)
    {
      iRval = InternalNotifySelf(wID, aSCROLL_NOTIFY, WB_SCROLL_VERTICAL, WB_SCROLL_FORWARD, 0, 0, 0);

      if(iRval)
      {
        return iRval; // to indicate it was handled
      }
    }

    // TODO:  anything else?
  }
  else if(pEvent->xclient.message_type == aWB_CHAR)
  {
    // handle cursors only - up, down, left, right, home, end, page up, page down, etc.

    long lKey WB_UNUSED = pEvent->xclient.data.l[0];             // return from WBKeyEventProcessKey
    long lAltCtrlShift WB_UNUSED = pEvent->xclient.data.l[1];    // *piAltCtrlShift from WBKeyEventProcessKey
#ifndef NO_DEBUG
    int nChar WB_UNUSED = (int)pEvent->xclient.data.l[2];        // # of characters decoded into pBuf (below)
    char *pBuf WB_UNUSED = (char *)&(pEvent->xclient.data.l[3]); // decode buffer (at least 8 chars in length)
#endif // !NO_DEBUG

#warning scroll bar hot keys have not been implemented yet
    // TODO:  scroll bar hotkeys


  }

//  WB_ERROR_PRINT("TEMPORARY:  %s %d - NOT handled\n", __FUNCTION__, __LINE__);
//  WBDebugDumpEvent(pEvent);

  return 0;
}


// this assumes WB_SCROLLINFO is valid.  To make it so, call WBUpdateScrollBarGeometry() or similar

void WBPaintHScrollBar(WB_SCROLLINFO *pScrollInfo, Display *pDisplay, Drawable wID,
                       WBGC gc, WB_GEOM *pgeomClient)
{
  CheckInitScrollColors();

  // fill scrollbar with background color
  WBSetForeground(gc, clrScrollBG.pixel);
  WBFillRectangle(pDisplay, wID, gc, pScrollInfo->geomHBar.x - 1, pScrollInfo->geomHBar.y,
                  pScrollInfo->geomHBar.width + 1, pScrollInfo->geomHBar.height);

  // draw 3D borders around everything

  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomHBar),
                     clrScrollBD3.pixel, clrScrollBD2.pixel);

  // if the scrollbar is DISABLED, do not draw the rest of it
  if(pScrollInfo->iHPos < pScrollInfo->iHMin ||
     pScrollInfo->iHPos > pScrollInfo->iHMax ||
     pScrollInfo->iHMax < pScrollInfo->iHMin)
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_ScrollBar | DebugSubSystem_Expose,
                   "%s - grey out iHPos=%d  iHMin=%d  iHMax=%d\n", __FUNCTION__,
                   pScrollInfo->iHPos, pScrollInfo->iHMin, pScrollInfo->iHMax);

    return;  // I am done (greyed out bar)
  }

  WB_DEBUG_PRINT(DebugLevel_Verbose | DebugSubSystem_ScrollBar | DebugSubSystem_Expose,
                 "%s - paint 'left' button %d %d %d %d (%d)\n", __FUNCTION__,
                 pScrollInfo->geomHLeft.x,
                 pScrollInfo->geomHLeft.y,
                 pScrollInfo->geomHLeft.width,
                 pScrollInfo->geomHLeft.height,
                 pScrollInfo->geomHLeft.border);

  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomHLeft),
                     clrScrollBD2.pixel, clrScrollBD3.pixel);

  WB_DEBUG_PRINT(DebugLevel_Verbose | DebugSubSystem_ScrollBar | DebugSubSystem_Expose,
                 "%s - paint 'right' button %d %d %d %d (%d)\n", __FUNCTION__,
                 pScrollInfo->geomHRight.x,
                 pScrollInfo->geomHRight.y,
                 pScrollInfo->geomHRight.width,
                 pScrollInfo->geomHRight.height,
                 pScrollInfo->geomHRight.border);

  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomHRight),
                     clrScrollBD2.pixel, clrScrollBD3.pixel);

  WB_DEBUG_PRINT(DebugLevel_Verbose | DebugSubSystem_ScrollBar | DebugSubSystem_Expose,
                 "%s - paint horizontal 'knob' %d %d %d %d (%d)\n", __FUNCTION__,
                 pScrollInfo->geomHKnob.x,
                 pScrollInfo->geomHKnob.y,
                 pScrollInfo->geomHKnob.width,
                 pScrollInfo->geomHKnob.height,
                 pScrollInfo->geomHKnob.border);

  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomHKnob),
                     clrScrollBD2.pixel, clrScrollBD3.pixel);

  // draw arrows

  WBDrawLeftArrow(pDisplay, wID, gc, &(pScrollInfo->geomHLeft), clrScrollFG.pixel);
  WBDrawRightArrow(pDisplay, wID, gc, &(pScrollInfo->geomHRight), clrScrollFG.pixel);
}

// NOTE:  this assumes WB_SCROLLINFO is valid.  To make it so, call WBUpdateScrollBarGeometry() or similar

void WBPaintVScrollBar(WB_SCROLLINFO *pScrollInfo, Display *pDisplay, Drawable wID,
                       WBGC gc, WB_GEOM *pgeomClient)
{
  CheckInitScrollColors();

  // fill scrollbar with background color
  WBSetForeground(gc, clrScrollBG.pixel);
  WBFillRectangle(pDisplay, wID, gc, pScrollInfo->geomVBar.x - 1, pScrollInfo->geomVBar.y,
                  pScrollInfo->geomVBar.width + 1, pScrollInfo->geomVBar.height);

  // draw 3D borders around everything

  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomVBar),
                     clrScrollBD3.pixel, clrScrollBD2.pixel);

  // if the scrollbar is DISABLED, do not draw the rest of it
  if(pScrollInfo->iVPos < pScrollInfo->iVMin ||
     pScrollInfo->iVPos > pScrollInfo->iVMax ||
     pScrollInfo->iVMax < pScrollInfo->iVMin)
  {
    WB_DEBUG_PRINT(DebugLevel_Chatty | DebugSubSystem_ScrollBar | DebugSubSystem_Expose,
                   "%s - grey out iVPos=%d  iVMin=%d  iVMax=%d\n", __FUNCTION__,
                   pScrollInfo->iVPos, pScrollInfo->iVMin, pScrollInfo->iVMax);

    return;  // I am done (greyed out bar)
  }

  WB_DEBUG_PRINT(DebugLevel_Verbose | DebugSubSystem_ScrollBar | DebugSubSystem_Expose,
                 "%s - paint 'up' button %d %d %d %d (%d)\n", __FUNCTION__,
                 pScrollInfo->geomVUp.x,
                 pScrollInfo->geomVUp.y,
                 pScrollInfo->geomVUp.width,
                 pScrollInfo->geomVUp.height,
                 pScrollInfo->geomVUp.border);

  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomVUp),
                     clrScrollBD2.pixel, clrScrollBD3.pixel);

  WB_DEBUG_PRINT(DebugLevel_Verbose | DebugSubSystem_ScrollBar | DebugSubSystem_Expose,
                 "%s - paint 'down' button %d %d %d %d (%d)\n", __FUNCTION__,
                 pScrollInfo->geomVDown.x,
                 pScrollInfo->geomVDown.y,
                 pScrollInfo->geomVDown.width,
                 pScrollInfo->geomVDown.height,
                 pScrollInfo->geomVDown.border);

  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomVDown),
                     clrScrollBD2.pixel, clrScrollBD3.pixel);

  WB_DEBUG_PRINT(DebugLevel_Verbose | DebugSubSystem_ScrollBar | DebugSubSystem_Expose,
                 "%s - paint vertical 'knob' %d %d %d %d (%d)\n", __FUNCTION__,
                 pScrollInfo->geomVKnob.x,
                 pScrollInfo->geomVKnob.y,
                 pScrollInfo->geomVKnob.width,
                 pScrollInfo->geomVKnob.height,
                 pScrollInfo->geomVKnob.border);

  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomVKnob),
                     clrScrollBD2.pixel, clrScrollBD3.pixel);

  // draw arrows

  WBDrawUpArrow(pDisplay, wID, gc, &(pScrollInfo->geomVUp), clrScrollFG.pixel);
  WBDrawDownArrow(pDisplay, wID, gc, &(pScrollInfo->geomVDown), clrScrollFG.pixel);
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                              //
//   ____                         _                 ____         _                    _    _                    //
//  |  _ \  _ __  __ _ __      __(_) _ __    __ _  |  _ \  _ __ (_) _ __ ___    __ _ | |_ (_)__   __ ___  ___   //
//  | | | || '__|/ _` |\ \ /\ / /| || '_ \  / _` | | |_) || '__|| || '_ ` _ \  / _` || __|| |\ \ / // _ \/ __|  //
//  | |_| || |  | (_| | \ V  V / | || | | || (_| | |  __/ | |   | || | | | | || (_| || |_ | | \ V /|  __/\__ \  //
//  |____/ |_|   \__,_|  \_/\_/  |_||_| |_| \__, | |_|    |_|   |_||_| |_| |_| \__,_| \__||_|  \_/  \___||___/  //
//                                          |___/                                                               //
//                                                                                                              //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void WBDrawBorderRect(Display *pDisplay, Drawable wID, WBGC gc,
                      WB_GEOM *pgeomBorder, unsigned long lBorderColor)
{
XPoint xpt[5];

  if(!pgeomBorder || !pDisplay || wID == None || gc == None)
  {
    return; // parameter validation
  }

  WBSetForeground(gc, lBorderColor);

  xpt[0].x=pgeomBorder->x;
  xpt[0].y=pgeomBorder->y;

  xpt[1].x = xpt[0].x
           + pgeomBorder->width
           - 1;  // 'inclusive' values

  xpt[1].y = xpt[0].y;

  xpt[2].x = xpt[1].x;
  xpt[2].y = xpt[1].y
           + pgeomBorder->height
           - 1;

  xpt[3].x = xpt[0].x;
  xpt[3].y = xpt[2].y;

  xpt[4].x = xpt[0].x;
  xpt[4].y = xpt[0].y + 1;   // exclude final point

  WBDrawLines(pDisplay, wID, gc, xpt, 5, CoordModeOrigin);
}

void WBDraw3DBorderRect(Display *pDisplay, Drawable wID, WBGC gc, WB_GEOM *pgeomBorder,
                        unsigned long lBorderColor1, unsigned long lBorderColor2)
{
XPoint xpt[4];
XColor clr;
int iR, iG, iB;


  if(!pgeomBorder || !pDisplay || wID == None || gc == None)
  {
    return; // parameter validation
  }

  WBSetForeground(gc, lBorderColor1);
  xpt[0].x = pgeomBorder->x;
  xpt[0].y = pgeomBorder->y
           + pgeomBorder->height - 1 - 1;  // exclude first point

  xpt[1].x = xpt[0].x;
  xpt[1].y = pgeomBorder->y;

  xpt[2].x = xpt[0].x
           + pgeomBorder->width - 1 - 1;   // exclude last point
  xpt[2].y = xpt[1].y;

  WBDrawLines(pDisplay, wID, gc, xpt, 3, CoordModeOrigin);

  WBSetForeground(gc, lBorderColor2);

  xpt[0].x = pgeomBorder->x
           + pgeomBorder->width - 1;
  xpt[0].y = pgeomBorder->y + 1;              // exclude first point

  xpt[1].x = xpt[0].x;
  xpt[1].y = pgeomBorder->y
           + pgeomBorder->height - 1;

  xpt[2].x = pgeomBorder->x + 1;              // exclude final point
  xpt[2].y = xpt[1].y;

  WBDrawLines(pDisplay, wID, gc, xpt, 3, CoordModeOrigin);

  // Use the RGB info to calculate an 'average' color for the corners

  bzero(&clr, sizeof(clr));
  clr.pixel = lBorderColor1;

  PXM_PixelToRGB(NULL, &clr);

  iR = (clr.flags & DoRed) ? (unsigned int)clr.red : 0;
  iG = (clr.flags & DoGreen) ? (unsigned int)clr.green : 0;
  iB = (clr.flags & DoBlue) ? (unsigned int)clr.blue : 0;

  bzero(&clr, sizeof(clr));
  clr.pixel = lBorderColor2;

  PXM_PixelToRGB(NULL, &clr);

  iR += (clr.flags & DoRed) ? (unsigned int)clr.red : 0;
  iG += (clr.flags & DoGreen) ? (unsigned int)clr.green : 0;
  iB += (clr.flags & DoBlue) ? (unsigned int)clr.blue : 0;

  bzero(&clr, sizeof(clr));

  clr.red = iR >> 1;
  clr.green = iG >> 1;
  clr.blue = iB >> 1;

  PXM_RGBToPixel(NULL, &clr); // TODO:  alloc the color as well?

//  WB_ERROR_PRINT("TEMPORARY:  %s - average of %08xH and %08xH is %08xH (%d, %d, %d)\n", __FUNCTION__,
//                 (unsigned int)lBorderColor1, (unsigned int)lBorderColor2,
//                 (unsigned int)clr.pixel, clr.red, clr.green, clr.blue);

  WBSetForeground(gc, clr.pixel);

  xpt[0].x = pgeomBorder->x;
  xpt[1].y = pgeomBorder->y;

  xpt[1].x = xpt[0].x + pgeomBorder->width - 1;
  xpt[0].y = xpt[1].y + pgeomBorder->height - 1;

  WBDrawPoints(pDisplay, wID, gc, xpt, 2, CoordModeOrigin);

  WBSetForeground(gc, lBorderColor1);

}

void WBDrawBorderElipse(Display *pDisplay, Drawable wID, WBGC gc,
                        WB_GEOM *pgeomBorder, unsigned long lBorderColor)
{
  if(!pgeomBorder || !pDisplay || wID == None || gc == None)
  {
    return; // parameter validation
  }

  WBSetForeground(gc, lBorderColor);

  WBDrawArc(pDisplay, wID, gc,
            pgeomBorder->x, pgeomBorder->y,
            pgeomBorder->width, pgeomBorder->height,
            0, 360 * 64); // draw a full circle within the geom bounds
}

void WBDraw3DBorderElipse(Display *pDisplay, Drawable wID, WBGC gc, WB_GEOM *pgeomBorder,
                          unsigned long lBorderColor1, unsigned long lBorderColor2)
{
  if(!pgeomBorder || !pDisplay || wID == None || gc == None)
  {
    return; // parameter validation
  }

  // use lBorderColor1 from 45 to 225, and lBorderColor2 from 225 back to 45
  // (positive angles indicate counterclockwise rotation for WBDrawArc)

  WBSetForeground(gc, lBorderColor2);

  WBDrawArc(pDisplay, wID, gc,
            pgeomBorder->x, pgeomBorder->y,
            pgeomBorder->width, pgeomBorder->height,
            0, 360 * 64); // entire circle

  WBSetForeground(gc, lBorderColor1);

  WBDrawArc(pDisplay, wID, gc,
            pgeomBorder->x, pgeomBorder->y,
            pgeomBorder->width, pgeomBorder->height,
            45 * 64, 180 * 64); // upper half-circle 45 to 180

  WBDrawArc(pDisplay, wID, gc,
            pgeomBorder->x, pgeomBorder->y,
            pgeomBorder->width, pgeomBorder->height,
            -135 * 64, -180 * 64); // upper half-circle 180 to 225 (-135)

//  WBSetForeground(gc, lBorderColor2);
//
//  WBDrawArc(pDisplay, wID, gc,
//            pgeomBorder->x, pgeomBorder->y,
//            pgeomBorder->width, pgeomBorder->height,
//            -45 * 64, -225 * 64); // lower half-circle
////            225 * 64, 45 * 64); // lower half-circle
}

void WBDrawDashedRect(Display *pDisplay, Drawable wID, WBGC gc, WB_GEOM *pgeomRect, unsigned long lColor)
{
static const char dash_list[4]={1,2,2,1};
WBGC gc2;


  gc2 = WBGetWindowCopyGC2(wID, gc);

  if(gc2)
  {
    WBDrawBorderRect(pDisplay, wID, gc2, pgeomRect, WhitePixel(pDisplay, DefaultScreen(pDisplay)));
    WBSetDashes(gc2, 1, dash_list, 4);
    WBSetLineAttributes(gc2, 1, LineOnOffDash, CapNotLast, JoinBevel);
    WBSetBackground(gc2, WhitePixel(pDisplay, DefaultScreen(pDisplay)));
    WBDrawBorderRect(pDisplay, wID, gc2, pgeomRect, lColor);

    WBFreeGC(gc2);
  }
  else
  {
    WB_ERROR_PRINT("%s:%d - unable to create GC\n", __FUNCTION__, __LINE__);
  }
}

void WBDrawLeftArrow(Display *pDisplay, Drawable wID, WBGC gc, WB_GEOM *pgeomRect, unsigned long lColor)
{
XPoint xpt[5];
long lBG, lFG;

  lBG = WBGetGCBGColor(gc);
  lFG = WBGetGCFGColor(gc); // save color context

  WBSetForeground(gc, lColor);
  WBSetBackground(gc, lColor);

  // LEFT ARROW
  xpt[0].x = pgeomRect->x + (pgeomRect->width >> 2);
  xpt[0].y = pgeomRect->y + (pgeomRect->height >> 2) + (pgeomRect->height >> 2);
  xpt[1].x = xpt[0].x + (pgeomRect->width >> 1) - 1;
  xpt[1].y = pgeomRect->y + (pgeomRect->height >> 2);
  xpt[2].x = xpt[1].x;
  xpt[2].y = pgeomRect->y + pgeomRect->height - 1 - (pgeomRect->height >> 2);
  xpt[3].x = xpt[0].x;
  xpt[3].y = xpt[2].y - (pgeomRect->height >> 2);
  xpt[4].x = xpt[0].x;
  xpt[4].y = xpt[0].y;

  WBDrawLines(pDisplay, wID, gc, xpt, 5, CoordModeOrigin);
  WBFillPolygon(pDisplay, wID, gc, xpt, 5, /*Convex*/Nonconvex, CoordModeOrigin);

  WBSetForeground(gc, lFG);
  WBSetBackground(gc, lBG); // restore color context
}

void WBDrawUpArrow(Display *pDisplay, Drawable wID, WBGC gc, WB_GEOM *pgeomRect, unsigned long lColor)
{
XPoint xpt[5];
long lBG, lFG;

  lBG = WBGetGCBGColor(gc);
  lFG = WBGetGCFGColor(gc); // save color context

  WBSetForeground(gc, lColor);
  WBSetBackground(gc, lColor);

  xpt[0].x = pgeomRect->x + (pgeomRect->width >> 2) + (pgeomRect->width >> 2);
  xpt[0].y = pgeomRect->y + (pgeomRect->height >> 2);
  xpt[1].x = pgeomRect->x + (pgeomRect->width >> 2);
  xpt[1].y = xpt[0].y + (pgeomRect->height >> 1) - 1;
  xpt[2].x = pgeomRect->x + pgeomRect->width - 1 - (pgeomRect->width >> 2);
  xpt[2].y = xpt[1].y;
  xpt[3].x = xpt[2].x - (pgeomRect->width >> 2);
  xpt[3].y = xpt[0].y;
  xpt[4].x = xpt[0].x;
  xpt[4].y = xpt[0].y;

  WBDrawLines(pDisplay, wID, gc, xpt, 5, CoordModeOrigin);
  WBFillPolygon(pDisplay, wID, gc, xpt, 5, /*Convex*/Nonconvex, CoordModeOrigin);

  WBSetForeground(gc, lFG);
  WBSetBackground(gc, lBG); // restore color context
}

void WBDrawRightArrow(Display *pDisplay, Drawable wID, WBGC gc, WB_GEOM *pgeomRect, unsigned long lColor)
{
XPoint xpt[5];
long lBG, lFG;

  lBG = WBGetGCBGColor(gc);
  lFG = WBGetGCFGColor(gc); // save color context

  WBSetForeground(gc, lColor);
  WBSetBackground(gc, lColor);

  // RIGHT ARROW
  xpt[0].x = pgeomRect->x + pgeomRect->width - 1 - (pgeomRect->width >> 2);
  xpt[0].y = pgeomRect->y + (pgeomRect->height >> 2) + (pgeomRect->height >> 2);
  xpt[1].x = xpt[0].x - (pgeomRect->width >> 1) + 1;
  xpt[1].y = pgeomRect->y + (pgeomRect->height >> 2);
  xpt[2].x = xpt[1].x;
  xpt[2].y = pgeomRect->y + pgeomRect->height - 1 - (pgeomRect->height >> 2);
  xpt[3].x = xpt[0].x;
  xpt[3].y = xpt[2].y - (pgeomRect->height >> 2);
  xpt[4].x = xpt[0].x;
  xpt[4].y = xpt[0].y;

  WBDrawLines(pDisplay, wID, gc, xpt, 5, CoordModeOrigin);
  WBFillPolygon(pDisplay, wID, gc, xpt, 5, /*Convex*/Nonconvex, CoordModeOrigin);

  WBSetForeground(gc, lFG);
  WBSetBackground(gc, lBG); // restore color context
}

void WBDrawDownArrow(Display *pDisplay, Drawable wID, WBGC gc, WB_GEOM *pgeomRect, unsigned long lColor)
{
XPoint xpt[5];
long lBG, lFG;

  lBG = WBGetGCBGColor(gc);
  lFG = WBGetGCFGColor(gc); // save color context

  WBSetForeground(gc, lColor);
  WBSetBackground(gc, lColor);

  xpt[0].x = pgeomRect->x + (pgeomRect->width >> 2) + (pgeomRect->width >> 2);
  xpt[0].y = pgeomRect->y + pgeomRect->height - 1 - (pgeomRect->height >> 2);
  xpt[1].x = pgeomRect->x + (pgeomRect->width >> 2);
  xpt[1].y = xpt[0].y - (pgeomRect->height >> 1) + 1;
  xpt[2].x = pgeomRect->x + pgeomRect->width - 1 - (pgeomRect->width >> 2);
  xpt[2].y = xpt[1].y;
  xpt[3].x = xpt[2].x - (pgeomRect->width >> 2);
  xpt[3].y = xpt[0].y;
  xpt[4].x = xpt[0].x;
  xpt[4].y = xpt[0].y;

  WBDrawLines(pDisplay, wID, gc, xpt, 5, CoordModeOrigin);
  WBFillPolygon(pDisplay, wID, gc, xpt, 5, /*Convex*/Nonconvex, CoordModeOrigin);

  WBSetForeground(gc, lFG);
  WBSetBackground(gc, lBG); // restore color context
}

void WBDraw3DBorderTab(Display *pDisplay, Drawable dw, WBGC gc, WB_GEOM *pgeomOutline,
                       int fFocus, unsigned long lFGColor, unsigned long lBGColor,
                       unsigned long lBorderColor1, unsigned long lBorderColor2,
                       unsigned long lHighlightColor,
                       WB_FONTC pFont, WB_FONTC pFontBold,
                       Atom aGraphic, const char *szText)
{
XPoint xpt[13];
XColor clrAvg, clrTemp;
unsigned long lHighlightColor2;
int iFontHeight, bFocus;
int i1, i2, iR, iG, iB, iY, iU, iV, iYBG, iY0, iU0, iV0;
Region rgnClip;
WBGC gc2;
WB_RECT rctTemp;


  if(!pFont)
  {
    pFont = WBGetDefaultFont();
  }

  if(!pFontBold)
  {
    pFontBold = WBGetDefaultFont();
  }

  iFontHeight = WBFontHeight(pFont);


  // begin by creating a region that consists of my 'rounded rect' polygon

  // create a rounded-corner trapezoid the encompasses the tab.  corner pixels will
  // be averages of the border colors.

  // lower left corner
  xpt[0].x = pgeomOutline->x;
  xpt[0].y = pgeomOutline->y + pgeomOutline->height + 1; // for clip rgn, I do this

  // left side
  xpt[1].x = xpt[0].x + 2; // slight trapezoid
  xpt[1].y = pgeomOutline->y + 3;  // room for corner

  // upper left corner
  xpt[2].x = xpt[1].x + 1;
  xpt[2].y = xpt[1].y - 1; // 45 degrees
  xpt[3].x = xpt[2].x + 1;
  xpt[3].y = xpt[2].y - 1; // again
  xpt[4].x = xpt[3].x + 1;
  xpt[4].y = xpt[3].y - 1; // now we're "on point"

  // top row
  xpt[5].x = xpt[0].x + pgeomOutline->width - 5;
  xpt[5].y = xpt[4].y;

  // upper right corner
  xpt[6].x = xpt[5].x + 1;
  xpt[6].y = xpt[5].y + 1; // 45 degrees
  xpt[7].x = xpt[6].x + 1;
  xpt[7].y = xpt[6].y + 1; // 45 degrees
  xpt[8].x = xpt[7].x + 1;
  xpt[8].y = xpt[7].y + 1; // 45 degrees

  // right side
  xpt[9].x = pgeomOutline->x + pgeomOutline->width;
  xpt[9].y = xpt[0].y; // same y as 1st point

  xpt[10].x = xpt[0].x;
  xpt[10].y = xpt[0].y; // close up the polygon

  rgnClip = XPolygonRegion(xpt, 11, WindingRule);
  if(rgnClip == None)
  {
    WB_ERROR_PRINT("ERROR:  %s - unable to create polygon region\n", __FUNCTION__);
    return;
  }

  // create GC copy and select the clipping region

  gc2 = WBCopyDrawableGC(pDisplay, dw, gc);

  if(gc2 == None)
  {
    XDestroyRegion(rgnClip);

    WB_ERROR_PRINT("ERROR:  %s - unable to create GC\n", __FUNCTION__);
    return;
  }

  // select the clip region
  WBSetRegion(gc2, rgnClip);

  // set 'bFocus' to indicate if I have focus.  'fFocus' also indicates 'x' button state
  // 0 or < -1 is "I do not have focus".  -1 or > 0 is "I have focus".  negative is 'x button clicked'

  bFocus = fFocus > 0 || fFocus == -1;

  lHighlightColor2 = lHighlightColor; // initially, to avoid warnings later.  it's only assigned/used when bFocus is TRUE

  if(bFocus)
  {
    // do the background color in the tab.  this will use the clip region to help me

    clrTemp.pixel = lBGColor; // default background color
    PXM_PixelToRGB(NULL, &clrTemp);

    iR = clrTemp.red >> 8;
    iG = clrTemp.green >> 8;
    iB = clrTemp.blue >> 8;

    PXM_RGBToYUV(iR, iG, iB, &iYBG, NULL, NULL); // get 'Y' for the background (assume grey)
    // if the background Y is less than 'pure white', split the difference
    if(iYBG < 255)
    {
      iYBG = (iYBG + 256) / 2; // halfway between white and background luminocity
    }

    iY0 = iYBG; // initialize this way

    clrTemp.pixel = lHighlightColor;
    PXM_PixelToRGB(NULL, &clrTemp);

    iR = clrTemp.red >> 8;  // convert to 8-bit colors
    iG = clrTemp.green >> 8;
    iB = clrTemp.blue >> 8;

    PXM_RGBToYUV(iR, iG, iB, &iY0, &iU0, &iV0); // cache YUV as iY0, iU0, iV0

    // restrict the range of the brightness of the highlight color vs background

    if(iY0 > 5 * iYBG / 8)      // no more than 5/8 of backgroun luma
    {
      iY0 = 5 * iYBG / 8;
    }
    else if(iY0 < 3 * iYBG / 8) // at least 3/8 of background luma
    {
      iY0 = 3 * iYBG / 8;
    }

    PXM_YUVToRGB(iY0, iU0, iV0, &iR, &iG, &iB); // convert back from YUV to RGB

    clrTemp.red = (iR << 8) + 128; // convert to 16-bit colors
    clrTemp.green = (iG << 8) + 128;
    clrTemp.blue = (iB << 8) + 128;

    PXM_RGBToPixel(NULL, &clrTemp); // fix 'pixel' entry

    lHighlightColor2 = clrTemp.pixel; // and store it for later (this is the shadow color now)


    i2 = 6 * (xpt[0].y - xpt[5].y - 2) / 7; // calculate 6/7 of the tab height, what I deem to be the 'white' point

//    WB_ERROR_PRINT("TEMPORARY:  %s - i2 is %d, from %d and %d\n", __FUNCTION__,
//                   i2, xpt[0].y, xpt[5].y);

    for(i1=xpt[5].y; i1 < xpt[0].y - 2; i1++)
    {
      XPoint xpt2[2];
      int iR2 = abs(i1 - (xpt[5].y + i2 / 2)); // 'i2 / 2' is 3/7 of the height...

      iR2 = 128 + WB_icos(iR2 * 240 / i2); // 255 would be pi/2, so go slightly less than that for 'full range' on the cosine
                                           // NOTE:  a value closer to '255' will darken the darkest part of the shadow
      iR2 = ((int)iR2 * (int)iR2) / 256; // use cos^2 - 'icos' returns a value between 0 and 255
//      iR2 *= iR2;  old way, squared it
//      iR2 = isqrt(iR2); old way, square root

      iY = iY0; // grab cached YUV values for highlight color
      iU = iU0;
      iV = iV0;

      // NOTE:  'iY' is the brightness of the highlight color, 'iYBG' the brightness of the background (averaged with white)

//      iY = iYBG * 3 / 4 + ((384 - iYBG) * iR2) / 384; // allows brightness to drop to a bit less than the background's brightness
      iY = (iYBG - iY + iY / 2) * iR2 / 256 + iY + iY / 2 + 4;

      if(iY > 255)
      {
        // 'U' and 'V' are actually signed values, +127,-128 so must subtract 128 before calc, add after
        // and in this case, we fade to white as luminocity adjusts to a value of 'pure white'
        iU = 128 + (iU - 128) * 255 / iY * 255 / iY;   // this will make the color "fade to white"
        iV = 128 + (iV - 128) * 255 / iY * 255 / iY;   // by reducing U and V by the amount in excess of '255' the luma goes
        iY = 255;
      }

      PXM_YUVToRGB(iY, iU, iV, &iR, &iG, &iB);

      clrTemp.red = (iR << 8) + 128;    // convert to 16-bit color - adding 128 is for the roundoff
      clrTemp.green = (iG << 8) + 128;
      clrTemp.blue = (iB << 8) + 128;
      clrTemp.flags = DoRed | DoGreen | DoBlue;

      PXM_RGBToPixel(NULL, &clrTemp);

//      WB_ERROR_PRINT("TEMPORARY:  %s - YUV is %d, %d, %d, RGB is %d, %d, %d  for %lu (%08lxH)\n", __FUNCTION__,
//                     iY, iU, iV,
//                     clrTemp.red, clrTemp.green, clrTemp.blue, clrTemp.pixel, clrTemp.pixel);

      WBSetForeground(gc2, clrTemp.pixel); // select this color

      xpt2[0].x = pgeomOutline->x + 1;
      xpt2[0].y = i1;
      xpt2[1].x = pgeomOutline->x + pgeomOutline->width - 2;
      xpt2[1].y = xpt2[0].y;

      if(i1 < xpt[5].y + 2) // corner hack, based on observation
      {
        xpt2[0].x += (xpt[5].y + 2) - i1;
        xpt2[1].x -= (xpt[5].y + 2) - i1;
      }

      // draw the line
      WBDrawLines(pDisplay, dw, gc2, xpt2, 2, CoordModeOrigin); // stop at point 6 (don't paint 6 to 7)
    }
  }


  // next, squeeze in the right/left edges of my points.  I've observed I need to do this
  // as a hack, don't do the left squeeze for the 'focus' tab

  if(!bFocus)
  {
    for(i1=0; i1 < 5; i1++)
    {
      xpt[i1].x ++;
    }
  }

  for(i1=5; i1 < 10; i1++)
  {
    xpt[i1].x --;
  }

  if(!bFocus)
  {
    xpt[0].y -= 3; // one above 'bottom' (where I'll draw a line)
  }
  else
  {
    xpt[0].y -= 2;
  }

  xpt[9].y = xpt[0].y; // same y as 1st point

  xpt[10].x = xpt[0].x; // re-close up polygon (again)
  xpt[10].y = xpt[0].y; // close up the polygon


  // make a copy of the GC

  WBSetForeground(gc2, lFGColor);
  WBSetBackground(gc2, lBGColor);

  // Use the RGB info to calculate an 'average' color for the corner transition

  bzero(&clrAvg, sizeof(clrAvg));
  clrAvg.pixel = lBorderColor1;

  PXM_PixelToRGB(NULL, &clrAvg);

  iR = (clrAvg.flags & DoRed) ? (unsigned int)clrAvg.red : 0;
  iG = (clrAvg.flags & DoGreen) ? (unsigned int)clrAvg.green : 0;
  iB = (clrAvg.flags & DoBlue) ? (unsigned int)clrAvg.blue : 0;

  bzero(&clrAvg, sizeof(clrAvg));
  clrAvg.pixel = lBorderColor2;

  PXM_PixelToRGB(NULL, &clrAvg);

  iR += (clrAvg.flags & DoRed) ? (unsigned int)clrAvg.red : 0;
  iG += (clrAvg.flags & DoGreen) ? (unsigned int)clrAvg.green : 0;
  iB += (clrAvg.flags & DoBlue) ? (unsigned int)clrAvg.blue : 0;

  bzero(&clrAvg, sizeof(clrAvg));

  clrAvg.red = iR >> 1;
  clrAvg.green = iG >> 1;
  clrAvg.blue = iB >> 1;

  PXM_RGBToPixel(NULL, &clrAvg); // TODO:  alloc the color as well?

  // next, draw polygon using 3D colors

  WBSetForeground(gc2, lBorderColor1);
  WBDrawLines(pDisplay, dw, gc2, xpt, 7, CoordModeOrigin); // stop at point 6 (don't paint 6 to 7)

  WBSetForeground(gc2, lBorderColor2);
  WBDrawLines(pDisplay, dw, gc2, xpt + 8, 2, CoordModeOrigin); // stop at point 6 (don't paint 6 or 7)

  if(bFocus)
  {
    // for non-focus, draw the bottom (7 to 8) using border color 2.  for focus, draw as background color

    WBSetForeground(gc2, lBGColor);
  }

  WBDrawLines(pDisplay, dw, gc2, xpt + 9, 2, CoordModeOrigin); // the bottom line

  // paint pixels 6 and 7 with the 'average' color
  WBSetForeground(gc2, clrAvg.pixel);
  WBDrawPoints(pDisplay, dw, gc2, xpt + 6, 2, CoordModeOrigin);

  if(!bFocus)
  {
    // when not in focus, also do avg color for the first pixel.  this completes the 3D effect 'color transition'
    WBDrawPoints(pDisplay, dw, gc2, xpt, 1, CoordModeOrigin);
  }



  // TAB TEXT (TODO: image atom)

  rctTemp.left = pgeomOutline->x + 1;
  rctTemp.top = pgeomOutline->y + 1;
  rctTemp.right = rctTemp.left + pgeomOutline->width - 1;
  rctTemp.bottom = rctTemp.top + pgeomOutline->height - 1;

  if(!szText)
  {
    szText = "{untitled}";
  }

  // for now just do centered text.  it's 3D text, shifted up-left and bottom-right for 3D effect

  if(bFocus) // 3D "sunken" text if I have the focus
  {
    rctTemp.left--;
    rctTemp.top--;
    rctTemp.right--;
    rctTemp.bottom--;

    WBSetBackground(gc2, lBGColor);
//    WBSetForeground(gc2, lHighlightColor2);
    WBSetForeground(gc2, lBGColor);

    DTDrawSingleLineText(pFont, szText, pDisplay, gc2, dw, 0, 0, &rctTemp,
                         DTAlignment_HCENTER | DTAlignment_VCENTER | DTAlignment_ANTIALIAS);

    rctTemp.left += 2;
    rctTemp.top += 2;
    rctTemp.right += 2;
    rctTemp.bottom += 2;

//    WBSetForeground(gc2, lBGColor);
    WBSetForeground(gc2, lHighlightColor2);

    // for now just do centered text
    DTDrawSingleLineText(pFont, szText, pDisplay, gc2, dw, 0, 0, &rctTemp,
                         DTAlignment_HCENTER | DTAlignment_VCENTER | DTAlignment_ANTIALIAS);


    rctTemp.left--;
    rctTemp.top--;
    rctTemp.right--;
    rctTemp.bottom--;

//    WBSetBackground(gc2, lHighlightColor2);
  }
  else
  {
    WBSetBackground(gc2, lBGColor);
  }

  WBSetForeground(gc2, lFGColor);

  // for now just do centered text
  DTDrawSingleLineText(pFont, szText, pDisplay, gc2, dw, 0, 0, &rctTemp,
                       DTAlignment_HCENTER | DTAlignment_VCENTER | DTAlignment_ANTIALIAS);


  // NOW, I need to draw the 'x' for the close button.  Fist, I calculate its rect

  rctTemp.top = pgeomOutline->y + 2;                         // top plus 2 pixels
  rctTemp.bottom = rctTemp.top + iFontHeight;                // height is font height
  rctTemp.right = pgeomOutline->x + pgeomOutline->width - 6; // right is 6 pixels from right edge
  rctTemp.left = rctTemp.right - iFontHeight + 2;            // left is 2 pixels + font height from right

  if(fFocus < 0) // clicking 'x' ?
  {
    WBSetForeground(gc2, lHighlightColor);
    WBSetBackground(gc2, lHighlightColor);
  }
  else
  {
    WBSetForeground(gc2, lBGColor);
    WBSetBackground(gc2, lBGColor);
  }

  // fill in with selected colors

  WBFillRectangle(pDisplay, dw, gc2, rctTemp.left, rctTemp.top, rctTemp.right - rctTemp.left, rctTemp.bottom - rctTemp.top);

  if(fFocus < 0) // clicking 'x' ?
  {
    WBSetForeground(gc2, lBGColor);
  }
  else
  {
    WBSetForeground(gc2, lHighlightColor);
  }

  // now draw the '+' using a BOLD font

  rctTemp.left -=2;
  rctTemp.right += 2;
  rctTemp.top -= 2;
  rctTemp.bottom += 2; // big enough to 'center' properly

  DTDrawSingleLineText(pFontBold, "x", pDisplay, gc2, dw, 0, 0, &rctTemp,
                       DTAlignment_HCENTER | DTAlignment_VCENTER);


  WBFreeGC(gc2);
  XDestroyRegion(rgnClip);


//  WB_ERROR_PRINT("TEMPORARY:  %s - only partially implemented\n", __FUNCTION__);
}



