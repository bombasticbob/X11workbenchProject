//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//               _             _                        _                       _                           //
//    __      __(_) _ __    __| |  ___ __      __    __| | _ __  ___  ___  ___ (_) _ __    __ _     ___     //
//    \ \ /\ / /| || '_ \  / _` | / _ \\ \ /\ / /   / _` || '__|/ _ \/ __|/ __|| || '_ \  / _` |   / __|    //
//     \ V  V / | || | | || (_| || (_) |\ V  V /   | (_| || |  |  __/\__ \\__ \| || | | || (_| | _| (__     //
//      \_/\_/  |_||_| |_| \__,_| \___/  \_/\_/_____\__,_||_|   \___||___/|___/|_||_| |_| \__, |(_)\___|    //
//                                            |_____|                                     |___/             //
//                                                                                                          //
//                     Utilities for painting and handling standard components of windows                   //
//                                                                                                          //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2016 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.
               Any claims to alleged functionality or features should be
               considered 'preliminary', and might not function as advertised.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

/** \file window_dressing.c Utilities for painting and handling standard components of windows */


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <errno.h>
#include <X11/Xlib.h>

#include "window_dressing.h"
#include "pixmap_helper.h"
#include "conf_help.h"
#include "draw_text.h"


static XColor clrScrollFG,  ///< foreground scroll bar color
              clrScrollBG,  ///< background scroll bar color
              clrScrollAFG, ///< active foreground scroll bar color
              clrScrollABG, ///< active background scroll bar color
              clrScrollHFG, ///< highlight foreground scroll bar color
              clrScrollHBG, ///< highlight background scroll bar color
              clrScrollBD,  ///< standard scroll bar border color
              clrScrollBD2, ///< 3D highlight scroll bar border color (light)
              clrScrollBD3; ///< 3D highlight scroll bar border color (dark)
/** \hideinitializer
  * \brief initialization flag for scroll colors.  when zero, colors not yet initialized
**/
static int iInitScrollColorFlag = 0;

/** \brief macro to load a color, mostly for readability
**/
#define LOAD_COLOR0(X,Y) if(CHGetResourceString(WBGetDefaultDisplay(), X, Y, sizeof(Y)) > 0) {  }
/** \brief macro to load a color with a fallback, mostly for readability
**/
#define LOAD_COLOR(X,Y,Z) if(CHGetResourceString(WBGetDefaultDisplay(), X, Y, sizeof(Y)) <= 0){ WB_WARN_PRINT("%s - WARNING:  can't find color %s, using default value %s\n", __FUNCTION__, X, Z); strcpy(Y,Z); }

/** \brief internal utility to check and initialize scroll bar standard colors
**/
static void CheckInitScrollColors(void)
{
  // TODO:  consider freeing the colors with XFreeColors on exit
  // TODO:  consider not even bothering with 'XAllocColor' and just use PXM_RGBToPixel()

  if(!iInitScrollColorFlag)
  {
    static const char *szBorder2="#FFFFFF", *szBorder2W="#C8C6C0", *szBorder3="#9C9A94"; // for 3D borders
    char szFG[16], szBG[16], szBD[16], szHFG[16], szHBG[16], szAFG[16], szABG[16]; // must be at least 14 characters
    static const char szFGName[]="Scrollbar.foreground";
    static const char szBGName[]="Scrollbar.background";
    static const char szHFGName[]="Scrollbar.highlightForeground";
    static const char szHBGName[]="Scrollbar.highlightBackground";
    static const char szAFGName[]="Scrollbar.activeForeground";
    static const char szABGName[]="Scrollbar.activeBackground";
    static const char szBDName[]="Scrollbar.border";

    Colormap colormap = DefaultColormap(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));


    LOAD_COLOR0(szFGName,szFG) else LOAD_COLOR0("*Dialog.foreground",szFG) else LOAD_COLOR0("*Form.foreground", szFG)
     else LOAD_COLOR0("*WmDialogShell.foreground",szFG) else LOAD_COLOR0("*WmForm.foreground", szFG)
     else LOAD_COLOR("*foreground", szFG, "#000000");

    LOAD_COLOR0(szBGName,szBG) else LOAD_COLOR0("*Dialog.background",szBG) else LOAD_COLOR0("*Form.background", szBG)
     else LOAD_COLOR0("*WmDialogShell.background",szBG)
     else LOAD_COLOR("*WmForm.background", szBG, "#dcdad5"); // default for gnome is dcdad5

    LOAD_COLOR(szHFGName,szHFG,szFG);
    LOAD_COLOR(szHBGName,szHBG,szBG);
    LOAD_COLOR(szAFGName,szAFG,szFG);
    LOAD_COLOR(szABGName,szABG,szBG);

    LOAD_COLOR0(szBDName,szBD) else LOAD_COLOR0("*Dialog.border",szBD) else LOAD_COLOR0("*Form.border", szBD)
     else LOAD_COLOR0("*WmDialogShell.border",szBD) else LOAD_COLOR0("*WmForm.border", szBD)
     else LOAD_COLOR0("*borderColor", szBD)
     else LOAD_COLOR("*border", szBD, "black"); // default for gnome

    XParseColor(WBGetDefaultDisplay(), colormap, szFG, &clrScrollFG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollFG);
    XParseColor(WBGetDefaultDisplay(), colormap, szBG, &clrScrollBG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollBG);
    XParseColor(WBGetDefaultDisplay(), colormap, szAFG, &clrScrollAFG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollAFG);
    XParseColor(WBGetDefaultDisplay(), colormap, szABG, &clrScrollABG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollABG);
    XParseColor(WBGetDefaultDisplay(), colormap, szHFG, &clrScrollHFG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollHFG);
    XParseColor(WBGetDefaultDisplay(), colormap, szHBG, &clrScrollHBG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollHBG);
    XParseColor(WBGetDefaultDisplay(), colormap, szBD, &clrScrollBD);

    // 3D border colors for now these are hard-coded - later derive them from FG and BG colors
    if(clrScrollBG.red >= 60000 && clrScrollBG.green >= 60000 &&
       clrScrollBG.blue >= 60000) // note see man page on XColor, values 0 through 65535 for RGB
    {
      XParseColor(WBGetDefaultDisplay(), colormap, szBorder2W, &clrScrollBD2);
    }
    else
    {
      XParseColor(WBGetDefaultDisplay(), colormap, szBorder2, &clrScrollBD2);
    }

    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollBD2);
    XParseColor(WBGetDefaultDisplay(), colormap, szBorder3, &clrScrollBD3);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollBD3);

    iInitScrollColorFlag = 1;
  }
}


/** \brief integer square root of a value 0-255
**/
static unsigned char isqrt(unsigned char iVal)
{
unsigned char aAnswers[256] =
{
  0,1,1,2,2,2,2,3,3,3,3,3,3,4,4,4,
  4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,6,
  6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,
  8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,
  9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,10,
  10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,
  11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
  11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,
  12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,
  13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
  13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,
  14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
  14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,
  15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
  15,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16
};


  return aAnswers[iVal & 0xff];
}

/** \brief integer 255 * cos(iVal * pi / 512) calculation via lookup table
**/
static unsigned char icos(unsigned char iVal)
{
unsigned char aAnswers[256] =
{
255,255,255,255,255,255,255,255,255,255,255,254,254,254,254,254,
254,254,253,253,253,253,253,252,252,252,252,252,251,251,251,250,
250,250,249,249,249,248,248,248,247,247,247,246,246,245,245,244,
244,244,243,243,242,242,241,241,240,240,239,238,238,237,237,236,
236,235,234,234,233,232,232,231,231,230,229,228,228,227,226,226,
225,224,223,223,222,221,220,220,219,218,217,216,215,215,214,213,
212,211,210,209,208,208,207,206,205,204,203,202,201,200,199,198,
197,196,195,194,193,192,191,190,189,188,187,186,185,184,183,181,
180,179,178,177,176,175,174,172,171,170,169,168,167,165,164,163,
162,161,159,158,157,156,154,153,152,151,149,148,147,146,144,143,
142,140,139,138,136,135,134,132,131,130,128,127,126,124,123,122,
120,119,117,116,115,113,112,110,109,108,106,105,103,102,100,99,
98,96,95,93,92,90,89,87,86,84,83,81,80,79,77,76,
74,73,71,70,68,67,65,63,62,60,59,57,56,54,53,51,
50,48,47,45,44,42,41,39,37,36,34,33,31,30,28,27,
25,23,22,20,19,17,16,14,13,11,9,8,6,5,3,2
};


  return aAnswers[iVal & 0xff];
}


#if 0 /* this function not currently used.  consider removeing it in a refactor */
static char ilog2n(unsigned char y)
{
  if(y & 0x08)
    return 4;
  else if(y & 0x04)
    return 3;
  else if(y & 0x02)
    return 2;
  else if(y & 0x01)
    return 1;
  else
    return 0;
}
#endif // 0

#if 0 /* this function not currently used.  consider removeing it in a refactor */
static char ilog2c(unsigned char y)
{
  if(y & 0xf0)
    return ilog2n(y >> 4) + 4;

  return ilog2n(y);
}
#endif // 0

#if 0 /* this function not currently used.  consider removeing it in a refactor */
static int ilog2s(unsigned short y)
{
  if(y & 0xff00)
  {
    return ilog2c((unsigned char)(y >> 8)) + 8;
  }

  return ilog2c((unsigned char)y);
}
#endif // 0

#if 0 /* this function not currently used.  consider removeing it in a refactor */
static int ilog2(unsigned int y)
{
  if(y & 0xffff0000)
  {
    return ilog2s((unsigned short)(y >> 16)) + 16;
  }

  return ilog2s((unsigned short)y);
}
#endif // 0

#if 0 /* this function not currently used.  consider removeing it in a refactor */
static int ilog2ll(WB_UINT64 y)
{
  if(y & 0xffffffff00000000LL)
  {
    return ilog2((unsigned int)(y >> 32)) + 32;
  }

  return ilog2((unsigned int)y);
}
#endif // 0


void WBSetVScrollRange(WB_SCROLLINFO *pSI, int iMin, int iMax)
{
  // TODO:  data validation
  pSI->iVMin = iMin;
  pSI->iVMax = iMax;
}

void WBSetHScrollRange(WB_SCROLLINFO *pSI, int iMin, int iMax)
{
  // TODO:  data validation
  pSI->iHMin = iMin;
  pSI->iHMax = iMax;
}

void WBSetVScrollPos(WB_SCROLLINFO *pSI, int iPos)
{
  // TODO:  data validation
  pSI->iVPos = iPos;
}

void WBSetHScrollPos(WB_SCROLLINFO *pSI, int iPos)
{
  // TODO:  data validation
  pSI->iHPos = iPos;
}

static void InternalNotifySelf(Window wID, Atom aNotify, long lData0, long lData1, long lData2, long lData3, long lData4)
{
Display *pDisplay = WBGetWindowDisplay(wID);

  XClientMessageEvent evt = {
                              .type=ClientMessage,
                              .serial=0,
                              .send_event=0,
                              .display=pDisplay,
                              .window=wID,
                              .message_type=aNotify,
                              .format=32
                            };
  evt.data.l[0] = lData0;
  evt.data.l[1] = lData1;
  evt.data.l[2] = lData2;
  evt.data.l[3] = lData3;
  evt.data.l[4] = lData4;

  WBWindowDispatch(wID, (XEvent *)&evt);
}


static void InternalCalcVScrollBar(WB_SCROLLINFO *pScrollInfo, WB_GEOM *pgeomClient, int iVScrollWidth, int iHScrollHeight)
{
int iKnobSize, iKnobPos, iBarHeight, iBarWidth;
int i1, i2;
int nListItems;


  iBarHeight = pgeomClient->height;
  iBarWidth = pgeomClient->width;

  pScrollInfo->iVScrollWidth = iVScrollWidth;
  pScrollInfo->iVBarHeight = iBarHeight;


  if(pScrollInfo->iVPos < pScrollInfo->iVMin || pScrollInfo->iVPos > pScrollInfo->iVMax)
  {
    pScrollInfo->iVPos = -1; // for now
  }

  nListItems = pScrollInfo->iVMax - pScrollInfo->iVMin + 1;


  // knob height equals 'nListItems / nListItems!' multiplied by
  // the available knob height, for a minimum value of 'iHScrollHeight'

  iKnobSize = (iBarHeight - 4 * iHScrollHeight - 2);

  if(iKnobSize > iHScrollHeight / 2)
  {
    i1 = iHScrollHeight * (2 * iHScrollHeight + 1);  // 'twice scroll height' factorial
    i2 = iHScrollHeight * 2;

    while(i2 > 2 && i1 > iKnobSize) // using the above starting point get 'max factorial less than height'
    {
      i1 -= i2;
      i2--;
    }

    if(nListItems >= i2) // more than twice scroll height?
    {
      if(nListItems > iKnobSize || iKnobSize - i1 < iHScrollHeight / 2)
      {
        iKnobSize = -1;  // to fix later
      }
      else
      {
        iKnobSize -= i1;  // twice scroll height factorial
        iKnobSize -= (nListItems - iHScrollHeight * 2 + 1);
      }
    }
    else
    {
      iKnobSize -= i1  // 'twice knob height' factorial
                 - (nListItems + 1) * nListItems / 2;  // 'nListItems' factorial
    }

    if(iKnobSize < 3 * iHScrollHeight / 4)
    {
      iKnobSize = 3 * iHScrollHeight / 4;  // minimum size
    }
  }
  else
  {
    iKnobSize = 3 * iHScrollHeight / 4;  // worst case use this anyway
  }

  // cache these geometries because I need them for mouse handling

  pScrollInfo->geomVBar.y      = pgeomClient->y + 1;
  pScrollInfo->geomVBar.height = pgeomClient->height - 2;
  pScrollInfo->geomVBar.width  = pScrollInfo->iVScrollWidth;
  pScrollInfo->geomVBar.x      = pgeomClient->x + pgeomClient->width
                               - pScrollInfo->geomVBar.width - 1;

  pScrollInfo->geomVDown.x      = pScrollInfo->geomVUp.x
                                = pScrollInfo->geomVBar.x + 1;
  pScrollInfo->geomVDown.width  = pScrollInfo->geomVUp.width
                                = pScrollInfo->geomVBar.width - 2;
  pScrollInfo->geomVDown.height = pScrollInfo->geomVUp.height
                                = iHScrollHeight - 1;

  pScrollInfo->geomVUp.y   = pScrollInfo->geomVBar.y + 1;
  pScrollInfo->geomVDown.y = pScrollInfo->geomVBar.y
                           + pScrollInfo->geomVBar.height
                           - pScrollInfo->geomVDown.height
                           - 1;

  pScrollInfo->geomVKnob.x      = pScrollInfo->geomVDown.x;
  pScrollInfo->geomVKnob.width  = pScrollInfo->geomVDown.width;
  pScrollInfo->geomVKnob.height = pScrollInfo->iVKnobSize
                                = iKnobSize;

  // now that I have a reasonable estimate of the knob size, calculate
  // the starting vertical position of the knob

  if(pScrollInfo->iVPos <= 0 || nListItems <= 0)
  {
    iKnobPos = 0;
  }
  else
  {
    int iBarScrollArea = pScrollInfo->geomVDown.y
                       - (pScrollInfo->geomVUp.y + pScrollInfo->geomVUp.height)
                       - iKnobSize
                       - 1; // inclusive value

    if(pScrollInfo->iVPos >= (nListItems - 1))
    {
      iKnobPos = iBarScrollArea;
    }
    else
    {
      iKnobPos = (WB_INT64)pScrollInfo->iVPos * (WB_INT64)iBarScrollArea
               / (WB_INT64)(nListItems - 1);
    }
  }


  pScrollInfo->geomVKnob.y = (pScrollInfo->iVKnob = iKnobPos)
                           + pScrollInfo->geomVUp.y + pScrollInfo->geomVUp.height;

  // fixed values go here
  pScrollInfo->geomVBar.border = 1;
  pScrollInfo->geomVUp.border = 0;
  pScrollInfo->geomVDown.border = 0;
  pScrollInfo->geomVKnob.border = 0;

}


static void InternalCalcHScrollBar(WB_SCROLLINFO *pScrollInfo, WB_GEOM *pgeomClient, int iVScrollWidth, int iHScrollHeight)
{
int iKnobSize, iKnobPos, iBarHeight, iBarWidth;
int i1, i2;
int nListItems;



  iBarHeight = pgeomClient->height;
  iBarWidth = pgeomClient->width;

  pScrollInfo->iHScrollHeight = iHScrollHeight;
  pScrollInfo->iHBarWidth = iBarWidth;


  if(pScrollInfo->iHPos < pScrollInfo->iHMin || pScrollInfo->iHPos > pScrollInfo->iHMax)
  {
    pScrollInfo->iHPos = -1; // for now
  }

  nListItems = pScrollInfo->iHMax - pScrollInfo->iHMin + 1;


  // knob height equals 'nListItems / nListItems!' multiplied by
  // the available knob height, for a minimum value of 'iHScrollHeight'

  iKnobSize = (iBarHeight - 4 * iHScrollHeight - 2);

  if(iKnobSize > iVScrollWidth / 2)
  {
    i1 = iVScrollWidth * (2 * iVScrollWidth + 1);  // 'twice scroll height' factorial
    i2 = iVScrollWidth * 2;

    while(i2 > 2 && i1 > iKnobSize) // using the above starting point get 'max factorial less than height'
    {
      i1 -= i2;
      i2--;
    }

    if(nListItems >= i2) // more than twice scroll height?
    {
      if(nListItems > iKnobSize || iKnobSize - i1 < iVScrollWidth / 2)
      {
        iKnobSize = -1;  // to fix later
      }
      else
      {
        iKnobSize -= i1;  // twice scroll height factorial
        iKnobSize -= (nListItems - iVScrollWidth * 2 + 1);
      }
    }
    else
    {
      iKnobSize -= i1  // 'twice knob height' factorial
                 - (nListItems + 1) * nListItems / 2;  // 'nListItems' factorial
    }

    if(iKnobSize < 3 * iVScrollWidth / 4)
    {
      iKnobSize = 3 * iVScrollWidth / 4;  // minimum size
    }
  }
  else
  {
    iKnobSize = 3 * iVScrollWidth / 4;  // worst case use this anyway
  }

  // cache these geometries because I need them for mouse handling

  pScrollInfo->geomHBar.x      = pgeomClient->x + 1;
  pScrollInfo->geomVBar.width  = pgeomClient->width - 2;
  pScrollInfo->geomVBar.height = pScrollInfo->iHScrollHeight;
  pScrollInfo->geomVBar.y      = pgeomClient->y + pgeomClient->height
                               - pScrollInfo->geomVBar.height - 1;

  pScrollInfo->geomHLeft.y      = pScrollInfo->geomHRight.y
                                = pScrollInfo->geomHBar.y + 1;
  pScrollInfo->geomHLeft.height = pScrollInfo->geomHRight.height
                                = pScrollInfo->geomHBar.height - 2;
  pScrollInfo->geomHLeft.width  = pScrollInfo->geomHRight.width
                                = iVScrollWidth - 1;

  pScrollInfo->geomHLeft.x     = pScrollInfo->geomHBar.x + 1;
  pScrollInfo->geomHRight.x    = pScrollInfo->geomHBar.x
                               + pScrollInfo->geomHBar.width
                               - pScrollInfo->geomHRight.width
                               - 1;

  pScrollInfo->geomHKnob.y      = pScrollInfo->geomHLeft.y;
  pScrollInfo->geomHKnob.height = pScrollInfo->geomHLeft.height;
  pScrollInfo->geomHKnob.width  = pScrollInfo->iHKnobSize
                                = iKnobSize;

  // now that I have a reasonable estimate of the knob size, calculate
  // the starting vertical position of the knob

  if(pScrollInfo->iHPos <= 0 || nListItems <= 0)
  {
    iKnobPos = 0;
  }
  else
  {
    int iBarScrollArea = pScrollInfo->geomHRight.y
                       - (pScrollInfo->geomHLeft.y + pScrollInfo->geomHLeft.width)
                       - iKnobSize
                       - 1; // inclusive value

    if(pScrollInfo->iHPos >= (nListItems - 1))
    {
      iKnobPos = iBarScrollArea;
    }
    else
    {
      iKnobPos = (WB_INT64)pScrollInfo->iHPos * (WB_INT64)iBarScrollArea
               / (WB_INT64)(nListItems - 1);
    }
  }


  pScrollInfo->geomHKnob.x = (pScrollInfo->iHKnob = iKnobPos)
                           + pScrollInfo->geomHLeft.x + pScrollInfo->geomHLeft.width;

  // fixed values go here
  pScrollInfo->geomVBar.border = 1;
  pScrollInfo->geomVUp.border = 0;
  pScrollInfo->geomVDown.border = 0;
  pScrollInfo->geomVKnob.border = 0;

}




void WBCalcVScrollBar(WB_SCROLLINFO *pScrollInfo, WB_GEOM *pgeomClient, int iVScrollWidth,
                      int iHScrollHeight, int nListItems, int nPos)
{
int iBarHeight, iBarWidth;


  iBarHeight = pgeomClient->height;
  iBarWidth = pgeomClient->width;

  if(pScrollInfo->iVBarHeight == iBarHeight &&
     pScrollInfo->iHBarWidth == iBarWidth &&
     pScrollInfo->iVKnob >= 0 &&
     pScrollInfo->iVKnobSize >= 0 &&
     pScrollInfo->iVPos == nPos &&
     pScrollInfo->iVMin == 0 &&
     pScrollInfo->iVMax == (nListItems - 1))
  {
    // assume it's set up correctly

//    WB_ERROR_TEXT("TEMPORARY:  short cycling calc scroll info\n");
//    return;
  }

  if(pScrollInfo->iHBarWidth != iBarWidth ||
     pScrollInfo->iVBarHeight != iBarHeight) // TODO:  do i need this???
  {
    // client size change detected
    // zero out the H Scroll info so that it forces re-calculation next time
    pScrollInfo->iHKnob = pScrollInfo->iHKnobSize = pScrollInfo->iHPos = pScrollInfo->iHMin = pScrollInfo->iHMax = 0;
  }

//  WB_ERROR_PRINT("TEMPORARY:  %d %d %d %d %d\n",
//                 iBarHeight, iVScrollWidth, iHScrollHeight, nListItems, nPos);

  pScrollInfo->iVMin = 0;
  pScrollInfo->iVMax = nListItems - 1;

  if(nPos == -1 ||
     (nPos >= pScrollInfo->iVMin && nPos <= pScrollInfo->iVMax))
  {
    pScrollInfo->iVPos = nPos;
  }
  else
  {
    pScrollInfo->iVPos = nPos = -1;
  }

  InternalCalcVScrollBar(pScrollInfo, pgeomClient, iVScrollWidth, iHScrollHeight);

  pScrollInfo->iHScrollHeight = iHScrollHeight;
  pScrollInfo->iHBarWidth = iBarWidth;

}

void WBCalcHScrollBar(WB_SCROLLINFO *pScrollInfo, WB_GEOM *pgeomClient, int iVScrollWidth,
                      int iHScrollHeight, int nListItems, int nPos)
{
int /*iKnobSize, iKnobPos,*/ iBarHeight, iBarWidth;
//int i1, i2;

  iBarHeight = pgeomClient->height;
  iBarWidth = pgeomClient->width;

  if(pScrollInfo->iVBarHeight == iBarHeight &&
     pScrollInfo->iHBarWidth == iBarWidth &&
     pScrollInfo->iVKnob >= 0 &&
     pScrollInfo->iVKnobSize >= 0 &&
     pScrollInfo->iVPos == nPos &&
     pScrollInfo->iVMin == 0 &&
     pScrollInfo->iVMax == (nListItems - 1))
  {
    // assume it's set up correctly

//    WB_ERROR_TEXT("TEMPORARY:  short cycling calc scroll info\n");
//    return;
  }

  if(pScrollInfo->iVBarHeight != iBarHeight ||
     pScrollInfo->iHBarWidth != iBarWidth) // TODO:  do I need this??
  {
    // client size change detected
    // zero out the V Scroll info so that it forces re-calculation next time
    pScrollInfo->iVKnob = pScrollInfo->iVKnobSize = pScrollInfo->iVPos = pScrollInfo->iVMin = pScrollInfo->iVMax = 0;
  }

  pScrollInfo->iHMin = 0;
  pScrollInfo->iHMax = nListItems - 1;


  if(nPos == -1 ||
     (nPos >= 0 && nPos < nListItems))
  {
    pScrollInfo->iHPos = nPos;
  }
  else
  {
    pScrollInfo->iHPos = nPos = -1;
  }

  InternalCalcHScrollBar(pScrollInfo, pgeomClient, iVScrollWidth, iHScrollHeight);

  pScrollInfo->iVScrollWidth = iVScrollWidth;
  pScrollInfo->iVBarHeight = iBarHeight;

}



int WBCalcVScrollDragPos(WB_SCROLLINFO *pScrollInfo, int iY)
{
  if(pScrollInfo &&
     (pScrollInfo->iVMax >= pScrollInfo->iVMin))
  {
    int nListItems = pScrollInfo->iVMax - pScrollInfo->iVMin + 1;
    int iKnobSize = pScrollInfo->geomVKnob.height;
    int iKnobPos = iY - iKnobSize / 3
                 - (pScrollInfo->geomVUp.y + pScrollInfo->geomVUp.height);

    int iBarScrollArea = pScrollInfo->geomVDown.y
                       - (pScrollInfo->geomVUp.y + pScrollInfo->geomVUp.height)
                       - iKnobSize
                       - 1; // inclusive value

    if(iBarScrollArea <= 0)
    {
      return pScrollInfo->iVMin;  // always assume 1st item's index
    }
    else
    {
      int nPos = (WB_INT64)iKnobPos * (WB_INT64)(nListItems - 1)
               / (WB_INT64)iBarScrollArea;

      WB_ERROR_PRINT("TEMPORARY:  iY=%d; nLI=%d  KS=%d  KP=%d  BSA=%d  nP=%d\n",
                     iY, nListItems, iKnobSize, iKnobPos, iBarScrollArea, nPos);

      if(nPos < pScrollInfo->iVMin)
      {
        return pScrollInfo->iVMin;
      }
      else if(nPos > pScrollInfo->iVMax)
      {
        return pScrollInfo->iVMax;
      }
      else
      {
        return nPos;
      }
    }
  }

  return -1;  // can't evaluate, so return -1
}

int WBCalcHScrollDragPos(WB_SCROLLINFO *pScrollInfo, int iX)
{
  return -1;  // for now, until implemented
}


void WBUpdateScrollBarGeometry(WB_SCROLLINFO *pSI, XFontSet fontSetRef,
                               WB_GEOM *pgeomClient, WB_GEOM *pgeomUsable)
{
WB_GEOM geom;
int iVScrollWidth, iHScrollHeight;
XCharStruct xBounds;

  // TODO:  data validation

  geom.x = pgeomClient->x;
  geom.y = pgeomClient->y;
  geom.width = pgeomClient->width;
  geom.height = pgeomClient->height;

  xBounds = WBFontSetMaxBounds(/*pDisplay*/WBGetDefaultDisplay(), fontSetRef);

  iVScrollWidth = WBTextWidth(fontSetRef, "X", 1) * 2 + 4; // standard width of vertical scrollbar
  iHScrollHeight = xBounds.ascent + xBounds.descent + 4;

  // calculate the rectangles for the scroll bars

  if(pSI->iVMin < pSI->iVMax)
  {
//    InternalCalcVScrollBar(pSI, pgeomClient, iVScrollWidth, pScrollInfo->iVMin,
//                           pScrollInfo->iVMax, pScrollInfo->iVPos);
    InternalCalcVScrollBar(pSI, pgeomClient, iVScrollWidth, geom.height - iHScrollHeight);

    geom.width -= iVScrollWidth;
  }

  if(pSI->iHMin < pSI->iHMax)
  {
//    InternalCalcHScrollBar(pSI, pgeomClient, iHScrollHeight, pScrollInfo->iHMin,
//                           pScrollInfo->iHMax, pScrollInfo->iHPos);
    InternalCalcHScrollBar(pSI, pgeomClient, iHScrollHeight, geom.width - iVScrollWidth);


    geom.height -= iHScrollHeight;
  }

  if(pgeomUsable)
  {
    memcpy(pgeomUsable, &geom, sizeof(*pgeomUsable));
  }
}


int WBScrollBarEvent(Window wID, XEvent *pEvent, WB_SCROLLINFO *pScrollInfo)
{
int iX, iY, iDirection, iPosition;


  if(wID == None || !pEvent || pEvent->type != ClientMessage || !pScrollInfo)
  {
    return 0; // only client message events and valid parameters
  }

  if(pEvent->xclient.message_type == aWM_POINTER)
  {
    if(pEvent->xclient.data.l[0] == WB_POINTER_CLICK)
    {
      // TODO:  handle shift-click, ctrl-click, alt-click

      if(pEvent->xclient.data.l[1] == WB_POINTER_BUTTON1 && // left button
         !pEvent->xclient.data.l[2])
      {
        iX = pEvent->xclient.data.l[3];
        iY = pEvent->xclient.data.l[4];

        if(WB_LIKELY(pScrollInfo != NULL))
        {
          iDirection = WB_SCROLL_NA;
          iPosition = 0;

          if(WBPointInGeom(iX, iY, pScrollInfo->geomVBar))
          {
            if(WBPointInGeom(iX, iY, pScrollInfo->geomVUp))
            {
              iDirection = WB_SCROLL_BACKWARD;
              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (up)\n", __FUNCTION__);
            }
            else if(WBPointInGeom(iX, iY, pScrollInfo->geomVDown))
            {
              iDirection = WB_SCROLL_FORWARD;
              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (down)\n", __FUNCTION__);
            }
            else if(WBPointInGeom(iX, iY, pScrollInfo->geomVKnob))
            {
              // ON THE KNOB - VScroll

              iDirection = WB_SCROLL_KNOB;
//              iPosition = pScrollInfo->iVMin; //pListInfo->nTop; // NO!
              iPosition = WBCalcVScrollDragPos(pScrollInfo, iY);

              if(iPosition < 0)
              {
                iPosition = pScrollInfo->iVMin; //pListInfo->nTop;
              }

              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (knob)\n", __FUNCTION__);

              // TODO:  determine position of knob
            }
            else if(iY >= pScrollInfo->geomVUp.y + pScrollInfo->geomVUp.height &&
                    iY < pScrollInfo->geomVKnob.y)
            {
              iDirection = WB_SCROLL_PAGEBACK;
              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (page up)\n", __FUNCTION__);
            }
            else if(iY >= pScrollInfo->geomVKnob.y + pScrollInfo->geomVKnob.height &&
                    iY < pScrollInfo->geomVDown.y)
            {
              iDirection = WB_SCROLL_PAGEFWD;
              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (page down)\n", __FUNCTION__);
            }
            else
            {
              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (unknown)\n", __FUNCTION__);
            }

            InternalNotifySelf(wID, aSCROLL_NOTIFY, WB_SCROLL_VERTICAL, iDirection, iPosition, 0, 0);

            return 1;  // handled
          }
          else if(WBPointInGeom(iX, iY, pScrollInfo->geomHBar))
          {
            if(WBPointInGeom(iX, iY, pScrollInfo->geomHLeft))
            {
              iDirection = WB_SCROLL_BACKWARD;
              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (left)\n", __FUNCTION__);
            }
            else if(WBPointInGeom(iX, iY, pScrollInfo->geomHRight))
            {
              iDirection = WB_SCROLL_FORWARD;
              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (right)\n", __FUNCTION__);
            }
            else if(WBPointInGeom(iX, iY, pScrollInfo->geomHKnob))
            {
              // ON THE KNOB - HScroll

              iDirection = WB_SCROLL_KNOB;
//              iPosition = pScrollInfo->iHMin; // NO!
              iPosition = WBCalcHScrollDragPos(pScrollInfo, iY);

              if(iPosition < 0)
              {
                iPosition = pScrollInfo->iHMin; //pListInfo->nTop;
              }

              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (knob)\n", __FUNCTION__);

              // TODO:  determine position of knob
            }
            else if(iX >= pScrollInfo->geomHLeft.x + pScrollInfo->geomHLeft.width &&
                    iX < pScrollInfo->geomHKnob.x)
            {
              iDirection = WB_SCROLL_PAGEBACK;
              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (page left)\n", __FUNCTION__);
            }
            else if(iX >= pScrollInfo->geomHKnob.x + pScrollInfo->geomHKnob.width &&
                    iX < pScrollInfo->geomHRight.x)
            {
              iDirection = WB_SCROLL_PAGEFWD;
              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (page right)\n", __FUNCTION__);
            }
            else
            {
              WB_ERROR_PRINT("TEMPORARY - %s Mouse click in scroll bar (unknown)\n", __FUNCTION__);
            }

            InternalNotifySelf(wID, aSCROLL_NOTIFY, WB_SCROLL_HORIZONTAL, iDirection, iPosition, 0, 0);

            return 1;  // handled
          }
        }
      }
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_DBLCLICK)
    {
      if(pEvent->xclient.data.l[1] == WB_POINTER_BUTTON1 && // left button
         !pEvent->xclient.data.l[2])
      {
        iX = pEvent->xclient.data.l[3];
        iY = pEvent->xclient.data.l[4];
        // assume selection already done, so notify owner

        if(WB_LIKELY(pScrollInfo != NULL))
        {
          if(WBPointInGeom(iX, iY, pScrollInfo->geomVBar))
          {
            // if not within knob, re-post to self as single-click
            if(!WBPointInGeom(iX, iY, pScrollInfo->geomVKnob))
            {
              XClientMessageEvent evt;
              memcpy(&evt, pEvent, sizeof(evt));
              evt.data.l[0] = WB_POINTER_CLICK;

              return WBScrollBarEvent(wID, (XEvent *)&evt, pScrollInfo);
            }
          }
          else if(WBPointInGeom(iX, iY, pScrollInfo->geomHBar))
          {
            // if not within knob, re-post to self as single-click
            if(!WBPointInGeom(iX, iY, pScrollInfo->geomHKnob))
            {
              XClientMessageEvent evt;
              memcpy(&evt, pEvent, sizeof(evt));
              evt.data.l[0] = WB_POINTER_CLICK;

              return WBScrollBarEvent(wID, (XEvent *)&evt, pScrollInfo);
            }
          }
        }
      }
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_CANCEL)
    {
      // canceling drag (as appropriate)

//      if(pScrollInfo &&
//         pEvent->xclient.data.l[1] == WB_POINTER_BUTTON1 && // left button
//         !pEvent->xclient.data.l[2])
//      {
//        pScrollInfo->iScrollState &= ~WBScrollState_LDRAG;
//      }
      if((pScrollInfo->iScrollState & WBScrollState_LDRAG) ||
         (pScrollInfo->iScrollState & WBScrollState_MDRAG) ||
         (pScrollInfo->iScrollState & WBScrollState_RDRAG))
      {
        pScrollInfo->iScrollState &= ~(WBScrollState_LDRAG | WBScrollState_MDRAG | WBScrollState_RDRAG);

        return 1;  // "handled"
      }
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_DRAG ||
            pEvent->xclient.data.l[0] == WB_POINTER_MOVE)
    {
      if(pEvent->xclient.data.l[1] == WB_POINTER_BUTTON1 && // left button
         !pEvent->xclient.data.l[2])
      {
        iX = pEvent->xclient.data.l[3];
        iY = pEvent->xclient.data.l[4];

        if(WB_LIKELY(pScrollInfo != NULL))
        {
          if(!WBPointInGeom(iX, iY, pScrollInfo->geomVBar) &&
             !WBPointInGeom(iX, iY, pScrollInfo->geomHBar) &&
             (!(pScrollInfo->iScrollState & WBScrollState_LDRAG) ||
              pEvent->xclient.data.l[0] == WB_POINTER_DRAG))
          {
            // TODO:  this is for multi-select listboxes, doing a drag-select

            pScrollInfo->iScrollState &= ~WBScrollState_LDRAG; // make sure

            return 0;  // "not handled" (allow drag-select to be handled by scrollbar owner)
          }
          else if(WBPointInGeom(iX, iY, pScrollInfo->geomVKnob) ||
                  WB_LIKELY(pEvent->xclient.data.l[0] == WB_POINTER_MOVE &&
                            (pScrollInfo->iScrollState & WBScrollState_LDRAG)))
          {
            if(pEvent->xclient.data.l[0] == WB_POINTER_DRAG) // begin drag, return window ID
            {
              WB_ERROR_PRINT("TEMPORARY - %s Mouse drag in scroll bar (knob)\n", __FUNCTION__);

              pScrollInfo->iScrollState |= WBScrollState_LDRAG;  // set the state bit for left-drag
              return((int)wID); // enabling the drag
            }

            iPosition = WBCalcVScrollDragPos(pScrollInfo, iY);

            if(iPosition < 0)
            {
              iPosition = pScrollInfo->iVMin; //pListInfo->nTop;
            }

            // track the mouse position along the center of the knob, if possible

            WB_ERROR_PRINT("TEMPORARY - %s Mouse motion in scroll bar (knob)\n", __FUNCTION__);

            InternalNotifySelf(wID, aSCROLL_NOTIFY, WB_SCROLL_VERTICAL,
                               WB_SCROLL_KNOB, iPosition, 0, 0);
          }
          else if(WBPointInGeom(iX, iY, pScrollInfo->geomHKnob) ||
                  WB_LIKELY(pEvent->xclient.data.l[0] == WB_POINTER_MOVE &&
                            (pScrollInfo->iScrollState & WBScrollState_HLDRAG)))
          {
            if(pEvent->xclient.data.l[0] == WB_POINTER_DRAG) // begin drag, return window ID
            {
              WB_ERROR_PRINT("TEMPORARY - %s Mouse drag in scroll bar (knob)\n", __FUNCTION__);

              pScrollInfo->iScrollState |= WBScrollState_HLDRAG;  // set the state bit for left-drag
              return((int)wID); // enabling the drag (window ID cannot be 'None')
            }

            iPosition = WBCalcHScrollDragPos(pScrollInfo, iX);

            if(iPosition < 0)
            {
              iPosition = pScrollInfo->iHMin; // pListInfo->nTop;
            }

            // track the mouse position along the center of the knob, if possible

            WB_ERROR_PRINT("TEMPORARY - %s Mouse motion in scroll bar (knob)\n", __FUNCTION__);

            InternalNotifySelf(wID, aSCROLL_NOTIFY, WB_SCROLL_HORIZONTAL,
                               WB_SCROLL_KNOB, iPosition, 0, 0);
          }
          else
          {
            WB_ERROR_PRINT("TEMPORARY - %s mouse motion in scroll bar outside of knob\n", __FUNCTION__);
          }
        }
      }
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_DROP)
    {
      if(WB_LIKELY(pScrollInfo != NULL))
      {
        if((pScrollInfo->iScrollState & WBScrollState_LDRAG) ||
           (pScrollInfo->iScrollState & WBScrollState_MDRAG) ||
           (pScrollInfo->iScrollState & WBScrollState_RDRAG))
        {
          pScrollInfo->iScrollState &= ~(WBScrollState_LDRAG | WBScrollState_MDRAG | WBScrollState_RDRAG);

          return 1;  // "handled" (just a notification anyway)
        }
      }
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_SCROLLUP)
    {
      InternalNotifySelf(wID, aSCROLL_NOTIFY, WB_SCROLL_VERTICAL, WB_SCROLL_BACKWARD, 0, 0, 0);
    }
    else if(pEvent->xclient.data.l[0] == WB_POINTER_SCROLLDOWN)
    {
      InternalNotifySelf(wID, aSCROLL_NOTIFY, WB_SCROLL_VERTICAL, WB_SCROLL_FORWARD, 0, 0, 0);
    }

    // TODO:  anything else?
  }
  else if(pEvent->xclient.message_type == aWM_CHAR)
  {
    // handle cursors only - up, down, left, right, home, end, page up, page down, etc.

    long lKey = pEvent->xclient.data.l[0];             // return from WBKeyEventProcessKey
    long lAltCtrlShift = pEvent->xclient.data.l[1];    // *piAltCtrlShift from WBKeyEventProcessKey
#ifndef NO_DEBUG
    int nChar = (int)pEvent->xclient.data.l[2];        // # of characters decoded into pBuf (below)
    char *pBuf = (char *)&(pEvent->xclient.data.l[3]); // decode buffer (at least 8 chars in length)
#endif // !NO_DEBUG


    // TODO:  scroll bar hotkeys


  }

  return 0;
}


// this assumes WB_SCROLLINFO is valid.  To make it so, call WBUpdateScrollBarGeometry() or similar

void WBPaintHScrollBar(WB_SCROLLINFO *pScrollInfo, Display *pDisplay, Drawable wID,
                       GC gc, WB_GEOM *pgeomClient)
{
  CheckInitScrollColors();

  // fill scrollbar with background color
  XSetForeground(pDisplay, gc, clrScrollBG.pixel);
  XFillRectangle(pDisplay, wID, gc, pScrollInfo->geomHBar.x - 1, pScrollInfo->geomHBar.y,
                 pScrollInfo->geomHBar.width + 1, pScrollInfo->geomHBar.height);

  // draw 3D borders around everything

  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomHBar),
                     clrScrollBD3.pixel, clrScrollBD2.pixel);

  // if the scrollbar is DISABLED, do not draw the rest of it
  if(pScrollInfo->iHPos < pScrollInfo->iHMin ||
     pScrollInfo->iHPos > pScrollInfo->iHMax ||
     pScrollInfo->iHMax < pScrollInfo->iHMin)
  {
//    WB_ERROR_PRINT("TEMPORARY:  grey out %d %d %d\n",
//                   pScrollInfo->iVPos, pScrollInfo->iVMin, pScrollInfo->iVMax);
    return;  // I am done (greyed out bar)
  }

  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomHLeft),
                     clrScrollBD2.pixel, clrScrollBD3.pixel);
  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomHRight),
                     clrScrollBD2.pixel, clrScrollBD3.pixel);
  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomHKnob),
                     clrScrollBD2.pixel, clrScrollBD3.pixel);

  // draw arrows

  WBDrawLeftArrow(pDisplay, wID, gc, &(pScrollInfo->geomHLeft), clrScrollFG.pixel);
  WBDrawRightArrow(pDisplay, wID, gc, &(pScrollInfo->geomHRight), clrScrollFG.pixel);
}

// NOTE:  this assumes WB_SCROLLINFO is valid.  To make it so, call WBUpdateScrollBarGeometry() or similar

void WBPaintVScrollBar(WB_SCROLLINFO *pScrollInfo, Display *pDisplay, Drawable wID,
                       GC gc, WB_GEOM *pgeomClient)
{
  CheckInitScrollColors();

  // fill scrollbar with background color
  XSetForeground(pDisplay, gc, clrScrollBG.pixel);
  XFillRectangle(pDisplay, wID, gc, pScrollInfo->geomVBar.x - 1, pScrollInfo->geomVBar.y,
                 pScrollInfo->geomVBar.width + 1, pScrollInfo->geomVBar.height);

  // draw 3D borders around everything

  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomVBar),
                     clrScrollBD3.pixel, clrScrollBD2.pixel);

  // if the scrollbar is DISABLED, do not draw the rest of it
  if(pScrollInfo->iVPos < pScrollInfo->iVMin ||
     pScrollInfo->iVPos > pScrollInfo->iVMax ||
     pScrollInfo->iVMax < pScrollInfo->iVMin)
  {
//    WB_ERROR_PRINT("TEMPORARY:  grey out %d %d %d\n",
//                   pScrollInfo->iVPos, pScrollInfo->iVMin, pScrollInfo->iVMax);
    return;  // I am done (greyed out bar)
  }

  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomVUp),
                     clrScrollBD2.pixel, clrScrollBD3.pixel);
  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomVDown),
                     clrScrollBD2.pixel, clrScrollBD3.pixel);
  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomVKnob),
                     clrScrollBD2.pixel, clrScrollBD3.pixel);

  // draw arrows

  WBDrawUpArrow(pDisplay, wID, gc, &(pScrollInfo->geomVUp), clrScrollFG.pixel);
  WBDrawDownArrow(pDisplay, wID, gc, &(pScrollInfo->geomVDown), clrScrollFG.pixel);
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                              //
//   ____                         _                 ____         _                    _    _                    //
//  |  _ \  _ __  __ _ __      __(_) _ __    __ _  |  _ \  _ __ (_) _ __ ___    __ _ | |_ (_)__   __ ___  ___   //
//  | | | || '__|/ _` |\ \ /\ / /| || '_ \  / _` | | |_) || '__|| || '_ ` _ \  / _` || __|| |\ \ / // _ \/ __|  //
//  | |_| || |  | (_| | \ V  V / | || | | || (_| | |  __/ | |   | || | | | | || (_| || |_ | | \ V /|  __/\__ \  //
//  |____/ |_|   \__,_|  \_/\_/  |_||_| |_| \__, | |_|    |_|   |_||_| |_| |_| \__,_| \__||_|  \_/  \___||___/  //
//                                          |___/                                                               //
//                                                                                                              //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void WBDrawBorderRect(Display *pDisplay, Drawable wID, GC gc,
                      WB_GEOM *pgeomBorder, unsigned long lBorderColor)
{
XPoint xpt[5];

  XSetForeground(pDisplay, gc, lBorderColor);

  xpt[0].x=pgeomBorder->x;
  xpt[0].y=pgeomBorder->y;

  xpt[1].x = xpt[0].x
           + pgeomBorder->width
           - 1;  // 'inclusive' values

  xpt[1].y = xpt[0].y;

  xpt[2].x = xpt[1].x;
  xpt[2].y = xpt[1].y
           + pgeomBorder->height
           - 1;

  xpt[3].x = xpt[0].x;
  xpt[3].y = xpt[2].y;

  xpt[4].x = xpt[0].x;
  xpt[4].y = xpt[0].y + 1;   // exclude final point

  XDrawLines(pDisplay, wID, gc, xpt, 5, CoordModeOrigin);
}

void WBDraw3DBorderRect(Display *pDisplay, Drawable wID, GC gc, WB_GEOM *pgeomBorder,
                        unsigned long lBorderColor1, unsigned long lBorderColor2)
{
XPoint xpt[4];
XColor clr;
int iR, iG, iB;


  XSetForeground(pDisplay, gc, lBorderColor1);
  xpt[0].x = pgeomBorder->x;
  xpt[0].y = pgeomBorder->y
           + pgeomBorder->height - 1 - 1;  // exclude first point

  xpt[1].x = xpt[0].x;
  xpt[1].y = pgeomBorder->y;

  xpt[2].x = xpt[0].x
           + pgeomBorder->width - 1 - 1;   // exclude last point
  xpt[2].y = xpt[1].y;

  XDrawLines(pDisplay, wID, gc, xpt, 3, CoordModeOrigin);

  XSetForeground(pDisplay, gc, lBorderColor2);

  xpt[0].x = pgeomBorder->x
           + pgeomBorder->width - 1;
  xpt[0].y = pgeomBorder->y + 1;              // exclude first point

  xpt[1].x = xpt[0].x;
  xpt[1].y = pgeomBorder->y
           + pgeomBorder->height - 1;

  xpt[2].x = pgeomBorder->x + 1;              // exclude final point
  xpt[2].y = xpt[1].y;

  XDrawLines(pDisplay, wID, gc, xpt, 3, CoordModeOrigin);

  // Use the RGB info to calculate an 'average' color for the corners

  bzero(&clr, sizeof(clr));
  clr.pixel = lBorderColor1;

  PXM_PixelToRGB(NULL, &clr);

  iR = (clr.flags & DoRed) ? (unsigned int)clr.red : 0;
  iG = (clr.flags & DoGreen) ? (unsigned int)clr.green : 0;
  iB = (clr.flags & DoBlue) ? (unsigned int)clr.blue : 0;

  bzero(&clr, sizeof(clr));
  clr.pixel = lBorderColor2;

  PXM_PixelToRGB(NULL, &clr);

  iR += (clr.flags & DoRed) ? (unsigned int)clr.red : 0;
  iG += (clr.flags & DoGreen) ? (unsigned int)clr.green : 0;
  iB += (clr.flags & DoBlue) ? (unsigned int)clr.blue : 0;

  bzero(&clr, sizeof(clr));

  clr.red = iR >> 1;
  clr.green = iG >> 1;
  clr.blue = iB >> 1;

  PXM_RGBToPixel(NULL, &clr); // TODO:  alloc the color as well?

//  WB_ERROR_PRINT("TEMPORARY:  %s - average of %08xH and %08xH is %08xH (%d, %d, %d)\n", __FUNCTION__,
//                 (unsigned int)lBorderColor1, (unsigned int)lBorderColor2,
//                 (unsigned int)clr.pixel, clr.red, clr.green, clr.blue);

  XSetForeground(pDisplay, gc, clr.pixel);

  xpt[0].x = pgeomBorder->x;
  xpt[1].y = pgeomBorder->y;

  xpt[1].x = xpt[0].x + pgeomBorder->width - 1;
  xpt[0].y = xpt[1].y + pgeomBorder->height - 1;

  XDrawPoints(pDisplay, wID, gc, xpt, 2, CoordModeOrigin);

  XSetForeground(pDisplay, gc, lBorderColor1);

}

void WBDrawDashedRect(Display *pDisplay, Drawable wID, GC gc, WB_GEOM *pgeomRect, unsigned long lColor)
{
static const char dash_list[4]={1,2,2,1};
GC gc2;


  gc2 = WBGetWindowCopyGC2(wID, gc);

  if(gc2)
  {
    WBDrawBorderRect(pDisplay, wID, gc2, pgeomRect, WhitePixel(pDisplay, DefaultScreen(pDisplay)));
    XSetDashes(pDisplay, gc2, 1, dash_list, 4);
    XSetLineAttributes(pDisplay, gc2, 1, LineOnOffDash, CapNotLast, JoinBevel);
    XSetBackground(pDisplay, gc2, WhitePixel(pDisplay, DefaultScreen(pDisplay)));
    WBDrawBorderRect(pDisplay, wID, gc2, pgeomRect, lColor);

    XFreeGC(pDisplay, gc2);
  }
  else
  {
    WB_ERROR_PRINT("%s:%d - unable to create GC\n", __FUNCTION__, __LINE__);
  }
}

void WBDrawLeftArrow(Display *pDisplay, Drawable wID, GC gc, WB_GEOM *pgeomRect, unsigned long lColor)
{
XPoint xpt[5];
long lBG, lFG;

  lBG = WBGetGCBGColor(pDisplay, gc);
  lFG = WBGetGCFGColor(pDisplay, gc); // save color context

  XSetForeground(pDisplay, gc, lColor);
  XSetBackground(pDisplay, gc, lColor);

  // LEFT ARROW
  xpt[0].x = pgeomRect->x + (pgeomRect->width >> 2);
  xpt[0].y = pgeomRect->y + (pgeomRect->height >> 2) + (pgeomRect->height >> 2);
  xpt[1].x = xpt[0].x + (pgeomRect->width >> 1) - 1;
  xpt[1].y = pgeomRect->y + (pgeomRect->height >> 2);
  xpt[2].x = xpt[1].x;
  xpt[2].y = pgeomRect->y + pgeomRect->height - 1 - (pgeomRect->height >> 2);
  xpt[3].x = xpt[0].x;
  xpt[3].y = xpt[2].y - (pgeomRect->height >> 2);
  xpt[4].x = xpt[0].x;
  xpt[4].y = xpt[0].y;

  XDrawLines(pDisplay, wID, gc, xpt, 5, CoordModeOrigin);
  XFillPolygon(pDisplay, wID, gc, xpt, 5, /*Convex*/Nonconvex, CoordModeOrigin);

  XSetForeground(pDisplay, gc, lFG);
  XSetBackground(pDisplay, gc, lBG); // restore color context
}

void WBDrawUpArrow(Display *pDisplay, Drawable wID, GC gc, WB_GEOM *pgeomRect, unsigned long lColor)
{
XPoint xpt[5];
long lBG, lFG;

  lBG = WBGetGCBGColor(pDisplay, gc);
  lFG = WBGetGCFGColor(pDisplay, gc); // save color context

  XSetForeground(pDisplay, gc, lColor);
  XSetBackground(pDisplay, gc, lColor);

  xpt[0].x = pgeomRect->x + (pgeomRect->width >> 2) + (pgeomRect->width >> 2);
  xpt[0].y = pgeomRect->y + (pgeomRect->height >> 2);
  xpt[1].x = pgeomRect->x + (pgeomRect->width >> 2);
  xpt[1].y = xpt[0].y + (pgeomRect->height >> 1) - 1;
  xpt[2].x = pgeomRect->x + pgeomRect->width - 1 - (pgeomRect->width >> 2);
  xpt[2].y = xpt[1].y;
  xpt[3].x = xpt[2].x - (pgeomRect->width >> 2);
  xpt[3].y = xpt[0].y;
  xpt[4].x = xpt[0].x;
  xpt[4].y = xpt[0].y;

  XDrawLines(pDisplay, wID, gc, xpt, 5, CoordModeOrigin);
  XFillPolygon(pDisplay, wID, gc, xpt, 5, /*Convex*/Nonconvex, CoordModeOrigin);

  XSetForeground(pDisplay, gc, lFG);
  XSetBackground(pDisplay, gc, lBG); // restore color context
}

void WBDrawRightArrow(Display *pDisplay, Drawable wID, GC gc, WB_GEOM *pgeomRect, unsigned long lColor)
{
XPoint xpt[5];
long lBG, lFG;

  lBG = WBGetGCBGColor(pDisplay, gc);
  lFG = WBGetGCFGColor(pDisplay, gc); // save color context

  XSetForeground(pDisplay, gc, lColor);
  XSetBackground(pDisplay, gc, lColor);

  // RIGHT ARROW
  xpt[0].x = pgeomRect->x + pgeomRect->width - 1 - (pgeomRect->width >> 2);
  xpt[0].y = pgeomRect->y + (pgeomRect->height >> 2) + (pgeomRect->height >> 2);
  xpt[1].x = xpt[0].x - (pgeomRect->width >> 1) + 1;
  xpt[1].y = pgeomRect->y + (pgeomRect->height >> 2);
  xpt[2].x = xpt[1].x;
  xpt[2].y = pgeomRect->y + pgeomRect->height - 1 - (pgeomRect->height >> 2);
  xpt[3].x = xpt[0].x;
  xpt[3].y = xpt[2].y - (pgeomRect->height >> 2);
  xpt[4].x = xpt[0].x;
  xpt[4].y = xpt[0].y;

  XDrawLines(pDisplay, wID, gc, xpt, 5, CoordModeOrigin);
  XFillPolygon(pDisplay, wID, gc, xpt, 5, /*Convex*/Nonconvex, CoordModeOrigin);

  XSetForeground(pDisplay, gc, lFG);
  XSetBackground(pDisplay, gc, lBG); // restore color context
}

void WBDrawDownArrow(Display *pDisplay, Drawable wID, GC gc, WB_GEOM *pgeomRect, unsigned long lColor)
{
XPoint xpt[5];
long lBG, lFG;

  lBG = WBGetGCBGColor(pDisplay, gc);
  lFG = WBGetGCFGColor(pDisplay, gc); // save color context

  XSetForeground(pDisplay, gc, lColor);
  XSetBackground(pDisplay, gc, lColor);

  xpt[0].x = pgeomRect->x + (pgeomRect->width >> 2) + (pgeomRect->width >> 2);
  xpt[0].y = pgeomRect->y + pgeomRect->height - 1 - (pgeomRect->height >> 2);
  xpt[1].x = pgeomRect->x + (pgeomRect->width >> 2);
  xpt[1].y = xpt[0].y - (pgeomRect->height >> 1) + 1;
  xpt[2].x = pgeomRect->x + pgeomRect->width - 1 - (pgeomRect->width >> 2);
  xpt[2].y = xpt[1].y;
  xpt[3].x = xpt[2].x - (pgeomRect->width >> 2);
  xpt[3].y = xpt[0].y;
  xpt[4].x = xpt[0].x;
  xpt[4].y = xpt[0].y;

  XDrawLines(pDisplay, wID, gc, xpt, 5, CoordModeOrigin);
  XFillPolygon(pDisplay, wID, gc, xpt, 5, /*Convex*/Nonconvex, CoordModeOrigin);

  XSetForeground(pDisplay, gc, lFG);
  XSetBackground(pDisplay, gc, lBG); // restore color context
}


void WBDraw3DBorderTab(Display *pDisplay, Drawable dw, GC gc, WB_GEOM *pgeomOutline,
                       int fFocus, unsigned long lFGColor, unsigned long lBGColor,
                       unsigned long lBorderColor1, unsigned long lBorderColor2,
                       unsigned long lHighlightColor,
                       XFontSet fontSet, XFontSet fontSetBold,
                       Atom aGraphic, const char *szText)
{
XPoint xpt[13];
XColor clrAvg, clrTemp;
int iFontHeight, bFocus;
int i1, i2, iR, iG, iB, iY, iU, iV, iYBG;
Region rgnClip;
GC gc2;
WB_RECT rctTemp;


  if(fontSet == None)
  {
    fontSet = WBGetDefaultFontSet(pDisplay);
  }

  if(fontSetBold == None)
  {
    fontSetBold = WBGetDefaultFontSet(pDisplay);
  }

  iFontHeight = WBFontSetHeight(pDisplay, fontSet);


  // begin by creating a region that consists of my 'rounded rect' polygon

  // create a rounded-corner trapezoid the encompasses the tab.  corner pixels will
  // be averages of the border colors.

  // lower left corner
  xpt[0].x = pgeomOutline->x;
  xpt[0].y = pgeomOutline->y + pgeomOutline->height + 1; // for clip rgn, I do this

  // left side
  xpt[1].x = xpt[0].x + 2; // slight trapezoid
  xpt[1].y = pgeomOutline->y + 3;  // room for corner

  // upper left corner
  xpt[2].x = xpt[1].x + 1;
  xpt[2].y = xpt[1].y - 1; // 45 degrees
  xpt[3].x = xpt[2].x + 1;
  xpt[3].y = xpt[2].y - 1; // again
  xpt[4].x = xpt[3].x + 1;
  xpt[4].y = xpt[3].y - 1; // now we're "on point"

  // top row
  xpt[5].x = xpt[0].x + pgeomOutline->width - 5;
  xpt[5].y = xpt[4].y;

  // upper right corner
  xpt[6].x = xpt[5].x + 1;
  xpt[6].y = xpt[5].y + 1; // 45 degrees
  xpt[7].x = xpt[6].x + 1;
  xpt[7].y = xpt[6].y + 1; // 45 degrees
  xpt[8].x = xpt[7].x + 1;
  xpt[8].y = xpt[7].y + 1; // 45 degrees

  // right side
  xpt[9].x = pgeomOutline->x + pgeomOutline->width;
  xpt[9].y = xpt[0].y; // same y as 1st point

  xpt[10].x = xpt[0].x;
  xpt[10].y = xpt[0].y; // close up the polygon

  rgnClip = XPolygonRegion(xpt, 11, WindingRule);
  if(rgnClip == None)
  {
    WB_ERROR_PRINT("ERROR:  %s - unable to create polygon region\n", __FUNCTION__);
    return;
  }

  // create GC copy and select the clipping region

  gc2 = WBCopyDrawableGC(pDisplay, dw, gc);

  if(gc2 == None)
  {
    XDestroyRegion(rgnClip);

    WB_ERROR_PRINT("ERROR:  %s - unable to create GC\n", __FUNCTION__);
    return;
  }

  // select the clip region
  XSetRegion(pDisplay, gc2, rgnClip);

  // set 'bFocus' to indicate if I have focus.  'fFocus' also indicates 'x' button state
  // 0 or < -1 is "I do not have focus".  -1 or > 0 is "I have focus".  negative is 'x button clicked'

  bFocus = fFocus > 0 || fFocus == -1;

  if(bFocus)
  {
    // do the background color in the tab.  this will use the clip region to help me

    clrTemp.pixel = lBGColor; // default background color
    PXM_PixelToRGB(NULL, &clrTemp);

    iR = clrTemp.red >> 8;
    iG = clrTemp.green >> 8;
    iB = clrTemp.blue >> 8;

    PXM_RGBToYUV(iR, iG, iB, &iYBG, NULL, NULL); // get 'Y' for the background (assume grey)

    i2 = 3 * (xpt[0].y - xpt[5].y - 2) / 5;

//    WB_ERROR_PRINT("TEMPORARY:  %s - i2 is %d, from %d and %d\n", __FUNCTION__,
//                   i2, xpt[0].y, xpt[5].y);

    for(i1=xpt[5].y; i1 < xpt[0].y - 2; i1++)
    {
      XPoint xpt2[2];
      int iR2 = abs(i1 - (xpt[5].y + i2));

//      iR2 *= iR2;
      iR2 = icos(iR2 * 232 / i2); // 255 would be pi/2, so go slightly less than that
//      iR2 = isqrt(iR2);

      clrTemp.pixel = lHighlightColor;
      PXM_PixelToRGB(NULL, &clrTemp);

      iR = clrTemp.red >> 8;
      iG = clrTemp.green >> 8;
      iB = clrTemp.blue >> 8;

      PXM_RGBToYUV(iR, iG, iB, &iY, &iU, &iV);

      iY = iYBG * 3 / 4 + ((384 - iYBG) * iR2) / 384; // allows brightness to drop to a bit less than the background's brightness

      if(iY > 255)
      {
        iU = 128 + (iU - 128) * 255 / iY * 255 / iY;
        iV = 128 + (iV - 128) * 255 / iY * 255 / iY;
        iY = 255;
      }

      PXM_YUVToRGB(iY, iU, iV, &iR, &iG, &iB);

      clrTemp.red = (iR << 8) + 128;
      clrTemp.green = (iG << 8) + 128;
      clrTemp.blue = (iB << 8) + 128;
      clrTemp.flags = DoRed | DoGreen | DoBlue;

      PXM_RGBToPixel(NULL, &clrTemp);

//      WB_ERROR_PRINT("TEMPORARY:  %s - YUV is %d, %d, %d, RGB is %d, %d, %d  for %lu (%08lxH)\n", __FUNCTION__,
//                     iY, iU, iV,
//                     clrTemp.red, clrTemp.green, clrTemp.blue, clrTemp.pixel, clrTemp.pixel);

      XSetForeground(pDisplay, gc2, clrTemp.pixel); // select this color

      xpt2[0].x = pgeomOutline->x + 1;
      xpt2[0].y = i1;
      xpt2[1].x = pgeomOutline->x + pgeomOutline->width - 2;
      xpt2[1].y = xpt2[0].y;

      if(i1 < xpt[5].y + 2) // corner hack, based on observation
      {
        xpt2[0].x += (xpt[5].y + 2) - i1;
        xpt2[1].x -= (xpt[5].y + 2) - i1;
      }

      // draw the line
      XDrawLines(pDisplay, dw, gc2, xpt2, 2, CoordModeOrigin); // stop at point 6 (don't paint 6 to 7)
    }
  }


  // next, squeeze in the right/left edges of my points.  I've observed I need to do this
  // as a hack, don't do the left squeeze for the 'focus' tab

  if(!bFocus)
  {
    for(i1=0; i1 < 5; i1++)
    {
      xpt[i1].x ++;
    }
  }

  for(i1=5; i1 < 10; i1++)
  {
    xpt[i1].x --;
  }

  if(!bFocus)
  {
    xpt[0].y -= 3; // one above 'bottom' (where I'll draw a line)
  }
  else
  {
    xpt[0].y -= 2;
  }

  xpt[9].y = xpt[0].y; // same y as 1st point

  xpt[10].x = xpt[0].x; // re-close up polygon (again)
  xpt[10].y = xpt[0].y; // close up the polygon


  // make a copy of the GC

  XSetForeground(pDisplay, gc2, lFGColor);
  XSetBackground(pDisplay, gc2, lBGColor);

  // Use the RGB info to calculate an 'average' color for the corner transition

  bzero(&clrAvg, sizeof(clrAvg));
  clrAvg.pixel = lBorderColor1;

  PXM_PixelToRGB(NULL, &clrAvg);

  iR = (clrAvg.flags & DoRed) ? (unsigned int)clrAvg.red : 0;
  iG = (clrAvg.flags & DoGreen) ? (unsigned int)clrAvg.green : 0;
  iB = (clrAvg.flags & DoBlue) ? (unsigned int)clrAvg.blue : 0;

  bzero(&clrAvg, sizeof(clrAvg));
  clrAvg.pixel = lBorderColor2;

  PXM_PixelToRGB(NULL, &clrAvg);

  iR += (clrAvg.flags & DoRed) ? (unsigned int)clrAvg.red : 0;
  iG += (clrAvg.flags & DoGreen) ? (unsigned int)clrAvg.green : 0;
  iB += (clrAvg.flags & DoBlue) ? (unsigned int)clrAvg.blue : 0;

  bzero(&clrAvg, sizeof(clrAvg));

  clrAvg.red = iR >> 1;
  clrAvg.green = iG >> 1;
  clrAvg.blue = iB >> 1;

  PXM_RGBToPixel(NULL, &clrAvg); // TODO:  alloc the color as well?

  // next, draw polygon using 3D colors

  XSetForeground(pDisplay, gc2, lBorderColor1);
  XDrawLines(pDisplay, dw, gc2, xpt, 7, CoordModeOrigin); // stop at point 6 (don't paint 6 to 7)

  XSetForeground(pDisplay, gc2, lBorderColor2);
  XDrawLines(pDisplay, dw, gc2, xpt + 8, 2, CoordModeOrigin); // stop at point 6 (don't paint 6 or 7)

  if(bFocus)
  {
    // for non-focus, draw the bottom (7 to 8) using border color 2.  for focus, draw as background color

    XSetForeground(pDisplay, gc2, lBGColor);
  }

  XDrawLines(pDisplay, dw, gc2, xpt + 9, 2, CoordModeOrigin); // the bottom line

  // paint pixels 6 and 7 with the 'average' color
  XSetForeground(pDisplay, gc2, clrAvg.pixel);
  XDrawPoints(pDisplay, dw, gc2, xpt + 6, 2, CoordModeOrigin);

  if(!bFocus)
  {
    // when not in focus, also do avg color for the first pixel.  this completes the 3D effect 'color transition'
    XDrawPoints(pDisplay, dw, gc2, xpt, 1, CoordModeOrigin);
  }



  // TAB TEXT (TODO: image atom)

  rctTemp.left = pgeomOutline->x;
  rctTemp.top = pgeomOutline->y;
  rctTemp.right = rctTemp.left + pgeomOutline->width;
  rctTemp.bottom = rctTemp.top + pgeomOutline->height;

  if(!szText)
  {
    szText = "{untitled}";
  }

  XSetForeground(pDisplay, gc2, lFGColor);

  // for now just do centered text
  DTDrawSingleLineText(fontSet, szText, pDisplay, gc2, dw, 0, 0, &rctTemp,
                       DTAlignment_HCENTER | DTAlignment_VCENTER);


  // NOW, I need to draw the 'x' for the close button.  Fist, I calculate its rect

  rctTemp.top = pgeomOutline->y + 2;                         // top plus 2 pixels
  rctTemp.bottom = rctTemp.top + iFontHeight;                // height is font height
  rctTemp.right = pgeomOutline->x + pgeomOutline->width - 6; // right is 6 pixels from right edge
  rctTemp.left = rctTemp.right - iFontHeight + 2;            // left is 2 pixels + font height from right

  if(fFocus < 0) // clicking 'x' ?
  {
    XSetForeground(pDisplay, gc2, lHighlightColor);
    XSetBackground(pDisplay, gc2, lHighlightColor);
  }
  else
  {
    XSetForeground(pDisplay, gc2, lBGColor);
    XSetBackground(pDisplay, gc2, lBGColor);
  }

  // fill in with selected colors

  XFillRectangle(pDisplay, dw, gc2, rctTemp.left, rctTemp.top, rctTemp.right - rctTemp.left, rctTemp.bottom - rctTemp.top);

  if(fFocus < 0) // clicking 'x' ?
  {
    XSetForeground(pDisplay, gc2, lBGColor);
  }
  else
  {
    XSetForeground(pDisplay, gc2, lHighlightColor);
  }

  // now draw the '+' using a BOLD font

  rctTemp.left -=2;
  rctTemp.right += 2;
  rctTemp.top -= 2;
  rctTemp.bottom += 2; // big enough to 'center' properly

  DTDrawSingleLineText(fontSetBold, "x", pDisplay, gc2, dw, 0, 0, &rctTemp,
                       DTAlignment_HCENTER | DTAlignment_VCENTER);


  XFreeGC(pDisplay, gc2);
  XDestroyRegion(rgnClip);


//  WB_ERROR_PRINT("TEMPORARY:  %s - only partially implemented\n", __FUNCTION__);
}



