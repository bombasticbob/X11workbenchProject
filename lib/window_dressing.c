//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//               _             _                        _                       _                           //
//    __      __(_) _ __    __| |  ___ __      __    __| | _ __  ___  ___  ___ (_) _ __    __ _     ___     //
//    \ \ /\ / /| || '_ \  / _` | / _ \\ \ /\ / /   / _` || '__|/ _ \/ __|/ __|| || '_ \  / _` |   / __|    //
//     \ V  V / | || | | || (_| || (_) |\ V  V /   | (_| || |  |  __/\__ \\__ \| || | | || (_| | _| (__     //
//      \_/\_/  |_||_| |_| \__,_| \___/  \_/\_/_____\__,_||_|   \___||___/|___/|_||_| |_| \__, |(_)\___|    //
//                                            |_____|                                     |___/             //
//                                                                                                          //
//                     Utilities for painting and handling standard components of windows                   //
//                                                                                                          //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2016 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no waranties, either implied or explicit.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

/** \file window_dressing.c Utilities for painting and handling standard components of windows */


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <errno.h>
#include <X11/Xlib.h>
#include "window_dressing.h"
#include "conf_help.h"

// also in window_helper.c
#define GCAll (GCFunction | GCPlaneMask | GCForeground | GCBackground | GCLineWidth | \
               GCLineStyle | GCCapStyle | GCJoinStyle | GCFillStyle | GCFillRule | \
               GCTile | GCStipple | GCTileStipXOrigin | GCTileStipYOrigin | GCFont | \
               GCSubwindowMode | GCGraphicsExposures | GCClipXOrigin | GCClipYOrigin | \
               GCClipMask | GCDashOffset | GCDashList | GCArcMode)



static XColor clrScrollFG, clrScrollBG, clrScrollAFG, clrScrollABG,
              clrScrollHFG, clrScrollHBG, clrScrollBD, clrScrollBD2, clrScrollBD3;
static int iInitScrollColorFlag = 0;

#define LOAD_COLOR0(X,Y) if(CHGetResourceString(WBGetDefaultDisplay(), X, Y, sizeof(Y)) > 0) {  }
#define LOAD_COLOR(X,Y,Z) if(CHGetResourceString(WBGetDefaultDisplay(), X, Y, sizeof(Y)) <= 0){ WB_WARN_PRINT("%s - WARNING:  can't find color %s, using default value %s\n", __FUNCTION__, X, Z); strcpy(Y,Z); }

static void CheckInitScrollColors(void)
{
  if(!iInitScrollColorFlag)
  {
    static const char *szBorder2="#FFFFFF", *szBorder2W="#C8C6C0", *szBorder3="#9C9A94"; // for 3D borders
    char szFG[16], szBG[16], szBD[16], szHFG[16], szHBG[16], szAFG[16], szABG[16];
    static const char szFGName[]="Scrollbar.foreground";
    static const char szBGName[]="Scrollbar.background";
    static const char szHFGName[]="Scrollbar.highlightForeground";
    static const char szHBGName[]="Scrollbar.highlightBackground";
    static const char szAFGName[]="Scrollbar.activeForeground";
    static const char szABGName[]="Scrollbar.activeBackground";
    static const char szBDName[]="Scrollbar.border";

    Colormap colormap = DefaultColormap(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));


    LOAD_COLOR0(szFGName,szFG) else LOAD_COLOR0("*Dialog.foreground",szFG) else LOAD_COLOR0("*Form.foreground", szFG)
     else LOAD_COLOR0("*WmDialogShell.foreground",szFG) else LOAD_COLOR0("*WmForm.foreground", szFG)
     else LOAD_COLOR("*foreground", szFG, "#000000");
//    if(bUseStaticColors)
//    {
      LOAD_COLOR0(szBGName,szBG) else LOAD_COLOR0("*Dialog.background",szBG) else LOAD_COLOR0("*Form.background", szBG)
       else LOAD_COLOR0("*WmDialogShell.background",szBG)
       else LOAD_COLOR("*WmForm.background", szBG, "#dcdad5"); // default for gnome is dcdad5
//    }
//    else
//    {
//      LOAD_COLOR0(szBGName,szBG) else LOAD_COLOR0("*Window.background",szBG)
//       else LOAD_COLOR("*background", szBG, "white");
//    }
    LOAD_COLOR(szHFGName,szHFG,szFG);
    LOAD_COLOR(szHBGName,szHBG,szBG);
    LOAD_COLOR(szAFGName,szAFG,szFG);
    LOAD_COLOR(szABGName,szABG,szBG);
    LOAD_COLOR0(szBDName,szBD) else LOAD_COLOR0("*Dialog.border",szBD) else LOAD_COLOR0("*Form.border", szBD)
     else LOAD_COLOR0("*WmDialogShell.border",szBD) else LOAD_COLOR0("*WmForm.border", szBD)
     else LOAD_COLOR0("*borderColor", szBD)
     else LOAD_COLOR("*border", szBD, "black"); // default for gnome

    XParseColor(WBGetDefaultDisplay(), colormap, szFG, &clrScrollFG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollFG);
    XParseColor(WBGetDefaultDisplay(), colormap, szBG, &clrScrollBG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollBG);
    XParseColor(WBGetDefaultDisplay(), colormap, szAFG, &clrScrollAFG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollAFG);
    XParseColor(WBGetDefaultDisplay(), colormap, szABG, &clrScrollABG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollABG);
    XParseColor(WBGetDefaultDisplay(), colormap, szHFG, &clrScrollHFG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollHFG);
    XParseColor(WBGetDefaultDisplay(), colormap, szHBG, &clrScrollHBG);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollHBG);
    XParseColor(WBGetDefaultDisplay(), colormap, szBD, &clrScrollBD);

    // 3D border colors for now these are hard-coded - later derive them from FG and BG colors
    if(clrScrollBG.red >= 60000 && clrScrollBG.green >= 60000 &&
       clrScrollBG.blue >= 60000) // note see man page on XColor, values 0 through 65535 for RGB
    {
      XParseColor(WBGetDefaultDisplay(), colormap, szBorder2W, &clrScrollBD2);
    }
    else
    {
      XParseColor(WBGetDefaultDisplay(), colormap, szBorder2, &clrScrollBD2);
    }
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollBD2);
    XParseColor(WBGetDefaultDisplay(), colormap, szBorder3, &clrScrollBD3);
    XAllocColor(WBGetDefaultDisplay(), colormap, &clrScrollBD3);

    iInitScrollColorFlag = 1;
  }
}



static char ilog2n(unsigned char y)
{
  if(y & 0x08)
    return 4;
  else if(y & 0x04)
    return 3;
  else if(y & 0x02)
    return 2;
  else if(y & 0x01)
    return 1;
  else
    return 0;
}

static char ilog2c(unsigned char y)
{
  if(y & 0xf0)
    return ilog2n(y >> 4) + 4;

  return ilog2n(y);
}

static int ilog2s(unsigned short y)
{
  if(y & 0xff00)
  {
    return ilog2c((unsigned char)(y >> 8)) + 8;
  }

  return ilog2c((unsigned char)y);
}

static int ilog2(unsigned int y)
{
  if(y & 0xffff0000)
  {
    return ilog2s((unsigned short)(y >> 16)) + 16;
  }

  return ilog2s((unsigned short)y);
}

static int ilog2ll(WB_UINT64 y)
{
  if(y & 0xffffffff00000000LL)
  {
    return ilog2((unsigned int)(y >> 32)) + 32;
  }

  return ilog2((unsigned int)y);
}

void WBCalcHScrollBar(WB_SCROLLINFO *pScrollInfo, WB_GEOM *pgeomClient, int iVScrollWidth,
                      int iHScrollHeight, int nListItems, int nPos)
{
int iKnobSize, iKnobPos, iBarHeight, iBarWidth;
int i1, i2;

  iBarHeight = pgeomClient->height;
  iBarWidth = pgeomClient->width;

  if(pScrollInfo->iVBarHeight == iBarHeight &&
     pScrollInfo->iHBarWidth == iBarWidth &&
     pScrollInfo->iVBarHeight == iBarHeight &&
     pScrollInfo->iHBarWidth == iBarWidth &&
     pScrollInfo->iVKnob >= 0 &&
     pScrollInfo->iVKnobSize >= 0 &&
     pScrollInfo->iVPos == nPos &&
     pScrollInfo->iVMin == 0 &&
     pScrollInfo->iVMax == (nListItems - 1))
  {
    // assume it's set up correctly

//    WB_ERROR_TEXT("TEMPORARY:  short cycling calc scroll info\n");
//    return;
  }

  if(pScrollInfo->iVBarHeight != iBarHeight ||
     pScrollInfo->iHBarWidth != iBarWidth ||
     pScrollInfo->iVBarHeight != iBarHeight ||
     pScrollInfo->iHBarWidth != iBarWidth)
  {
    // client size change detected
    // zero out the V Scroll info so that it forces re-calculation next time
    pScrollInfo->iVKnob = pScrollInfo->iVKnobSize = pScrollInfo->iVPos = pScrollInfo->iVMin = pScrollInfo->iVMax = 0;
  }

  pScrollInfo->iVScrollWidth = iVScrollWidth;
  pScrollInfo->iHScrollHeight = iHScrollHeight;
  pScrollInfo->iVBarHeight = iBarHeight;
  pScrollInfo->iHBarWidth = iBarWidth;

  pScrollInfo->iHMin = 0;
  pScrollInfo->iHMax = nListItems - 1;
  if(nPos == -1 ||
     (nPos >= 0 && nPos < nListItems))
  {
    pScrollInfo->iHPos = nPos;
  }
  else
  {
    pScrollInfo->iHPos = nPos = -1;
  }



  // TODO:  calculate the geometries

}

int WBCalcVScrollDragPos(WB_SCROLLINFO *pScrollInfo, int iY)
{
  if(pScrollInfo &&
     (pScrollInfo->iVMax >= pScrollInfo->iVMin))
  {
    int nListItems = pScrollInfo->iVMax - pScrollInfo->iVMin + 1;
    int iKnobSize = pScrollInfo->geomVKnob.height;
    int iKnobPos = iY - iKnobSize / 3
                 - (pScrollInfo->geomVUp.y + pScrollInfo->geomVUp.height);

    int iBarScrollArea = pScrollInfo->geomVDown.y
                       - (pScrollInfo->geomVUp.y + pScrollInfo->geomVUp.height)
                       - iKnobSize
                       - 1; // inclusive value

    if(iBarScrollArea <= 0)
    {
      return pScrollInfo->iVMin;  // always assume 1st item's index
    }
    else
    {
      int nPos = (WB_INT64)iKnobPos * (WB_INT64)(nListItems - 1)
               / (WB_INT64)iBarScrollArea;

      WB_ERROR_PRINT("TEMPORARY:  iY=%d; nLI=%d  KS=%d  KP=%d  BSA=%d  nP=%d\n",
                     iY, nListItems, iKnobSize, iKnobPos, iBarScrollArea, nPos);

      if(nPos < pScrollInfo->iVMin)
      {
        return pScrollInfo->iVMin;
      }
      else if(nPos > pScrollInfo->iVMax)
      {
        return pScrollInfo->iVMax;
      }
      else
      {
        return nPos;
      }
    }
  }

  return -1;  // can't evaluate, so return -1
}

int WBCalcHScrollDragPos(WB_SCROLLINFO *pScrollInfo, int iX)
{
  return -1;  // for now, until implemented
}

void WBCalcVScrollBar(WB_SCROLLINFO *pScrollInfo, WB_GEOM *pgeomClient, int iVScrollWidth,
                      int iHScrollHeight, int nListItems, int nPos)
{
int iKnobSize, iKnobPos, iBarHeight, iBarWidth;
int i1, i2;

  iBarHeight = pgeomClient->height;
  iBarWidth = pgeomClient->width;

  if(pScrollInfo->iVBarHeight == iBarHeight &&
     pScrollInfo->iHBarWidth == iBarWidth &&
     pScrollInfo->iVBarHeight == iBarHeight &&
     pScrollInfo->iHBarWidth == iBarWidth &&
     pScrollInfo->iVKnob >= 0 &&
     pScrollInfo->iVKnobSize >= 0 &&
     pScrollInfo->iVPos == nPos &&
     pScrollInfo->iVMin == 0 &&
     pScrollInfo->iVMax == (nListItems - 1))
  {
    // assume it's set up correctly

//    WB_ERROR_TEXT("TEMPORARY:  short cycling calc scroll info\n");
//    return;
  }

  if(pScrollInfo->iVBarHeight != iBarHeight ||
     pScrollInfo->iHBarWidth != iBarWidth ||
     pScrollInfo->iVBarHeight != iBarHeight ||
     pScrollInfo->iHBarWidth != iBarWidth)
  {
    // client size change detected
    // zero out the H Scroll info so that it forces re-calculation next time
    pScrollInfo->iHKnob = pScrollInfo->iHKnobSize = pScrollInfo->iHPos = pScrollInfo->iHMin = pScrollInfo->iHMax = 0;
  }


//  WB_ERROR_PRINT("TEMPORARY:  %d %d %d %d %d\n",
//                 iBarHeight, iVScrollWidth, iHScrollHeight, nListItems, nPos);

  pScrollInfo->iVScrollWidth = iVScrollWidth;
  pScrollInfo->iHScrollHeight = iHScrollHeight;
  pScrollInfo->iVBarHeight = iBarHeight;
  pScrollInfo->iHBarWidth = iBarWidth;

  pScrollInfo->iVMin = 0;
  pScrollInfo->iVMax = nListItems - 1;
  if(nPos == -1 ||
     (nPos >= 0 && nPos < nListItems))
  {
    pScrollInfo->iVPos = nPos;
  }
  else
  {
    pScrollInfo->iVPos = nPos = -1;
  }

  // knob height equals 'nListItems / nListItems!' multiplied by
  // the available knob height, for a minimum value of 'iHScrollHeight'

  iKnobSize = (iBarHeight - 4 * iHScrollHeight - 2);
  if(iKnobSize > iHScrollHeight / 2)
  {
    i1 = iHScrollHeight * (2 * iHScrollHeight + 1);  // 'twice scroll height' factorial
    i2 = iHScrollHeight * 2;

    while(i2 > 2 && i1 > iKnobSize) // using the above starting point get 'max factorial less than height'
    {
      i1 -= i2;
      i2--;
    }

    if(nListItems >= i2) // more than twice scroll height?
    {
      if(nListItems > iKnobSize || iKnobSize - i1 < iHScrollHeight / 2)
      {
        iKnobSize = -1;  // to fix later
      }
      else
      {
        iKnobSize -= i1;  // twice scroll height factorial
        iKnobSize -= (nListItems - iHScrollHeight * 2 + 1);
      }
    }
    else
    {
      iKnobSize -= i1  // 'twice knob height' factorial
                 - (nListItems + 1) * nListItems / 2;  // 'nListItems' factorial
    }

    if(iKnobSize < 3 * iHScrollHeight / 4)
    {
      iKnobSize = 3 * iHScrollHeight / 4;  // minimum size
    }
  }
  else
  {
    iKnobSize = 3 * iHScrollHeight / 4;  // worst case use this anyway
  }

  // cache these geometries because I need them for mouse handling

  pScrollInfo->geomVBar.y      = pgeomClient->y + 1;
  pScrollInfo->geomVBar.height = pgeomClient->height - 2;
  pScrollInfo->geomVBar.width  = pScrollInfo->iVScrollWidth;
  pScrollInfo->geomVBar.x      = pgeomClient->x + pgeomClient->width
                              - pScrollInfo->geomVBar.width - 1;

  pScrollInfo->geomVDown.x      = pScrollInfo->geomVUp.x
                               = pScrollInfo->geomVBar.x + 1;
  pScrollInfo->geomVDown.width  = pScrollInfo->geomVUp.width
                               = pScrollInfo->geomVBar.width - 2;
  pScrollInfo->geomVDown.height = pScrollInfo->geomVUp.height
                               = pScrollInfo->iHScrollHeight - 1;

  pScrollInfo->geomVUp.y   = pScrollInfo->geomVBar.y + 1;
  pScrollInfo->geomVDown.y = pScrollInfo->geomVBar.y
                          + pScrollInfo->geomVBar.height
                          - pScrollInfo->geomVDown.height - 1;

  pScrollInfo->geomVKnob.x     = pScrollInfo->geomVDown.x;
  pScrollInfo->geomVKnob.width = pScrollInfo->geomVDown.width;
  pScrollInfo->geomVKnob.height = pScrollInfo->iVKnobSize
                               = iKnobSize;

  // now that I have a reasonable estimate of the knob size, calculate
  // the starting vertical position of the knob

  if(nPos <= 0 || nListItems <= 0)
  {
    iKnobPos = 0;
  }
  else
  {
    int iBarScrollArea = pScrollInfo->geomVDown.y
                       - (pScrollInfo->geomVUp.y + pScrollInfo->geomVUp.height)
                       - iKnobSize
                       - 1; // inclusive value

    if(nPos >= (nListItems - 1))
    {
      iKnobPos = iBarScrollArea;
    }
    else
    {
      iKnobPos = (WB_INT64)nPos * (WB_INT64)iBarScrollArea
               / (WB_INT64)(nListItems - 1);
    }
  }


  pScrollInfo->geomVKnob.y = (pScrollInfo->iVKnob = iKnobPos)
                           + pScrollInfo->geomVUp.y + pScrollInfo->geomVUp.height;

  // fixed values go here
  pScrollInfo->geomVBar.border = 1;
  pScrollInfo->geomVUp.border = 0;
  pScrollInfo->geomVDown.border = 0;
  pScrollInfo->geomVKnob.border = 0;

}

void WBDrawBorderRect(Display *pDisplay, Window wID, GC gc,
                      WB_GEOM *pgeomBorder, unsigned long lBorderColor)
{
XPoint xpt[5];

  XSetForeground(pDisplay, gc, lBorderColor);

  xpt[0].x=pgeomBorder->x;
  xpt[0].y=pgeomBorder->y;

  xpt[1].x = xpt[0].x
           + pgeomBorder->width
           - 1;  // 'inclusive' values

  xpt[1].y = xpt[0].y;

  xpt[2].x = xpt[1].x;
  xpt[2].y = xpt[1].y
           + pgeomBorder->height
           - 1;

  xpt[3].x = xpt[0].x;
  xpt[3].y = xpt[2].y;

  xpt[4].x = xpt[0].x;
  xpt[4].y = xpt[0].y + 1;   // exclude final point

  XDrawLines(pDisplay, wID, gc, xpt, 5, CoordModeOrigin);
}

void WBDraw3DBorderRect(Display *pDisplay, Window wID, GC gc, WB_GEOM *pgeomBorder,
                        unsigned long lBorderColor1, unsigned long lBorderColor2)
{
XPoint xpt[4];
XColor clr;
unsigned long lBorderColorAvg;
int iR, iG, iB;


  XSetForeground(pDisplay, gc, lBorderColor1);
  xpt[0].x = pgeomBorder->x;
  xpt[0].y = pgeomBorder->y
           + pgeomBorder->height - 1 - 1;  // exclude first point

  xpt[1].x = xpt[0].x;
  xpt[1].y = pgeomBorder->y;

  xpt[2].x = xpt[0].x
           + pgeomBorder->width - 1 - 1;   // exclude last point
  xpt[2].y = xpt[1].y;

  XDrawLines(pDisplay, wID, gc, xpt, 3, CoordModeOrigin);

  XSetForeground(pDisplay, gc, lBorderColor2);

  xpt[0].x = pgeomBorder->x
           + pgeomBorder->width - 1;
  xpt[0].y = pgeomBorder->y + 1;              // exclude first point

  xpt[1].x = xpt[0].x;
  xpt[1].y = pgeomBorder->y
           + pgeomBorder->height - 1;

  xpt[2].x = pgeomBorder->x + 1;              // exclude final point
  xpt[2].y = xpt[1].y;

  XDrawLines(pDisplay, wID, gc, xpt, 3, CoordModeOrigin);


  // must use XQueryColor or pass in XColor pointers to get 'average' color
  // between the two for the 'corner' pixels

  bzero(&clr, sizeof(clr));
  clr.pixel = lBorderColor1;
  XQueryColor(pDisplay, DefaultColormap(pDisplay, DefaultScreen(pDisplay)), &clr);
  iR = (clr.flags & DoRed) ? (unsigned int)clr.red : 0;
  iG = (clr.flags & DoGreen) ? (unsigned int)clr.green : 0;
  iB = (clr.flags & DoBlue) ? (unsigned int)clr.blue : 0;

//  WB_ERROR_PRINT("TEMPORARY 1 : %d %d %d %d \n", clr.pixel, iR, iG, iB);

  bzero(&clr, sizeof(clr));
  clr.pixel = lBorderColor2;
  XQueryColor(pDisplay, DefaultColormap(pDisplay, DefaultScreen(pDisplay)), &clr);
  iR += (clr.flags & DoRed) ? (unsigned int)clr.red : 0;
  iG += (clr.flags & DoGreen) ? (unsigned int)clr.green : 0;
  iB += (clr.flags & DoBlue) ? (unsigned int)clr.blue : 0;

//  WB_ERROR_PRINT("TEMPORARY 2 : %d %d %d %d \n", clr.pixel, iR, iG, iB);


  bzero(&clr, sizeof(clr));
  clr.red = iR >> 1;
  clr.green = iG >> 1;
  clr.blue = iB >> 1;

  XAllocColor(pDisplay, DefaultColormap(pDisplay, DefaultScreen(pDisplay)), &clr);

  XSetForeground(pDisplay, gc, clr.pixel);

  xpt[0].x = pgeomBorder->x;
  xpt[1].y = pgeomBorder->y;

  xpt[1].x = xpt[0].x + pgeomBorder->width - 1;
  xpt[0].y = xpt[1].y + pgeomBorder->height - 1;

  XDrawPoints(pDisplay, wID, gc, xpt, 2, CoordModeOrigin);

  XSetForeground(pDisplay, gc, lBorderColor1);

  XFreeColors(pDisplay, DefaultColormap(pDisplay, DefaultScreen(pDisplay)),
              &clr.pixel, 1, 0);

}

void WBDrawDashedRect(Display *pDisplay, Window wID, GC gc, WB_GEOM *pgeomRect, unsigned long lColor)
{
static const char dash_list[4]={1,2,2,1};
int i1;
XGCValues val;
GC gc2;


  gc2 = WBGetWindowCopyGC2(wID, gc);

//  bzero(&val, sizeof(val));
//  i1 = XGetGCValues(pDisplay, gc, GCAll & ~(GCClipMask | GCDashOffset | GCDashList), &val);
//
//  if(!i1)  // zero on failure
//  {
//    WB_ERROR_PRINT("%s:%d - unable to get GC values, %d\n", __FUNCTION__, __LINE__, i1);
//    for(i1=0; i1 < 32; i1++)
//    {
//      if(XGetGCValues(pDisplay, gc, 1L << i1, &val))
//      {
//        WB_ERROR_PRINT("TEMPORARY:  %d works\n", i1);
//      }
//    }
//    return;
//  }
//
//  gc2 = XCreateGC(pDisplay, wID, (GCFont | GCForeground | GCBackground), &val);

  if(gc2)
  {
//    XChangeGC(pDisplay, gc2, GCAll & ~(GCClipMask | GCDashOffset | GCDashList), &val);
    WBDrawBorderRect(pDisplay, wID, gc2, pgeomRect, WhitePixel(pDisplay, DefaultScreen(pDisplay)));
    XSetDashes(pDisplay, gc2, 1, dash_list, 4);
    XSetLineAttributes(pDisplay, gc2, 1, LineOnOffDash, CapNotLast, JoinBevel);
    XSetBackground(pDisplay, gc2, WhitePixel(pDisplay, DefaultScreen(pDisplay)));
    WBDrawBorderRect(pDisplay, wID, gc2, pgeomRect, lColor);

    XFreeGC(pDisplay, gc2);
  }
  else
  {
    WB_ERROR_PRINT("%s:%d - unable to create GC\n", __FUNCTION__, __LINE__);
  }
}

// this assumes WB_SCROLLINFO is valid.  TO make it so, call ListCalcVScrollBar or similar
void WBPaintVScrollBar(WB_SCROLLINFO *pScrollInfo, Display *pDisplay, Window wID,
                       GC gc, WB_GEOM *pgeomClient)
{
//WB_GEOM geomBar, geomUp, geomDown, geomKnob;
XPoint xpt[5];

  CheckInitScrollColors();

  // fill scrollbar with background color
  XSetForeground(pDisplay, gc, clrScrollBG.pixel);
  XFillRectangle(pDisplay, wID, gc, pScrollInfo->geomVBar.x - 1, pScrollInfo->geomVBar.y,
                 pScrollInfo->geomVBar.width + 1, pScrollInfo->geomVBar.height);

  // draw 3D borders around everything

  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomVBar),
                     clrScrollBD3.pixel, clrScrollBD2.pixel);

  // if the scrollbar is DISABLED, do not draw the rest of it
  if(pScrollInfo->iVPos < pScrollInfo->iVMin ||
     pScrollInfo->iVPos > pScrollInfo->iVMax ||
     pScrollInfo->iVMax < pScrollInfo->iVMin)
  {
//    WB_ERROR_PRINT("TEMPORARY:  grey out %d %d %d\n",
//                   pScrollInfo->iVPos, pScrollInfo->iVMin, pScrollInfo->iVMax);
    return;  // I am done (greyed out bar)
  }

  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomVUp),
                     clrScrollBD2.pixel, clrScrollBD3.pixel);
  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomVDown),
                     clrScrollBD2.pixel, clrScrollBD3.pixel);
  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomVKnob),
                     clrScrollBD2.pixel, clrScrollBD3.pixel);

  // draw arrows

  XSetForeground(pDisplay, gc, clrScrollFG.pixel);

  xpt[0].x = pScrollInfo->geomVUp.x + (pScrollInfo->geomVUp.width >> 2) + (pScrollInfo->geomVUp.width >> 2);
  xpt[0].y = pScrollInfo->geomVUp.y + (pScrollInfo->geomVUp.height >> 2);
  xpt[1].x = pScrollInfo->geomVUp.x + (pScrollInfo->geomVUp.width >> 2);
  xpt[1].y = xpt[0].y + (pScrollInfo->geomVUp.height >> 1) - 1;
  xpt[2].x = pScrollInfo->geomVUp.x + pScrollInfo->geomVUp.width - 1 - (pScrollInfo->geomVUp.width >> 2);
  xpt[2].y = xpt[1].y;
  xpt[3].x = xpt[2].x - (pScrollInfo->geomVUp.width >> 2);
  xpt[3].y = xpt[0].y;
  xpt[4].x = xpt[0].x;
  xpt[4].y = xpt[0].y;

  XDrawLines(pDisplay, wID, gc, xpt, 5, CoordModeOrigin);
  XFillPolygon(pDisplay, wID, gc, xpt, 4, Convex, CoordModeOrigin);

  xpt[0].x = pScrollInfo->geomVDown.x + (pScrollInfo->geomVDown.width >> 2) + (pScrollInfo->geomVDown.width >> 2);
  xpt[0].y = pScrollInfo->geomVDown.y + pScrollInfo->geomVDown.height - 1 - (pScrollInfo->geomVDown.height >> 2);
  xpt[1].x = pScrollInfo->geomVDown.x + (pScrollInfo->geomVUp.width >> 2);
  xpt[1].y = xpt[0].y - (pScrollInfo->geomVDown.height >> 1) + 1;
  xpt[2].x = pScrollInfo->geomVDown.x + pScrollInfo->geomVDown.width - 1 - (pScrollInfo->geomVDown.width >> 2);
  xpt[2].y = xpt[1].y;
  xpt[3].x = xpt[2].x - (pScrollInfo->geomVUp.width >> 2);
  xpt[3].y = xpt[0].y;
  xpt[4].x = xpt[0].x;
  xpt[4].y = xpt[0].y;

  XDrawLines(pDisplay, wID, gc, xpt, 5, CoordModeOrigin);
  XFillPolygon(pDisplay, wID, gc, xpt, 4, Convex, CoordModeOrigin);
}

// this assumes WB_SCROLLINFO is valid.  TO make it so, call ListCalcHScrollBar or similar
void WBPaintHScrollBar(WB_SCROLLINFO *pScrollInfo, Display *pDisplay, Window wID,
                       GC gc, WB_GEOM *pgeomClient)
{
//WB_GEOM geomBar, geomLeft, geomRight, geomKnob;
XPoint xpt[5];

  CheckInitScrollColors();

  // fill scrollbar with background color
  XSetForeground(pDisplay, gc, clrScrollBG.pixel);
  XFillRectangle(pDisplay, wID, gc, pScrollInfo->geomHBar.x - 1, pScrollInfo->geomHBar.y,
                 pScrollInfo->geomHBar.width + 1, pScrollInfo->geomHBar.height);

  // draw 3D borders around everything

  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomHBar),
                     clrScrollBD3.pixel, clrScrollBD2.pixel);

  // if the scrollbar is DISABLED, do not draw the rest of it
  if(pScrollInfo->iHPos < pScrollInfo->iHMin ||
     pScrollInfo->iHPos > pScrollInfo->iHMax ||
     pScrollInfo->iHMax < pScrollInfo->iHMin)
  {
//    WB_ERROR_PRINT("TEMPORARY:  grey out %d %d %d\n",
//                   pScrollInfo->iVPos, pScrollInfo->iVMin, pScrollInfo->iVMax);
    return;  // I am done (greyed out bar)
  }

  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomHLeft),
                     clrScrollBD2.pixel, clrScrollBD3.pixel);
  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomHRight),
                     clrScrollBD2.pixel, clrScrollBD3.pixel);
  WBDraw3DBorderRect(pDisplay, wID, gc, &(pScrollInfo->geomHKnob),
                     clrScrollBD2.pixel, clrScrollBD3.pixel);

  // draw arrows

  XSetForeground(pDisplay, gc, clrScrollFG.pixel);

// TODO this is copied from painting the vertical scroll bar - fix it for horizontal!
//  xpt[0].x = pScrollInfo->geomVUp.x + (pScrollInfo->geomVUp.width >> 2) + (pScrollInfo->geomVUp.width >> 2);
//  xpt[0].y = pScrollInfo->geomVUp.y + (pScrollInfo->geomVUp.height >> 2);
//  xpt[1].x = pScrollInfo->geomVUp.x + (pScrollInfo->geomVUp.width >> 2);
//  xpt[1].y = xpt[0].y + (pScrollInfo->geomVUp.height >> 1) - 1;
//  xpt[2].x = pScrollInfo->geomVUp.x + pScrollInfo->geomVUp.width - 1 - (pScrollInfo->geomVUp.width >> 2);
//  xpt[2].y = xpt[1].y;
//  xpt[3].x = xpt[2].x - (pScrollInfo->geomVUp.width >> 2);
//  xpt[3].y = xpt[0].y;
//  xpt[4].x = xpt[0].x;
//  xpt[4].y = xpt[0].y;
//
//  XDrawLines(pDisplay, wID, gc, xpt, 5, CoordModeOrigin);
//  XFillPolygon(pDisplay, wID, gc, xpt, 4, Convex, CoordModeOrigin);
//
//  xpt[0].x = pScrollInfo->geomVDown.x + (pScrollInfo->geomVDown.width >> 2) + (pScrollInfo->geomVDown.width >> 2);
//  xpt[0].y = pScrollInfo->geomVDown.y + pScrollInfo->geomVDown.height - 1 - (pScrollInfo->geomVDown.height >> 2);
//  xpt[1].x = pScrollInfo->geomVDown.x + (pScrollInfo->geomVUp.width >> 2);
//  xpt[1].y = xpt[0].y - (pScrollInfo->geomVDown.height >> 1) + 1;
//  xpt[2].x = pScrollInfo->geomVDown.x + pScrollInfo->geomVDown.width - 1 - (pScrollInfo->geomVDown.width >> 2);
//  xpt[2].y = xpt[1].y;
//  xpt[3].x = xpt[2].x - (pScrollInfo->geomVUp.width >> 2);
//  xpt[3].y = xpt[0].y;
//  xpt[4].x = xpt[0].x;
//  xpt[4].y = xpt[0].y;
//
//  XDrawLines(pDisplay, wID, gc, xpt, 5, CoordModeOrigin);
//  XFillPolygon(pDisplay, wID, gc, xpt, 4, Convex, CoordModeOrigin);
}


