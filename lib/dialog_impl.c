/////////////////////////////////////////////////////////////////////////////////////////////
//              _  _         _                     _                    _                  //
//           __| |(_)  __ _ | |  ___    __ _      (_) _ __ ___   _ __  | |    ___          //
//          / _` || | / _` || | / _ \  / _` |     | || '_ ` _ \ | '_ \ | |   / __|         //
//         | (_| || || (_| || || (_) || (_| |     | || | | | | || |_) || | _| (__          //
//          \__,_||_| \__,_||_| \___/  \__, |_____|_||_| |_| |_|| .__/ |_|(_)\___|         //
//                                     |___/|_____|             |_|                        //
//                                                                                         //
//                          implementation of standard modal dialogs                       //
//                                                                                         //
/////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2016 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no waranties, either implied or explicit.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

/** \file dialog_impl.c
  * \brief Dialog box implementation file for standard types of dialog boxes
  *
  * This file implements a number of standard dialog boxes including the
  * 'file open' dialog box, message boxes, input boxes, and the splash screen.
*/


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <signal.h>
#include <time.h>

#ifndef XK_Delete /* moslty for interix */
#define XK_MISCELLANY /* mostly for interix */
#include <X11/keysymdef.h> // some platforms don't automatically include this with X headers
#endif // XK_Delete

#include "window_helper.h"
#include "pixmap_helper.h"  // pixmap helpers, including pre-defined icons
#include "dialog_window.h"
#include "dialog_controls.h"
#include "conf_help.h"
#include "file_help.h"
#include "draw_text.h"


#define THIS_SUBSYSTEM DebugSubSystem_Dialog

//-------------------------------------------------------------------
//
// alteration of 'gleam' behavior for 'Splash' dialog
// default is the 'wide' gleam that uses 1/r^2
//
//#define GLEAM_OLD /* use this to do the 'old' gleam behavior */
//#define GLEAM_NARROW /* use this to produce the 'narrow' gleam */
//
//------------------------------------------------------------------


///////////////
// MESSAGE BOX
///////////////

struct _MESSAGE_BOX_
{
  int iType;
  const char *szTitle;
  const char *szMessage;
};

static int GetMessageBoxIconPixmapID(int iMBIconMask)
{
  switch(iMBIconMask & MessageBox_ICON_MASK)
  {
    case MessageBox_Error:
      return ID_ICON_STOP;
    case MessageBox_Warning:
      return ID_ICON_WARN;
    case MessageBox_Info:
      return ID_ICON_OK;
    case MessageBox_Asterisk:
      return ID_ICON_SPLAT;
    case MessageBox_Question:
      return ID_ICON_WHAT;
    case MessageBox_BoldQuestion:
      return ID_ICON_WHAT_BOLD;
    case MessageBox_WTF:
      return ID_ICON_WTF;
    case MessageBox_Bang:
      return ID_ICON_BANG;
    case MessageBox_Triangle:
      return ID_ICON_TRIANGLE;
    case MessageBox_FaceOfDeath:
      return ID_ICON_DEATH;
    case MessageBox_JollyRoger:
      return ID_ICON_SKULL;
    case MessageBox_ThumbsUp:
      return ID_ICON_THUMBUP;
    case MessageBox_ThumbsDown:
      return ID_ICON_THUMBDOWN;
    case MessageBox_MiddleFinger:
      return ID_ICON_FINGER;
    case MessageBox_TeddyBear:
      return ID_ICON_BEAR;
    case MessageBox_Barney:
      return ID_ICON_BARNEY;
    case MessageBox_App:
      return ID_ICON_APP;

//    default:
//      pixmap = None;
  }

  return -1;
}

static int MessageBoxCallback(Window wID, XEvent *pEvent)
{
WBDialogWindow *pDlg = DLGGetDialogWindowStruct(wID);
struct _MESSAGE_BOX_ *pUserData = (struct _MESSAGE_BOX_ *)(pDlg ? pDlg->pUserData : NULL);
//#ifndef NO_DEBUG
//WB_UINT64 ullTime = WBGetTimeIndex();
//#endif // NO_DEBUG


  if(pEvent->type == ClientMessage && pEvent->xclient.message_type == aDIALOG_INIT)
  {
    if(!pDlg)
    {
      WB_ERROR_PRINT("MessageBoxCallback - no WBDialogWindow structure in DIALOG_INIT for %d (%08xH) %p %08xH %08xH\n",
                     (unsigned int)wID, (unsigned int)wID, WBGetWindowData(wID, 0), DIALOG_WINDOW_TAG, ((WBDialogWindow *)WBGetWindowData(wID, 0))->ulTag);
      return 0; // can't process any messages now
    }
    else
    {
      // assigning the correct icon

      Window wIDIcon = DLGGetDialogControl(pDlg, 1000);  // ID 1000 for icon
      WBDialogControl *pCtrl = DLGGetDialogControlStruct(wIDIcon);

      if(pCtrl)
      {
        Pixmap pixmap2 = None;
        Pixmap pixmap = PXM_GetIconPixmap(GetMessageBoxIconPixmapID(pUserData->iType & MessageBox_ICON_MASK),
                                          NULL, &pixmap2);

        if(pixmap != None)
        {
          WBDialogControlSetIconPixmap(pCtrl, pixmap, pixmap2);
        }
      }
    }

    // assign the caption text to the caption window (which varies and must be assigned at run time)

    DLGSetControlCaption((WBDialogWindow *)pDlg, 1001, pUserData->szMessage);

//    WB_ERROR_PRINT("TEMPORARY:  %s line %d  delta tick %lld\n", __FUNCTION__, __LINE__, (WBGetTimeIndex() - ullTime));

    return 1;
  }

  if(!pDlg)
  {
    WB_WARN_PRINT("MessageBoxCallback - no WBDialogWindow structure\n");
    return 0; // can't process any messages now
  }

  if(pEvent->type == ClientMessage && pEvent->xclient.message_type == aCONTROL_NOTIFY)
  {
    WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Event | DebugSubSystem_Dialog,
                   "%s - MessageBox ClientMessage CONTROL_NOTIFY\n", __FUNCTION__);

    switch(pEvent->xclient.data.l[1]) // control ID
    {
      case IDOK:
      case IDCANCEL:
        if(pEvent->xclient.data.l[0] == aBUTTON_PRESS)
        {
          WBEndModal(wID, pEvent->xclient.data.l[1]);
        }
        break;

      default:
        WB_WARN_PRINT("%s - MessageBox ClientMessage CONTROL_NOTIFY client id=%lx\n",
                      __FUNCTION__, pEvent->xclient.data.l[1]);
    }
  }






  return 0;
}

int DLGMessageBox(int iType, Window wIDOwner, const char *szTitle, const char *szMessage)
{
static const char szOKBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"OK Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDOK TITLE:OK X:80 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szNoBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"OK Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDCANCEL TITLE:No X:80 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szYesBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"OK Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDYES TITLE:Yes X:80 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szCancelBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"OK Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDCANCEL TITLE:Cancel X:80 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szAbortBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"OK Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDABORT TITLE:Abort X:80 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szRetryBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"OK Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDRETRY TITLE:Retry X:80 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szIgnoreBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"OK Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDIGNORE TITLE:Ignore X:80 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szOKCancelBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"OK/Cancel Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDOK TITLE:OK X:40 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:CancelButton ID:IDCANCEL TITLE:Cancel X:120 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szYesNoBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"Yes/No Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDYES TITLE:_Yes X:40 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:CancelButton ID:IDNO TITLE:_No X:120 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szYesNoCancelBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"Yes/No Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDYES TITLE:_Yes X:20 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:PushButton ID:IDNO TITLE:_No X:80 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:CancelButton ID:IDCANCEL TITLE:Cancel X:140 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szAbortRetryBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"Yes/No Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDABORT TITLE:_Abort X:40 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:CancelButton ID:IDRETRY TITLE:_Retry X:120 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szAbortRetryIgnoreBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"Yes/No Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDYES TITLE:_Abort X:20 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:PushButton ID:IDRETRY TITLE:_Retry X:80 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:CancelButton ID:IDIGNORE TITLE:_Ignore X:140 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";

struct _MESSAGE_BOX_ mbox;
const char *pRes;
WBDialogWindow *pDlg;
WB_GEOM geomParent;
Window wIDDlg;
int iRval, iX, iY;


// for now I determine the standard message box size THIS way
#define MESSAGE_BOX_WIDTH 400
#define MESSAGE_BOX_HEIGHT 100
#define MESSAGE_BOX_OFFSET 50

  mbox.iType = iType;
  mbox.szTitle = szTitle;
  mbox.szMessage = szMessage;

  bzero(&geomParent, sizeof(geomParent));

  if(wIDOwner != None)
  {
    WBGetWindowGeom0(wIDOwner, &geomParent); // parent geometry in absolute coordinates

    iX = geomParent.x + geomParent.border + MESSAGE_BOX_OFFSET;
    iY = geomParent.y + geomParent.border + MESSAGE_BOX_OFFSET;
  }
  else
  {
    // center in screen with slight random offset (so that every window won't always appear in exactly the same place)
    iY = (DisplayHeight(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()))
          - MESSAGE_BOX_HEIGHT + MESSAGE_BOX_OFFSET - (int)(WBGetTimeIndex() % (2 * MESSAGE_BOX_OFFSET)))
       / 2;

    iX = (DisplayWidth(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()))
          - MESSAGE_BOX_WIDTH + MESSAGE_BOX_OFFSET - (int)((~WBGetTimeIndex()) % (2 * MESSAGE_BOX_OFFSET)))
       / 2;
  }

  switch(iType & MessageBox_BUTTON_MASK)
  {
    case MessageBox_OK:
      pRes = szOKBox;
      break;

    case MessageBox_Yes:
      pRes = szYesBox;
      break;

    case MessageBox_No:
      pRes = szNoBox;
      break;

    case MessageBox_Cancel:
      pRes = szCancelBox;
      break;

    case MessageBox_Abort:
      pRes = szAbortBox;
      break;

    case MessageBox_Retry:
      pRes = szRetryBox;
      break;

    case MessageBox_Ignore:
      pRes = szIgnoreBox;
      break;

    case MessageBox_OK | MessageBox_Cancel:
      pRes = szOKCancelBox;
      break;

    case MessageBox_Yes | MessageBox_No:
      pRes = szYesNoBox;
      break;

    case MessageBox_Yes | MessageBox_No | MessageBox_Cancel:
      pRes = szYesNoCancelBox;
      break;

    case MessageBox_Abort | MessageBox_Retry:
      pRes = szAbortRetryBox;
      break;

    case MessageBox_Abort | MessageBox_Retry | MessageBox_Ignore:
      pRes = szAbortRetryIgnoreBox;
      break;

    default:
      if((iType & MessageBox_Abort) || (iType & MessageBox_Retry) || (iType & MessageBox_Ignore))
      {
        pRes = szAbortRetryIgnoreBox;
      }
      else if((iType & MessageBox_Yes) || (iType & MessageBox_No) || (iType & MessageBox_Cancel))
      {
        pRes = szYesNoCancelBox;
      }
      else
      {
        pRes = szOKBox;
      }
  }


//  WB_ERROR_PRINT("TEMPORARY:  %s - calling DLGCreateDialogWindow\n", __FUNCTION__);

  pDlg = DLGCreateDialogWindow(szTitle,pRes, iX, iY,
                               MESSAGE_BOX_WIDTH,
                               MESSAGE_BOX_HEIGHT, // TODO:  derive from ???
                               MessageBoxCallback,
                               WBDialogWindow_VISIBLE, &mbox);

  if(pDlg) // TODO:  manage this stuff as part of 'DLGCreateDialogWindow' instead
  {
    wIDDlg = pDlg->wID;

    if(wIDOwner != None)
    {
      Atom a1;
      unsigned int ai1[3];

      DLGAssignOwner(pDlg, wIDOwner);

      a1 = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE", False);
      ai1[0] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_TASKBAR", False);
      ai1[1] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_PAGER", False);

      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_ATOM, 32, PropModeReplace, (unsigned char *)ai1, 2);

      a1 = XInternAtom(WBGetWindowDisplay(wIDDlg), "WM_TRANSIENT_FOR", False);
      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_WINDOW, 32, PropModeReplace, (unsigned char *)&wIDOwner, 1);
    }

    WBSetWindowIcon(wIDDlg, GetMessageBoxIconPixmapID(iType & MessageBox_ICON_MASK));

//    WB_ERROR_PRINT("TEMPORARY:  %s - calling WBShowModal\n", __FUNCTION__);

    iRval = WBShowModal(wIDDlg, 0);

    return iRval;
  }

  return -1;  // by default return -1 on error
}


///////////////
// INPUT BOX
///////////////

struct _INPUT_BOX_
{
  const char *szTitle;
  const char *szMessage;
  char *szRval;
};


static int InputBoxCallback(Window wID, XEvent *pEvent)
{
WBDialogWindow *pDlg = DLGGetDialogWindowStruct(wID);
struct _INPUT_BOX_ *pUserData = (struct _INPUT_BOX_ *)(pDlg ? pDlg->pUserData : NULL);


  if(!pDlg)
    return 0; // can't process any messages now

  if(pEvent->type == ClientMessage && pEvent->xclient.message_type == aDIALOG_INIT)
  {
    // assigning the correct icon
    {
      WBDialogControl *pCtrl = DLGGetDialogControlStructFromID(pDlg, 1000); // ID 1000 for icon

      if(pCtrl)
      {
        Pixmap pixmap2 = None;
        Pixmap pixmap = PXM_GetIconPixmap(ID_ICON_WHAT, NULL, &pixmap2);

        if(pixmap != None)
        {
          WBDialogControlSetIconPixmap(pCtrl, pixmap, pixmap2);
        }
      }
    }

    // assign the caption text to the caption window (which varies and must be assigned at run time)

    DLGSetControlCaption((WBDialogWindow *)pDlg, 1001, pUserData->szMessage);

    if(pUserData->szRval)
    {
      DLGSetControlCaption(pDlg, 1002, pUserData->szRval);
    }

    return 1;
  }

  if(pEvent->type == ClientMessage && pEvent->xclient.message_type == aCONTROL_NOTIFY)
  {
    WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Event | DebugSubSystem_Dialog,
                     "%s - MessageBox ClientMessage CONTROL_NOTIFY\n", __FUNCTION__);

    switch(pEvent->xclient.data.l[1]) // control ID
    {
      case IDOK:
      case IDCANCEL:
        if(pEvent->xclient.data.l[0] == aBUTTON_PRESS)
        {
          const char *pText = DLGGetControlCaption(pDlg, 1002);

          if(pUserData->szRval)
          {
            WBFree(pUserData->szRval);
          }
          if(pText)
          {
            pUserData->szRval = WBCopyString(pText);
          }
          else
          {
            WB_ERROR_PRINT("TEMPORARY: %s - NULL 'pText' for edit control\n", __FUNCTION__);
            pUserData->szRval = NULL; // empty string
          }

          WBEndModal(wID, pEvent->xclient.data.l[1]);
        }
        break;

      case 1002:
        WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Event | DebugSubSystem_Dialog,
                       "%s - INPUT BOX 'EDIT' NOTIFICATION %ld\n",
                       __FUNCTION__, pEvent->xclient.data.l[0]);

        // TODO:  update window text
        break;

      default:
        WB_WARN_PRINT("%s - MessageBox ClientMessage CONTROL_NOTIFY client id=%lx\n",
                      __FUNCTION__, pEvent->xclient.data.l[0]);
    }
  }

  return 0;
}

char *DLGInputBox(Window wIDOwner, const char *szTitle, const char *szPrompt, const char *szDefault,
                  int iWidth, int iMaxChar)
{
static const char szInputDialogRes[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:60 WIDTH:200 TITLE:\"User Input\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE\n"
  "  CONTROL:Edit ID:1002 X:2 Y:22 WIDTH:196 HEIGHT:16 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDOK TITLE:OK X:40 Y:40 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:CancelButton ID:IDCANCEL TITLE:Cancel X:120 Y:40 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
WBDialogWindow *pDlg;
struct _INPUT_BOX_ sRval;
int iRval;
Window wIDDlg;


  sRval.szTitle = szTitle;
  sRval.szMessage = szPrompt;
  if(szDefault && *szDefault)
  {
    sRval.szRval = WBCopyString(szDefault); // a copy of the default value
  }
  else
  {
    sRval.szRval = NULL;
  }

  pDlg = DLGCreateDialogWindow(szTitle,szInputDialogRes,
                               100,100,300,60,InputBoxCallback,
                               WBDialogWindow_VISIBLE,&sRval);

  if(pDlg) // TODO:  manage this stuff as part of 'DLGCreateDialogWindow' instead
  {
    wIDDlg = pDlg->wID;

    if(wIDOwner != None)
    {
      Atom a1;
      unsigned int ai1[3];

      DLGAssignOwner(pDlg, wIDOwner);

      a1 = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE", False);
      ai1[0] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_TASKBAR", False);
      ai1[1] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_PAGER", False);

      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_ATOM, 32, PropModeReplace, (unsigned char *)ai1, 2);

      a1 = XInternAtom(WBGetWindowDisplay(wIDDlg), "WM_TRANSIENT_FOR", False);
      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_WINDOW, 32, PropModeReplace, (unsigned char *)&wIDOwner, 1);
    }

    iRval = WBShowModal(pDlg->wID, 0);

    if(iRval == IDOK)
    {
      return sRval.szRval;
    }
    else if(iRval != IDCANCEL)
    {
      WB_ERROR_PRINT("TEMPORARY - %s - iRval is %d\n", __FUNCTION__, iRval);
    }
  }

  // it ends up here on 'cancel', etc. - so if a buffer was allocated, free it

  if(sRval.szRval)
  {
    WBFree(sRval.szRval);
  }

  return NULL;
}



///////////////
// FILE DIALOG
///////////////

struct _FILE_DIALOG_
{
  const char *szDefPath;
  const char *szDefName;
  const char *szExtAndDescList;
  char *szPathName;  // WBAlloc'd
};


#define FILE_DIALOG_PATH_TREE_CONTROL 1000
#define FILE_DIALOG_FILE_LIST_CONTROL 1001
#define FILE_DIALOG_FILE_NAME_CONTROL 1002

static int FileDialogCallback(Window wID, XEvent *pEvent)
{
WBDialogWindow *pDlg = DLGGetDialogWindowStruct(wID);
struct _FILE_DIALOG_ *pUserData = (struct _FILE_DIALOG_ *)(pDlg ? pDlg->pUserData : NULL);
//Display *pDisplay = WBGetWindowDisplay(wID);
char *p1, *p2;


  if(!pDlg)
    return 0; // can't process any messages now

  if(pEvent->type == ClientMessage && pEvent->xclient.message_type == aDIALOG_INIT)
  {
    if(!pUserData->szPathName || !*(pUserData->szPathName) ||
       (!strchr(pUserData->szPathName, '/') && !WBIsDirectory(pUserData->szPathName)))
    {
      if(!pUserData->szDefPath || !*(pUserData->szDefPath))
      {
        // set the 'DLGC_PATH' property for appropriate controls
        DLGSetControlProperty(pDlg, FILE_DIALOG_FILE_LIST_CONTROL,
                              aDLGC_PATH, ".");  // set path to '.' if not specified already
      }
      else
      {
        DLGSetControlProperty(pDlg, FILE_DIALOG_FILE_LIST_CONTROL,
                              aDLGC_PATH, pUserData->szDefPath);
      }
    }
    else
    {
      p1 = WBCopyString(pUserData->szDefPath);
      if(!p1)
      {
        WB_ERROR_PRINT("%s - no memory to copy path string (a)\n", __FUNCTION__);
      }
      else
      {
        p2 = strrchr(p1, '/');
        if(p2)
        {
          p2[1] = 0;  // keep the '/'
        }

        DLGSetControlProperty(pDlg, FILE_DIALOG_FILE_LIST_CONTROL,
                              aDLGC_PATH, p1);

        WBFree(p1);
      }
    }

    return 1;
  }

  if(pEvent->type != ClientMessage)
  {
    return 0; // unhandled at this time
  }

  // EVERYTHING AT THIS POINT IS A CLIENT MESSAGE

  if(pEvent->xclient.message_type == aCONTROL_NOTIFY)
  {
    // l[0] == message
    // l[1] == control ID
    // l[2] ==
    switch(pEvent->xclient.data.l[1])
    {
      case IDOK:
      case IDCANCEL:
        if(pEvent->xclient.data.l[0] == aBUTTON_PRESS)
        {
          if(pEvent->xclient.data.l[1] == IDOK)
          {
            const char *pPath = DLGGetControlCaption(pDlg, FILE_DIALOG_FILE_NAME_CONTROL);
            const char *pDir = DLGGetControlProperty(pDlg, FILE_DIALOG_FILE_LIST_CONTROL, aDLGC_PATH);

            if(pUserData->szPathName)
            {
              WBFree(pUserData->szPathName);
            }

            if(pPath && pPath[0] == '/')
            {
              pUserData->szPathName = WBCopyString(pPath); // absolute path assignment
            }
            else
            {
              if(pDir && *pDir)
              {
                pUserData->szPathName = WBCopyString(pDir);

                if(pUserData->szPathName && *pUserData->szPathName &&
                   pUserData->szPathName[strlen(pUserData->szPathName) - 1] != '/')
                {
                  WBCatString(&(pUserData->szPathName), "/");
                }
              }
              else
              {
                pUserData->szPathName = WBCopyString("./");
              }

//              WB_ERROR_PRINT("TEMPORARY %s ---> dir=\"%s\" path=\"%s\" \n", __FUNCTION__, pUserData->szPathName, pPath);

              if(pUserData->szPathName && pPath)
              {
                WBCatString(&(pUserData->szPathName), pPath);
              }

              // check for '/../' within path - if present, canonicalize it
              if(pUserData->szPathName &&
                 (strstr(pUserData->szPathName, "/../") ||
                  (strlen(pUserData->szPathName) > 3 &&
                   (!memcmp(pUserData->szPathName, "../", 3) ||
                    !memcmp(pUserData->szPathName + strlen(pUserData->szPathName) - 3, "/..", 3)))))
              {
                p1 = WBGetCanonicalPath(pUserData->szPathName);
                if(p1)
                {
                  WBFree(pUserData->szPathName);
                  pUserData->szPathName = p1;
                }
                else
                {
                  WB_ERROR_PRINT("ERROR - %s - Unable to get canonical path for \"%s\"\n", __FUNCTION__, pUserData->szPathName);
                }
              }
            }

            if(pUserData->szPathName && *pUserData->szPathName &&
               (pUserData->szPathName[strlen(pUserData->szPathName) - 1] == '/' || WBIsDirectory(pUserData->szPathName)))
            {
              // if it ends in a '/' it's supposed to be a DIRECTORY and I must change to it
              p1 = WBCopyString(pUserData->szPathName);
              if(p1 && (!*p1 || p1[strlen(p1) - 1] != '/'))
              {
                WBCatString(&p1, "/");  // make sure it ends in '/'
              }

              if(!p1)
              {
                WB_ERROR_PRINT("%s - no memory to copy path string (b)\n", __FUNCTION__);
              }
              else
              {
                // TODO:  do I do a chdir() ?

                DLGSetControlProperty(pDlg, FILE_DIALOG_FILE_LIST_CONTROL,
                                      aDLGC_PATH, p1);

//                WB_ERROR_PRINT("TEMPORARY %s ---> new path=\"%s\"\n", __FUNCTION__, p1);

                // also I want to make sure that the file name control contains the new path
                DLGSetControlCaption(pDlg, FILE_DIALOG_FILE_NAME_CONTROL, p1);

                WBFree(p1);
              }

              return 1; // handled (do not close the dialog box)
            }
          }

          WBEndModal(wID, pEvent->xclient.data.l[1]);
          return 1; // handled!
        }
        break;

      case FILE_DIALOG_FILE_LIST_CONTROL:
        if(pEvent->xclient.data.l[0] == aLIST_NOTIFY) // list control notifications
        {
          if(pEvent->xclient.data.l[2] == WB_LIST_SELCHANGE)
          {
            // assign the textbox value to the selected text
            if(pEvent->xclient.data.l[3] >= 0)
            {
              WBDialogControl *pCtrl = DLGGetDialogControlStructFromID(pDlg, pEvent->xclient.data.l[1]);
              if(pCtrl)
              {
                const char *pText = DLGGetControlListText(pCtrl, pEvent->xclient.data.l[3]);

                if(pText)
                {
//                  WB_WARN_PRINT("%s - assigning control text \"%s\"\n", __FUNCTION__, pText);
                  if(*pText == '@')
                  {
                    char *p1 = WBCopyString(pText + 1);

                    if(p1)
                    {
                      WBCatString(&p1, "/");
                      if(p1)
                      {
                        DLGSetControlCaption(pDlg, FILE_DIALOG_FILE_NAME_CONTROL, p1);
                        WBFree(p1);
                      }
                    }
                  }
                  else // assume '~'
                  {
                    DLGSetControlCaption(pDlg, FILE_DIALOG_FILE_NAME_CONTROL, pText + 1);
                  }
                }
              }
            }

            return 1; // handled
          }
          else if(pEvent->xclient.data.l[2] == WB_LIST_DBLCLICK)
          {
            // NOTE:  pEvent->xclient.data.l[3] contains the selection index

            // Rather than allowing the default handler to deal with it, post an 'OK' button notification
            // so that the same code deals with THIS as with the OK button

//            XClientMessageEvent evt = {
//                                        .type=ClientMessage,
//                                        .serial=0,
//                                        .send_event=0,
//                                        .display=pDisplay,
//                                        .window=wID,
//                                        .message_type=aCONTROL_NOTIFY,
//                                        .format=32
//                                      };
//            evt.data.l[0] = aBUTTON_PRESS;
//            evt.data.l[1] = IDOK;
//            evt.data.l[2] = 0;
//            evt.data.l[3] = 0;
//            evt.data.l[4] = 0;
//
//            WBPostPriorityEvent(wID, (XEvent *)&evt);

            // build a 'click' notification event to make sure I capture the correct name
            DLGNotifyDlg(pDlg, aCONTROL_NOTIFY, aLIST_NOTIFY, FILE_DIALOG_FILE_LIST_CONTROL,
                         WB_LIST_SELCHANGE, pEvent->xclient.data.l[3], 0); // duplicates a 'SEL CHANGE" event

            {
#ifndef NO_DEBUG
              char *p1 = WBGetAtomName(WBGetWindowDisplay(wID), (Atom)pEvent->xclient.data.l[0]);
              WB_WARN_PRINT("%s - LIST_NOTIFY WB_LIST_DBLCLICK control notification message %ld (%s)  %ld (%08lxH), %ld (%08lxH)\n",
                            __FUNCTION__, pEvent->xclient.data.l[0],  p1,
                            pEvent->xclient.data.l[1], pEvent->xclient.data.l[1],
                            pEvent->xclient.data.l[2], pEvent->xclient.data.l[2]);
              if(p1)
              {
                WBFree(p1);
              }
#endif // NO_DEBUG
            }

            DLGNotifyDlgAsync(pDlg, aCONTROL_NOTIFY, aBUTTON_PRESS, IDOK, 0, 0, 0); // post a button press event

            return 1;
          }

          return 0; // not handled
        }
        break;

      default:
        {
#ifndef NO_DEBUG
          char *p1 = WBGetAtomName(WBGetWindowDisplay(wID), (Atom)pEvent->xclient.data.l[0]);

          WB_WARN_PRINT("%s - TODO:  control notification message %ld (%s)  %ld (%08lxH), %ld (%08lxH)\n",
                        __FUNCTION__, pEvent->xclient.data.l[0], p1,
                        pEvent->xclient.data.l[1], pEvent->xclient.data.l[1],
                        pEvent->xclient.data.l[2], pEvent->xclient.data.l[2]);

          if(p1)
          {
            WBFree(p1);
          }
#endif // NO_DEBUG
        }
    }
  }
  else if(pEvent->xclient.message_type == aGOTFOCUS)
  {
    return 0; // for now
  }
  else if(pEvent->xclient.message_type == aLOSTFOCUS)
  {
    return 0; // for now
  }
  else
  {
#ifndef NO_DEBUG
    char *p1 = WBGetAtomName(WBGetWindowDisplay(wID), (Atom)pEvent->xclient.message_type);
    char *p2 = WBGetAtomName(WBGetWindowDisplay(wID), (Atom)pEvent->xclient.data.l[0]);

    WB_WARN_PRINT("%s - unhandled notification %s %ld (%s)  %ld (%08lxH), %ld (%08lxH)\n",
                  __FUNCTION__, p1,
                  pEvent->xclient.data.l[0], p2,
                  pEvent->xclient.data.l[1], pEvent->xclient.data.l[1],
                  pEvent->xclient.data.l[2], pEvent->xclient.data.l[2]);

    if(p1)
    {
      WBFree(p1);
    }
    if(p2)
    {
      WBFree(p2);
    }
#endif // NO_DEBUG
  }

  return 0;
}

char *DLGFileDialog(int iType, Window wIDOwner, const char *szDefPath, const char *szDefName,
                    const char *szExtAndDescList)
{
static const char szFileDialogRes[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:250 WIDTH:260 TITLE:\"File Dialog\"\n"
  "  CONTROL:PathTree ID:1000 X:2 Y:2 HEIGHT:200 WIDTH:116 VISIBLE\n"
  "  CONTROL:FileList ID:1001 X:122 Y:2 HEIGHT:200 WIDTH:136 VISIBLE\n"
  "  CONTROL:Edit ID:1002 X:2 Y:206 WIDTH:296 HEIGHT:16 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDOK TITLE:OK X:40 Y:230 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:CancelButton ID:IDCANCEL TITLE:Cancel X:180 Y:230 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
WBDialogWindow *pDlg;
struct _FILE_DIALOG_ data;
int iRval;
Window wIDDlg;


  data.szDefPath = szDefPath;
  data.szDefName = szDefName;
  data.szExtAndDescList = szExtAndDescList;
  data.szPathName = NULL;

  pDlg = DLGCreateDialogWindow("File Select",szFileDialogRes,
                               100,100,300,100,FileDialogCallback,
                               WBDialogWindow_VISIBLE,&data);

  if(pDlg) // TODO:  manage this stuff as part of 'DLGCreateDialogWindow' instead
  {
    wIDDlg = pDlg->wID;

    if(wIDOwner != None)
    {
      Atom a1;
      unsigned int ai1[3];

      DLGAssignOwner(pDlg, wIDOwner);

      a1 = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE", False);
      ai1[0] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_TASKBAR", False);
      ai1[1] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_PAGER", False);

      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_ATOM, 32, PropModeReplace, (unsigned char *)ai1, 2);

      a1 = XInternAtom(WBGetWindowDisplay(wIDDlg), "WM_TRANSIENT_FOR", False);
      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_WINDOW, 32, PropModeReplace, (unsigned char *)&wIDOwner, 1);
    }

    iRval = WBShowModal(pDlg->wID, 0);

    if(iRval == IDOK)
    {
      if(data.szPathName)
      {
        return data.szPathName;
      }
      else
      {
        return NULL;  // for now, to prevent page fault
      }
    }
  }

  // it ends up here on 'cancel', etc. - so if a buffer was allocated, free it

  if(data.szPathName)
  {
    WBFree(data.szPathName);
  }

  return NULL;
}

// construct a splash screen based on the size of the pixmap and position
// the copyright text in the lower 1/3 of the splash screen, centered, then
// pass a 'diagonal flash' across it, and close the screen after a total of
// 5 seconds, returning back to the application.

typedef struct _SPLASH_
{
  Pixmap pixmap, pixmap2;
  char *szCopyright;
  int iW, iH; // width/height of bitmap
  int iDepth; // depth, needed to create compatible pixmaps
  int nIter; // total # of iterations thus far
  XFontSet fontSet;//Struct *pFont;
  int nGleam;      // current gleam center position
  WB_GEOM geomBorder;
  XStandardColormap cmap;
  XImage *pImage;
  void *pImageData;
  unsigned long cbImageData;
  unsigned long clrText, clrBlack, clrWhite; // pixel colors
} SPLASH;

static int splash_callback(Window wID, XEvent *pEvent);
static int SplashDoExposeEvent(XExposeEvent *pEvent, Display *pDisplay,
                               Window wID, struct _SPLASH_ *pData);

#define SPLASH_FRAMERATE 30 /* make this configurable? */
#define SPLASH_TIME 1500 /* milliseconds */

void DLGSplashScreen(char *aXPM[], const char *szCopyright, unsigned long clrText)
{
Window wID;//, wIDTemp;
XSetWindowAttributes xswa;  /* Temporary Set Window Attribute struct */
int iX, iY, iW, iH;
XSizeHints  xsh;            /* Size hints for window manager */
XWMHints xwmh;
XPM_ATTRIBUTES xattr;
SPLASH data;
Atom a1;
unsigned int ai1[3];


  bzero(&data, sizeof(data));
  bzero(&xattr, sizeof(xattr));

  if(XPM_CREATE_PIXMAP_FROM_DATA(WBGetDefaultDisplay(), WBGetHiddenHelperWindow(),
                                 aXPM, &(data.pixmap), &(data.pixmap2), &xattr))
  {
    WB_ERROR_PRINT("XPM_CREATE_PIXMAP_FROM_DATA ERROR\n");
    return;
  }

  iW = xattr.width + 4;  // border width is 2
  iH = xattr.height + 4; // border width is 2
  data.iDepth = xattr.depth;
  if(!data.iDepth)
  {
    data.iDepth = DefaultDepth(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));
  }

  if(!iW || !iH || data.pixmap == None)
  {
    WB_ERROR_PRINT("%s - iW=%d, iH=%d, data.pixmap=%d (%08xH)\n",
                   __FUNCTION__, iW, iH, (int)data.pixmap, (int)data.pixmap);
    return;
  }

//  WB_ERROR_PRINT("TEMPORARY %s - iW=%d, iH=%d, data.pixmap=%d (%08xH)\n",
//                 __FUNCTION__, iW, iH, (int)data.pixmap, (int)data.pixmap);

  // TODO:  choose font, calculate bounds of text area
  //        save font/bounds data and/or combine text into pixmap with transparent background


  iX = DisplayWidth(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));
  iY = DisplayHeight(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));

  iX = (iX - iW) / 2;
  iY = (iY - iH) / 2; // centered

  data.szCopyright = WBCopyString(szCopyright);
  data.clrText = clrText;
  data.clrBlack = BlackPixel(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));
  data.clrWhite = WhitePixel(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));
  data.iW = xattr.width;
  data.iH = xattr.height;
  data.fontSet = None;  // must do this
  data.nGleam = 0;
  data.pImage = NULL;
  data.pImageData = NULL;
  data.cbImageData = 0;

  bzero(&xswa, sizeof(xswa));

  xswa.border_pixel = data.clrBlack;
  xswa.background_pixel = data.clrWhite;
  xswa.colormap = DefaultColormap(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));
  xswa.bit_gravity = CenterGravity;

  wID = WBCreateWindow(WBGetDefaultDisplay(), None,//DefaultRootWindow(WBGetDefaultDisplay()),
                       splash_callback, "Splash",
                       iX, iY, iW, iH, 0,
                       InputOutput,
                       CWBorderPixel | CWBackPixel | CWColormap | CWBitGravity | CWOverrideRedirect,
                       &xswa);

  if(wID <= 0)
  {
    return;
  }

  WBSetWindowData(wID, 0, (void *)&data);
  WBCreateWindowDefaultGC(wID, clrText, xswa.background_pixel);

  bzero(&xsh, sizeof(xsh));

  xsh.flags = (USPosition | USSize | PBaseSize | PMinSize | PMaxSize | PWinGravity);
  xsh.x = iX;
  xsh.y = iY;
  xsh.width = xsh.base_width = xsh.min_width = xsh.max_width = iW;
  xsh.height = xsh.base_height = xsh.min_height = xsh.max_height = iH;
  xsh.win_gravity = NorthWestGravity; // StaticGravity

  bzero(&xwmh, sizeof(xwmh));
  xwmh.flags = InputHint;
  xwmh.input = 0;  // never take focus

  // set title, size hints, and 'WM_HINTS' hints (so WM knows where to put the window and how to set focus)
  WBSetWMProperties(wID, "splashwindow", &xsh, &xwmh, NULL);

  // before mapping the window, set some properties
  a1 = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_WINDOW_TYPE", False);
  ai1[0] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_WINDOW_TYPE_SPLASH", False);
  XChangeProperty(WBGetDefaultDisplay(), wID, a1, XA_ATOM, 32, PropModeReplace, (unsigned char *)ai1, 1);


  a1 = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE", False);
  ai1[0] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_MODAL", False);
  ai1[1] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_TASKBAR", False);
  ai1[2] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_PAGER", False);
  XChangeProperty(WBGetDefaultDisplay(), wID, a1, XA_ATOM, 32, PropModeReplace, (unsigned char *)ai1, 3);

  // must EXPLICITLY allow PAINTING (and other stuff) i.e. ExposureMask
  XSelectInput(WBGetDefaultDisplay(), wID, WB_STANDARD_INPUT_MASK);

  WBDefaultStandardColormap(WBGetDefaultDisplay(), &data.cmap);

  if(CreateTimer(WBGetDefaultDisplay(), wID, 1000000 / SPLASH_FRAMERATE, 1, 1)) // periodic timer at 'frame rate'
  {
    WBDestroyWindow(wID);
  }
  else
  {
    WBMapWindow(WBGetDefaultDisplay(), wID);  // make window visible

    WBShowModal(wID, -1); // timer will cause window to go away automatically
  }

  if(data.szCopyright)
  {
    WBFree((void *)data.szCopyright);
  }

  if(data.pImageData)
  {
    WBFree(data.pImageData);
  }

  BEGIN_XCALL_DEBUG_WRAPPER
  if(data.pImage)
  {
    XDestroyImage(data.pImage);
  }

  if(data.pixmap != None)
  {
    XFreePixmap(WBGetDefaultDisplay(), data.pixmap);
    data.pixmap = None;
  }

  if(data.pixmap2 != None)
  {
    XFreePixmap(WBGetDefaultDisplay(), data.pixmap2);
    data.pixmap2 = None;
  }

  if(data.fontSet)
  {
    XFreeFontSet(WBGetDefaultDisplay(), data.fontSet);
  }
  END_XCALL_DEBUG_WRAPPER
}

static int splash_callback(Window wID, XEvent *pEvent)
{
Display *pDisplay = WBGetWindowDisplay(wID);
struct _SPLASH_ *pData = (struct _SPLASH_ *)WBGetWindowData(wID, 0);


  if(pData && pEvent->type == Expose)
  {
    return SplashDoExposeEvent((XExposeEvent *)pEvent, pDisplay, wID, pData);
  }

  if(pEvent->type == ClientMessage &&
     pEvent->xclient.message_type == aWM_TIMER)
  {
    if(!pData)
    {
      DeleteTimer(WBGetDefaultDisplay(), wID, 1);
      WBUnmapWindow(WBGetDefaultDisplay(), wID);
      WBDestroyWindow(wID);
      return 1;
    }

    pData->nIter ++;

    if(pData->nIter * 1000 >= SPLASH_FRAMERATE * (SPLASH_TIME + 1000))
    {
      DeleteTimer(WBGetDefaultDisplay(), wID, 1);
      WBSetWindowData(wID, 0, NULL);
      WBDestroyWindow(wID);
    }
    else
    {
      WBInvalidateGeom(wID, NULL, 1);
    }

    return 1;
  }

  // special handling for 'destroy'
  if(pEvent->type == DestroyNotify &&
     pEvent->xdestroywindow.window == wID)
  {
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                   "%s - DestroyNotify\n", __FUNCTION__);

    WBSetWindowData(wID, 0, NULL);

    return 1;
  }

  return 0;  // not handled
}

static int SplashDoExposeEvent(XExposeEvent *pEvent, Display *pDisplay,
                               Window wID, struct _SPLASH_ *pData)
{
XFontSet fontSet;
GC gc;
Pixmap pxTemp;
XGCValues xgcv;
WB_GEOM geomText;
int iX, iY, iTimeStart, iTimeEnd;


  if(!pDisplay)
  {
    pDisplay = WBGetDefaultDisplay();
  }

//  gc = WBBeginPaint(wID, pEvent, &geomPaint);  // gnome b0rks this - window has absolute coordinates!

  if(pData->fontSet == None && pData->szCopyright && *(pData->szCopyright))
  {
    fontSet = DTCalcIdealFontSet(WBGetDefaultDisplay(), WBGetDefaultFontSet(WBGetDefaultDisplay()),
                                 pData->szCopyright, &geomText);

    if(fontSet == None)
    {
      fontSet = WBFontSetFromFont(WBGetDefaultDisplay(), WBGetDefaultFont()); // makes a copy of the font set, basically
    }

    pData->fontSet = fontSet;
  }

  fontSet = pData->fontSet; // cache it for later


  bzero(&xgcv, sizeof(xgcv));
//  if(pFont)
//  {
//    xgcv.font = pData->pFont->fid;
//    xgcv.fill_style = FillSolid;
//  }
  xgcv.foreground = pData->clrText;
  xgcv.background = pData->clrWhite;
  xgcv.line_width = 1;
  xgcv.function = GXcopy; // copy
  xgcv.cap_style = CapProjecting;

  gc = XCreateGC(pDisplay, wID,
                 (/*(xgcv.font ? GCFont | GCFillStyle : 0) | */GCForeground | GCBackground | GCCapStyle | GCFunction | GCLineWidth),
                 &xgcv);

  if(!gc)
  {
    WB_WARN_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);
    return 0;
  }

  // now we get to create a window-compatible pixmap compatible with the window size
  // NOTE:  XListDepths and XDefaultDepth may be needed to convert pixmaps to something that's compatible

  WBGetWindowGeom(wID, &(pData->geomBorder));
  pData->geomBorder.x = pData->geomBorder.y = 0; // force this (for now, gnome has absolute coordinates for splash window!)

// not currently being used - later if I need it, uncomment - gcc in linux barphs on unused assigned vars
//  xrct.x = pData->geomBorder.x;
//  xrct.y = pData->geomBorder.y;
//  xrct.width = pData->geomBorder.width;
//  xrct.height = pData->geomBorder.height;


  if(pData->pixmap2 != None) // first part was already done
  {
    pxTemp = pData->pixmap2;
  }
  else
  {
    pxTemp = XCreatePixmap(pDisplay, wID, pData->iW + 4, pData->iH + 4,
                           DefaultDepth(pDisplay, DefaultScreen(pDisplay)));

    if(pxTemp == None)
    {
      WB_ERROR_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);
      XFreeGC(pDisplay, gc);
      return 0;
    }

    if(pData->pixmap != None)  // just in case
    {
      XCopyArea(pDisplay, pData->pixmap, pxTemp, gc,
                0, 0, pData->iW, pData->iH,
                pData->geomBorder.x + 2, pData->geomBorder.y + 2);
    }
    else
    {
      // TODO: erase the background of the drawable, WBEraseBackground maybe?
    }

    // this fixes the border areas properly

    xgcv.line_width = 3;
    xgcv.function = GXcopy; // copy
    xgcv.cap_style = CapProjecting;

    XChangeGC(pDisplay, gc, GCCapStyle | GCFunction | GCLineWidth, &xgcv);

    XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, 0,0, pData->iW + 3, 0);
    XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, pData->iW + 3, 0, pData->iW + 3, pData->iH + 3);
    XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, pData->iW + 3, pData->iH + 3, 0, pData->iH + 3);
    XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, 0, pData->iH + 3, 0, 0);

    pData->pixmap2 = pxTemp; // temporarily cache it here (I'll juggle it after allocating 2nd pixmap)

    // next, I must create a *new* temporary pixmap as my 'working' pixmap.  the previous one is the 'reference' pixmap

    pxTemp = XCreatePixmap(pDisplay, wID, pData->iW + 4, pData->iH + 4,
                           DefaultDepth(pDisplay, DefaultScreen(pDisplay)));

    if(pxTemp == None)
    {
      WB_ERROR_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);

      XFreePixmap(WBGetDefaultDisplay(), pData->pixmap2); // restartability
      pData->pixmap2 = None;

      XFreeGC(pDisplay, gc);
      return 0;
    }

    if(pData->pixmap != None)  // just in case, test for it
    {
      XFreePixmap(WBGetDefaultDisplay(), pData->pixmap);
    }    

    pData->pixmap = pData->pixmap2; // NOW, ref pixmap (with image and border) goes into 'pixmap'
    pData->pixmap2 = pxTemp;        // and the 'working' copy into 'pixmap2' (which is also 'pxTemp')

    // make an exact duplicate without any clipping regions
    XCopyArea(pDisplay, pData->pixmap, pxTemp, gc,
              0, 0, pData->iW + 4, pData->iH + 4, 0, 0);  // make a good copy of it at least once
  }

  if(pData->nIter <= 1)
  {
//    WBClearWindow(wID, gc);  GC doesn't have a clip region yet, don't do this
    XClearWindow(pDisplay, wID);  // erase background
  }
  else if(pData->nIter == SPLASH_FRAMERATE / 2) // after first half second
  {
    geomText.x = pData->geomBorder.x + 2;
    geomText.y = pData->geomBorder.y + 2;
    geomText.width = pData->geomBorder.width - 4;
    geomText.height = pData->geomBorder.height - 4;

    geomText.y += (geomText.height * 2) / 3;
    geomText.height -= (geomText.height * 2) / 3; // bottom 1/3

    // copyright string is 1 or 2 lines, for now use whatever font I end up with and draw lines separately

    if(fontSet != None)
    {
      WB_RECT rctBounds;
      rctBounds.left = geomText.x;
      rctBounds.top = geomText.y;
      rctBounds.right = rctBounds.left + geomText.width;
      rctBounds.bottom = rctBounds.top + geomText.height;

      DTDrawMultiLineText(fontSet, pData->szCopyright, pDisplay, gc, pData->pixmap,
                          -8, 0, &rctBounds, DTAlignment_VCENTER | DTAlignment_HCENTER);
#if 0
      p1 = pData->szCopyright;
      p2 = strchr(p1, '\n');

      if(p2)
      {
        *(p2++) = 0;
      }

      if(!p2 || !*p2)
      {
        iX = geomText.x + (geomText.width - XTextWidth(pFont, p1, strlen(p1))) / 2;
        iY = geomText.y + (geomText.height - pFont->max_bounds.ascent + pFont->max_bounds.descent) / 2
           + pFont->max_bounds.ascent; // bottom of text

        XDrawString(pDisplay, pxTemp ? pxTemp : wID, gc, iX, iY, p1, strlen(p1));
      }
      else
      {
        iX = geomText.x + (geomText.width - XTextWidth(pFont, p1, strlen(p1))) / 2;
        iY = geomText.y + (geomText.height - 2 * (pFont->max_bounds.ascent + pFont->max_bounds.descent)) / 2
           + pFont->max_bounds.ascent; // bottom of text

        XDrawString(pDisplay, pxTemp ? pxTemp : wID, gc, iX, iY, p1, strlen(p1));

        iX = geomText.x + (geomText.width - XTextWidth(pFont, p2, strlen(p2))) / 2;
        iY += pFont->max_bounds.ascent + pFont->max_bounds.descent;

        XDrawString(pDisplay, pxTemp ? pxTemp : wID, gc, iX, iY, p2, strlen(p2));
      }

      if(p2)
      {
        *(p2 - 1) = '\n'; // restore it for next time
      }
#endif // 0
    }
    else
    {
      fprintf(stderr, "NO FONT, iter=%d\n", pData->nIter);
    }

    // make an exact duplicate without any clipping regions

    XCopyArea(pDisplay, pData->pixmap, pxTemp, gc,
              0, 0, pData->iW + 4, pData->iH + 4, 0, 0);

    // now, grab an XImage for it

    pData->pImage = XGetImage(pDisplay, pxTemp, 0, 0, pData->iW + 4, pData->iH + 4,
                              0xffffffff, XYPixmap);
  }

  // TODO:  consider creating clip regions to improve performance

  if(pData->nIter >= SPLASH_FRAMERATE / 2) // after first half second
  {
    iTimeStart = 1250 * SPLASH_FRAMERATE;                     // 1.5 seconds' worth in msecs, not seconds
    iTimeEnd = (SPLASH_TIME + 1000) * SPLASH_FRAMERATE
             - 500 * SPLASH_FRAMERATE;                        // 1/2 sec before end

    if(iTimeStart + 1000 * SPLASH_FRAMERATE / 2 > iTimeEnd)
    {
      iTimeStart = iTimeEnd - SPLASH_FRAMERATE / 2;
    }

    // drawing the 'gleam' diagonally from upper left to lower right
    // TODO:  make this optional?

    if(pData->nIter * 1000 > iTimeEnd)
    {
      if(pData->pImage)
      {
        XPutImage(pDisplay, pData->pixmap2, gc, pData->pImage, 0, 0, 0, 0, pData->iW + 4, pData->iH + 4);

        XDestroyImage(pData->pImage); // destroy it now that I'm done with it
        pData->pImage = NULL;         // no longer stored (already cleaned up)
      }
    }
    else if(pData->nIter * 1000 >= iTimeStart && pData->nIter * 1000 <= iTimeEnd)
    {
      int iDelta = iTimeEnd - iTimeStart + 1;
      int iTemp;
      XImage *pI; // the image I'll be manipulating

      iTemp = pData->nIter * 1000L - iTimeStart;
      iTemp = (int)(((long long)iTemp * (long long)iTemp) / (iTimeEnd - iTimeStart));

      // get the starting points and end points
      iX = 2 * (pData->iW * iTemp / iDelta + pData->iW / (2 * iDelta) / 1000); // x pos of top
      iY = 2 * (pData->iH * iTemp / iDelta + pData->iH / (2 * iDelta) / 1000); // y pos of left

      // will draw the line from 0,iY to iX,0

      if(!pData->pImage)
      {
        pData->pImage = XGetImage(pDisplay, pData->pixmap2, 0, 0, pData->iW + 4, pData->iH + 4,
                                  0xffffffff, // I've tried 0, 1, and THIS value - no apparent difference
                                  XYPixmap); // TODO:  use ZPixmap instead?
      }

      pI = pData->pImage;

      if(pI && !pData->pImageData)
      {
        // this formula can be found in the xorg-server source:
        // length = ximage->bytes_per_line * ximage->height;
        // this is from 'xnestGetImage' in hw/xnest/GCOps.c
        // note that they don't include 'depth' in that.  when I exclude 'depth', it doesn't work
        // TODO:  do I need to pay attention to PADDING?  docs and source suggest 'no'

//        WB_ERROR_PRINT("TEMPORARY:  %s - bytes_per_line=%d, height=%d, depth=%d\n", __FUNCTION__,
//                       pI->bytes_per_line, pI->height, pI->depth);
        
        pData->cbImageData = PXM_GetImageDataLength(pI);
        pData->pImageData = WBAlloc(pData->cbImageData + 4);

        if(pData->pImageData)
        {
          memcpy(pData->pImageData, PXM_GetImageDataPtr(pI), pData->cbImageData);
        }
      }

      if(!pI)
      {
        // don't do anything
      }
      else
      {
#if defined(GLEAM_OLD)
#define GLEAM_WIDTH 10
        static int aLuma[GLEAM_WIDTH + 1] = { 255, 249, 231, 202, 167, 128, 88, 53, 24, 6, 0  }; // 'luma' values for "the gleam" based on offset from center
#elif defined(GLEAM_NARROW)
#define GLEAM_WIDTH 17
        static int aLuma[GLEAM_WIDTH + 1] = { 255, 202, 161, 128, 101, 80, 64, 51, 40,
                                              32, 25, 20, 16, 13, 10, 8, 6, 5  }; // similar but 1/r^2 version (no cos)
#else // WIDE gleam
#define GLEAM_WIDTH 29
        static int aLuma[GLEAM_WIDTH + 1] = { 255,225,198,175,154,136,120,106,93,82,72,64,
                                              56,50,44,39,34,30,26,23,21,18,16,14,12,11,10,8,7,7 }; // a bit wider, more obvious
#endif // GLEAM_OLD, GLEAM_NARROW

        int iX0, iY0, iX1, i1, i2, iW, iL, iMaxX, iMaxY;

        // NOW I get the fun of directly manipulating my image.  W00T!

        // effectively I do this:  XDrawLine(pDisplay, pxTemp, gc, -2, iY, iX, -2) and it's 19 pixels wide
        
        // So the line has a width of '2*GLEAM_WIDTH + 1' pixels.  The pixels represent a white reflection
        // centering at the coordinates I specified above, that is the line from -2, iY to iX, -2 .  This
        // actually SHOULD be offset by 2 pixels so that it does not affect the border, but that's less iomportant

        // draw the line.  19 pixels wide is actually +/- 9.  We start with a single pixel-width line, then
        // do a for loop from/to +/- GLEAM_WIDTH on the X axis, keeping Y constant.  if Y did not change, skip it.

        iMaxX = pData->iW;
        iMaxY = pData->iH;

        for(iX0 = -GLEAM_WIDTH, iY0 = iY + GLEAM_WIDTH; iX0 < iMaxX + GLEAM_WIDTH && iY0 > -GLEAM_WIDTH; iX0++)
        {
          i1 = (int)(((iX - iX0) * (long long)iMaxY) / iMaxX); // a muldiv conversion (where I should be)

          if(iY0 > i1) // so I don't repeat what I've done
          {
            for(; iY0 > i1; iY0--) // remember, top < bottom so if I start at the bottom, must SUBTRACT
            {
              // +/- GLEAM_WIDTH pixels
              i2 = iX0 + GLEAM_WIDTH;
              for(iX1=iX0 - GLEAM_WIDTH, iW = -GLEAM_WIDTH; iX1 <= i2; iX1++, iW++)
              {
                // is my current iX1, iY0 inside the desired rectangle?  If so, calculate the
                // new color and assign it to this point.

                if(iX1 > 2 && iX1 < iMaxX &&
                   iY0 > 2 && iY0 < iMaxY)
                {
                  XColor clrTemp, clrPixel;
                  int iY, iU, iV, iR, iG, iB;

                  clrPixel.pixel = XGetPixel(pI, iX1 + 2, iY0 + 2);
                  PXM_PixelToRGB(&(pData->cmap), &clrPixel);

                  PXM_RGBToYUV(clrPixel.red >> 8, clrPixel.green >> 8, clrPixel.blue >> 8,
                               &iY, &iU, &iV);

                  iL = aLuma[abs(iW)]; // the 'Luma' constant, 0-255 (with 255 = 'white')

                  // new pixel luma will be:  luma * (1 + iL / 128) (maxed at 255)
                  // if new luma is > 255, reduce iU and iV (delta from 128) by the 'factor'
                  // such that iU = 128 + (iU - 128) * factor [etc.]
                  // and the 'factor' would be 255 / iU (the new value)

                  iY = ((short)iY * ((short)256 + (short)iL)) / (short)256; // >> 6;/// (short)128;

                  if(iY > 255)
                  {
                    iU = (short)128 + (((short)iU - (short)128) * (short)256) / (short)iY;
                    iV = (short)128 + (((short)iV - (short)128) * (short)256) / (short)iY;
                    iY = 255;
                  }

                  PXM_YUVToRGB(iY, iU, iV, &iR, &iG, &iB);

                  clrTemp.red   = iR << 8;
                  clrTemp.green = iG << 8;
                  clrTemp.blue  = iB << 8;
                  clrTemp.flags = DoRed | DoGreen | DoBlue;

                  PXM_RGBToPixel(&(pData->cmap), &clrTemp);

                  XPutPixel(pI, iX1 + 2, iY0 + 2, clrTemp.pixel);
                }
              }            
            }
          }
        }        

        // TODO:  assign clipping region to gc

//        llTick -= WBGetTimeIndex();

        XPutImage(pDisplay, pData->pixmap2, gc, pI, 0, 0, 0, 0, pData->iW + 4, pData->iH + 4);
        XFlush(pDisplay); // make sure

//        llTick += WBGetTimeIndex();

        if(pData->pImageData)
        {
          // restore previous image data now that I'm done messing with it
          memcpy(PXM_GetImageDataPtr(pI), pData->pImageData, pData->cbImageData); // restore previous image data
        }
        else
        {
          XDestroyImage(pI);
          pData->pImage = NULL; // no longer stored (a fallback)
        }

//        WB_ERROR_PRINT("TEMPORARY:  %s - pixel stuff takes %llu millis\n", __FUNCTION__, llTick);
      }

#if 0
      // using some interesting raster ops, 'highlight' the pixels along the line of
      // (0,iY),(iX,0) or (iX,pData->iH-1),(pData->iW-1,iY)

      XSetForeground(pDisplay, gc, pData->clrWhite & 0x404040);

      xgcv.line_width = 19;
      xgcv.function = GXor; // a or b
      xgcv.cap_style = CapProjecting;

      XChangeGC(pDisplay, gc, GCCapStyle | GCFunction | GCLineWidth, &xgcv);

      if(!bInvert)
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, -2, iY, iX, -2);
      }
      else
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, iX, pData->iH + 4, pData->iW + 4, iY);
      }

      XSetForeground(pDisplay, gc, pData->clrWhite & 0x808080);

      xgcv.line_width = 11;
      xgcv.function = GXor; // a or b
      xgcv.cap_style = CapProjecting;

      XChangeGC(pDisplay, gc, GCCapStyle | GCFunction | GCLineWidth, &xgcv);

      if(!bInvert)
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, -2, iY, iX, -2);
      }
      else
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, iX, pData->iH + 4, pData->iW + 4, iY);
      }

      XSetForeground(pDisplay, gc, pData->clrWhite & 0xc0c0c0);

      xgcv.line_width = 5;
      xgcv.function = GXor; // a or b
      xgcv.cap_style = CapProjecting;

      XChangeGC(pDisplay, gc, GCCapStyle | GCFunction | GCLineWidth, &xgcv);

      if(!bInvert)
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, -2, iY, iX, -2);
      }
      else
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, iX, pData->iH + 4, pData->iW + 4, iY);
      }

      XSetForeground(pDisplay, gc, pData->clrWhite);

      xgcv.line_width = 1;
      xgcv.function = GXcopy; // copy
      xgcv.cap_style = CapProjecting;

      XChangeGC(pDisplay, gc, GCCapStyle | GCFunction | GCLineWidth, &xgcv);

      if(!bInvert)
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, -2, iY, iX, -2);
      }
      else
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, iX, pData->iH + 4, pData->iW + 4, iY);
      }
#endif // 0
    }
  }

  if(pxTemp) // using the 2nd pixmap to do the work, thus making the whole screen update at once
  {
    XCopyArea(pDisplay, pxTemp, wID, gc, 0, 0, pData->iW + 4, pData->iH + 4, pData->geomBorder.x, pData->geomBorder.y);
  }

  XFreeGC(pDisplay, gc);
  XSync(pDisplay, 0); // force update NOW
  WBValidateGeom(wID, NULL);
//  WBEndPaint(wID, gc);

  return 1;  // processed
}


