/////////////////////////////////////////////////////////////////////////////////////////////
//              _  _         _                     _                    _                  //
//           __| |(_)  __ _ | |  ___    __ _      (_) _ __ ___   _ __  | |    ___          //
//          / _` || | / _` || | / _ \  / _` |     | || '_ ` _ \ | '_ \ | |   / __|         //
//         | (_| || || (_| || || (_) || (_| |     | || | | | | || |_) || | _| (__          //
//          \__,_||_| \__,_||_| \___/  \__, |_____|_||_| |_| |_|| .__/ |_|(_)\___|         //
//                                     |___/|_____|             |_|                        //
//                                                                                         //
//                          implementation of standard modal dialogs                       //
//                                                                                         //
/////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2016 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no waranties, either implied or explicit.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

/** \file dialog_impl.c
  * \brief Dialog box implementation file for standard types of dialog boxes
  *
  * This file implements a number of standard dialog boxes including the
  * 'file open' dialog box, message boxes, input boxes, and the splash screen.
*/


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <signal.h>
#include <time.h>

#ifndef XK_Delete /* moslty for interix */
#define XK_MISCELLANY /* mostly for interix */
#include <X11/keysymdef.h> // some platforms don't automatically include this with X headers
#endif // XK_Delete

#include "window_helper.h"
#include "pixmap_helper.h"  // pixmap helpers, including pre-defined icons
#include "dialog_window.h"
#include "dialog_controls.h"
#include "conf_help.h"
#include "file_help.h"
#include "draw_text.h"


#define THIS_SUBSYSTEM DebugSubSystem_Dialog





///////////////
// MESSAGE BOX
///////////////

struct _MESSAGE_BOX_
{
  int iType;
  const char *szTitle;
  const char *szMessage;
};

static int GetMessageBoxIconPixmapID(int iMBIconMask)
{
  switch(iMBIconMask & MessageBox_ICON_MASK)
  {
    case MessageBox_Error:
      return ID_ICON_STOP;
    case MessageBox_Warning:
      return ID_ICON_WARN;
    case MessageBox_Info:
      return ID_ICON_OK;
    case MessageBox_Asterisk:
      return ID_ICON_SPLAT;
    case MessageBox_Question:
      return ID_ICON_WHAT;
    case MessageBox_BoldQuestion:
      return ID_ICON_WHAT_BOLD;
    case MessageBox_WTF:
      return ID_ICON_WTF;
    case MessageBox_Bang:
      return ID_ICON_BANG;
    case MessageBox_Triangle:
      return ID_ICON_TRIANGLE;
    case MessageBox_FaceOfDeath:
      return ID_ICON_DEATH;
    case MessageBox_JollyRoger:
      return ID_ICON_SKULL;
    case MessageBox_ThumbsUp:
      return ID_ICON_THUMBUP;
    case MessageBox_ThumbsDown:
      return ID_ICON_THUMBDOWN;
    case MessageBox_MiddleFinger:
      return ID_ICON_FINGER;
    case MessageBox_TeddyBear:
      return ID_ICON_BEAR;
    case MessageBox_Barney:
      return ID_ICON_BARNEY;
    case MessageBox_App:
      return ID_ICON_APP;

//    default:
//      pixmap = None;
  }

  return -1;
}

static int MessageBoxCallback(Window wID, XEvent *pEvent)
{
WBDialogWindow *pDlg = DLGGetDialogWindowStruct(wID);
struct _MESSAGE_BOX_ *pUserData = (struct _MESSAGE_BOX_ *)(pDlg ? pDlg->pUserData : NULL);
//#ifndef NODEBUG
//WB_UINT64 ullTime = WBGetTimeIndex();
//#endif // NODEBUG


  if(pEvent->type == ClientMessage && pEvent->xclient.message_type == aDIALOG_INIT)
  {
    if(!pDlg)
    {
      WB_ERROR_PRINT("MessageBoxCallback - no WBDialogWindow structure in DIALOG_INIT for %d (%08xH) %p %08xH %08xH\n",
                     (unsigned int)wID, (unsigned int)wID, WBGetWindowData(wID, 0), DIALOG_WINDOW_TAG, ((WBDialogWindow *)WBGetWindowData(wID, 0))->ulTag);
      return 0; // can't process any messages now
    }
    else
    {
      // assigning the correct icon

      Window wIDIcon = DLGGetDialogControl(pDlg, 1000);  // ID 1000 for icon
      WBDialogControl *pCtrl = DLGGetDialogControlStruct(wIDIcon);

      if(pCtrl)
      {
        Pixmap pixmap2 = None;
        Pixmap pixmap = PXM_GetIconPixmap(GetMessageBoxIconPixmapID(pUserData->iType & MessageBox_ICON_MASK),
                                          NULL, &pixmap2);

        if(pixmap != None)
        {
          WBDialogControlSetIconPixmap(pCtrl, pixmap, pixmap2);
        }
      }
    }

    // assign the caption text to the caption window (which varies and must be assigned at run time)

    DLGSetControlCaption((WBDialogWindow *)pDlg, 1001, pUserData->szMessage);

//    WB_ERROR_PRINT("TEMPORARY:  %s line %d  delta tick %lld\n", __FUNCTION__, __LINE__, (WBGetTimeIndex() - ullTime));

    return 1;
  }

  if(!pDlg)
  {
    WB_WARN_PRINT("MessageBoxCallback - no WBDialogWindow structure\n");
    return 0; // can't process any messages now
  }

  if(pEvent->type == ClientMessage && pEvent->xclient.message_type == aCONTROL_NOTIFY)
  {
    WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Event | DebugSubSystem_Dialog,
                   "%s - MessageBox ClientMessage CONTROL_NOTIFY\n", __FUNCTION__);

    switch(pEvent->xclient.data.l[1]) // control ID
    {
      case IDOK:
      case IDCANCEL:
        if(pEvent->xclient.data.l[0] == aBUTTON_PRESS)
        {
          WBEndModal(wID, pEvent->xclient.data.l[1]);
        }
        break;

      default:
        WB_WARN_PRINT("%s - MessageBox ClientMessage CONTROL_NOTIFY client id=%lx\n",
                      __FUNCTION__, pEvent->xclient.data.l[1]);
    }
  }






  return 0;
}

int DLGMessageBox(int iType, Window wIDOwner, const char *szTitle, const char *szMessage)
{
static const char szOKBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"OK Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDOK TITLE:OK X:80 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szOKCancelBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"OK/Cancel Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDOK TITLE:OK X:40 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:CancelButton ID:IDCANCEL TITLE:Cancel X:120 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szYesNoBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"Yes/No Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDYES TITLE:Yes X:40 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:CancelButton ID:IDNO TITLE:No X:120 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";

struct _MESSAGE_BOX_ mbox;
const char *pRes;
WBDialogWindow *pDlg;
WB_GEOM geomParent;
Window wIDDlg;
int iRval, iX, iY;


// for now I determine the standard message box size THIS way
#define MESSAGE_BOX_WIDTH 400
#define MESSAGE_BOX_HEIGHT 100
#define MESSAGE_BOX_OFFSET 50

  mbox.iType = iType;
  mbox.szTitle = szTitle;
  mbox.szMessage = szMessage;

  bzero(&geomParent, sizeof(geomParent));

  if(wIDOwner != None)
  {
    WBGetWindowGeom0(wIDOwner, &geomParent); // parent geometry in absolute coordinates

    iX = geomParent.x + geomParent.border + MESSAGE_BOX_OFFSET;
    iY = geomParent.y + geomParent.border + MESSAGE_BOX_OFFSET;
  }
  else
  {
    // center in screen with slight random offset (so that every window won't always appear in exactly the same place)
    iY = (DisplayHeight(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()))
          - MESSAGE_BOX_HEIGHT + MESSAGE_BOX_OFFSET - (int)(WBGetTimeIndex() % (2 * MESSAGE_BOX_OFFSET)))
       / 2;

    iX = (DisplayWidth(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()))
          - MESSAGE_BOX_WIDTH + MESSAGE_BOX_OFFSET - (int)((~WBGetTimeIndex()) % (2 * MESSAGE_BOX_OFFSET)))
       / 2;
  }

  switch(iType & MessageBox_BUTTON_MASK)
  {
    case MessageBox_OK:
      pRes = szOKBox;
      break;

    case MessageBox_OK | MessageBox_Cancel:
      pRes = szOKCancelBox;
      break;

    case MessageBox_Yes | MessageBox_No:
      pRes = szYesNoBox;
      break;

    default:
      pRes = szOKBox;  // for now just do this
  }


  pDlg = DLGCreateDialogWindow(szTitle,pRes, iX, iY,
                               MESSAGE_BOX_WIDTH,
                               MESSAGE_BOX_HEIGHT, // TODO:  derive from ???
                               MessageBoxCallback,
                               WBDialogWindow_VISIBLE, &mbox);

  if(pDlg) // TODO:  manage this stuff as part of 'DLGCreateDialogWindow' instead
  {
    wIDDlg = pDlg->wID;

    if(wIDOwner != None)
    {
      Atom a1;
      unsigned int ai1[3];

      DLGAssignOwner(pDlg, wIDOwner);

      a1 = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE", False);
      ai1[0] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_TASKBAR", False);
      ai1[1] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_PAGER", False);

      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_ATOM, 32, PropModeReplace, (unsigned char *)ai1, 2);

      a1 = XInternAtom(WBGetWindowDisplay(wIDDlg), "WM_TRANSIENT_FOR", False);
      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_WINDOW, 32, PropModeReplace, (unsigned char *)&wIDOwner, 1);
    }

    WBSetWindowIcon(wIDDlg, GetMessageBoxIconPixmapID(iType & MessageBox_ICON_MASK));

    iRval = WBShowModal(wIDDlg, 0);

    return iRval;
  }

  return -1;  // by default return -1 on error
}


///////////////
// INPUT BOX
///////////////

struct _INPUT_BOX_
{
  const char *szTitle;
  const char *szMessage;
  char *szRval;
};


static int InputBoxCallback(Window wID, XEvent *pEvent)
{
WBDialogWindow *pDlg = DLGGetDialogWindowStruct(wID);
struct _INPUT_BOX_ *pUserData = (struct _INPUT_BOX_ *)(pDlg ? pDlg->pUserData : NULL);


  if(!pDlg)
    return 0; // can't process any messages now

  if(pEvent->type == ClientMessage && pEvent->xclient.message_type == aDIALOG_INIT)
  {
    // assigning the correct icon
    {
      WBDialogControl *pCtrl = DLGGetDialogControlStructFromID(pDlg, 1000); // ID 1000 for icon

      if(pCtrl)
      {
        Pixmap pixmap2 = None;
        Pixmap pixmap = PXM_GetIconPixmap(ID_ICON_WHAT, NULL, &pixmap2);

        if(pixmap != None)
        {
          WBDialogControlSetIconPixmap(pCtrl, pixmap, pixmap2);
        }
      }
    }

    // assign the caption text to the caption window (which varies and must be assigned at run time)

    DLGSetControlCaption((WBDialogWindow *)pDlg, 1001, pUserData->szMessage);

    if(pUserData->szRval)
    {
      DLGSetControlCaption(pDlg, 1002, pUserData->szRval);
    }

    return 1;
  }

  if(pEvent->type == ClientMessage && pEvent->xclient.message_type == aCONTROL_NOTIFY)
  {
    WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Event | DebugSubSystem_Dialog,
                     "%s - MessageBox ClientMessage CONTROL_NOTIFY\n", __FUNCTION__);

    switch(pEvent->xclient.data.l[1]) // control ID
    {
      case IDOK:
      case IDCANCEL:
        if(pEvent->xclient.data.l[0] == aBUTTON_PRESS)
        {
          const char *pText = DLGGetControlCaption(pDlg, 1002);

          if(pUserData->szRval)
          {
            free(pUserData->szRval);
          }
          if(pText)
          {
            pUserData->szRval = WBCopyString(pText);
          }
          else
          {
            WB_ERROR_PRINT("TEMPORARY: %s - NULL 'pText' for edit control\n", __FUNCTION__);
            pUserData->szRval = NULL; // empty string
          }

          WBEndModal(wID, pEvent->xclient.data.l[1]);
        }
        break;

      case 1002:
        WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Event | DebugSubSystem_Dialog,
                       "%s - INPUT BOX 'EDIT' NOTIFICATION %ld\n",
                       __FUNCTION__, pEvent->xclient.data.l[0]);

        // TODO:  update window text
        break;

      default:
        WB_WARN_PRINT("%s - MessageBox ClientMessage CONTROL_NOTIFY client id=%lx\n",
                      __FUNCTION__, pEvent->xclient.data.l[0]);
    }
  }

  return 0;
}

char *DLGInputBox(Window wIDOwner, const char *szTitle, const char *szPrompt, const char *szDefault,
                  int iWidth, int iMaxChar)
{
static const char szInputDialogRes[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:60 WIDTH:200 TITLE:\"User Input\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE\n"
  "  CONTROL:Edit ID:1002 X:2 Y:22 WIDTH:196 HEIGHT:16 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDOK TITLE:OK X:40 Y:40 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:CancelButton ID:IDCANCEL TITLE:Cancel X:120 Y:40 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
WBDialogWindow *pDlg;
struct _INPUT_BOX_ sRval;
int iRval;
Window wIDDlg;


  sRval.szTitle = szTitle;
  sRval.szMessage = szPrompt;
  if(szDefault && *szDefault)
  {
    sRval.szRval = WBCopyString(szDefault); // a copy of the default value
  }
  else
  {
    sRval.szRval = NULL;
  }

  pDlg = DLGCreateDialogWindow(szTitle,szInputDialogRes,
                               100,100,300,60,InputBoxCallback,
                               WBDialogWindow_VISIBLE,&sRval);

  if(pDlg) // TODO:  manage this stuff as part of 'DLGCreateDialogWindow' instead
  {
    wIDDlg = pDlg->wID;

    if(wIDOwner != None)
    {
      Atom a1;
      unsigned int ai1[3];

      DLGAssignOwner(pDlg, wIDOwner);

      a1 = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE", False);
      ai1[0] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_TASKBAR", False);
      ai1[1] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_PAGER", False);

      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_ATOM, 32, PropModeReplace, (unsigned char *)ai1, 2);

      a1 = XInternAtom(WBGetWindowDisplay(wIDDlg), "WM_TRANSIENT_FOR", False);
      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_WINDOW, 32, PropModeReplace, (unsigned char *)&wIDOwner, 1);
    }

    iRval = WBShowModal(pDlg->wID, 0);

    if(iRval == IDOK)
    {
      return sRval.szRval;
    }
    else if(iRval != IDCANCEL)
    {
      WB_ERROR_PRINT("TEMPORARY - %s - iRval is %d\n", __FUNCTION__, iRval);
    }
  }

  // it ends up here on 'cancel', etc. - so if a buffer was allocated, free it

  if(sRval.szRval)
  {
    free(sRval.szRval);
  }

  return NULL;
}



///////////////
// FILE DIALOG
///////////////

struct _FILE_DIALOG_
{
  const char *szDefPath;
  const char *szDefName;
  const char *szExtAndDescList;
  char *szPathName;  // malloc'd
};


#define FILE_DIALOG_PATH_TREE_CONTROL 1000
#define FILE_DIALOG_FILE_LIST_CONTROL 1001
#define FILE_DIALOG_FILE_NAME_CONTROL 1002

static int FileDialogCallback(Window wID, XEvent *pEvent)
{
WBDialogWindow *pDlg = DLGGetDialogWindowStruct(wID);
struct _FILE_DIALOG_ *pUserData = (struct _FILE_DIALOG_ *)(pDlg ? pDlg->pUserData : NULL);
//Display *pDisplay = WBGetWindowDisplay(wID);
char *p1, *p2;


  if(!pDlg)
    return 0; // can't process any messages now

  if(pEvent->type == ClientMessage && pEvent->xclient.message_type == aDIALOG_INIT)
  {
    if(!pUserData->szPathName || !*(pUserData->szPathName) ||
       (!strchr(pUserData->szPathName, '/') && !WBIsDirectory(pUserData->szPathName)))
    {
      if(!pUserData->szDefPath || !*(pUserData->szDefPath))
      {
        // set the 'DLGC_PATH' property for appropriate controls
        DLGSetControlProperty(pDlg, FILE_DIALOG_FILE_LIST_CONTROL,
                              aDLGC_PATH, ".");  // set path to '.' if not specified already
      }
      else
      {
        DLGSetControlProperty(pDlg, FILE_DIALOG_FILE_LIST_CONTROL,
                              aDLGC_PATH, pUserData->szDefPath);
      }
    }
    else
    {
      p1 = WBCopyString(pUserData->szDefPath);
      if(!p1)
      {
        WB_ERROR_PRINT("%s - no memory to copy path string (a)\n", __FUNCTION__);
      }
      else
      {
        p2 = strrchr(p1, '/');
        if(p2)
        {
          p2[1] = 0;  // keep the '/'
        }

        DLGSetControlProperty(pDlg, FILE_DIALOG_FILE_LIST_CONTROL,
                              aDLGC_PATH, p1);

        free(p1);
      }
    }

    return 1;
  }

  if(pEvent->type != ClientMessage)
  {
    return 0; // unhandled at this time
  }

  // EVERYTHING AT THIS POINT IS A CLIENT MESSAGE

  if(pEvent->xclient.message_type == aCONTROL_NOTIFY)
  {
    // l[0] == message
    // l[1] == control ID
    // l[2] ==
    switch(pEvent->xclient.data.l[1])
    {
      case IDOK:
      case IDCANCEL:
        if(pEvent->xclient.data.l[0] == aBUTTON_PRESS)
        {
          if(pEvent->xclient.data.l[1] == IDOK)
          {
            const char *pPath = DLGGetControlCaption(pDlg, FILE_DIALOG_FILE_NAME_CONTROL);
            const char *pDir = DLGGetControlProperty(pDlg, FILE_DIALOG_FILE_LIST_CONTROL, aDLGC_PATH);

            if(pUserData->szPathName)
            {
              free(pUserData->szPathName);
            }

            if(pPath && pPath[0] == '/')
            {
              pUserData->szPathName = WBCopyString(pPath); // absolute path assignment
            }
            else
            {
              if(pDir && *pDir)
              {
                pUserData->szPathName = WBCopyString(pDir);

                if(pUserData->szPathName && *pUserData->szPathName &&
                   pUserData->szPathName[strlen(pUserData->szPathName) - 1] != '/')
                {
                  WBCatString(&(pUserData->szPathName), "/");
                }
              }
              else
              {
                pUserData->szPathName = WBCopyString("./");
              }

//              WB_ERROR_PRINT("TEMPORARY %s ---> dir=\"%s\" path=\"%s\" \n", __FUNCTION__, pUserData->szPathName, pPath);

              if(pUserData->szPathName && pPath)
              {
                WBCatString(&(pUserData->szPathName), pPath);
              }

              // check for '/../' within path - if present, canonicalize it
              if(pUserData->szPathName &&
                 (strstr(pUserData->szPathName, "/../") ||
                  (strlen(pUserData->szPathName) > 3 &&
                   (!memcmp(pUserData->szPathName, "../", 3) ||
                    !memcmp(pUserData->szPathName + strlen(pUserData->szPathName) - 3, "/..", 3)))))
              {
                p1 = WBGetCanonicalPath(pUserData->szPathName);
                if(p1)
                {
                  free(pUserData->szPathName);
                  pUserData->szPathName = p1;
                }
                else
                {
                  WB_ERROR_PRINT("ERROR - %s - Unable to get canonical path for \"%s\"\n", __FUNCTION__, pUserData->szPathName);
                }
              }
            }

            if(pUserData->szPathName && *pUserData->szPathName &&
               (pUserData->szPathName[strlen(pUserData->szPathName) - 1] == '/' || WBIsDirectory(pUserData->szPathName)))
            {
              // if it ends in a '/' it's supposed to be a DIRECTORY and I must change to it
              p1 = WBCopyString(pUserData->szPathName);
              if(p1 && (!*p1 || p1[strlen(p1) - 1] != '/'))
              {
                WBCatString(&p1, "/");  // make sure it ends in '/'
              }

              if(!p1)
              {
                WB_ERROR_PRINT("%s - no memory to copy path string (b)\n", __FUNCTION__);
              }
              else
              {
                // TODO:  do I do a chdir() ?

                DLGSetControlProperty(pDlg, FILE_DIALOG_FILE_LIST_CONTROL,
                                      aDLGC_PATH, p1);

//                WB_ERROR_PRINT("TEMPORARY %s ---> new path=\"%s\"\n", __FUNCTION__, p1);

                // also I want to make sure that the file name control contains the new path
                DLGSetControlCaption(pDlg, FILE_DIALOG_FILE_NAME_CONTROL, p1);

                free(p1);
              }

              return 1; // handled (do not close the dialog box)
            }
          }

          WBEndModal(wID, pEvent->xclient.data.l[1]);
          return 1; // handled!
        }
        break;

      case FILE_DIALOG_FILE_LIST_CONTROL:
        if(pEvent->xclient.data.l[0] == aLIST_NOTIFY) // list control notifications
        {
          if(pEvent->xclient.data.l[2] == WB_LIST_SELCHANGE)
          {
            // assign the textbox value to the selected text
            if(pEvent->xclient.data.l[3] >= 0)
            {
              WBDialogControl *pCtrl = DLGGetDialogControlStructFromID(pDlg, pEvent->xclient.data.l[1]);
              if(pCtrl)
              {
                const char *pText = DLGGetControlListText(pCtrl, pEvent->xclient.data.l[3]);

                if(pText)
                {
//                  WB_WARN_PRINT("%s - assigning control text \"%s\"\n", __FUNCTION__, pText);
                  if(*pText == '@')
                  {
                    char *p1 = WBCopyString(pText + 1);

                    if(p1)
                    {
                      WBCatString(&p1, "/");
                      if(p1)
                      {
                        DLGSetControlCaption(pDlg, FILE_DIALOG_FILE_NAME_CONTROL, p1);
                        free(p1);
                      }
                    }
                  }
                  else // assume '~'
                  {
                    DLGSetControlCaption(pDlg, FILE_DIALOG_FILE_NAME_CONTROL, pText + 1);
                  }
                }
              }
            }

            return 1; // handled
          }
          else if(pEvent->xclient.data.l[2] == WB_LIST_DBLCLICK)
          {
            // NOTE:  pEvent->xclient.data.l[3] contains the selection index

            // Rather than allowing the default handler to deal with it, post an 'OK' button notification
            // so that the same code deals with THIS as with the OK button

//            XClientMessageEvent evt = {
//                                        .type=ClientMessage,
//                                        .serial=0,
//                                        .send_event=0,
//                                        .display=pDisplay,
//                                        .window=wID,
//                                        .message_type=aCONTROL_NOTIFY,
//                                        .format=32
//                                      };
//            evt.data.l[0] = aBUTTON_PRESS;
//            evt.data.l[1] = IDOK;
//            evt.data.l[2] = 0;
//            evt.data.l[3] = 0;
//            evt.data.l[4] = 0;
//
//            WBPostPriorityEvent(wID, (XEvent *)&evt);

            // build a 'click' notification event to make sure I capture the correct name
            DLGNotifyDlg(pDlg, aCONTROL_NOTIFY, aLIST_NOTIFY, FILE_DIALOG_FILE_LIST_CONTROL,
                         WB_LIST_SELCHANGE, pEvent->xclient.data.l[3], 0); // duplicates a 'SEL CHANGE" event

            WB_WARN_PRINT("%s - LIST_NOTIFY WB_LIST_DBLCLICK control notification message %ld (%s)  %ld (%08lxH), %ld (%08lxH)\n",
                          __FUNCTION__, pEvent->xclient.data.l[0],
                          XGetAtomName(WBGetWindowDisplay(wID), (Atom)pEvent->xclient.data.l[0]),
                          pEvent->xclient.data.l[1], pEvent->xclient.data.l[1],
                          pEvent->xclient.data.l[2], pEvent->xclient.data.l[2]);

            DLGNotifyDlgAsync(pDlg, aCONTROL_NOTIFY, aBUTTON_PRESS, IDOK, 0, 0, 0); // post a button press event

            return 1;
          }

          return 0; // not handled
        }
        break;

      default:
        WB_WARN_PRINT("%s - TODO:  control notification message %ld (%s)  %ld (%08lxH), %ld (%08lxH)\n",
                      __FUNCTION__, pEvent->xclient.data.l[0],
                      XGetAtomName(WBGetWindowDisplay(wID), (Atom)pEvent->xclient.data.l[0]),
                      pEvent->xclient.data.l[1], pEvent->xclient.data.l[1],
                      pEvent->xclient.data.l[2], pEvent->xclient.data.l[2]);

    }
  }
  else if(pEvent->xclient.message_type == aGOTFOCUS)
  {
    return 0; // for now
  }
  else if(pEvent->xclient.message_type == aLOSTFOCUS)
  {
    return 0; // for now
  }
  else
  {
    WB_WARN_PRINT("%s - unhandled notification %s %ld (%s)  %ld (%08lxH), %ld (%08lxH)\n",
                  __FUNCTION__, XGetAtomName(WBGetWindowDisplay(wID), (Atom)pEvent->xclient.message_type),
                  pEvent->xclient.data.l[0], XGetAtomName(WBGetWindowDisplay(wID), (Atom)pEvent->xclient.data.l[0]),
                  pEvent->xclient.data.l[1], pEvent->xclient.data.l[1],
                  pEvent->xclient.data.l[2], pEvent->xclient.data.l[2]);
  }

  return 0;
}

char *DLGFileDialog(int iType, Window wIDOwner, const char *szDefPath, const char *szDefName,
                    const char *szExtAndDescList)
{
static const char szFileDialogRes[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:250 WIDTH:260 TITLE:\"File Dialog\"\n"
  "  CONTROL:PathTree ID:1000 X:2 Y:2 HEIGHT:200 WIDTH:116 VISIBLE\n"
  "  CONTROL:FileList ID:1001 X:122 Y:2 HEIGHT:200 WIDTH:136 VISIBLE\n"
  "  CONTROL:Edit ID:1002 X:2 Y:206 WIDTH:296 HEIGHT:16 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDOK TITLE:OK X:40 Y:230 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:CancelButton ID:IDCANCEL TITLE:Cancel X:180 Y:230 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
WBDialogWindow *pDlg;
struct _FILE_DIALOG_ data;
int iRval;
Window wIDDlg;


  data.szDefPath = szDefPath;
  data.szDefName = szDefName;
  data.szExtAndDescList = szExtAndDescList;
  data.szPathName = NULL;

  pDlg = DLGCreateDialogWindow("File Select",szFileDialogRes,
                               100,100,300,100,FileDialogCallback,
                               WBDialogWindow_VISIBLE,&data);

  if(pDlg) // TODO:  manage this stuff as part of 'DLGCreateDialogWindow' instead
  {
    wIDDlg = pDlg->wID;

    if(wIDOwner != None)
    {
      Atom a1;
      unsigned int ai1[3];

      DLGAssignOwner(pDlg, wIDOwner);

      a1 = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE", False);
      ai1[0] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_TASKBAR", False);
      ai1[1] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_PAGER", False);

      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_ATOM, 32, PropModeReplace, (unsigned char *)ai1, 2);

      a1 = XInternAtom(WBGetWindowDisplay(wIDDlg), "WM_TRANSIENT_FOR", False);
      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_WINDOW, 32, PropModeReplace, (unsigned char *)&wIDOwner, 1);
    }

    iRval = WBShowModal(pDlg->wID, 0);

    if(iRval == IDOK)
    {
      if(data.szPathName)
      {
        return data.szPathName;
      }
      else
      {
        return NULL;  // for now, to prevent page fault
      }
    }
  }

  // it ends up here on 'cancel', etc. - so if a buffer was allocated, free it

  if(data.szPathName)
    free(data.szPathName);

  return NULL;
}

// construct a splash screen based on the size of the pixmap and position
// the copyright text in the lower 1/3 of the splash screen, centered, then
// pass a 'diagonal flash' across it, and close the screen after a total of
// 5 seconds, returning back to the application.

typedef struct _SPLASH_
{
  Pixmap pixmap, pixmap2;
  char *szCopyright;
  int iW, iH; // width/height of bitmap
  int iDepth; // depth, needed to create compatible bitmaps
  int nIter; // total # of iterations thus far
  XFontStruct *pFont;
  unsigned long clrText, clrBlack, clrWhite; // pixel colors
} SPLASH;

static int splash_callback(Window wID, XEvent *pEvent);
static int SplashDoExposeEvent(XExposeEvent *pEvent, Display *pDisplay,
                               Window wID, struct _SPLASH_ *pData);

#define SPLASH_FRAMERATE 100 /* make this configurable? */
#define SPLASH_TIME 2 /* seconds */

void DLGSplashScreen(char *aXPM[], const char *szCopyright, unsigned long clrText)
{
Window wID;//, wIDTemp;
XSetWindowAttributes xswa;  /* Temporary Set Window Attribute struct */
int iX, iY, iW, iH;
XSizeHints  xsh;            /* Size hints for window manager */
XWMHints xwmh;
XPM_ATTRIBUTES xattr;
SPLASH data;
Atom a1;
unsigned int ai1[3];


  bzero(&data, sizeof(data));
  bzero(&xattr, sizeof(xattr));

  if(XPM_CREATE_PIXMAP_FROM_DATA(WBGetDefaultDisplay(), WBGetHiddenHelperWindow(),
                                 aXPM, &(data.pixmap), &(data.pixmap2), &xattr))
  {
    WB_ERROR_PRINT("XPM_CREATE_PIXMAP_FROM_DATA ERROR\n");
    return;
  }

  iW = xattr.width + 4;  // border width is 2
  iH = xattr.height + 4; // border width is 2
  data.iDepth = xattr.depth;
  if(!data.iDepth)
  {
    data.iDepth = DefaultDepth(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));
  }

  if(!iW || !iH || data.pixmap == None)
  {
    WB_ERROR_PRINT("%s - iW=%d, iH=%d, data.pixmap=%d (%08xH)\n",
                   __FUNCTION__, iW, iH, (int)data.pixmap, (int)data.pixmap);
    return;
  }

  WB_ERROR_PRINT("TEMPORARY %s - iW=%d, iH=%d, data.pixmap=%d (%08xH)\n",
                 __FUNCTION__, iW, iH, (int)data.pixmap, (int)data.pixmap);

  // TODO:  choose font, calculate bounds of text area
  //        save font/bounds data and/or combine text into pixmap with transparent background


  iX = DisplayWidth(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));
  iY = DisplayHeight(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));

  iX = (iX - iW) / 2;
  iY = (iY - iH) / 2; // centered

  data.szCopyright = WBCopyString(szCopyright);
  data.clrText = clrText;
  data.clrBlack = BlackPixel(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));
  data.clrWhite = WhitePixel(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));
  data.iW = xattr.width;
  data.iH = xattr.height;
  data.pFont = NULL;  // must do this

  bzero(&xswa, sizeof(xswa));

  xswa.border_pixel = data.clrBlack;
  xswa.background_pixel = data.clrWhite;
  xswa.colormap = DefaultColormap(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));
  xswa.bit_gravity = CenterGravity;

  wID = WBCreateWindow(WBGetDefaultDisplay(), None,//DefaultRootWindow(WBGetDefaultDisplay()),
                       splash_callback, "Splash",
                       iX, iY, iW, iH, 0,
                       InputOutput,
                       CWBorderPixel | CWBackPixel | CWColormap | CWBitGravity | CWOverrideRedirect,
                       &xswa);

  if(wID <= 0)
  {
    return;
  }

  WBSetWindowData(wID, 0, (void *)&data);
  WBCreateWindowDefaultGC(wID, clrText, xswa.background_pixel);

  bzero(&xsh, sizeof(xsh));

  xsh.flags = (USPosition | USSize | PBaseSize | PMinSize | PMaxSize | PWinGravity);
  xsh.x = iX;
  xsh.y = iY;
  xsh.width = xsh.base_width = xsh.min_width = xsh.max_width = iW;
  xsh.height = xsh.base_height = xsh.min_height = xsh.max_height = iH;
  xsh.win_gravity = NorthWestGravity; // StaticGravity

  bzero(&xwmh, sizeof(xwmh));
  xwmh.flags = InputHint;
  xwmh.input = 0;  // never take focus

  // set title, size hints, and 'WM_HINTS' hints (so WM knows where to put the window and how to set focus)
  WBSetWMProperties(wID, "splashwindow", &xsh, &xwmh, NULL);

  // before mapping the window, set some properties
  a1 = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_WINDOW_TYPE", False);
  ai1[0] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_WINDOW_TYPE_SPLASH", False);
  XChangeProperty(WBGetDefaultDisplay(), wID, a1, XA_ATOM, 32, PropModeReplace, (unsigned char *)ai1, 1);


  a1 = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE", False);
  ai1[0] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_MODAL", False);
  ai1[1] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_TASKBAR", False);
  ai1[2] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_PAGER", False);
  XChangeProperty(WBGetDefaultDisplay(), wID, a1, XA_ATOM, 32, PropModeReplace, (unsigned char *)ai1, 3);

  // must EXPLICITLY allow PAINTING (and other stuff) i.e. ExposureMask
  XSelectInput(WBGetDefaultDisplay(), wID, WB_STANDARD_INPUT_MASK);

  if(CreateTimer(WBGetDefaultDisplay(), wID, 1000000 / SPLASH_FRAMERATE, 1, 1)) // periodic timer at 'frame rate'
  {
    WBDestroyWindow(wID);
  }
  else
  {
    WBMapWindow(WBGetDefaultDisplay(), wID);  // make window visible

    WBShowModal(wID, -1); // timer will cause window to go away automatically
  }

  if(data.szCopyright)
  {
    free((void *)data.szCopyright);
  }

  BEGIN_XCALL_DEBUG_WRAPPER
  if(data.pixmap != None)
  {
    XFreePixmap(WBGetDefaultDisplay(), data.pixmap);
    data.pixmap = None;
  }

  if(data.pixmap2 != None)
  {
    XFreePixmap(WBGetDefaultDisplay(), data.pixmap2);
    data.pixmap2 = None;
  }

  if(data.pFont)
  {
    XFreeFont(WBGetDefaultDisplay(), data.pFont);
  }
  END_XCALL_DEBUG_WRAPPER
}

static int splash_callback(Window wID, XEvent *pEvent)
{
Display *pDisplay = WBGetWindowDisplay(wID);
struct _SPLASH_ *pData = (struct _SPLASH_ *)WBGetWindowData(wID, 0);


  if(pData && pEvent->type == Expose)
  {
    return SplashDoExposeEvent((XExposeEvent *)pEvent, pDisplay, wID, pData);
  }

  if(pEvent->type == ClientMessage &&
     pEvent->xclient.message_type == aWM_TIMER)
  {
    if(!pData)
    {
      DeleteTimer(WBGetDefaultDisplay(), wID, 1);
      WBUnmapWindow(WBGetDefaultDisplay(), wID);
      WBDestroyWindow(wID);
      return 1;
    }

    pData->nIter ++;

    if(pData->nIter >= SPLASH_FRAMERATE * SPLASH_TIME)
    {
      DeleteTimer(WBGetDefaultDisplay(), wID, 1);
      WBSetWindowData(wID, 0, NULL);
      WBDestroyWindow(wID);
    }
    else
    {
      WBInvalidateGeom(wID, NULL, 1);
    }

    return 1;
  }

  // special handling for 'destroy'
  if(pEvent->type == DestroyNotify &&
     pEvent->xdestroywindow.window == wID)
  {
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                   "%s - DestroyNotify\n", __FUNCTION__);

    WBSetWindowData(wID, 0, NULL);

    return 1;
  }

  return 0;  // not handled
}

static int SplashDoExposeEvent(XExposeEvent *pEvent, Display *pDisplay,
                               Window wID, struct _SPLASH_ *pData)
{
  XFontStruct *pFont;//, *pOldFont;
//  XPoint xpt[3];
  GC gc;// = WBGetWindowDefaultGC(wID);
  Pixmap pxTemp;
  XGCValues xgcv;
  WB_GEOM geomBorder, geomText;
  XRectangle xrct;
//  WB_GEOM geomPaint;
  int i1, i2, iX, iY, iTimeStart, iTimeEnd;
//  int iW, iH, iHPos, iVPos;
//  XWindowAttributes xwa;      /* Temp Get Window Attribute struct */
//  char *p1, *p2;

  if(!pDisplay)
  {
    pDisplay = WBGetDefaultDisplay();
  }

//  gc = WBBeginPaint(wID, pEvent, &geomPaint);  // gnome b0rks this - window has absolute coordinates!

  if(!pData->pFont && pData->szCopyright && *(pData->szCopyright))
  {
    pFont = DTCalcIdealFont(NULL, pData->szCopyright, &geomText);

    if(!pFont)
    {
      pFont = WBGetDefaultFont();
    }

    pData->pFont = WBCopyFont(pFont);
  }

  pFont = pData->pFont; // cache it

  bzero(&xgcv, sizeof(xgcv));
  if(pFont)
  {
    xgcv.font = pData->pFont->fid;
    xgcv.fill_style = FillSolid;
  }
  xgcv.foreground = pData->clrText;
  xgcv.background = pData->clrWhite;
  xgcv.line_width = 1;
  xgcv.function = GXcopy; // copy
  xgcv.cap_style = CapProjecting;

  gc = XCreateGC(pDisplay, wID,
                 ((xgcv.font ? GCFont | GCFillStyle : 0) | GCForeground | GCBackground | GCCapStyle | GCFunction | GCLineWidth),
                 &xgcv);

  if(!gc)
  {
    WB_WARN_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);
    return 0;
  }

  // now we get to create a window-compatible pixmap compatible with the window size
  // NOTE:  XListDepths and XDefaultDepth may be needed to convert pixmaps to something that's compatible

  pxTemp = XCreatePixmap(pDisplay, wID, pData->iW + 4, pData->iH + 4,
                         DefaultDepth(pDisplay, DefaultScreen(pDisplay)));

  if(!pxTemp)
  {
    WB_ERROR_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);
    XFreeGC(pDisplay, gc);
    return 0;
  }

  WBGetWindowGeom(wID, &geomBorder);

  geomBorder.x = geomBorder.y = 0; // force this (for now, gnome has absolute coordinates for splash window!)

  xrct.x = geomBorder.x;
  xrct.y = geomBorder.y;
  xrct.width = geomBorder.width;
  xrct.height = geomBorder.height;

  if(pData->nIter <= 1)
  {
//    WBClearWindow(wID, gc);  GC doesn't have a clip region yet, don't do this
    XClearWindow(pDisplay, wID);  // erase background
  }

  // TODO:  create pixmap, do the operations, then render pixmap
  // TODO:  consider creating clip regions to improve performance

  XCopyArea(pDisplay, pData->pixmap, pxTemp ? pxTemp : wID, gc,
            0, 0, pData->iW, pData->iH, geomBorder.x + 2, geomBorder.y + 2);

  if(pData->nIter >= SPLASH_FRAMERATE / 2) // after first half second
  {
    geomText.x = geomBorder.x + 2;
    geomText.y = geomBorder.y + 2;
    geomText.width = geomBorder.width - 4;
    geomText.height = geomBorder.height - 4;

    geomText.y += (geomText.height * 2) / 3;
    geomText.height -= (geomText.height * 2) / 3; // bottom 1/3

    // copyright string is 1 or 2 lines, for now use whatever font I end up with and draw lines separately

    if(pFont)
    {
      WB_RECT rctBounds;
      rctBounds.left = geomText.x;
      rctBounds.top = geomText.y;
      rctBounds.right = rctBounds.left + geomText.width;
      rctBounds.bottom = rctBounds.top + geomText.height;

      DTDrawMultiLineText(pFont, pData->szCopyright, pDisplay, gc, pxTemp ? pxTemp : wID,
                          -8, 0, &rctBounds, DTAlignment_VCENTER | DTAlignment_HCENTER);
#if 0
      p1 = pData->szCopyright;
      p2 = strchr(p1, '\n');

      if(p2)
      {
        *(p2++) = 0;
      }

      if(!p2 || !*p2)
      {
        iX = geomText.x + (geomText.width - XTextWidth(pFont, p1, strlen(p1))) / 2;
        iY = geomText.y + (geomText.height - pFont->max_bounds.ascent + pFont->max_bounds.descent) / 2
           + pFont->max_bounds.ascent; // bottom of text

        XDrawString(pDisplay, pxTemp ? pxTemp : wID, gc, iX, iY, p1, strlen(p1));
      }
      else
      {
        iX = geomText.x + (geomText.width - XTextWidth(pFont, p1, strlen(p1))) / 2;
        iY = geomText.y + (geomText.height - 2 * (pFont->max_bounds.ascent + pFont->max_bounds.descent)) / 2
           + pFont->max_bounds.ascent; // bottom of text

        XDrawString(pDisplay, pxTemp ? pxTemp : wID, gc, iX, iY, p1, strlen(p1));

        iX = geomText.x + (geomText.width - XTextWidth(pFont, p2, strlen(p2))) / 2;
        iY += pFont->max_bounds.ascent + pFont->max_bounds.descent;

        XDrawString(pDisplay, pxTemp ? pxTemp : wID, gc, iX, iY, p2, strlen(p2));
      }

      if(p2)
      {
        *(p2 - 1) = '\n'; // restore it for next time
      }
#endif // 0
    }
    else
    {
      fprintf(stderr, "NO FONT, iter=%d\n", pData->nIter);
    }

    iTimeStart = 3 * SPLASH_FRAMERATE / 2;
    iTimeEnd = SPLASH_TIME * SPLASH_FRAMERATE - SPLASH_FRAMERATE / 2; // 1/2 sec before end

    if(iTimeStart + SPLASH_FRAMERATE / 2 > iTimeEnd)
    {
      iTimeStart = iTimeEnd - SPLASH_FRAMERATE / 2;
    }

    // drawing the 'glimmer' diagonally from upper left to lower right
    // TODO:  make this optional?

    if(pData->nIter >= iTimeStart && pData->nIter <= iTimeEnd)
    {
      int bInvert = 0;
      int iDelta = iTimeEnd - iTimeStart + 1;

      iX = 2 * (pData->iW * (pData->nIter - iTimeStart) / iDelta + pData->iW / (2 * iDelta));
      iY = 2 * (pData->iH * (pData->nIter - iTimeStart) / iDelta + pData->iH / (2 * iDelta));

      if(iX > pData->iW || iY > pData->iH)
      {
        i1 = (iX - pData->iW) * pData->iH / pData->iW;
        i2 = (iY - pData->iH) * pData->iW / pData->iH;

        iX = i2;
        iY = i1;
        bInvert = 1; // so it's (iX,pData->iH-1),(pData->iW-1,iY)
      }

      // using some interesting raster ops, 'highlight' the pixels along the line of
      // (0,iY),(iX,0) or (iX,pData->iH-1),(pData->iW-1,iY)

      XSetForeground(pDisplay, gc, pData->clrWhite & 0x404040);

      xgcv.line_width = 19;
      xgcv.function = GXor; // a or b
      xgcv.cap_style = CapProjecting;

      XChangeGC(pDisplay, gc, GCCapStyle | GCFunction | GCLineWidth, &xgcv);

      if(!bInvert)
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, -2, iY, iX, -2);
      }
      else
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, iX, pData->iH + 4, pData->iW + 4, iY);
      }

      XSetForeground(pDisplay, gc, pData->clrWhite & 0x808080);

      xgcv.line_width = 11;
      xgcv.function = GXor; // a or b
      xgcv.cap_style = CapProjecting;

      XChangeGC(pDisplay, gc, GCCapStyle | GCFunction | GCLineWidth, &xgcv);

      if(!bInvert)
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, -2, iY, iX, -2);
      }
      else
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, iX, pData->iH + 4, pData->iW + 4, iY);
      }

      XSetForeground(pDisplay, gc, pData->clrWhite & 0xc0c0c0);

      xgcv.line_width = 5;
      xgcv.function = GXor; // a or b
      xgcv.cap_style = CapProjecting;

      XChangeGC(pDisplay, gc, GCCapStyle | GCFunction | GCLineWidth, &xgcv);

      if(!bInvert)
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, -2, iY, iX, -2);
      }
      else
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, iX, pData->iH + 4, pData->iW + 4, iY);
      }

      XSetForeground(pDisplay, gc, pData->clrWhite);

      xgcv.line_width = 1;
      xgcv.function = GXcopy; // copy
      xgcv.cap_style = CapProjecting;

      XChangeGC(pDisplay, gc, GCCapStyle | GCFunction | GCLineWidth, &xgcv);

      if(!bInvert)
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, -2, iY, iX, -2);
      }
      else
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, iX, pData->iH + 4, pData->iW + 4, iY);
      }
    }
  }

  // this fixes the border areas properly

  xgcv.line_width = 3;
  xgcv.function = GXcopy; // copy
  xgcv.cap_style = CapProjecting;

  XChangeGC(pDisplay, gc, GCCapStyle | GCFunction | GCLineWidth, &xgcv);

  XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, 0,0, pData->iW + 3, 0);
  XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, pData->iW + 3, 0, pData->iW + 3, pData->iH + 3);
  XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, pData->iW + 3, pData->iH + 3, 0, pData->iH + 3);
  XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, 0, pData->iH + 3, 0, 0);

  if(pxTemp) // use the spare bitmap to do the work, thus making the whole screen update at once
  {
    XCopyArea(pDisplay, pxTemp, wID, gc, 0, 0, pData->iW + 4, pData->iH + 4, geomBorder.x, geomBorder.y);
    XFreePixmap(pDisplay, pxTemp);
  }

  XFreeGC(pDisplay, gc);
  XSync(pDisplay, 0); // force update NOW
  WBValidateGeom(wID, NULL);
//  WBEndPaint(wID, gc);

  return 1;  // processed
}


