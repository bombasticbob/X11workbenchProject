/////////////////////////////////////////////////////////////////////////////////////////////
//              _  _         _                     _                    _                  //
//           __| |(_)  __ _ | |  ___    __ _      (_) _ __ ___   _ __  | |    ___          //
//          / _` || | / _` || | / _ \  / _` |     | || '_ ` _ \ | '_ \ | |   / __|         //
//         | (_| || || (_| || || (_) || (_| |     | || | | | | || |_) || | _| (__          //
//          \__,_||_| \__,_||_| \___/  \__, |_____|_||_| |_| |_|| .__/ |_|(_)\___|         //
//                                     |___/|_____|             |_|                        //
//                                                                                         //
//                          implementation of standard modal dialogs                       //
//                                                                                         //
/////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************

    X11workbench - X11 programmer's 'work bench' application and toolkit
    Copyright (c) 2010-2018 by Bob Frazier (aka 'Big Bad Bombastic Bob')
                             all rights reserved

  DISCLAIMER:  The X11workbench application and toolkit software are supplied
               'as-is', with no warranties, either implied or explicit.
               Any claims to alleged functionality or features should be
               considered 'preliminary', and might not function as advertised.

  BSD-like license:

  There is no restriction as to what you can do with this software, so long
  as you include the above copyright notice and DISCLAIMER for any distributed
  work that is equal to or derived from this one, along with this paragraph
  that explains the terms of the license if the source is also being made
  available.  A "derived work" describes a work that uses a significant portion
  of the source files or algorithms that are included with this one.
  Specifically excluded from this are files that were generated by the software,
  or anything that is included with the software that is part of another package
  (such as files that were created or added during the 'configure' process).
  Specifically included is the use of part or all of any of the X11 workbench
  toolkit source or header files in your distributed application.  If you do not
  ship the source, the above copyright statement is still required to be placed
  in a reasonably prominent place, such as documentation, splash screens, and/or
  'about the application' dialog boxes.

  Use and distribution are in accordance with GPL, LGPL, and/or the above
  BSD-like license.  See COPYING and README files for more information.


  Additional information at http://sourceforge.net/projects/X11workbench

******************************************************************************/

/** \file dialog_impl.c
  * \brief Dialog box implementation file for standard types of dialog boxes
  *
  * This file implements a number of standard dialog boxes including the
  * 'file open' dialog box, message boxes, input boxes, and the splash screen.
*/


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>
#include <string.h>
#include <strings.h>
#include <signal.h>
#include <time.h>

#ifndef XK_Delete /* moslty for interix */
#define XK_MISCELLANY /* mostly for interix */
#include <X11/keysymdef.h> // some platforms don't automatically include this with X headers
#endif // XK_Delete

#include "window_helper.h"
#include "pixmap_helper.h"  // pixmap helpers, including pre-defined icons
#include "dialog_window.h"
#include "dialog_controls.h"
#include "conf_help.h"
#include "file_help.h"
#include "draw_text.h"


#define THIS_SUBSYSTEM DebugSubSystem_Dialog

//-------------------------------------------------------------------
//
// alteration of 'gleam' behavior for 'Splash' dialog
// default is the 'wide' gleam that uses 1/r^2
//
//#define GLEAM_OLD /* use this to do the 'old' gleam behavior */
//#define GLEAM_NARROW /* use this to produce the 'narrow' gleam */
//
//------------------------------------------------------------------


///////////////
// MESSAGE BOX
///////////////

struct _MESSAGE_BOX_
{
  int iType;
  const char *szTitle;
  const char *szMessage;
};

static int GetMessageBoxIconPixmapID(int iMBIconMask)
{
  switch(iMBIconMask & MessageBox_ICON_MASK)
  {
    case MessageBox_Error:
      return ID_ICON_STOP;
    case MessageBox_Warning:
      return ID_ICON_WARN;
    case MessageBox_Info:
      return ID_ICON_OK;
    case MessageBox_Asterisk:
      return ID_ICON_SPLAT;
    case MessageBox_Question:
      return ID_ICON_WHAT;
    case MessageBox_BoldQuestion:
      return ID_ICON_WHAT_BOLD;
    case MessageBox_WTF:
      return ID_ICON_WTF;
    case MessageBox_Bang:
      return ID_ICON_BANG;
    case MessageBox_Triangle:
      return ID_ICON_TRIANGLE;
    case MessageBox_FaceOfDeath:
      return ID_ICON_DEATH;
    case MessageBox_JollyRoger:
      return ID_ICON_SKULL;
    case MessageBox_ThumbsUp:
      return ID_ICON_THUMBUP;
    case MessageBox_ThumbsDown:
      return ID_ICON_THUMBDOWN;
    case MessageBox_MiddleFinger:
      return ID_ICON_FINGER;
    case MessageBox_TeddyBear:
      return ID_ICON_BEAR;
    case MessageBox_Barney:
      return ID_ICON_BARNEY;
    case MessageBox_App:
      return ID_ICON_APP;

//    default:
//      pixmap = None;
  }

  return -1;
}

static int MessageBoxCallback(Window wID, XEvent *pEvent)
{
WBDialogWindow *pDlg = DLGGetDialogWindowStruct(wID);
struct _MESSAGE_BOX_ *pUserData = (struct _MESSAGE_BOX_ *)(pDlg ? pDlg->pUserData : NULL);
//#ifndef NO_DEBUG
//WB_UINT64 ullTime = WBGetTimeIndex();
//#endif // NO_DEBUG


  if(pEvent->type == ClientMessage && pEvent->xclient.message_type == aDIALOG_INIT)
  {
    if(!pDlg)
    {
      WB_ERROR_PRINT("MessageBoxCallback - no WBDialogWindow structure in DIALOG_INIT for %d (%08xH) %p %08xH %08xH\n",
                     (unsigned int)wID, (unsigned int)wID, WBGetWindowData(wID, 0), DIALOG_WINDOW_TAG, ((WBDialogWindow *)WBGetWindowData(wID, 0))->ulTag);
      return 0; // can't process any messages now
    }
    else
    {
      // assigning the correct icon

      Window wIDIcon = DLGGetDialogControl(pDlg, 1000);  // ID 1000 for icon
      WBDialogControl *pCtrl = DLGGetDialogControlStruct(wIDIcon);

      if(pCtrl)
      {
        Pixmap pixmap2 = None;
        Pixmap pixmap = PXM_GetIconPixmap(GetMessageBoxIconPixmapID(pUserData->iType & MessageBox_ICON_MASK),
                                          NULL, &pixmap2);

        if(pixmap != None)
        {
          WBDialogControlSetIconPixmap(pCtrl, pixmap, pixmap2);
        }
      }
    }

    // assign the caption text to the caption window (which varies and must be assigned at run time)

    DLGSetControlCaption((WBDialogWindow *)pDlg, 1001, pUserData->szMessage);

//    WB_ERROR_PRINT("TEMPORARY:  %s line %d  delta tick %lld\n", __FUNCTION__, __LINE__, (WBGetTimeIndex() - ullTime));

    return 1;
  }

  if(!pDlg)
  {
    WB_WARN_PRINT("MessageBoxCallback - no WBDialogWindow structure\n");
    return 0; // can't process any messages now
  }

  if(pEvent->type == ClientMessage && pEvent->xclient.message_type == aCONTROL_NOTIFY)
  {
    WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Event | DebugSubSystem_Dialog,
                   "%s - MessageBox ClientMessage CONTROL_NOTIFY\n", __FUNCTION__);

    switch(pEvent->xclient.data.l[1]) // control ID
    {
      case IDOK:
      case IDCANCEL:
        if(pEvent->xclient.data.l[0] == aBUTTON_PRESS)
        {
          WBEndModal(wID, pEvent->xclient.data.l[1]);
        }
        break;

      default:
        WB_WARN_PRINT("%s - MessageBox ClientMessage CONTROL_NOTIFY client id=%lx\n",
                      __FUNCTION__, pEvent->xclient.data.l[1]);
    }
  }






  return 0;
}

int DLGMessageBox(int iType, Window wIDOwner, const char *szTitle, const char *szMessage)
{
static const char szOKBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"OK Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE HALIGN_TEXT_CENTER\n"
  "  CONTROL:DefPushButton ID:IDOK TITLE:OK X:80 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szNoBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"OK Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE HALIGN_TEXT_CENTER\n"
  "  CONTROL:DefPushButton ID:IDCANCEL TITLE:No X:80 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szYesBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"OK Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE HALIGN_TEXT_CENTER\n"
  "  CONTROL:DefPushButton ID:IDYES TITLE:Yes X:80 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szCancelBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"OK Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE HALIGN_TEXT_CENTER\n"
  "  CONTROL:DefPushButton ID:IDCANCEL TITLE:Cancel X:80 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szAbortBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"OK Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE HALIGN_TEXT_CENTER\n"
  "  CONTROL:DefPushButton ID:IDABORT TITLE:Abort X:80 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szRetryBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"OK Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE HALIGN_TEXT_CENTER\n"
  "  CONTROL:DefPushButton ID:IDRETRY TITLE:Retry X:80 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szIgnoreBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"OK Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE HALIGN_TEXT_CENTER\n"
  "  CONTROL:DefPushButton ID:IDIGNORE TITLE:Ignore X:80 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szOKCancelBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"OK/Cancel Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE HALIGN_TEXT_CENTER\n"
  "  CONTROL:DefPushButton ID:IDOK TITLE:OK X:40 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:CancelButton ID:IDCANCEL TITLE:Cancel X:120 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szYesNoBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"Yes/No Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE HALIGN_TEXT_CENTER\n"
  "  CONTROL:DefPushButton ID:IDYES TITLE:_Yes X:40 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:CancelButton ID:IDNO TITLE:_No X:120 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szYesNoCancelBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"Yes/No Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE HALIGN_TEXT_CENTER\n"
  "  CONTROL:DefPushButton ID:IDYES TITLE:_Yes X:20 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:PushButton ID:IDNO TITLE:_No X:80 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:CancelButton ID:IDCANCEL TITLE:Cancel X:140 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szAbortRetryBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"Yes/No Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE HALIGN_TEXT_CENTER\n"
  "  CONTROL:DefPushButton ID:IDABORT TITLE:_Abort X:40 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:CancelButton ID:IDRETRY TITLE:_Retry X:120 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
static const char szAbortRetryIgnoreBox[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:50 WIDTH:200 TITLE:\"Yes/No Box\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE HALIGN_TEXT_CENTER\n"
  "  CONTROL:DefPushButton ID:IDYES TITLE:_Abort X:20 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:PushButton ID:IDRETRY TITLE:_Retry X:80 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:CancelButton ID:IDIGNORE TITLE:_Ignore X:140 Y:28 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";

struct _MESSAGE_BOX_ mbox;
const char *pRes;
WBDialogWindow *pDlg;
WB_GEOM geomParent;
Window wIDDlg;
int iRval, iX, iY;


// for now I determine the standard message box size THIS way
#define MESSAGE_BOX_WIDTH 400
#define MESSAGE_BOX_HEIGHT 100
#define MESSAGE_BOX_OFFSET 50

  mbox.iType = iType;
  mbox.szTitle = szTitle;
  mbox.szMessage = szMessage;

  bzero(&geomParent, sizeof(geomParent));

  if(wIDOwner != None)
  {
    WBGetWindowGeom0(wIDOwner, &geomParent); // parent geometry in absolute coordinates

    iX = geomParent.x + geomParent.border + MESSAGE_BOX_OFFSET;
    iY = geomParent.y + geomParent.border + MESSAGE_BOX_OFFSET;
  }
  else
  {
    // center in screen with slight random offset (so that every window won't always appear in exactly the same place)
    iY = (DisplayHeight(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()))
          - MESSAGE_BOX_HEIGHT + MESSAGE_BOX_OFFSET - (int)(WBGetTimeIndex() % (2 * MESSAGE_BOX_OFFSET)))
       / 2;

    iX = (DisplayWidth(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()))
          - MESSAGE_BOX_WIDTH + MESSAGE_BOX_OFFSET - (int)((~WBGetTimeIndex()) % (2 * MESSAGE_BOX_OFFSET)))
       / 2;
  }

  switch(iType & MessageBox_BUTTON_MASK)
  {
    case MessageBox_OK:
      pRes = szOKBox;
      break;

    case MessageBox_Yes:
      pRes = szYesBox;
      break;

    case MessageBox_No:
      pRes = szNoBox;
      break;

    case MessageBox_Cancel:
      pRes = szCancelBox;
      break;

    case MessageBox_Abort:
      pRes = szAbortBox;
      break;

    case MessageBox_Retry:
      pRes = szRetryBox;
      break;

    case MessageBox_Ignore:
      pRes = szIgnoreBox;
      break;

    case MessageBox_OK | MessageBox_Cancel:
      pRes = szOKCancelBox;
      break;

    case MessageBox_Yes | MessageBox_No:
      pRes = szYesNoBox;
      break;

    case MessageBox_Yes | MessageBox_No | MessageBox_Cancel:
      pRes = szYesNoCancelBox;
      break;

    case MessageBox_Abort | MessageBox_Retry:
      pRes = szAbortRetryBox;
      break;

    case MessageBox_Abort | MessageBox_Retry | MessageBox_Ignore:
      pRes = szAbortRetryIgnoreBox;
      break;

    default:
      if((iType & MessageBox_Abort) || (iType & MessageBox_Retry) || (iType & MessageBox_Ignore))
      {
        pRes = szAbortRetryIgnoreBox;
      }
      else if((iType & MessageBox_Yes) || (iType & MessageBox_No) || (iType & MessageBox_Cancel))
      {
        pRes = szYesNoCancelBox;
      }
      else
      {
        pRes = szOKBox;
      }
  }


//  WB_ERROR_PRINT("TEMPORARY:  %s - calling DLGCreateDialogWindow\n", __FUNCTION__);

  pDlg = DLGCreateDialogWindow(szTitle,pRes, iX, iY,
                               MESSAGE_BOX_WIDTH,
                               MESSAGE_BOX_HEIGHT, // TODO:  derive from ???
                               MessageBoxCallback,
                               WBDialogWindow_VISIBLE, &mbox);

  if(pDlg) // TODO:  manage this stuff as part of 'DLGCreateDialogWindow' instead
  {
    wIDDlg = pDlg->wID;

    if(wIDOwner != None)
    {
      Atom a1;
      unsigned int ai1[3];

      DLGAssignOwner(pDlg, wIDOwner);

      a1 = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE", False);
      ai1[0] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_TASKBAR", False);
      ai1[1] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_PAGER", False);

      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_ATOM, 32, PropModeReplace, (unsigned char *)ai1, 2);

      a1 = XInternAtom(WBGetWindowDisplay(wIDDlg), "WM_TRANSIENT_FOR", False);
      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_WINDOW, 32, PropModeReplace, (unsigned char *)&wIDOwner, 1);
    }

    WBSetWindowIcon(wIDDlg, GetMessageBoxIconPixmapID(iType & MessageBox_ICON_MASK));

//    WB_ERROR_PRINT("TEMPORARY:  %s - calling WBShowModal\n", __FUNCTION__);

    iRval = WBShowModal(wIDDlg, 0);

    return iRval;
  }

  return -1;  // by default return -1 on error
}


///////////////
// INPUT BOX
///////////////

struct _INPUT_BOX_
{
  const char *szTitle;
  const char *szMessage;
  char *szRval;
};


static int InputBoxCallback(Window wID, XEvent *pEvent)
{
WBDialogWindow *pDlg = DLGGetDialogWindowStruct(wID);
struct _INPUT_BOX_ *pUserData = (struct _INPUT_BOX_ *)(pDlg ? pDlg->pUserData : NULL);


  if(!pDlg)
    return 0; // can't process any messages now

  if(pEvent->type == ClientMessage && pEvent->xclient.message_type == aDIALOG_INIT)
  {
    // assigning the correct icon
    {
      WBDialogControl *pCtrl = DLGGetDialogControlStructFromID(pDlg, 1000); // ID 1000 for icon

      if(pCtrl)
      {
        Pixmap pixmap2 = None;
        Pixmap pixmap = PXM_GetIconPixmap(ID_ICON_WHAT, NULL, &pixmap2);

        if(pixmap != None)
        {
          WBDialogControlSetIconPixmap(pCtrl, pixmap, pixmap2);
        }
      }
    }

    // assign the caption text to the caption window (which varies and must be assigned at run time)

    DLGSetControlCaption((WBDialogWindow *)pDlg, 1001, pUserData->szMessage);

    if(pUserData->szRval)
    {
      DLGSetControlCaption(pDlg, 1002, pUserData->szRval);
    }

    return 1;
  }

  if(pEvent->type == ClientMessage && pEvent->xclient.message_type == aCONTROL_NOTIFY)
  {
    WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Event | DebugSubSystem_Dialog,
                     "%s - MessageBox ClientMessage CONTROL_NOTIFY\n", __FUNCTION__);

    switch(pEvent->xclient.data.l[1]) // control ID
    {
      case IDOK:
      case IDCANCEL:
        if(pEvent->xclient.data.l[0] == aBUTTON_PRESS)
        {
          const char *pText = DLGGetControlCaption(pDlg, 1002);

          if(pUserData->szRval)
          {
            WBFree(pUserData->szRval);
          }
          if(pText)
          {
            pUserData->szRval = WBCopyString(pText);
          }
          else
          {
            WB_ERROR_PRINT("TEMPORARY: %s - NULL 'pText' for edit control\n", __FUNCTION__);
            pUserData->szRval = NULL; // empty string
          }

          WBEndModal(wID, pEvent->xclient.data.l[1]);
        }
        break;

      case 1002:
        WB_DEBUG_PRINT(DebugLevel_Light | DebugSubSystem_Event | DebugSubSystem_Dialog,
                       "%s - INPUT BOX 'EDIT' NOTIFICATION %ld\n",
                       __FUNCTION__, pEvent->xclient.data.l[0]);

        // TODO:  update window text
        break;

      default:
        WB_WARN_PRINT("%s - MessageBox ClientMessage CONTROL_NOTIFY client id=%lx\n",
                      __FUNCTION__, pEvent->xclient.data.l[0]);
    }
  }

  return 0;
}

char *DLGInputBox(Window wIDOwner, const char *szTitle, const char *szPrompt, const char *szDefault,
                  int iWidth, int iMaxChar)
{
static const char szInputDialogRes[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:60 WIDTH:200 TITLE:\"User Input\"\n"
  "  CONTROL:Icon ID:1000 X:2 Y:2 HEIGHT:20 WIDTH:20 VISIBLE\n"
  "  CONTROL:Text ID:1001 X:24 Y:2 HEIGHT:20 WIDTH:172 VISIBLE HALIGN_TEXT_CENTER\n"
  "  CONTROL:Edit ID:1002 X:2 Y:22 WIDTH:196 HEIGHT:16 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDOK TITLE:OK X:40 Y:40 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:CancelButton ID:IDCANCEL TITLE:Cancel X:120 Y:40 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
WBDialogWindow *pDlg;
struct _INPUT_BOX_ sRval;
int iRval;
Window wIDDlg;


  sRval.szTitle = szTitle;
  sRval.szMessage = szPrompt;
  if(szDefault && *szDefault)
  {
    sRval.szRval = WBCopyString(szDefault); // a copy of the default value
  }
  else
  {
    sRval.szRval = NULL;
  }

  pDlg = DLGCreateDialogWindow(szTitle,szInputDialogRes,
                               100,100,300,60,InputBoxCallback,
                               WBDialogWindow_VISIBLE,&sRval);

  if(pDlg) // TODO:  manage this stuff as part of 'DLGCreateDialogWindow' instead
  {
    wIDDlg = pDlg->wID;

    if(wIDOwner != None)
    {
      Atom a1;
      unsigned int ai1[3];

      DLGAssignOwner(pDlg, wIDOwner);

      a1 = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE", False);
      ai1[0] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_TASKBAR", False);
      ai1[1] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_PAGER", False);

      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_ATOM, 32, PropModeReplace, (unsigned char *)ai1, 2);

      a1 = XInternAtom(WBGetWindowDisplay(wIDDlg), "WM_TRANSIENT_FOR", False);
      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_WINDOW, 32, PropModeReplace, (unsigned char *)&wIDOwner, 1);
    }

    iRval = WBShowModal(pDlg->wID, 0);

    if(iRval == IDOK)
    {
      return sRval.szRval;
    }
    else if(iRval != IDCANCEL)
    {
      WB_ERROR_PRINT("TEMPORARY - %s - iRval is %d\n", __FUNCTION__, iRval);
    }
  }

  // it ends up here on 'cancel', etc. - so if a buffer was allocated, free it

  if(sRval.szRval)
  {
    WBFree(sRval.szRval);
  }

  return NULL;
}



///////////////
// FILE DIALOG
///////////////

struct _FILE_DIALOG_
{
  const char *szDefPath;
  const char *szDefName;
  const char *szExtAndDescList;
  char *szPathName;  // WBAlloc'd
};


#define FILE_DIALOG_PATH_TREE_CONTROL 1000
#define FILE_DIALOG_FILE_LIST_CONTROL 1001
#define FILE_DIALOG_FILE_NAME_CONTROL 1002

static int FileDialogCallback(Window wID, XEvent *pEvent)
{
WBDialogWindow *pDlg = DLGGetDialogWindowStruct(wID);
struct _FILE_DIALOG_ *pUserData = (struct _FILE_DIALOG_ *)(pDlg ? pDlg->pUserData : NULL);
//Display *pDisplay = WBGetWindowDisplay(wID);
char *p1, *p2;


  if(!pDlg)
    return 0; // can't process any messages now

  if(pEvent->type == ClientMessage && pEvent->xclient.message_type == aDIALOG_INIT)
  {
    if(!pUserData->szPathName || !*(pUserData->szPathName) ||
       (!strchr(pUserData->szPathName, '/') && !WBIsDirectory(pUserData->szPathName)))
    {
      if(!pUserData->szDefPath || !*(pUserData->szDefPath))
      {
        // set the 'DLGC_PATH' property for appropriate controls
        DLGSetControlProperty(pDlg, FILE_DIALOG_FILE_LIST_CONTROL,
                              aDLGC_PATH, ".");  // set path to '.' if not specified already
      }
      else
      {
        DLGSetControlProperty(pDlg, FILE_DIALOG_FILE_LIST_CONTROL,
                              aDLGC_PATH, pUserData->szDefPath);
      }
    }
    else
    {
      p1 = WBCopyString(pUserData->szDefPath);
      if(!p1)
      {
        WB_ERROR_PRINT("%s - no memory to copy path string (a)\n", __FUNCTION__);
      }
      else
      {
        p2 = strrchr(p1, '/');
        if(p2)
        {
          p2[1] = 0;  // keep the '/'
        }

        DLGSetControlProperty(pDlg, FILE_DIALOG_FILE_LIST_CONTROL,
                              aDLGC_PATH, p1);

        WBFree(p1);
      }
    }

    return 1;
  }

  if(pEvent->type != ClientMessage)
  {
    return 0; // unhandled at this time
  }

  // EVERYTHING AT THIS POINT IS A CLIENT MESSAGE

  if(pEvent->xclient.message_type == aCONTROL_NOTIFY)
  {
    // l[0] == message
    // l[1] == control ID
    // l[2] ==
    switch(pEvent->xclient.data.l[1])
    {
      case IDOK:
      case IDCANCEL:
        if(pEvent->xclient.data.l[0] == aBUTTON_PRESS)
        {
          if(pEvent->xclient.data.l[1] == IDOK)
          {
            const char *pPath = DLGGetControlCaption(pDlg, FILE_DIALOG_FILE_NAME_CONTROL);
            const char *pDir = DLGGetControlProperty(pDlg, FILE_DIALOG_FILE_LIST_CONTROL, aDLGC_PATH);

            if(pUserData->szPathName)
            {
              WBFree(pUserData->szPathName);
            }

            if(pPath && pPath[0] == '/')
            {
              pUserData->szPathName = WBCopyString(pPath); // absolute path assignment
            }
            else
            {
              if(pDir && *pDir)
              {
                pUserData->szPathName = WBCopyString(pDir);

                if(pUserData->szPathName && *pUserData->szPathName &&
                   pUserData->szPathName[strlen(pUserData->szPathName) - 1] != '/')
                {
                  WBCatString(&(pUserData->szPathName), "/");
                }
              }
              else
              {
                pUserData->szPathName = WBCopyString("./");
              }

//              WB_ERROR_PRINT("TEMPORARY %s ---> dir=\"%s\" path=\"%s\" \n", __FUNCTION__, pUserData->szPathName, pPath);

              if(pUserData->szPathName && pPath)
              {
                WBCatString(&(pUserData->szPathName), pPath);
              }

              // check for '/../' within path - if present, canonicalize it
              if(pUserData->szPathName &&
                 (strstr(pUserData->szPathName, "/../") ||
                  (strlen(pUserData->szPathName) > 3 &&
                   (!memcmp(pUserData->szPathName, "../", 3) ||
                    !memcmp(pUserData->szPathName + strlen(pUserData->szPathName) - 3, "/..", 3)))))
              {
                p1 = WBGetCanonicalPath(pUserData->szPathName);
                if(p1)
                {
                  WBFree(pUserData->szPathName);
                  pUserData->szPathName = p1;
                }
                else
                {
                  WB_ERROR_PRINT("ERROR - %s - Unable to get canonical path for \"%s\"\n", __FUNCTION__, pUserData->szPathName);
                }
              }
            }

            if(pUserData->szPathName && *pUserData->szPathName &&
               (pUserData->szPathName[strlen(pUserData->szPathName) - 1] == '/' || WBIsDirectory(pUserData->szPathName)))
            {
              // if it ends in a '/' it's supposed to be a DIRECTORY and I must change to it
              p1 = WBCopyString(pUserData->szPathName);
              if(p1 && (!*p1 || p1[strlen(p1) - 1] != '/'))
              {
                WBCatString(&p1, "/");  // make sure it ends in '/'
              }

              if(!p1)
              {
                WB_ERROR_PRINT("%s - no memory to copy path string (b)\n", __FUNCTION__);
              }
              else
              {
                // TODO:  do I do a chdir() ?

                DLGSetControlProperty(pDlg, FILE_DIALOG_FILE_LIST_CONTROL,
                                      aDLGC_PATH, p1);

//                WB_ERROR_PRINT("TEMPORARY %s ---> new path=\"%s\"\n", __FUNCTION__, p1);

                // also I want to make sure that the file name control contains the new path
                DLGSetControlCaption(pDlg, FILE_DIALOG_FILE_NAME_CONTROL, p1);

                WBFree(p1);
              }

              return 1; // handled (do not close the dialog box)
            }
          }

          WBEndModal(wID, pEvent->xclient.data.l[1]);
          return 1; // handled!
        }
        break;

      case FILE_DIALOG_FILE_LIST_CONTROL:
        if(pEvent->xclient.data.l[0] == aLIST_NOTIFY) // list control notifications
        {
          if(pEvent->xclient.data.l[2] == WB_LIST_SELCHANGE)
          {
            // assign the textbox value to the selected text
            if(pEvent->xclient.data.l[3] >= 0)
            {
              WBDialogControl *pCtrl = DLGGetDialogControlStructFromID(pDlg, pEvent->xclient.data.l[1]);
              if(pCtrl)
              {
                const char *pText = DLGGetControlListText(pCtrl, pEvent->xclient.data.l[3]);

                if(pText)
                {
//                  WB_WARN_PRINT("%s - assigning control text \"%s\"\n", __FUNCTION__, pText);
                  if(*pText == '@')
                  {
                    char *p1 = WBCopyString(pText + 1);

                    if(p1)
                    {
                      WBCatString(&p1, "/");
                      if(p1)
                      {
                        DLGSetControlCaption(pDlg, FILE_DIALOG_FILE_NAME_CONTROL, p1);
                        WBFree(p1);
                      }
                    }
                  }
                  else // assume '~'
                  {
                    DLGSetControlCaption(pDlg, FILE_DIALOG_FILE_NAME_CONTROL, pText + 1);
                  }
                }
              }
            }

            return 1; // handled
          }
          else if(pEvent->xclient.data.l[2] == WB_LIST_DBLCLICK)
          {
            // NOTE:  pEvent->xclient.data.l[3] contains the selection index

            // Rather than allowing the default handler to deal with it, post an 'OK' button notification
            // so that the same code deals with THIS as with the OK button

//            XClientMessageEvent evt = {
//                                        .type=ClientMessage,
//                                        .serial=0,
//                                        .send_event=0,
//                                        .display=pDisplay,
//                                        .window=wID,
//                                        .message_type=aCONTROL_NOTIFY,
//                                        .format=32
//                                      };
//            evt.data.l[0] = aBUTTON_PRESS;
//            evt.data.l[1] = IDOK;
//            evt.data.l[2] = 0;
//            evt.data.l[3] = 0;
//            evt.data.l[4] = 0;
//
//            WBPostPriorityEvent(wID, (XEvent *)&evt);

            // build a 'click' notification event to make sure I capture the correct name
            DLGNotifyDlg(pDlg, aCONTROL_NOTIFY, aLIST_NOTIFY, FILE_DIALOG_FILE_LIST_CONTROL,
                         WB_LIST_SELCHANGE, pEvent->xclient.data.l[3], 0); // duplicates a 'SEL CHANGE" event

            {
#ifndef NO_DEBUG
              char *p1 = WBGetAtomName(WBGetWindowDisplay(wID), (Atom)pEvent->xclient.data.l[0]);
              WB_WARN_PRINT("%s - LIST_NOTIFY WB_LIST_DBLCLICK control notification message %ld (%s)  %ld (%08lxH), %ld (%08lxH)\n",
                            __FUNCTION__, pEvent->xclient.data.l[0],  p1,
                            pEvent->xclient.data.l[1], pEvent->xclient.data.l[1],
                            pEvent->xclient.data.l[2], pEvent->xclient.data.l[2]);
              if(p1)
              {
                WBFree(p1);
              }
#endif // NO_DEBUG
            }

            DLGNotifyDlgAsync(pDlg, aCONTROL_NOTIFY, aBUTTON_PRESS, IDOK, 0, 0, 0); // post a button press event

            return 1;
          }

          return 0; // not handled
        }
        break;

      default:
        {
#ifndef NO_DEBUG
          char *p1 = WBGetAtomName(WBGetWindowDisplay(wID), (Atom)pEvent->xclient.data.l[0]);

          WB_WARN_PRINT("%s - TODO:  control notification message %ld (%s)  %ld (%08lxH), %ld (%08lxH)\n",
                        __FUNCTION__, pEvent->xclient.data.l[0], p1,
                        pEvent->xclient.data.l[1], pEvent->xclient.data.l[1],
                        pEvent->xclient.data.l[2], pEvent->xclient.data.l[2]);

          if(p1)
          {
            WBFree(p1);
          }
#endif // NO_DEBUG
        }
    }
  }
  else if(pEvent->xclient.message_type == aGOTFOCUS)
  {
    // control ID is in pEvent->xclient.data.l[0]
    return 0; // for now
  }
  else if(pEvent->xclient.message_type == aLOSTFOCUS)
  {
    // control ID is in pEvent->xclient.data.l[0]
    return 0; // for now
  }
  else
  {
#ifndef NO_DEBUG
    char *p1 = WBGetAtomName(WBGetWindowDisplay(wID), (Atom)pEvent->xclient.message_type);
    char *p2 = WBGetAtomName(WBGetWindowDisplay(wID), (Atom)pEvent->xclient.data.l[0]);

    WB_WARN_PRINT("%s - unhandled notification %s %ld (%s)  %ld (%08lxH), %ld (%08lxH)\n",
                  __FUNCTION__, p1,
                  pEvent->xclient.data.l[0], p2,
                  pEvent->xclient.data.l[1], pEvent->xclient.data.l[1],
                  pEvent->xclient.data.l[2], pEvent->xclient.data.l[2]);

    if(p1)
    {
      WBFree(p1);
    }
    if(p2)
    {
      WBFree(p2);
    }
#endif // NO_DEBUG
  }

  return 0;
}

char *DLGFileDialog(int iType, Window wIDOwner, const char *szDefPath, const char *szDefName,
                    const char *szExtAndDescList)
{
static const char szFileDialogRes[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:250 WIDTH:260 TITLE:\"File Dialog\"\n"
  "  CONTROL:PathTree ID:1000 X:2 Y:2 HEIGHT:200 WIDTH:116 VISIBLE\n"
  "  CONTROL:FileList ID:1001 X:122 Y:2 HEIGHT:200 WIDTH:136 VISIBLE\n"
  "  CONTROL:Edit ID:1002 X:2 Y:206 WIDTH:296 HEIGHT:16 VISIBLE\n"
  "  CONTROL:DefPushButton ID:IDOK TITLE:OK X:40 Y:230 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:CancelButton ID:IDCANCEL TITLE:Cancel X:180 Y:230 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "END_DIALOG\n";
WBDialogWindow *pDlg;
struct _FILE_DIALOG_ data;
int iRval;
Window wIDDlg;


  data.szDefPath = szDefPath;
  data.szDefName = szDefName;
  data.szExtAndDescList = szExtAndDescList;
  data.szPathName = NULL;

  pDlg = DLGCreateDialogWindow("File Select",szFileDialogRes,
                               100,100,300,100,FileDialogCallback,
                               WBDialogWindow_VISIBLE,&data);

  if(pDlg) // TODO:  manage this stuff as part of 'DLGCreateDialogWindow' instead
  {
    wIDDlg = pDlg->wID;

    if(wIDOwner != None)
    {
      Atom a1;
      unsigned int ai1[3];

      DLGAssignOwner(pDlg, wIDOwner);

      a1 = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE", False);
      ai1[0] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_TASKBAR", False);
      ai1[1] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_PAGER", False);

      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_ATOM, 32, PropModeReplace, (unsigned char *)ai1, 2);

      a1 = XInternAtom(WBGetWindowDisplay(wIDDlg), "WM_TRANSIENT_FOR", False);
      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_WINDOW, 32, PropModeReplace, (unsigned char *)&wIDOwner, 1);
    }

    iRval = WBShowModal(pDlg->wID, 0);

    if(iRval == IDOK)
    {
      if(data.szPathName)
      {
        return data.szPathName;
      }
      else
      {
        return NULL;  // for now, to prevent page fault
      }
    }
  }

  // it ends up here on 'cancel', etc. - so if a buffer was allocated, free it

  if(data.szPathName)
  {
    WBFree(data.szPathName);
  }

  return NULL;
}


///////////////
// COLOR DIALOG
///////////////

struct _COLOR_DIALOG_
{
  int iLuma, iChroma, iSaturation;
  int iRed, iGreen, iBlue; // 0-255 RGB values
  unsigned long lPixel; // XColor pixel value
  XStandardColormap stdColorMap;
  XColor *pColor; // to be assigned on exit

  // 'old' control values for when values change
  int iOldL, iOldC, iOldS, iOldR, iOldG, iOldB;
  unsigned long lOldP;

  // TODO:  additional cached internal values for image and pixmap

  int iXLumaSat, iYLumaSat, iXChroma, iOldXLS, iOldYLS, iOldXC;
  XImage *pimgLumaSat, *pimgChroma;
  Pixmap pixmapLumaSat, pixmapChroma;
};

#define LUMA_SAT_PICKER 1001
#define CHROMA_PICKER   1002
#define LUMA_BOX        1003
#define CHROMA_BOX      1004
#define SAT_BOX         1005
#define RED_BOX         1006
#define GREEN_BOX       1007
#define BLUE_BOX        1008
#define COLORBOX        1009
#define COLORBOX_VALUE  1010

#define COLOR_IMAGE_SIZE 256 /* note that dialog units are 2 pixels each */
#define CHROMA_RIBBON_HEIGHT 24 /* note that dialog units are 2 pixels each */
#define COLOR_IMAGE_COLOR_FACTOR 1 /* multiply by this to get 0-255 [effectively] */
#define COLORBOX_PIXMAP_WIDTH  96 /* width of 'colorbox' pixmap */
#define COLORBOX_PIXMAP_HEIGHT 24 /* height of 'colorbox' pixmap */

#ifdef COMPILER_SUPPORTS_UNUSED_ATTRIBUTE
// prototype needed so I can declare it 'WB_UNUSED'
static void ColorDialogDumpData(const char *szCaption, struct _COLOR_DIALOG_ *pData) WB_UNUSED;
#endif // COMPILER_SUPPORTS_UNUSED_ATTRIBUTE

static void ColorDialogDumpData(const char *szCaption, struct _COLOR_DIALOG_ *pData)
{
  WBDebugPrint("ColorDialogDumpData - %s\n", szCaption);
  WBDebugPrint("  iLuma=%-3d  iChroma=%-3d  iSaturation=%-3d\n",
               pData->iLuma, pData->iChroma, pData->iSaturation);
  WBDebugPrint("  iRed=%-3d   iGreen=%-3d   iBlue=%-3d\n",
               pData->iRed, pData->iGreen, pData->iBlue);

  WBDebugPrint("  iOldL=%-3d  iOldC=%-3d    iOldS=%-3d\n",
               pData->iOldL, pData->iOldC, pData->iOldS);
  WBDebugPrint("  iOldR=%-3d  iOldG=%-3d    iOldB=%-3d\n",
               pData->iOldR, pData->iOldG, pData->iOldB);

  WBDebugPrint("  lPixel = %-8lu \"#%-6.6lX\"\n", pData->lPixel, pData->lPixel);
  WBDebugPrint("  lOldP  = %-8lu \"#%-6.6lX\"\n\n", pData->lOldP, pData->lOldP);

  WBDebugPrint("  iXLumaSat = %-3d  iYLumaSat = %-3d  iXChroma = %-3d\n"
               "  iOldXLS   = %-3d  iOldYLS   = %-3d  iOldXC   = %-3d\n\n",
               pData->iXLumaSat, pData->iYLumaSat, pData->iXChroma,
               pData->iOldXLS, pData->iOldYLS, pData->iOldXC);

  WBDebugPrint("  pimgLumaSat   = %p\n", pData->pimgLumaSat);
  WBDebugPrint("  pimgChroma    = %p\n", pData->pimgChroma);

  WBDebugPrint("  pixmapLumaSat = %lu (%lxH)\n",
               (unsigned long)pData->pimgLumaSat, (unsigned long)pData->pimgLumaSat);
  WBDebugPrint("  pixmapChroma  = %lu (%lxH)\n",
               (unsigned long)pData->pimgChroma, (unsigned long)pData->pimgChroma);
  WBDebugPrint("**********************************************************************\n");
}

static XImage * CreateLumaSaturationImage(Display *pDisplay, XStandardColormap *pSCM, int nChroma)
{
int iR, iG, iB, iSat, iLum;
XImage *pImage;


  pImage = XGetImage(WBGetDefaultDisplay(), None, 0, 0, COLOR_IMAGE_SIZE, COLOR_IMAGE_SIZE,
                     0xffffffff, XYPixmap);

  if(pImage == None)
  {
    return None;
  }

//  pData->cbImageData = PXM_GetImageDataLength(pI);
//  pData->pImageData = WBAlloc(pData->cbImageData + 4);
//
//  if(pData->pImageData)
//  {
//    memcpy(pData->pImageData, PXM_GetImageDataPtr(pI), pData->cbImageData);
//  }

//  PXM_RGBToHSV(iR, iG, iB, &nChroma, &iSat, &iLum);

  for(iSat = COLOR_IMAGE_SIZE - 1; iSat >= 0; iSat--)
  {
    for(iLum = 0; iLum < COLOR_IMAGE_SIZE; iLum++)
    {
      XColor clr;

      PXM_HSVToRGB(nChroma,
                   iSat * COLOR_IMAGE_COLOR_FACTOR,
                   iLum * COLOR_IMAGE_COLOR_FACTOR,
                   &iR, &iG, &iB);

      RGB255_TO_XCOLOR(iR, iG, iB, clr);
      PXM_RGBToPixel(pSCM, &clr); // make sure the RGB members are correct

      // use XPutPixel to put the pixel at row 'iSat', column 'iLum'

      XPutPixel(pImage, iLum, iSat, clr.pixel); // this should actually be VERY fast
    }
  }

  return pImage;
}

static XImage * CreateChromaImage(Display *pDisplay, XStandardColormap *pSCM)
{
int iR, iG, iB, iChroma, iRow;
XImage *pImage;


  pImage = XGetImage(pDisplay, None, 0, 0, COLOR_IMAGE_SIZE, CHROMA_RIBBON_HEIGHT,
                     0xffffffff, XYPixmap);

  if(pImage == None)
  {
    return None;
  }

  for(iChroma=0; iChroma < COLOR_IMAGE_SIZE; iChroma++)
  {
    XColor clr;

    PXM_HSVToRGB(iChroma * COLOR_IMAGE_COLOR_FACTOR,
                 255, 255, &iR, &iG, &iB);

    RGB255_TO_XCOLOR(iR, iG, iB, clr);
    PXM_RGBToPixel(pSCM, &clr); // make sure the RGB members are correct

    // use XPutPixel to put the pixel at row 'iSat', column 'iLum'
    for(iRow=0; iRow < CHROMA_RIBBON_HEIGHT; iRow++)
    {
      XPutPixel(pImage, iChroma, iRow, clr.pixel); // this should actually be VERY fast
    }
  }

  return pImage;
}

static void ColorDialogImagesFromData(Display *pDisplay, WBDialogControl *pctrlLumaSat,
                                      WBDialogControl *pctrlChroma, struct _COLOR_DIALOG_ *pUserData)
{
//  int iXLumaSat, iYLumaSat, iXChroma, iOldXLS, iOldYLS, iOldXC;



}

static void ColorDialogDataFromPixel(struct _COLOR_DIALOG_ *pUserData)
{
XColor clr;

  clr.pixel = pUserData->lPixel;

  PXM_PixelToRGB(&(pUserData->stdColorMap), &clr); // make sure the RGB members are correct

  RGB255_FROM_XCOLOR(clr, pUserData->iRed, pUserData->iGreen, pUserData->iBlue);

  PXM_RGBToHSV(pUserData->iRed, pUserData->iGreen, pUserData->iBlue,
               &pUserData->iChroma,
               &pUserData->iSaturation,
               &pUserData->iLuma);


  // fix all of the 'old' values to match
  pUserData->iOldR = pUserData->iRed;
  pUserData->iOldG = pUserData->iGreen;
  pUserData->iOldB = pUserData->iBlue;

  pUserData->iOldC = pUserData->iChroma;
  pUserData->iOldL = pUserData->iLuma;
  pUserData->iOldS = pUserData->iSaturation;

  pUserData->lOldP = pUserData->lPixel;
}

static int ColorDialogRGBFromHSV(struct _COLOR_DIALOG_ *pUserData)
{
XColor clr;
int iRval;

  PXM_HSVToRGB(pUserData->iChroma, pUserData->iSaturation, pUserData->iLuma,
               &pUserData->iRed,
               &pUserData->iGreen,
               &pUserData->iBlue);

  RGB255_TO_XCOLOR(pUserData->iRed, pUserData->iGreen, pUserData->iBlue, clr);
  PXM_RGBToPixel(&(pUserData->stdColorMap), &clr); // make sure the pixel is correct

  pUserData->lPixel = clr.pixel; // and now I'm consistent!

  iRval = pUserData->lOldP != pUserData->lPixel ||
          pUserData->iOldR != pUserData->iRed ||
          pUserData->iOldG != pUserData->iGreen ||
          pUserData->iOldB != pUserData->iBlue ||
          pUserData->iOldC != pUserData->iChroma ||
          pUserData->iOldL != pUserData->iLuma ||
          pUserData->iOldS != pUserData->iSaturation;

  // fix all of the 'old' values to match
  pUserData->iOldR = pUserData->iRed;
  pUserData->iOldG = pUserData->iGreen;
  pUserData->iOldB = pUserData->iBlue;

  pUserData->iOldC = pUserData->iChroma;
  pUserData->iOldL = pUserData->iLuma;
  pUserData->iOldS = pUserData->iSaturation;

  pUserData->lOldP = pUserData->lPixel;

  return iRval;
}

static int ColorDialogHSVFromRGB(struct _COLOR_DIALOG_ *pUserData)
{
XColor clr;
int iRval;

  PXM_RGBToHSV(pUserData->iRed, pUserData->iGreen, pUserData->iBlue,
               &pUserData->iChroma,
               &pUserData->iSaturation,
               &pUserData->iLuma);

  RGB255_TO_XCOLOR(pUserData->iRed, pUserData->iGreen, pUserData->iBlue, clr);
  PXM_RGBToPixel(&(pUserData->stdColorMap), &clr); // make sure the pixel is correct

  pUserData->lPixel = clr.pixel; // and now I'm consistent!

  iRval = pUserData->lOldP != pUserData->lPixel ||
          pUserData->iOldR != pUserData->iRed ||
          pUserData->iOldG != pUserData->iGreen ||
          pUserData->iOldB != pUserData->iBlue ||
          pUserData->iOldC != pUserData->iChroma ||
          pUserData->iOldL != pUserData->iLuma ||
          pUserData->iOldS != pUserData->iSaturation;

  // fix all of the 'old' values to match
  pUserData->iOldR = pUserData->iRed;
  pUserData->iOldG = pUserData->iGreen;
  pUserData->iOldB = pUserData->iBlue;

  pUserData->iOldC = pUserData->iChroma;
  pUserData->iOldL = pUserData->iLuma;
  pUserData->iOldS = pUserData->iSaturation;

  pUserData->lOldP = pUserData->lPixel;

  return iRval;
}

static void ColorDialogAssignColorboxPixmap(Display *pDisplay, WBDialogControl *pCtrl, unsigned long lPixel)
{
GC gc;
Pixmap pxTemp;
XGCValues xgcv;
int iW = COLORBOX_PIXMAP_WIDTH;
int iH = COLORBOX_PIXMAP_HEIGHT;
//WB_GEOM geom;


//  // TEMPORARY - to make sure I fill the thing...
//  WBGetWindowGeom(pCtrl->wID, &geom);
//
//  if((geom.width - 4) > iW || (geom.height - 4) > iH)
//  {
//    WB_ERROR_PRINT("TEMPORARY:  %s - re-assign width/height from %d,%d to %d,%d\n",
//                   __FUNCTION__, iW, iH, geom.width - 4, geom.height - 4);
//
//    iW = geom.width - 4;
//    iH = geom.height - 4;
//  }

  // step 1: a simple graphics context to fill the rectangle with

  bzero(&xgcv, sizeof(xgcv));
  xgcv.foreground = lPixel;
  xgcv.background = lPixel;
  xgcv.line_width = 1;
  xgcv.function = GXcopy; // copy
  xgcv.cap_style = CapProjecting;

  gc = XCreateGC(pDisplay, pCtrl->wID,
                 (GCForeground | GCBackground | GCCapStyle | GCFunction | GCLineWidth),
                 &xgcv);

  if(gc == None)
  {
    WB_ERROR_PRINT("ERROR:  %s - unable to create gc for pixmap\n", __FUNCTION__);
    return;
  }

//  XSetForeground(pDisplay, gc, lPixel);
//  XSetBackground(pDisplay, gc, lPixel); // assign to the same color

  // step 2:  create a pixmap that's the right size

  pxTemp = XCreatePixmap(pDisplay, pCtrl->wID, iW, iH,
                         DefaultDepth(pDisplay, DefaultScreen(pDisplay)));

  if(pxTemp == None)
  {
    WB_ERROR_PRINT("ERROR:  %s - unable to create pixmap\n", __FUNCTION__);
  }
  else
  {
    XFillRectangle(pDisplay, pxTemp, gc, 0, 0, iW, iH);

    // set pixmap for control now - control will own it.

    WBDialogControlSetPixmap(pCtrl, pxTemp); // and done!
  }

  WBDialogControlInvalidateGeom(pCtrl, NULL, 1); // paints immediately

  XFreeGC(pDisplay, gc);
}

static void ColorDialogAssignLumaSatPixmap(Display *pDisplay, WBDialogControl *pCtrl, int iS, int iV)
{
}

static void ColorDialogAssignChromaPixmap(Display *pDisplay, WBDialogControl *pCtrl, int iH)
{
}

static unsigned long ColorDialogGetPixelValueFromControl(WBDialogControl *pCtrl)
{
const char *pTemp;
const char *p3;
unsigned long lPixel;


  lPixel = 0; // pre-assign to zero

  pTemp = WBDialogControlGetCaption(pCtrl);

  if(pTemp && *pTemp)
  {
    p3 = pTemp;
    while(*p3 && *p3 <= ' ') // skip leading white space
    {
      p3++;
    }
    if(*p3 == '#')
    {
      sscanf(p3 + 1, "%lX", &lPixel);
    }
    else if(!strncasecmp("0x", p3, 2))
    {
      sscanf(p3, "%lX", &lPixel);
    }
    else
    {
      sscanf(p3, "%ld", &lPixel);
    }

    lPixel &= 0xffffffff; // for now, limit to a 32-bit value (later, allow 64-bit colors?)
  }

  return lPixel;
}


static int ColorDialogCallback(Window wID, XEvent *pEvent)
{
Display *pDisplay = WBGetWindowDisplay(wID);
WBDialogWindow *pDlg = DLGGetDialogWindowStruct(wID);
struct _COLOR_DIALOG_ *pUserData = (struct _COLOR_DIALOG_ *)(pDlg ? pDlg->pUserData : NULL);
//Display *pDisplay = WBGetWindowDisplay(wID);


  if(!pDlg || !pUserData)
  {
    return 0; // can't process any messages now
  }

  if(pEvent->type == ClientMessage && pEvent->xclient.message_type == aDIALOG_INIT)
  {
    // initialize dialog box

    ColorDialogDataFromPixel(pUserData); // make everything in 'pUserData' consistent

    // now, assign correct values to the image coordinates representing color info
    if(pUserData->lPixel == 0) // black
    {
      pUserData->iXLumaSat = 0;
      pUserData->iYLumaSat = 0;
    }
    else
    {
      pUserData->iXLumaSat = (pUserData->iLuma + (COLOR_IMAGE_COLOR_FACTOR - 1))
                           / COLOR_IMAGE_COLOR_FACTOR;
      pUserData->iYLumaSat = COLOR_IMAGE_SIZE
                           - (pUserData->iSaturation + (COLOR_IMAGE_COLOR_FACTOR - 1))
                             / COLOR_IMAGE_COLOR_FACTOR;
    }

    pUserData->iXChroma = (pUserData->iChroma + (COLOR_IMAGE_COLOR_FACTOR - 1))
                        / COLOR_IMAGE_COLOR_FACTOR;

    pUserData->iOldXLS = pUserData->iOldYLS = pUserData->iOldXC = -1; // force re-initialization, just in case

    ColorDialogImagesFromData(pDisplay, WBGetDialogEntryControlStruct(pDlg, LUMA_SAT_PICKER),
                              WBGetDialogEntryControlStruct(pDlg, CHROMA_PICKER), pUserData);

    WBDialogControlSetCaptionInt(WBGetDialogEntryControlStruct(pDlg, LUMA_BOX),
                                 pUserData->iLuma, NULL);
    WBDialogControlSetCaptionInt(WBGetDialogEntryControlStruct(pDlg, CHROMA_BOX),
                                 pUserData->iChroma, NULL);
    WBDialogControlSetCaptionInt(WBGetDialogEntryControlStruct(pDlg, SAT_BOX),
                                 pUserData->iSaturation, NULL);

    WBDialogControlSetCaptionInt(WBGetDialogEntryControlStruct(pDlg, RED_BOX),
                                 pUserData->iRed, NULL);
    WBDialogControlSetCaptionInt(WBGetDialogEntryControlStruct(pDlg, GREEN_BOX),
                                 pUserData->iGreen, NULL);
    WBDialogControlSetCaptionInt(WBGetDialogEntryControlStruct(pDlg, BLUE_BOX),
                                 pUserData->iBlue, NULL);

    WBDialogControlSetCaptionLong(WBGetDialogEntryControlStruct(pDlg, COLORBOX_VALUE),
                                  pUserData->lPixel, "#%-08.8lX");

    ColorDialogAssignColorboxPixmap(pDisplay, WBGetDialogEntryControlStruct(pDlg, COLORBOX_VALUE),
                                    pUserData->lPixel);

    ColorDialogAssignLumaSatPixmap(pDisplay, WBGetDialogEntryControlStruct(pDlg, LUMA_SAT_PICKER),
                                   pUserData->iSaturation, pUserData->iLuma);
    ColorDialogAssignChromaPixmap(pDisplay, WBGetDialogEntryControlStruct(pDlg, CHROMA_PICKER),
                                  pUserData->iChroma);

    return 1;
  }

  if(pEvent->type != ClientMessage)
  {
    return 0; // unhandled at this time
  }

  // EVERYTHING AT THIS POINT IS A CLIENT MESSAGE

  if(pEvent->xclient.message_type == aCONTROL_NOTIFY)
  {
    // l[0] == message
    // l[1] == control ID
    // l[2] == hashed pointer to control's structure
    // [the rest are event dependent]

    if(pEvent->xclient.data.l[0] == aBUTTON_PRESS)
    {
      switch(pEvent->xclient.data.l[1])
      {
        case IDOK:
        case IDCANCEL:
          if(pEvent->xclient.data.l[1] == IDOK)
          {
            // do any data copying that's necessary on 'OK'

            pUserData->iRed = WBDialogControlGetCaptionInt(WBGetDialogEntryControlStruct(pDlg, RED_BOX));
            pUserData->iGreen = WBDialogControlGetCaptionInt(WBGetDialogEntryControlStruct(pDlg, GREEN_BOX));
            pUserData->iBlue = WBDialogControlGetCaptionInt(WBGetDialogEntryControlStruct(pDlg, BLUE_BOX));

            if(pUserData->iRed != pUserData->iOldR ||
               pUserData->iGreen != pUserData->iOldG ||
               pUserData->iBlue != pUserData->iOldB)
            {
              ColorDialogHSVFromRGB(pUserData);
            }
            else
            {
              pUserData->lPixel = ColorDialogGetPixelValueFromControl(WBGetDialogEntryControlStruct(pDlg, COLORBOX_VALUE));

              if(pUserData->lPixel != pUserData->lOldP)
              {
                ColorDialogDataFromPixel(pUserData); // make everything in 'pUserData' consistent with 'lPixel'
              }
              else
              {
                pUserData->iLuma = WBDialogControlGetCaptionInt(WBGetDialogEntryControlStruct(pDlg, LUMA_BOX));
                pUserData->iChroma = WBDialogControlGetCaptionInt(WBGetDialogEntryControlStruct(pDlg, CHROMA_BOX));
                pUserData->iSaturation = WBDialogControlGetCaptionInt(WBGetDialogEntryControlStruct(pDlg, SAT_BOX));

                if(pUserData->iLuma != pUserData->iOldL ||
                   pUserData->iChroma != pUserData->iOldC ||
                   pUserData->iSaturation != pUserData->iOldS)
                {
                  ColorDialogRGBFromHSV(pUserData); // fix it
                }
              }
            }

            if(pUserData->pColor) // if I have an XColor, which I should, then set it up correctly
            {
              pUserData->pColor->pixel = pUserData->lPixel;
              PXM_PixelToRGB(&(pUserData->stdColorMap), pUserData->pColor);
            }
            else // the following code won't execute at this time, left for reference later
            {
              // TODO:  send a notification event to the owner window??
            }
          }

          WBEndModal(wID, pEvent->xclient.data.l[1]); // all buttons close the dialog box
          return 1; // handled!
      }
    }
    else if((pEvent->xclient.data.l[0] == aMOUSE_CLICK ||
             pEvent->xclient.data.l[0] == aMOUSE_DBLCLICK ||
             pEvent->xclient.data.l[0] == aMOUSE_DRAG) &&
            WB_LIKELY(pEvent->xclient.data.l[1] == LUMA_SAT_PICKER ||
                      pEvent->xclient.data.l[1] == CHROMA_PICKER))
    {
#ifndef NO_DEBUG
      char *p1 = WBGetAtomName(WBGetWindowDisplay(wID), (Atom)pEvent->xclient.data.l[0]);

      WB_ERROR_PRINT("%s - TODO:  control MOUSE notification message %ld (%s)  %ld (%08lxH), %ld (%08lxH), %ld (%08lxH), %ld (%08lxH)\n",
                     __FUNCTION__, pEvent->xclient.data.l[0], p1,
                     pEvent->xclient.data.l[1], pEvent->xclient.data.l[1],
                     pEvent->xclient.data.l[2], pEvent->xclient.data.l[2],
                     pEvent->xclient.data.l[3], pEvent->xclient.data.l[3],
                     pEvent->xclient.data.l[4], pEvent->xclient.data.l[4]);

      if(p1)
      {
        WBFree(p1);
      }
#endif // NO_DEBUG
    }
    else
    {
#ifndef NO_DEBUG
      char *p1 = WBGetAtomName(WBGetWindowDisplay(wID), (Atom)pEvent->xclient.data.l[0]);

      WB_WARN_PRINT("%s - TODO:  control notification message %ld (%s)  %ld (%08lxH), %ld (%08lxH)\n",
                    __FUNCTION__, pEvent->xclient.data.l[0], p1,
                    pEvent->xclient.data.l[1], pEvent->xclient.data.l[1],
                    pEvent->xclient.data.l[2], pEvent->xclient.data.l[2]);

      if(p1)
      {
        WBFree(p1);
      }
#endif // NO_DEBUG
    }
  }
  else if(pEvent->xclient.message_type == aLOSTFOCUS) // monitor these
  {
    switch(pEvent->xclient.data.l[0]) // the control identifier
    {
      case IDOK:
      case IDCANCEL:
        break; // don't bother here

      case COLORBOX_VALUE:
        pUserData->lPixel = ColorDialogGetPixelValueFromControl(WBGetDialogEntryControlStruct(pDlg, COLORBOX_VALUE));

        if(pUserData->lPixel != pUserData->lOldP) // value changed?
        {
          WB_ERROR_PRINT("TEMPORARY:  %s - Color Value Box Changed from %ld to %ld\n", __FUNCTION__, pUserData->lOldP, pUserData->lPixel);

          ColorDialogDataFromPixel(pUserData); // make everything in 'pUserData' consistent with 'lPixel'

          goto fix_rgb_hsv_and_colors;
        }

        break; // no change so bust out now

      case LUMA_SAT_PICKER:
      case CHROMA_PICKER:

        // NOTE:  click/drag on color boxen should automatically fix luma/chroma/sat
        //        while clicking and dragging, so assume it's good now
        if(ColorDialogRGBFromHSV(pUserData)) // fixes everything
        {
fix_rgb_hsv_and_colors:
          WBDialogControlSetCaptionInt(WBGetDialogEntryControlStruct(pDlg, LUMA_BOX),
                                       pUserData->iLuma, NULL);
          WBDialogControlSetCaptionInt(WBGetDialogEntryControlStruct(pDlg, CHROMA_BOX),
                                       pUserData->iChroma, NULL);
          WBDialogControlSetCaptionInt(WBGetDialogEntryControlStruct(pDlg, SAT_BOX),
                                       pUserData->iSaturation, NULL);

          WBDialogControlSetCaptionInt(WBGetDialogEntryControlStruct(pDlg, RED_BOX),
                                       pUserData->iRed, NULL);
          WBDialogControlSetCaptionInt(WBGetDialogEntryControlStruct(pDlg, GREEN_BOX),
                                       pUserData->iGreen, NULL);
          WBDialogControlSetCaptionInt(WBGetDialogEntryControlStruct(pDlg, BLUE_BOX),
                                       pUserData->iBlue, NULL);

          // ALWAYS do this one - it reformats the text in 'COLORBOX_VALUE' to standard color designator
          WBDialogControlSetCaptionLong(WBGetDialogEntryControlStruct(pDlg, COLORBOX_VALUE),
                                        pUserData->lPixel, "#%-08.8lX");

          ColorDialogAssignColorboxPixmap(pDisplay, WBGetDialogEntryControlStruct(pDlg, COLORBOX), pUserData->lPixel);

          if(pEvent->xclient.data.l[1] == COLORBOX_VALUE) // for color value, do the next part
          {
            ColorDialogAssignLumaSatPixmap(pDisplay, WBGetDialogEntryControlStruct(pDlg, LUMA_SAT_PICKER),
                                           pUserData->iSaturation, pUserData->iLuma);
            ColorDialogAssignChromaPixmap(pDisplay, WBGetDialogEntryControlStruct(pDlg, CHROMA_PICKER),
                                          pUserData->iChroma);
          }
        }

        break;

      case LUMA_BOX:
        pUserData->iLuma = WBDialogControlGetCaptionInt(WBGetDialogEntryControlStruct(pDlg, LUMA_BOX)) & 0xff;
        if(pUserData->iLuma != pUserData->iOldL) // value changed?
        {
          WB_ERROR_PRINT("TEMPORARY:  %s - Luma Box Changed from %d to %d\n", __FUNCTION__, pUserData->iOldL, pUserData->iLuma);
fix_rgb_and_colors:
          ColorDialogRGBFromHSV(pUserData);

          WBDialogControlSetCaptionInt(WBGetDialogEntryControlStruct(pDlg, RED_BOX),
                                       pUserData->iRed, NULL);
          WBDialogControlSetCaptionInt(WBGetDialogEntryControlStruct(pDlg, GREEN_BOX),
                                       pUserData->iGreen, NULL);
          WBDialogControlSetCaptionInt(WBGetDialogEntryControlStruct(pDlg, BLUE_BOX),
                                       pUserData->iBlue, NULL);

          WBDialogControlSetCaptionLong(WBGetDialogEntryControlStruct(pDlg, COLORBOX_VALUE),
                                        pUserData->lPixel, "#%-08.8lX");

          ColorDialogAssignColorboxPixmap(pDisplay, WBGetDialogEntryControlStruct(pDlg, COLORBOX), pUserData->lPixel);
          ColorDialogAssignLumaSatPixmap(pDisplay, WBGetDialogEntryControlStruct(pDlg, LUMA_SAT_PICKER),
                                         pUserData->iSaturation, pUserData->iLuma);
          ColorDialogAssignChromaPixmap(pDisplay, WBGetDialogEntryControlStruct(pDlg, CHROMA_PICKER),
                                        pUserData->iChroma);
        }

        break;

      case CHROMA_BOX:
        pUserData->iChroma = WBDialogControlGetCaptionInt(WBGetDialogEntryControlStruct(pDlg, CHROMA_BOX)) & 0xff;
        if(pUserData->iChroma != pUserData->iOldC) // value changed?
        {
          WB_ERROR_PRINT("TEMPORARY:  %s - Chroma Box Changed from %d to %d\n", __FUNCTION__, pUserData->iOldC, pUserData->iChroma);
          goto fix_rgb_and_colors;
        }

        break;

      case SAT_BOX:
        pUserData->iSaturation = WBDialogControlGetCaptionInt(WBGetDialogEntryControlStruct(pDlg, CHROMA_BOX)) & 0xff;
        if(pUserData->iSaturation != pUserData->iOldS) // value changed?
        {
          WB_ERROR_PRINT("TEMPORARY:  %s - Sat Box Changed from %d to %d\n", __FUNCTION__, pUserData->iOldS, pUserData->iSaturation);
          goto fix_rgb_and_colors;
        }

        break;


      case RED_BOX:
        pUserData->iRed = WBDialogControlGetCaptionInt(WBGetDialogEntryControlStruct(pDlg, RED_BOX)) & 0xff;
        if(pUserData->iRed != pUserData->iOldR) // value changed?
        {
          WB_ERROR_PRINT("TEMPORARY:  %s - Red Box Changed from %d to %d\n", __FUNCTION__, pUserData->iOldR, pUserData->iRed);
fix_hsv_and_colors:
          ColorDialogHSVFromRGB(pUserData);

          WBDialogControlSetCaptionInt(WBGetDialogEntryControlStruct(pDlg, LUMA_BOX),
                                       pUserData->iLuma, NULL);
          WBDialogControlSetCaptionInt(WBGetDialogEntryControlStruct(pDlg, CHROMA_BOX),
                                       pUserData->iChroma, NULL);
          WBDialogControlSetCaptionInt(WBGetDialogEntryControlStruct(pDlg, SAT_BOX),
                                       pUserData->iSaturation, NULL);

          WBDialogControlSetCaptionLong(WBGetDialogEntryControlStruct(pDlg, COLORBOX_VALUE),
                                        pUserData->lPixel, "#%-08.8lX");

          ColorDialogAssignColorboxPixmap(pDisplay, WBGetDialogEntryControlStruct(pDlg, COLORBOX), pUserData->lPixel);
          ColorDialogAssignLumaSatPixmap(pDisplay, WBGetDialogEntryControlStruct(pDlg, LUMA_SAT_PICKER),
                                         pUserData->iSaturation, pUserData->iLuma);
          ColorDialogAssignChromaPixmap(pDisplay, WBGetDialogEntryControlStruct(pDlg, CHROMA_PICKER),
                                        pUserData->iChroma);
        }

        break;

      case GREEN_BOX:
        pUserData->iGreen = WBDialogControlGetCaptionInt(WBGetDialogEntryControlStruct(pDlg, GREEN_BOX)) & 0xff;
        if(pUserData->iGreen != pUserData->iOldG) // value changed?
        {
          WB_ERROR_PRINT("TEMPORARY:  %s - Green Box Changed from %d to %d\n", __FUNCTION__, pUserData->iOldG, pUserData->iGreen);
          goto fix_hsv_and_colors;
        }

        break;

      case BLUE_BOX:
        pUserData->iBlue = WBDialogControlGetCaptionInt(WBGetDialogEntryControlStruct(pDlg, BLUE_BOX)) & 0xff;
        if(pUserData->iBlue != pUserData->iOldB) // value changed?
        {
          WB_ERROR_PRINT("TEMPORARY:  %s - Blue Box Changed from %d to %d\n", __FUNCTION__, pUserData->iOldB, pUserData->iBlue);
          goto fix_hsv_and_colors;
        }

        break;
    }
    return 0; // I want this to happen because it lets other things happen, too
  }
  else if(pEvent->xclient.message_type == aGOTFOCUS)
  {
//#ifndef NO_DEBUG
//    {
//      char *p1 = WBGetAtomName(WBGetWindowDisplay(wID), (Atom)pEvent->xclient.data.l[0]);
//
//      WB_WARN_PRINT("TEMPORARY:  %s - GOT FOCUS notification message %ld (%s)  %ld (%08lxH), %ld (%08lxH)\n",
//                    __FUNCTION__, pEvent->xclient.data.l[0], p1,
//                    pEvent->xclient.data.l[1], pEvent->xclient.data.l[1],
//                    pEvent->xclient.data.l[2], pEvent->xclient.data.l[2]);
//
//      if(p1)
//      {
//        WBFree(p1);
//      }
//    }
//#endif // NO_DEBUG

    // control ID is in pEvent->xclient.data.l[0]

    return 0; // for now
  }
  else
  {
#ifndef NO_DEBUG
    char *p1 = WBGetAtomName(WBGetWindowDisplay(wID), (Atom)pEvent->xclient.message_type);
    char *p2 = WBGetAtomName(WBGetWindowDisplay(wID), (Atom)pEvent->xclient.data.l[0]);

    WB_WARN_PRINT("%s - unhandled ClientMessage %d (%s) %ld (%s)  %ld (%08lxH), %ld (%08lxH)\n",
                  __FUNCTION__, (int)pEvent->xclient.message_type, (const char *)(p1 ? p1 : "(Null)"),
                  pEvent->xclient.data.l[0], (const char *)(p2 ? p2 : "(Null)"),
                  pEvent->xclient.data.l[1], pEvent->xclient.data.l[1],
                  pEvent->xclient.data.l[2], pEvent->xclient.data.l[2]);

    if(p1)
    {
      WBFree(p1);
    }
    if(p2)
    {
      WBFree(p2);
    }
#endif // NO_DEBUG
  }

  return 0;
}

int DLGColorDialog(Window wIDOwner, XStandardColormap *pColorMap, XColor *pColor)
{
static const char szColorDialogRes[]=
  "BEGIN_DIALOG FONT:Variable HEIGHT:182 WIDTH:280 TITLE:\"Color Chooser\"\n"

  // these controls are first in the tab order
  "  CONTROL:Image ID:1009          X:150 Y:120 WIDTH:50 HEIGHT:14 VISIBLE\n"
  "  CONTROL:Text  TITLE:\"Value:\" X:200 Y:122 WIDTH:24 HEIGHT:10 NOBORDER VISIBLE VALIGN_TEXT_CENTER HALIGN_TEXT_RIGHT\n"
  "  CONTROL:Edit  ID:1010          X:228 Y:122 WIDTH:40 HEIGHT:10 VISIBLE\n"

  // then the buttons
  "  CONTROL:DefPushButton ID:IDOK     TITLE:OK     X:60 Y:160 WIDTH:40 HEIGHT:18 VISIBLE\n"
  "  CONTROL:CancelButton  ID:IDCANCEL TITLE:Cancel X:180 Y:160 WIDTH:40 HEIGHT:18 VISIBLE\n"

  // then the images
  "  CONTROL:Image ID:1001 X:2 Y:2   HEIGHT:132 WIDTH:132 VISIBLE CLICKABLE\n" // 128x128 image, luma/saturation
  "  CONTROL:Image ID:1002 X:2 Y:136 HEIGHT:16  WIDTH:132 VISIBLE CLICKABLE\n" // 128x12 image, chroma

  // then the rest
  "  CONTROL:Text  TITLE:\"Lum:\"  X:140 Y:22 WIDTH:22 HEIGHT:10 NOBORDER VISIBLE VALIGN_TEXT_CENTER HALIGN_TEXT_RIGHT\n"
  "  CONTROL:Edit  ID:1003         X:164 Y:22 WIDTH:28 HEIGHT:10 VISIBLE\n"
  "  CONTROL:Text  TITLE:\"Chr:\"  X:140 Y:44 WIDTH:22 HEIGHT:10 NOBORDER VISIBLE VALIGN_TEXT_CENTER HALIGN_TEXT_RIGHT\n"
  "  CONTROL:Edit  ID:1004         X:164 Y:44 WIDTH:28 HEIGHT:10 VISIBLE\n"
  "  CONTROL:Text  TITLE:\"Sat:\"  X:140 Y:66 WIDTH:22 HEIGHT:10 NOBORDER VISIBLE VALIGN_TEXT_CENTER HALIGN_TEXT_RIGHT\n"
  "  CONTROL:Edit  ID:1005         X:164 Y:66 WIDTH:28 HEIGHT:10 VISIBLE\n"

  "  CONTROL:Text  TITLE:\"Red:\"  X:210 Y:22 WIDTH:22 HEIGHT:10 NOBORDER VISIBLE VALIGN_TEXT_CENTER HALIGN_TEXT_RIGHT\n"
  "  CONTROL:Edit  ID:1006         X:234 Y:22 WIDTH:28 HEIGHT:10 VISIBLE\n"
  "  CONTROL:Text  TITLE:\"Grn:\"  X:210 Y:44 WIDTH:22 HEIGHT:10 NOBORDER VISIBLE VALIGN_TEXT_CENTER HALIGN_TEXT_RIGHT\n"
  "  CONTROL:Edit  ID:1007         X:234 Y:44 WIDTH:28 HEIGHT:10 VISIBLE\n"
  "  CONTROL:Text  TITLE:\"Blu:\"  X:210 Y:66 WIDTH:22 HEIGHT:10 NOBORDER VISIBLE VALIGN_TEXT_CENTER HALIGN_TEXT_RIGHT\n"
  "  CONTROL:Edit  ID:1008         X:234 Y:66 WIDTH:28 HEIGHT:10 VISIBLE\n"

  "END_DIALOG\n";
WBDialogWindow *pDlg;
Display *pDisplay;
struct _COLOR_DIALOG_ data;
int iRval = IDCANCEL; // default return is 'cancel'
Window wIDDlg;


  if(!pColor)
  {
    return -1; // not valid
  }

  if(wIDOwner)
  {
    pDisplay = WBGetWindowDisplay(wIDOwner);
  }
  else
  {
    pDisplay = WBGetDefaultDisplay();
  }

  memset(&data, 0, sizeof(data));

  if(WB_LIKELY(pColorMap)) // should always be the case
  {
    memcpy(&(data.stdColorMap), pColorMap, sizeof(data.stdColorMap));
  }
  else
  {
    WBDefaultStandardColormap(pDisplay, &(data.stdColorMap));
  }

  data.pColor = pColor; // pixel value will become initial color
  data.pimgLumaSat = NULL;
  data.pimgChroma = NULL;
  data.pixmapLumaSat = None;
  data.pixmapChroma = None;

  data.lPixel = pColor->pixel; // cache it - the rest will take care of itself

  // now that all of THAT is done, do the dialog box

  pDlg = DLGCreateDialogWindow("Color Chooser",szColorDialogRes,
                               100,100,300,100,ColorDialogCallback,
                               WBDialogWindow_VISIBLE,&data);

  if(pDlg) // TODO:  manage this stuff as part of 'DLGCreateDialogWindow' instead
  {
    wIDDlg = pDlg->wID;

    if(wIDOwner != None)
    {
      Atom a1;
      unsigned int ai1[3];

      DLGAssignOwner(pDlg, wIDOwner);

      a1 = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE", False);
      ai1[0] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_TASKBAR", False);
      ai1[1] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_PAGER", False);

      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_ATOM, 32, PropModeReplace, (unsigned char *)ai1, 2);

      a1 = XInternAtom(WBGetWindowDisplay(wIDDlg), "WM_TRANSIENT_FOR", False);
      XChangeProperty(WBGetWindowDisplay(wIDDlg), wIDDlg, a1, XA_WINDOW, 32, PropModeReplace, (unsigned char *)&wIDOwner, 1);
    }

    iRval = WBShowModal(pDlg->wID, 0);

    if(iRval == IDOK)
    {
      // check pColor assigned via data.pColor?
    }
  }

  // free up any resources here


  return iRval;
}



//////////////
// FONT DIALOG
//////////////


XFontSet DLGFontDialog(Display *pDisplay, Window wIDOwner, XFontSet fsDefault)
{
  return None;
}




////////////////
// SPLASH SCREEN
////////////////


// construct a splash screen based on the size of the pixmap and position
// the copyright text in the lower 1/3 of the splash screen, centered, then
// pass a 'diagonal flash' across it, and close the screen after a total of
// 5 seconds, returning back to the application.

typedef struct _SPLASH_
{
  Pixmap pixmap, pixmap2;
  char *szCopyright;
  int iW, iH; // width/height of bitmap
  int iDepth; // depth, needed to create compatible pixmaps
  int nIter; // total # of iterations thus far
  XFontSet fontSet;//Struct *pFont;
  int nGleam;      // current gleam center position
  WB_GEOM geomBorder;
  XStandardColormap cmap;
  XImage *pImage;
  void *pImageData;
  unsigned long cbImageData;
  unsigned long clrText, clrBlack, clrWhite; // pixel colors
} SPLASH;

static int splash_callback(Window wID, XEvent *pEvent);
static int SplashDoExposeEvent(XExposeEvent *pEvent, Display *pDisplay,
                               Window wID, struct _SPLASH_ *pData);

#define SPLASH_FRAMERATE 30 /* make this configurable? */
#define SPLASH_TIME 1500 /* milliseconds */

void DLGSplashScreen(char *aXPM[], const char *szCopyright, unsigned long clrText)
{
Window wID;//, wIDTemp;
XSetWindowAttributes xswa;  /* Temporary Set Window Attribute struct */
int iX, iY, iW, iH;
XSizeHints  xsh;            /* Size hints for window manager */
XWMHints xwmh;
XPM_ATTRIBUTES xattr;
SPLASH data;
Atom a1;
unsigned int ai1[3];


  bzero(&data, sizeof(data));
  bzero(&xattr, sizeof(xattr));

  if(XPM_CREATE_PIXMAP_FROM_DATA(WBGetDefaultDisplay(), WBGetHiddenHelperWindow(),
                                 aXPM, &(data.pixmap), &(data.pixmap2), &xattr))
  {
    WB_ERROR_PRINT("XPM_CREATE_PIXMAP_FROM_DATA ERROR\n");
    return;
  }

  iW = xattr.width + 4;  // border width is 2
  iH = xattr.height + 4; // border width is 2
  data.iDepth = xattr.depth;
  if(!data.iDepth)
  {
    data.iDepth = DefaultDepth(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));
  }

  if(!iW || !iH || data.pixmap == None)
  {
    WB_ERROR_PRINT("%s - iW=%d, iH=%d, data.pixmap=%d (%08xH)\n",
                   __FUNCTION__, iW, iH, (int)data.pixmap, (int)data.pixmap);
    return;
  }

//  WB_ERROR_PRINT("TEMPORARY %s - iW=%d, iH=%d, data.pixmap=%d (%08xH)\n",
//                 __FUNCTION__, iW, iH, (int)data.pixmap, (int)data.pixmap);

  // TODO:  choose font, calculate bounds of text area
  //        save font/bounds data and/or combine text into pixmap with transparent background


  iX = DisplayWidth(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));
  iY = DisplayHeight(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));

  iX = (iX - iW) / 2;
  iY = (iY - iH) / 2; // centered

  data.szCopyright = WBCopyString(szCopyright);
  data.clrText = clrText;
  data.clrBlack = BlackPixel(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));
  data.clrWhite = WhitePixel(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));
  data.iW = xattr.width;
  data.iH = xattr.height;
  data.fontSet = None;  // must do this
  data.nGleam = 0;
  data.pImage = NULL;
  data.pImageData = NULL;
  data.cbImageData = 0;

  bzero(&xswa, sizeof(xswa));

  xswa.border_pixel = data.clrBlack;
  xswa.background_pixel = data.clrWhite;
  xswa.colormap = DefaultColormap(WBGetDefaultDisplay(), DefaultScreen(WBGetDefaultDisplay()));
  xswa.bit_gravity = CenterGravity;

  wID = WBCreateWindow(WBGetDefaultDisplay(), None,//DefaultRootWindow(WBGetDefaultDisplay()),
                       splash_callback, "Splash",
                       iX, iY, iW, iH, 0,
                       InputOutput,
                       CWBorderPixel | CWBackPixel | CWColormap | CWBitGravity | CWOverrideRedirect,
                       &xswa);

  if(wID <= 0)
  {
    return;
  }

  WBSetWindowData(wID, 0, (void *)&data);
  WBCreateWindowDefaultGC(wID, clrText, xswa.background_pixel);

  bzero(&xsh, sizeof(xsh));

  xsh.flags = (USPosition | USSize | PBaseSize | PMinSize | PMaxSize | PWinGravity);
  xsh.x = iX;
  xsh.y = iY;
  xsh.width = xsh.base_width = xsh.min_width = xsh.max_width = iW;
  xsh.height = xsh.base_height = xsh.min_height = xsh.max_height = iH;
  xsh.win_gravity = NorthWestGravity; // StaticGravity

  bzero(&xwmh, sizeof(xwmh));
  xwmh.flags = InputHint;
  xwmh.input = 0;  // never take focus

  // set title, size hints, and 'WM_HINTS' hints (so WM knows where to put the window and how to set focus)
  WBSetWMProperties(wID, "splashwindow", &xsh, &xwmh, NULL);

  // before mapping the window, set some properties
  a1 = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_WINDOW_TYPE", False);
  ai1[0] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_WINDOW_TYPE_SPLASH", False);
  XChangeProperty(WBGetDefaultDisplay(), wID, a1, XA_ATOM, 32, PropModeReplace, (unsigned char *)ai1, 1);


  a1 = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE", False);
  ai1[0] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_MODAL", False);
  ai1[1] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_TASKBAR", False);
  ai1[2] = XInternAtom(WBGetDefaultDisplay(), "_NET_WM_STATE_SKIP_PAGER", False);
  XChangeProperty(WBGetDefaultDisplay(), wID, a1, XA_ATOM, 32, PropModeReplace, (unsigned char *)ai1, 3);

  // must EXPLICITLY allow PAINTING (and other stuff) i.e. ExposureMask
  XSelectInput(WBGetDefaultDisplay(), wID, WB_STANDARD_INPUT_MASK);

  WBDefaultStandardColormap(WBGetDefaultDisplay(), &data.cmap);

  if(CreateTimer(WBGetDefaultDisplay(), wID, 1000000 / SPLASH_FRAMERATE, 1, 1)) // periodic timer at 'frame rate'
  {
    WBDestroyWindow(wID);
  }
  else
  {
    WBMapWindow(WBGetDefaultDisplay(), wID);  // make window visible

    WBShowModal(wID, -1); // timer will cause window to go away automatically
  }

  if(data.szCopyright)
  {
    WBFree((void *)data.szCopyright);
  }

  if(data.pImageData)
  {
    WBFree(data.pImageData);
  }

  BEGIN_XCALL_DEBUG_WRAPPER
  if(data.pImage)
  {
    XDestroyImage(data.pImage);
  }

  if(data.pixmap != None)
  {
    XFreePixmap(WBGetDefaultDisplay(), data.pixmap);
    data.pixmap = None;
  }

  if(data.pixmap2 != None)
  {
    XFreePixmap(WBGetDefaultDisplay(), data.pixmap2);
    data.pixmap2 = None;
  }

  if(data.fontSet)
  {
    XFreeFontSet(WBGetDefaultDisplay(), data.fontSet);
  }
  END_XCALL_DEBUG_WRAPPER
}

static int splash_callback(Window wID, XEvent *pEvent)
{
Display *pDisplay = WBGetWindowDisplay(wID);
struct _SPLASH_ *pData = (struct _SPLASH_ *)WBGetWindowData(wID, 0);


  if(pData && pEvent->type == Expose)
  {
    return SplashDoExposeEvent((XExposeEvent *)pEvent, pDisplay, wID, pData);
  }

  if(pEvent->type == ClientMessage &&
     pEvent->xclient.message_type == aWB_TIMER)
  {
    if(!pData)
    {
      DeleteTimer(WBGetDefaultDisplay(), wID, 1);
      WBUnmapWindow(WBGetDefaultDisplay(), wID);
      WBDestroyWindow(wID);
      return 1;
    }

    pData->nIter ++;

    if(pData->nIter * 1000 >= SPLASH_FRAMERATE * (SPLASH_TIME + 1000))
    {
      DeleteTimer(WBGetDefaultDisplay(), wID, 1);
      WBSetWindowData(wID, 0, NULL);
      WBDestroyWindow(wID);
    }
    else
    {
      WBInvalidateGeom(wID, NULL, 1);
    }

    return 1;
  }

  // special handling for 'destroy'
  if(pEvent->type == DestroyNotify &&
     pEvent->xdestroywindow.window == wID)
  {
    WB_DEBUG_PRINT(DebugLevel_Heavy | DebugSubSystem_Event | DebugSubSystem_DialogCtrl,
                   "%s - DestroyNotify\n", __FUNCTION__);

    WBSetWindowData(wID, 0, NULL);

    return 1;
  }

  return 0;  // not handled
}

static int SplashDoExposeEvent(XExposeEvent *pEvent, Display *pDisplay,
                               Window wID, struct _SPLASH_ *pData)
{
XFontSet fontSet;
GC gc;
Pixmap pxTemp;
XGCValues xgcv;
WB_GEOM geomText;
int iX, iY, iTimeStart, iTimeEnd;


  if(!pDisplay)
  {
    pDisplay = WBGetDefaultDisplay();
  }

//  gc = WBBeginPaint(wID, pEvent, &geomPaint);  // gnome b0rks this - window has absolute coordinates!

  if(pData->fontSet == None && pData->szCopyright && *(pData->szCopyright))
  {
    fontSet = DTCalcIdealFontSet(WBGetDefaultDisplay(), WBGetDefaultFontSet(WBGetDefaultDisplay()),
                                 pData->szCopyright, &geomText);

    if(fontSet == None)
    {
      fontSet = WBFontSetFromFont(WBGetDefaultDisplay(), WBGetDefaultFont()); // makes a copy of the font set, basically
    }

    pData->fontSet = fontSet;
  }

  fontSet = pData->fontSet; // cache it for later


  bzero(&xgcv, sizeof(xgcv));
//  if(pFont)
//  {
//    xgcv.font = pData->pFont->fid;
//    xgcv.fill_style = FillSolid;
//  }
  xgcv.foreground = pData->clrText;
  xgcv.background = pData->clrWhite;
  xgcv.line_width = 1;
  xgcv.function = GXcopy; // copy
  xgcv.cap_style = CapProjecting;

  gc = XCreateGC(pDisplay, wID,
                 (/*(xgcv.font ? GCFont | GCFillStyle : 0) | */GCForeground | GCBackground | GCCapStyle | GCFunction | GCLineWidth),
                 &xgcv);

  if(!gc)
  {
    WB_WARN_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);
    return 0;
  }

  // now we get to create a window-compatible pixmap compatible with the window size
  // NOTE:  XListDepths and XDefaultDepth may be needed to convert pixmaps to something that's compatible

  WBGetWindowGeom(wID, &(pData->geomBorder));
  pData->geomBorder.x = pData->geomBorder.y = 0; // force this (for now, gnome has absolute coordinates for splash window!)

// not currently being used - later if I need it, uncomment - gcc in linux barphs on unused assigned vars
//  xrct.x = pData->geomBorder.x;
//  xrct.y = pData->geomBorder.y;
//  xrct.width = pData->geomBorder.width;
//  xrct.height = pData->geomBorder.height;


  if(pData->pixmap2 != None) // first part was already done
  {
    pxTemp = pData->pixmap2;
  }
  else
  {
    pxTemp = XCreatePixmap(pDisplay, wID, pData->iW + 4, pData->iH + 4,
                           DefaultDepth(pDisplay, DefaultScreen(pDisplay)));

    if(pxTemp == None)
    {
      WB_ERROR_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);
      XFreeGC(pDisplay, gc);
      return 0;
    }

    if(pData->pixmap != None)  // just in case
    {
      XCopyArea(pDisplay, pData->pixmap, pxTemp, gc,
                0, 0, pData->iW, pData->iH,
                pData->geomBorder.x + 2, pData->geomBorder.y + 2);
    }
    else
    {
      // TODO: erase the background of the drawable, WBEraseBackground maybe?
    }

    // this fixes the border areas properly

    xgcv.line_width = 3;
    xgcv.function = GXcopy; // copy
    xgcv.cap_style = CapProjecting;

    XChangeGC(pDisplay, gc, GCCapStyle | GCFunction | GCLineWidth, &xgcv);

    XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, 0,0, pData->iW + 3, 0);
    XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, pData->iW + 3, 0, pData->iW + 3, pData->iH + 3);
    XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, pData->iW + 3, pData->iH + 3, 0, pData->iH + 3);
    XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, 0, pData->iH + 3, 0, 0);

    pData->pixmap2 = pxTemp; // temporarily cache it here (I'll juggle it after allocating 2nd pixmap)

    // next, I must create a *new* temporary pixmap as my 'working' pixmap.  the previous one is the 'reference' pixmap

    pxTemp = XCreatePixmap(pDisplay, wID, pData->iW + 4, pData->iH + 4,
                           DefaultDepth(pDisplay, DefaultScreen(pDisplay)));

    if(pxTemp == None)
    {
      WB_ERROR_PRINT("%s - * BUG *  line %d\n", __FUNCTION__, __LINE__);

      XFreePixmap(WBGetDefaultDisplay(), pData->pixmap2); // restartability
      pData->pixmap2 = None;

      XFreeGC(pDisplay, gc);
      return 0;
    }

    if(pData->pixmap != None)  // just in case, test for it
    {
      XFreePixmap(WBGetDefaultDisplay(), pData->pixmap);
    }

    pData->pixmap = pData->pixmap2; // NOW, ref pixmap (with image and border) goes into 'pixmap'
    pData->pixmap2 = pxTemp;        // and the 'working' copy into 'pixmap2' (which is also 'pxTemp')

    // make an exact duplicate without any clipping regions
    XCopyArea(pDisplay, pData->pixmap, pxTemp, gc,
              0, 0, pData->iW + 4, pData->iH + 4, 0, 0);  // make a good copy of it at least once
  }

  if(pData->nIter <= 1)
  {
//    WBClearWindow(wID, gc);  GC doesn't have a clip region yet, don't do this
    XClearWindow(pDisplay, wID);  // erase background
  }
  else if(pData->nIter == SPLASH_FRAMERATE / 2) // after first half second
  {
    geomText.x = pData->geomBorder.x + 2;
    geomText.y = pData->geomBorder.y + 2;
    geomText.width = pData->geomBorder.width - 4;
    geomText.height = pData->geomBorder.height - 4;

    geomText.y += (geomText.height * 2) / 3;
    geomText.height -= (geomText.height * 2) / 3; // bottom 1/3

    // copyright string is 1 or 2 lines, for now use whatever font I end up with and draw lines separately

    if(fontSet != None)
    {
      WB_RECT rctBounds;
      rctBounds.left = geomText.x;
      rctBounds.top = geomText.y;
      rctBounds.right = rctBounds.left + geomText.width;
      rctBounds.bottom = rctBounds.top + geomText.height;

      DTDrawMultiLineText(fontSet, pData->szCopyright, pDisplay, gc, pData->pixmap,
                          -8, 0, &rctBounds, DTAlignment_VCENTER | DTAlignment_HCENTER);
#if 0
      p1 = pData->szCopyright;
      p2 = strchr(p1, '\n');

      if(p2)
      {
        *(p2++) = 0;
      }

      if(!p2 || !*p2)
      {
        iX = geomText.x + (geomText.width - XTextWidth(pFont, p1, strlen(p1))) / 2;
        iY = geomText.y + (geomText.height - pFont->max_bounds.ascent + pFont->max_bounds.descent) / 2
           + pFont->max_bounds.ascent; // bottom of text

        XDrawString(pDisplay, pxTemp ? pxTemp : wID, gc, iX, iY, p1, strlen(p1));
      }
      else
      {
        iX = geomText.x + (geomText.width - XTextWidth(pFont, p1, strlen(p1))) / 2;
        iY = geomText.y + (geomText.height - 2 * (pFont->max_bounds.ascent + pFont->max_bounds.descent)) / 2
           + pFont->max_bounds.ascent; // bottom of text

        XDrawString(pDisplay, pxTemp ? pxTemp : wID, gc, iX, iY, p1, strlen(p1));

        iX = geomText.x + (geomText.width - XTextWidth(pFont, p2, strlen(p2))) / 2;
        iY += pFont->max_bounds.ascent + pFont->max_bounds.descent;

        XDrawString(pDisplay, pxTemp ? pxTemp : wID, gc, iX, iY, p2, strlen(p2));
      }

      if(p2)
      {
        *(p2 - 1) = '\n'; // restore it for next time
      }
#endif // 0
    }
    else
    {
      fprintf(stderr, "NO FONT, iter=%d\n", pData->nIter);
    }

    // make an exact duplicate without any clipping regions

    XCopyArea(pDisplay, pData->pixmap, pxTemp, gc,
              0, 0, pData->iW + 4, pData->iH + 4, 0, 0);

    // now, grab an XImage for it

    pData->pImage = XGetImage(pDisplay, pxTemp, 0, 0, pData->iW + 4, pData->iH + 4,
                              0xffffffff, XYPixmap);
  }

  // TODO:  consider creating clip regions to improve performance

  if(pData->nIter >= SPLASH_FRAMERATE / 2) // after first half second
  {
    iTimeStart = 1250 * SPLASH_FRAMERATE;                     // 1.5 seconds' worth in msecs, not seconds
    iTimeEnd = (SPLASH_TIME + 1000) * SPLASH_FRAMERATE
             - 500 * SPLASH_FRAMERATE;                        // 1/2 sec before end

    if(iTimeStart + 1000 * SPLASH_FRAMERATE / 2 > iTimeEnd)
    {
      iTimeStart = iTimeEnd - SPLASH_FRAMERATE / 2;
    }

    // drawing the 'gleam' diagonally from upper left to lower right
    // TODO:  make this optional?

    if(pData->nIter * 1000 > iTimeEnd)
    {
      if(pData->pImage)
      {
        XPutImage(pDisplay, pData->pixmap2, gc, pData->pImage, 0, 0, 0, 0, pData->iW + 4, pData->iH + 4);

        XDestroyImage(pData->pImage); // destroy it now that I'm done with it
        pData->pImage = NULL;         // no longer stored (already cleaned up)
      }
    }
    else if(pData->nIter * 1000 >= iTimeStart && pData->nIter * 1000 <= iTimeEnd)
    {
      int iDelta = iTimeEnd - iTimeStart + 1;
      int iTemp;
      XImage *pI; // the image I'll be manipulating

      iTemp = pData->nIter * 1000L - iTimeStart;
      iTemp = (int)(((long long)iTemp * (long long)iTemp) / (iTimeEnd - iTimeStart));

      // get the starting points and end points
      iX = 2 * (pData->iW * iTemp / iDelta + pData->iW / (2 * iDelta) / 1000); // x pos of top
      iY = 2 * (pData->iH * iTemp / iDelta + pData->iH / (2 * iDelta) / 1000); // y pos of left

      // will draw the line from 0,iY to iX,0

      if(!pData->pImage)
      {
        pData->pImage = XGetImage(pDisplay, pData->pixmap2, 0, 0, pData->iW + 4, pData->iH + 4,
                                  0xffffffff, // I've tried 0, 1, and THIS value - no apparent difference
                                  XYPixmap); // TODO:  use ZPixmap instead?
      }

      pI = pData->pImage;

      if(pI && !pData->pImageData)
      {
        // this formula can be found in the xorg-server source:
        // length = ximage->bytes_per_line * ximage->height;
        // this is from 'xnestGetImage' in hw/xnest/GCOps.c
        // note that they don't include 'depth' in that.  when I exclude 'depth', it doesn't work
        // TODO:  do I need to pay attention to PADDING?  docs and source suggest 'no'

//        WB_ERROR_PRINT("TEMPORARY:  %s - bytes_per_line=%d, height=%d, depth=%d\n", __FUNCTION__,
//                       pI->bytes_per_line, pI->height, pI->depth);

        pData->cbImageData = PXM_GetImageDataLength(pI);
        pData->pImageData = WBAlloc(pData->cbImageData + 4);

        if(pData->pImageData)
        {
          memcpy(pData->pImageData, PXM_GetImageDataPtr(pI), pData->cbImageData);
        }
      }

      if(!pI)
      {
        // don't do anything
      }
      else
      {
#if defined(GLEAM_OLD)
#define GLEAM_WIDTH 10
        static int aLuma[GLEAM_WIDTH + 1] = { 255, 249, 231, 202, 167, 128, 88, 53, 24, 6, 0  }; // 'luma' values for "the gleam" based on offset from center
#elif defined(GLEAM_NARROW)
#define GLEAM_WIDTH 17
        static int aLuma[GLEAM_WIDTH + 1] = { 255, 202, 161, 128, 101, 80, 64, 51, 40,
                                              32, 25, 20, 16, 13, 10, 8, 6, 5  }; // similar but 1/r^2 version (no cos)
#else // WIDE gleam
#define GLEAM_WIDTH 29
        static int aLuma[GLEAM_WIDTH + 1] = { 255,225,198,175,154,136,120,106,93,82,72,64,
                                              56,50,44,39,34,30,26,23,21,18,16,14,12,11,10,8,7,7 }; // a bit wider, more obvious
#endif // GLEAM_OLD, GLEAM_NARROW

        int iX0, iY0, iX1, i1, i2, iW, iL, iMaxX, iMaxY;

        // NOW I get the fun of directly manipulating my image.  W00T!

        // effectively I do this:  XDrawLine(pDisplay, pxTemp, gc, -2, iY, iX, -2) and it's 19 pixels wide

        // So the line has a width of '2*GLEAM_WIDTH + 1' pixels.  The pixels represent a white reflection
        // centering at the coordinates I specified above, that is the line from -2, iY to iX, -2 .  This
        // actually SHOULD be offset by 2 pixels so that it does not affect the border, but that's less iomportant

        // draw the line.  19 pixels wide is actually +/- 9.  We start with a single pixel-width line, then
        // do a for loop from/to +/- GLEAM_WIDTH on the X axis, keeping Y constant.  if Y did not change, skip it.

        iMaxX = pData->iW;
        iMaxY = pData->iH;

        for(iX0 = -GLEAM_WIDTH, iY0 = iY + GLEAM_WIDTH; iX0 < iMaxX + GLEAM_WIDTH && iY0 > -GLEAM_WIDTH; iX0++)
        {
          i1 = (int)(((iX - iX0) * (long long)iMaxY) / iMaxX); // a muldiv conversion (where I should be)

          if(iY0 > i1) // so I don't repeat what I've done
          {
            for(; iY0 > i1; iY0--) // remember, top < bottom so if I start at the bottom, must SUBTRACT
            {
              // +/- GLEAM_WIDTH pixels
              i2 = iX0 + GLEAM_WIDTH;
              for(iX1=iX0 - GLEAM_WIDTH, iW = -GLEAM_WIDTH; iX1 <= i2; iX1++, iW++)
              {
                // is my current iX1, iY0 inside the desired rectangle?  If so, calculate the
                // new color and assign it to this point.

                if(iX1 > 2 && iX1 < iMaxX &&
                   iY0 > 2 && iY0 < iMaxY)
                {
                  XColor clrTemp, clrPixel;
                  int iY, iU, iV, iR, iG, iB;

                  clrPixel.pixel = XGetPixel(pI, iX1 + 2, iY0 + 2);
                  PXM_PixelToRGB(&(pData->cmap), &clrPixel);

                  PXM_RGBToYUV(clrPixel.red >> 8, clrPixel.green >> 8, clrPixel.blue >> 8,
                               &iY, &iU, &iV);

                  iL = aLuma[abs(iW)]; // the 'Luma' constant, 0-255 (with 255 = 'white')

                  // new pixel luma will be:  luma * (1 + iL / 128) (maxed at 255)
                  // if new luma is > 255, reduce iU and iV (delta from 128) by the 'factor'
                  // such that iU = 128 + (iU - 128) * factor [etc.]
                  // and the 'factor' would be 255 / iU (the new value)

                  iY = ((short)iY * ((short)256 + (short)iL)) / (short)256; // >> 6;/// (short)128;

                  if(iY > 255)
                  {
                    iU = (short)128 + (((short)iU - (short)128) * (short)256) / (short)iY;
                    iV = (short)128 + (((short)iV - (short)128) * (short)256) / (short)iY;
                    iY = 255;
                  }

                  PXM_YUVToRGB(iY, iU, iV, &iR, &iG, &iB);

                  clrTemp.red   = iR << 8;
                  clrTemp.green = iG << 8;
                  clrTemp.blue  = iB << 8;
                  clrTemp.flags = DoRed | DoGreen | DoBlue;

                  PXM_RGBToPixel(&(pData->cmap), &clrTemp);

                  XPutPixel(pI, iX1 + 2, iY0 + 2, clrTemp.pixel);
                }
              }
            }
          }
        }

        // TODO:  assign clipping region to gc

//        llTick -= WBGetTimeIndex();

        XPutImage(pDisplay, pData->pixmap2, gc, pI, 0, 0, 0, 0, pData->iW + 4, pData->iH + 4);
        XFlush(pDisplay); // make sure

//        llTick += WBGetTimeIndex();

        if(pData->pImageData)
        {
          // restore previous image data now that I'm done messing with it
          memcpy(PXM_GetImageDataPtr(pI), pData->pImageData, pData->cbImageData); // restore previous image data
        }
        else
        {
          XDestroyImage(pI);
          pData->pImage = NULL; // no longer stored (a fallback)
        }

//        WB_ERROR_PRINT("TEMPORARY:  %s - pixel stuff takes %llu millis\n", __FUNCTION__, llTick);
      }

#if 0
      // using some interesting raster ops, 'highlight' the pixels along the line of
      // (0,iY),(iX,0) or (iX,pData->iH-1),(pData->iW-1,iY)

      XSetForeground(pDisplay, gc, pData->clrWhite & 0x404040);

      xgcv.line_width = 19;
      xgcv.function = GXor; // a or b
      xgcv.cap_style = CapProjecting;

      XChangeGC(pDisplay, gc, GCCapStyle | GCFunction | GCLineWidth, &xgcv);

      if(!bInvert)
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, -2, iY, iX, -2);
      }
      else
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, iX, pData->iH + 4, pData->iW + 4, iY);
      }

      XSetForeground(pDisplay, gc, pData->clrWhite & 0x808080);

      xgcv.line_width = 11;
      xgcv.function = GXor; // a or b
      xgcv.cap_style = CapProjecting;

      XChangeGC(pDisplay, gc, GCCapStyle | GCFunction | GCLineWidth, &xgcv);

      if(!bInvert)
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, -2, iY, iX, -2);
      }
      else
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, iX, pData->iH + 4, pData->iW + 4, iY);
      }

      XSetForeground(pDisplay, gc, pData->clrWhite & 0xc0c0c0);

      xgcv.line_width = 5;
      xgcv.function = GXor; // a or b
      xgcv.cap_style = CapProjecting;

      XChangeGC(pDisplay, gc, GCCapStyle | GCFunction | GCLineWidth, &xgcv);

      if(!bInvert)
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, -2, iY, iX, -2);
      }
      else
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, iX, pData->iH + 4, pData->iW + 4, iY);
      }

      XSetForeground(pDisplay, gc, pData->clrWhite);

      xgcv.line_width = 1;
      xgcv.function = GXcopy; // copy
      xgcv.cap_style = CapProjecting;

      XChangeGC(pDisplay, gc, GCCapStyle | GCFunction | GCLineWidth, &xgcv);

      if(!bInvert)
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, -2, iY, iX, -2);
      }
      else
      {
        XDrawLine(pDisplay, pxTemp ? pxTemp : wID, gc, iX, pData->iH + 4, pData->iW + 4, iY);
      }
#endif // 0
    }
  }

  if(pxTemp) // using the 2nd pixmap to do the work, thus making the whole screen update at once
  {
    XCopyArea(pDisplay, pxTemp, wID, gc, 0, 0, pData->iW + 4, pData->iH + 4, pData->geomBorder.x, pData->geomBorder.y);
  }

  XFreeGC(pDisplay, gc);
  XSync(pDisplay, 0); // force update NOW
  WBValidateGeom(wID, NULL);
//  WBEndPaint(wID, gc);

  return 1;  // processed
}


